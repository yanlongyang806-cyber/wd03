#include "textparser.h"

//auto-generated staticdefine for enum CritterVarTypeObsolete
//autogeneratednocheckin
StaticDefineInt CritterVarTypeObsoleteEnum[] =
{
	DEFINE_INT
	{ "Int", CritterVarType_Int},
	{ "Float", CritterVarType_Float},
	{ "String", CritterVarType_String},
	{ "Msg", CritterVarType_Msg},
	DEFINE_END
};
void autoEnum_fixup_CritterVarTypeObsolete(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(CritterVarTypeObsoleteEnum, "CritterVarTypeObsolete");
}

//auto-generated staticdefine for enum CritterSubType
//autogeneratednocheckin
StaticDefineInt CritterSubTypeEnum[] =
{
	DEFINE_INT
	{ "UNKNOWN", CritterSubType_UNKNOWN},
	{ "CIVILIAN_CAR", CritterSubType_CIVILIAN_CAR},
	{ "COUNT", CritterSubType_COUNT},
	DEFINE_END
};
void autoEnum_fixup_CritterSubType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(CritterSubTypeEnum, "CritterSubType");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CritterRankDifficulty
#define TYPE_parse_CritterRankDifficulty CritterRankDifficulty
ParseTable parse_CritterRankDifficulty[] =
{
	{ "CritterRankDifficulty", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CritterRankDifficulty), 0, NULL, 0, NULL },
	{ "SubRank",				TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(CritterRankDifficulty, pcSubRank, 0), NULL },
	{ "Difficulty",				TOK_STRUCTPARAM | TOK_F32(CritterRankDifficulty, fDifficulty, 0), NULL },
	{ "\n",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CritterRankDifficulty()
{
	int iSize = sizeof(CritterRankDifficulty);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CritterRankDifficulty, iSize, "CritterRankDifficulty", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_CritterRankDifficulty[];
#define TYPE_parse_CritterRankDifficulty CritterRankDifficulty
//Structparser.exe autogenerated ParseTable for struct CritterRankDef
#define TYPE_parse_CritterRankDef CritterRankDef
ParseTable parse_CritterRankDef[] =
{
	{ "CritterRankDef", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CritterRankDef), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Name",					TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(CritterRankDef, pcName, 0), NULL },
	{ "IsDefault",				TOK_AUTOINT(CritterRankDef, bIsDefault, 0), NULL },
	{ "IsMissionRewardDefault",	TOK_AUTOINT(CritterRankDef, bIsMissionRewardDefault, 0), NULL },
	{ "IgnoresFallingDamage",	TOK_AUTOINT(CritterRankDef, bIgnoresFallingDamage, 0), NULL },
	{ "Order",					TOK_AUTOINT(CritterRankDef, iOrder, 0), NULL },
	{ "ConModifier",			TOK_AUTOINT(CritterRankDef, iConModifier, 0), NULL },
	{ "LevelDifficultyMod",		TOK_F32(CritterRankDef, fLevelDifficultyMod, 0), NULL },
	{ "DifficultyValue",		TOK_STRUCT(CritterRankDef, eaDifficulty, parse_CritterRankDifficulty) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CritterRankDef()
{
	int iSize = sizeof(CritterRankDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CritterRankDef, iSize, "CritterRankDef", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_CritterRankDef[];
#define TYPE_parse_CritterRankDef CritterRankDef
//Structparser.exe autogenerated ParseTable for struct CritterRankDefs
#define TYPE_parse_CritterRankDefs CritterRankDefs
ParseTable parse_CritterRankDefs[] =
{
	{ "CritterRankDefs", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CritterRankDefs), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "CritterRank",		TOK_STRUCT(CritterRankDefs, eaRanks, parse_CritterRankDef) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CritterRankDefs()
{
	int iSize = sizeof(CritterRankDefs);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CritterRankDefs, iSize, "CritterRankDefs", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CritterSubRankDef
#define TYPE_parse_CritterSubRankDef CritterSubRankDef
ParseTable parse_CritterSubRankDef[] =
{
	{ "CritterSubRankDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CritterSubRankDef), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Name",				TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(CritterSubRankDef, pcName, 0), NULL },
	{ "IsDefault",			TOK_AUTOINT(CritterSubRankDef, bIsDefault, 0), NULL },
	{ "ClassInfoType",		TOK_POOL_STRING | TOK_STRING(CritterSubRankDef, pcClassInfoType, 0), NULL },
	{ "Order",				TOK_AUTOINT(CritterSubRankDef, iOrder, 0), NULL },
	{ "ConModifier",		TOK_AUTOINT(CritterSubRankDef, iConModifier, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CritterSubRankDef()
{
	int iSize = sizeof(CritterSubRankDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CritterSubRankDef, iSize, "CritterSubRankDef", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_CritterSubRankDef[];
#define TYPE_parse_CritterSubRankDef CritterSubRankDef
//Structparser.exe autogenerated ParseTable for struct CritterSubRankDefs
#define TYPE_parse_CritterSubRankDefs CritterSubRankDefs
ParseTable parse_CritterSubRankDefs[] =
{
	{ "CritterSubRankDefs", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CritterSubRankDefs), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "CritterSubRank",		TOK_STRUCT(CritterSubRankDefs, eaRanks, parse_CritterSubRankDef) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CritterSubRankDefs()
{
	int iSize = sizeof(CritterSubRankDefs);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CritterSubRankDefs, iSize, "CritterSubRankDefs", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct aiModifierDef
#define TYPE_parse_aiModifierDef aiModifierDef
ParseTable parse_aiModifierDef[] =
{
	{ "aiModifierDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(aiModifierDef), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "WeightMulti",	TOK_F32(aiModifierDef, fWeightMulti, 1), NULL },
	{ "MinDistMulti",	TOK_F32(aiModifierDef, fMinDistMulti, 1), NULL },
	{ "MaxDistMulti",	TOK_F32(aiModifierDef, fMaxDistMulti, 1), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_aiModifierDef()
{
	int iSize = sizeof(aiModifierDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_aiModifierDef, iSize, "aiModifierDef", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_aiModifierDef[2].param = GET_INTPTR_FROM_FLOAT((float)1);
	parse_aiModifierDef[3].param = GET_INTPTR_FROM_FLOAT((float)1);
	parse_aiModifierDef[4].param = GET_INTPTR_FROM_FLOAT((float)1);
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CritterPowerConfig
#define TYPE_parse_CritterPowerConfig CritterPowerConfig
ParseTable parse_CritterPowerConfig[] =
{
	{ "CritterPowerConfig", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CritterPowerConfig), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Power",					TOK_STRUCTPARAM | TOK_REFERENCE(CritterPowerConfig, hPower, 0, "PowerDef") },
	{ "Name",					TOK_REDUNDANTNAME | TOK_STRUCTPARAM | TOK_REFERENCE(CritterPowerConfig, hPower, 0, "PowerDef") },
	{ "Key",					TOK_KEY | TOK_AUTOINT(CritterPowerConfig, iKey, 0), NULL },
	{ "Order",					TOK_F32(CritterPowerConfig, fOrder, 0), NULL },
	{ "AIPreferredMinRange",	TOK_F32(CritterPowerConfig, fAIPreferredMinRange, 0), NULL },
	{ "AIPreferedMinRange",		TOK_REDUNDANTNAME | TOK_F32(CritterPowerConfig, fAIPreferredMinRange, 0), NULL },
	{ "AIPreferredMaxRange",	TOK_F32(CritterPowerConfig, fAIPreferredMaxRange, 0), NULL },
	{ "AIPreferedMaxRange",		TOK_REDUNDANTNAME | TOK_F32(CritterPowerConfig, fAIPreferredMaxRange, 0), NULL },
	{ "AIWeight",				TOK_F32(CritterPowerConfig, fAIWeight, 1), NULL },
	{ "AIWeightModifier",		TOK_OPTIONALLATEBINDSTRUCT(CritterPowerConfig, pExprAIWeightModifier) },
	{ "AIWeightModifier",		TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(CritterPowerConfig, pExprAIWeightModifier) },
	{ "AIChainTarget",			TOK_POOL_STRING | TOK_STRING(CritterPowerConfig, pchAIChainTarget, 0), NULL },
	{ "AIChainTime",			TOK_F32(CritterPowerConfig, fAIChainTime, 0), NULL },
	{ "AIChainRequiresBlock",	TOK_OPTIONALLATEBINDSTRUCT(CritterPowerConfig, pExprAIChainRequires) },
	{ "AIChainRequires",		TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(CritterPowerConfig, pExprAIChainRequires) },
	{ "AIEndConditionBlock",	TOK_OPTIONALLATEBINDSTRUCT(CritterPowerConfig, pExprAIEndCondition) },
	{ "AIEndCondition",			TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(CritterPowerConfig, pExprAIEndCondition) },
	{ "AIRequiresBlock",		TOK_OPTIONALLATEBINDSTRUCT(CritterPowerConfig, pExprAIRequires) },
	{ "AIRequires",				TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(CritterPowerConfig, pExprAIRequires) },
	{ "AITargetOverrideBlock",	TOK_OPTIONALLATEBINDSTRUCT(CritterPowerConfig, pExprAITargetOverride) },
	{ "AITargetOverride",		TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(CritterPowerConfig, pExprAITargetOverride) },
	{ "AICureRequiresBlock",	TOK_OPTIONALLATEBINDSTRUCT(CritterPowerConfig, pExprAICureRequires) },
	{ "AICureRequires",			TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(CritterPowerConfig, pExprAICureRequires) },
	{ "AIPowerConfigDef",		TOK_GLOBAL_NAME | TOK_POOL_STRING | TOK_STRING(CritterPowerConfig, pchAIPowerConfigDef, 0), "AIPowerConfigDef" },
	{ "AIPowerConfigDefInst",	TOK_OPTIONALLATEBINDSTRUCT(CritterPowerConfig, aiPowerConfigDefInst) },
	{ "Group",					TOK_AUTOINT(CritterPowerConfig, iGroup, 0), NULL },
	{ "Chance",					TOK_F32(CritterPowerConfig, fChance, 1), NULL },
	{ "Weight",					TOK_F32(CritterPowerConfig, fWeight, 0), NULL },
	{ "MinLevel",				TOK_AUTOINT(CritterPowerConfig, iMinLevel, -1), NULL },
	{ "MaxLevel",				TOK_AUTOINT(CritterPowerConfig, iMaxLevel, -1), NULL },
	{ "AddPowerRequiresBlock",	TOK_OPTIONALLATEBINDSTRUCT(CritterPowerConfig, pExprAddPowerRequires) },
	{ "AddPowerRequires",		TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(CritterPowerConfig, pExprAddPowerRequires) },
	{ "AutoDescDisabled",		TOK_AUTOINT(CritterPowerConfig, bAutoDescDisabled, 0), NULL },
	{ "Disabled",				TOK_AUTOINT(CritterPowerConfig, bDisabled, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CritterPowerConfig()
{
	int iSize = sizeof(CritterPowerConfig);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CritterPowerConfig, iSize, "CritterPowerConfig", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_CritterPowerConfig[10].param = GET_INTPTR_FROM_FLOAT((float)1);
	parse_CritterPowerConfig[28].param = GET_INTPTR_FROM_FLOAT((float)1);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_CritterPowerConfig(void)
{
	DoAutoStructLateBind(parse_CritterPowerConfig, 11, "Expression");
	DoAutoStructLateBind(parse_CritterPowerConfig, 12, "Expression_StructParam");
	DoAutoStructLateBind(parse_CritterPowerConfig, 15, "Expression");
	DoAutoStructLateBind(parse_CritterPowerConfig, 16, "Expression_StructParam");
	DoAutoStructLateBind(parse_CritterPowerConfig, 17, "Expression");
	DoAutoStructLateBind(parse_CritterPowerConfig, 18, "Expression_StructParam");
	DoAutoStructLateBind(parse_CritterPowerConfig, 19, "Expression");
	DoAutoStructLateBind(parse_CritterPowerConfig, 20, "Expression_StructParam");
	DoAutoStructLateBind(parse_CritterPowerConfig, 21, "Expression");
	DoAutoStructLateBind(parse_CritterPowerConfig, 22, "Expression_StructParam");
	DoAutoStructLateBind(parse_CritterPowerConfig, 23, "Expression");
	DoAutoStructLateBind(parse_CritterPowerConfig, 24, "Expression_StructParam");
	DoAutoStructLateBind(parse_CritterPowerConfig, 26, "AIPowerConfigDef");
	DoAutoStructLateBind(parse_CritterPowerConfig, 32, "Expression");
	DoAutoStructLateBind(parse_CritterPowerConfig, 33, "Expression_StructParam");
}
//autogeneratednocheckin
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
//Structparser.exe autogenerated ParseTable for struct CritterCostume
#define TYPE_parse_CritterCostume CritterCostume
ParseTable parse_CritterCostume[] =
{
	{ "CritterCostume", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CritterCostume), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Costume",					TOK_STRUCTPARAM | TOK_REFERENCE(CritterCostume, hCostumeRef, 0, "PlayerCostume") },
	{ "Name",						TOK_REDUNDANTNAME | TOK_STRUCTPARAM | TOK_REFERENCE(CritterCostume, hCostumeRef, 0, "PlayerCostume") },
	{ "Weight",						TOK_STRUCTPARAM | TOK_F32(CritterCostume, fWeight, 0), NULL },
	{ "Key",						TOK_STRUCTPARAM | TOK_KEY | TOK_AUTOINT(CritterCostume, iKey, 0), NULL },
	{ "Order",						TOK_STRUCTPARAM | TOK_F32(CritterCostume, fOrder, 0), NULL },
	{ "MinLevel",					TOK_STRUCTPARAM | TOK_AUTOINT(CritterCostume, iMinLevel, -1), NULL },
	{ "MaxLevel",					TOK_STRUCTPARAM | TOK_AUTOINT(CritterCostume, iMaxLevel, -1), NULL },
	{ "MinTeamSize",				TOK_STRUCTPARAM | TOK_AUTOINT(CritterCostume, iMinTeamSize, -1), NULL },
	{ "MaxTeamSize",				TOK_STRUCTPARAM | TOK_AUTOINT(CritterCostume, iMaxTeamSize, -1), NULL },
	{ "AssetSetIndex",				TOK_AUTOINT(CritterCostume, iAssetSetIndex, -1), NULL },
	{ "displayNameMsg",				TOK_EMBEDDEDSTRUCT(CritterCostume, displayNameMsg, parse_DisplayMessage)},
	{ "displaySubNameMsg",			TOK_EMBEDDEDSTRUCT(CritterCostume, displaySubNameMsg, parse_DisplayMessage)},
	{ "voiceSet",					TOK_POOL_STRING | TOK_STRING(CritterCostume, voiceSet, 0), NULL },
	{ "CreateIgnoresDisplayName",	TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_CritterCostume()
{
	int iSize = sizeof(CritterCostume);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CritterCostume, iSize, "CritterCostume", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(CritterCostume) + 7) / 4;
		CritterCostume *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bCreateIgnoresDisplayName = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterCostume[15]);
		pTemp->bCreateIgnoresDisplayName = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CritterLore
#define TYPE_parse_CritterLore CritterLore
ParseTable parse_CritterLore[] =
{
	{ "CritterLore", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CritterLore), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Key",			TOK_KEY | TOK_AUTOINT(CritterLore, iKey, 0), NULL },
	{ "Order",			TOK_F32(CritterLore, fOrder, 0), NULL },
	{ "Item",			TOK_REFERENCE(CritterLore, hItem, 0, "ItemDef") },
	{ "DC",				TOK_AUTOINT(CritterLore, DC, 0), NULL },
	{ "Attrib",			TOK_AUTOINT(CritterLore, eAttrib, -1), AttribTypeEnum },
	{ "Power",			TOK_REFERENCE(CritterLore, hPower, 0, "PowerDef") },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CritterLore()
{
	int iSize = sizeof(CritterLore);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CritterLore, iSize, "CritterLore", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldVariable[];
#define TYPE_parse_WorldVariable WorldVariable
//Structparser.exe autogenerated ParseTable for struct CritterVar
#define TYPE_parse_CritterVar CritterVar
ParseTable parse_CritterVar[] =
{
	{ "CritterVar", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CritterVar), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "Key",		TOK_KEY | TOK_AUTOINT(CritterVar, iKey, 0), NULL },
	{ "Order",		TOK_F32(CritterVar, fOrder, 0), NULL },
	{ "Var",		TOK_EMBEDDEDSTRUCT(CritterVar, var, parse_WorldVariable)},
	{ "Name",		TOK_IGNORE, 0 },
	{ "Type",		TOK_IGNORE, 0 },
	{ "Int",		TOK_IGNORE, 0 },
	{ "Float",		TOK_IGNORE, 0 },
	{ "String",		TOK_IGNORE, 0 },
	{ "Msg",		TOK_IGNORE, 0 },
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CritterVar()
{
	int iSize = sizeof(CritterVar);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CritterVar, iSize, "CritterVar", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CritterFactionRelationship
#define TYPE_parse_CritterFactionRelationship CritterFactionRelationship
ParseTable parse_CritterFactionRelationship[] =
{
	{ "CritterFactionRelationship", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CritterFactionRelationship), 0, NULL, 0, NULL },
	{ "hFactionRef",				TOK_STRUCTPARAM | TOK_REFERENCE(CritterFactionRelationship, hFactionRef, 0, "CritterFaction") },
	{ "Reputation",					TOK_STRUCTPARAM | TOK_F32(CritterFactionRelationship, fReputation, 0), NULL },
	{ "Relation",					TOK_STRUCTPARAM | TOK_AUTOINT(CritterFactionRelationship, eRelation, 0), EntityRelationEnum },
	{ "\n",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CritterFactionRelationship()
{
	int iSize = sizeof(CritterFactionRelationship);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CritterFactionRelationship, iSize, "CritterFactionRelationship", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_CritterFactionRelationship[];
#define TYPE_parse_CritterFactionRelationship CritterFactionRelationship
//Structparser.exe autogenerated ParseTable for struct CritterFaction
#define TYPE_parse_CritterFaction CritterFaction
ParseTable parse_CritterFaction[] =
{
	{ "CritterFaction", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CritterFaction), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Name",					TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_KEY | TOK_STRING(CritterFaction, pchName, 0), NULL },
	{ "FileName",				TOK_POOL_STRING | TOK_CURRENTFILE(CritterFaction, pchFileName), NULL},
	{ "DefaultEnemyFaction",	TOK_AUTOINT(CritterFaction, bDefaultEnemyFaction, 0), NULL },
	{ "DefaultPlayerFaction",	TOK_AUTOINT(CritterFaction, bDefaultPlayerFaction, 0), NULL },
	{ "CanBeSubFaction",		TOK_AUTOINT(CritterFaction, bCanBeSubFaction, 0), NULL },
	{ "relationship",			TOK_STRUCT(CritterFaction, relationship, parse_CritterFactionRelationship) },
	{ "PlayerFaction",			TOK_IGNORE, 0 },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CritterFaction()
{
	int iSize = sizeof(CritterFaction);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CritterFaction, iSize, "CritterFaction", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_CritterVar[];
#define TYPE_parse_CritterVar CritterVar
extern ParseTable parse_CritterLore[];
#define TYPE_parse_CritterLore CritterLore
//Structparser.exe autogenerated ParseTable for struct CritterGroup
#define TYPE_parse_CritterGroup CritterGroup
ParseTable parse_CritterGroup[] =
{
	{ "CritterGroup", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CritterGroup), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Name",						TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_KEY | TOK_STRING(CritterGroup, pchName, 0), NULL },
	{ "FileName",					TOK_POOL_STRING | TOK_CURRENTFILE(CritterGroup, pchFileName), NULL},
	{ "Scope",						TOK_POOL_STRING | TOK_STRING(CritterGroup, pchScope, 0), NULL },
	{ "Notes",						TOK_STRING(CritterGroup, pchNotes, 0), NULL },
	{ "displayNameMsg",				TOK_EMBEDDEDSTRUCT(CritterGroup, displayNameMsg, parse_DisplayMessage)},
	{ "descriptionMsg",				TOK_EMBEDDEDSTRUCT(CritterGroup, descriptionMsg, parse_DisplayMessage)},
	{ "Icon",						TOK_POOL_STRING | TOK_STRING(CritterGroup, pcIcon, 0), NULL },
	{ "SkillType",					TOK_AUTOINT(CritterGroup, eSkillType, 0), SkillTypeEnum },
	{ "RewardTable",				TOK_REFERENCE(CritterGroup, hRewardTable, 0, "RewardTable") },
	{ "AddRewardTable",				TOK_REFERENCE(CritterGroup, hAddRewardTable, 0, "RewardTable") },
	{ "ChatBubbleDef",				TOK_REFERENCE(CritterGroup, hChatBubbleDef, 0, "ChatBubbleDef") },
	{ "MaleVoiceSet",				TOK_POOL_STRING | TOK_STRING(CritterGroup, maleVoiceSet, 0), NULL },
	{ "FemaleVoiceSet",				TOK_POOL_STRING | TOK_STRING(CritterGroup, femaleVoiceSet, 0), NULL },
	{ "NeutralVoiceSet",			TOK_POOL_STRING | TOK_STRING(CritterGroup, neutralVoiceSet, 0), NULL },
	{ "SpawnAnim",					TOK_GLOBAL_NAME | TOK_POOL_STRING | TOK_STRING(CritterGroup, pchSpawnAnim, 0), "AnimationLibrary" },
	{ "SpawnLockdownTime",			TOK_F32(CritterGroup, fSpawnLockdownTime, 0), NULL },
	{ "SpawnAnimAlternate",			TOK_GLOBAL_NAME | TOK_POOL_STRING | TOK_STRING(CritterGroup, pchSpawnAnimAlternate, 0), "AnimationLibrary" },
	{ "SpawnLockdownTimeAlternate",	TOK_F32(CritterGroup, fSpawnLockdownTimeAlternate, 0), NULL },
	{ "CritterVars",				TOK_STRUCT(CritterGroup, ppCritterVars, parse_CritterVar) },
	{ "CritterLoreEntries",			TOK_STRUCT(CritterGroup, ppCritterLoreEntries, parse_CritterLore) },
	{ "HeadshotCritterGroup",		TOK_REFERENCE(CritterGroup, hHeadshotCritterGroup, 0, "CritterGroup") },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CritterGroup()
{
	int iSize = sizeof(CritterGroup);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CritterGroup, iSize, "CritterGroup", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InheritanceData[];
#define TYPE_parse_InheritanceData InheritanceData
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_CritterCostume[];
#define TYPE_parse_CritterCostume CritterCostume
extern ParseTable parse_CritterPowerConfig[];
#define TYPE_parse_CritterPowerConfig CritterPowerConfig
extern ParseTable parse_CritterVar[];
#define TYPE_parse_CritterVar CritterVar
extern ParseTable parse_DefaultItemDef[];
#define TYPE_parse_DefaultItemDef DefaultItemDef
extern ParseTable parse_CritterLore[];
#define TYPE_parse_CritterLore CritterLore
//Structparser.exe autogenerated ParseTable for struct CritterDef
#define TYPE_parse_CritterDef CritterDef
ParseTable parse_CritterDef[] =
{
	{ "CritterDef", 						TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CritterDef), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "Inheritance",					TOK_INHERITANCE_STRUCT | TOK_SERVER_ONLY | TOK_OPTIONALSTRUCT(CritterDef, pInheritance, parse_InheritanceData) },
	{ "Name",							TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_KEY | TOK_STRING(CritterDef, pchName, 0), NULL },
	{ "FileName",						TOK_POOL_STRING | TOK_CURRENTFILE(CritterDef, pchFileName), NULL},
	{ "Comment",						TOK_STRING(CritterDef, pchComment, 0), NULL },
	{ "Scope",							TOK_POOL_STRING | TOK_STRING(CritterDef, pchScope, 0), NULL },
	{ "MinLevel",						TOK_STRUCTPARAM | TOK_AUTOINT(CritterDef, iMinLevel, 0), NULL },
	{ "MaxLevel",						TOK_STRUCTPARAM | TOK_AUTOINT(CritterDef, iMaxLevel, 0), NULL },
	{ "noCrossFade",					TOK_AUTOINT(CritterDef, noCrossFade, 0), NULL },
	{ "KeyBlock",						TOK_AUTOINT(CritterDef, iKeyBlock, 0), NULL },
	{ "Index",							TOK_AUTOINT(CritterDef, iIndex, -1), NULL },
	{ "RandomCivilianName",				TOK_AUTOINT(CritterDef, bRandomCivilianName, 0), NULL },
	{ "hGroupOverrideDisplayNameMsg",	TOK_EMBEDDEDSTRUCT(CritterDef, hGroupOverrideDisplayNameMsg, parse_DisplayMessage)},
	{ "Faction",						TOK_REFERENCE(CritterDef, hFaction, 0, "CritterFaction") },
	{ "Species",						TOK_REFERENCE(CritterDef, hSpecies, 0, "SpeciesDef") },
	{ "Gang",							TOK_AUTOINT(CritterDef, iGangID, 0), NULL },
	{ "GroupName",						TOK_REFERENCE(CritterDef, hGroup, 0, "CritterGroup") },
	{ "Class",							TOK_GLOBAL_NAME | TOK_POOL_STRING | TOK_STRING(CritterDef, pchClass, 0), "CharacterClassInfo" },
	{ "CritterTags",					TOK_INTARRAY(CritterDef, piTags),  CritterTagsEnum},
	{ "SpawnLimit",						TOK_AUTOINT(CritterDef, iSpawnLimit, 0), CritterSpawnLimitEnum },
	{ "Rank",							TOK_POOL_STRING | TOK_STRING(CritterDef, pcRank, 0), NULL },
	{ "SubRank",						TOK_POOL_STRING | TOK_STRING(CritterDef, pcSubRank, 0), NULL },
	{ "PvPFlagged",						TOK_AUTOINT(CritterDef, bPvPFlagged, 0), NULL },
	{ "Template",						TOK_NO_INHERIT | TOK_AUTOINT(CritterDef, bTemplate, false), NULL },
	{ "DisabledForContacts",			TOK_AUTOINT(CritterDef, bDisabledForContacts, 0), NULL },
	{ "SkillType",						TOK_AUTOINT(CritterDef, eSkillType, 0), SkillTypeEnum },
	{ "refCount",						TOK_AUTOINT(CritterDef, refCount, 0), NULL },
	{ "displayNameMsg",					TOK_EMBEDDEDSTRUCT(CritterDef, displayNameMsg, parse_DisplayMessage)},
	{ "displaySubNameMsg",				TOK_EMBEDDEDSTRUCT(CritterDef, displaySubNameMsg, parse_DisplayMessage)},
	{ "descriptionMsg",					TOK_EMBEDDEDSTRUCT(CritterDef, descriptionMsg, parse_DisplayMessage)},
	{ "Costume",						TOK_STRUCT(CritterDef, ppCostume, parse_CritterCostume) },
	{ "CostumeWeight",					TOK_REDUNDANTNAME | TOK_STRUCT(CritterDef, ppCostume, parse_CritterCostume) },
	{ "GenerateRandomCostume",			TOK_BIT, 0, 8, NULL},
	{ "RandomDefaultStance",			TOK_BIT, 0, 8, NULL},
	{ "DefaultStanceDef",				TOK_REFERENCE(CritterDef, hDefaultStanceDef, 0, "PowerDef") },
	{ "OverrideCostume",				TOK_REFERENCE(CritterDef, hOverrideCostumeRef, 0, "PlayerCostume") },
	{ "StanceWords",					TOK_POOL_STRING | TOK_STRINGARRAY(CritterDef, ppchStanceWords), NULL },
	{ "RewardTable",					TOK_REFERENCE(CritterDef, hRewardTable, 0, "RewardTable") },
	{ "AddRewardTable",					TOK_REFERENCE(CritterDef, hAddRewardTable, 0, "RewardTable") },
	{ "PreferredMinRange",				TOK_NO_WRITE | TOK_F32(CritterDef, fPreferredMinRange_UNUSED, 0), NULL },
	{ "PreferedMinRange",				TOK_REDUNDANTNAME | TOK_NO_WRITE | TOK_F32(CritterDef, fPreferredMinRange_UNUSED, 0), NULL },
	{ "PreferredMaxRange",				TOK_NO_WRITE | TOK_F32(CritterDef, fPreferredMaxRange_UNUSED, 0), NULL },
	{ "PreferedMaxRange",				TOK_REDUNDANTNAME | TOK_NO_WRITE | TOK_F32(CritterDef, fPreferredMaxRange_UNUSED, 0), NULL },
	{ "Leash",							TOK_NO_WRITE | TOK_F32(CritterDef, fLeash_UNUSED, 0), NULL },
	{ "AIConfig",						TOK_GLOBAL_NAME | TOK_POOL_STRING | TOK_STRING(CritterDef, pchAIConfig, 0), "AIConfig" },
	{ "AI",								TOK_REDUNDANTNAME | TOK_GLOBAL_NAME | TOK_POOL_STRING | TOK_STRING(CritterDef, pchAIConfig, 0), "AIConfig" },
	{ "FSM",							TOK_REFERENCE(CritterDef, hFSM, 0, "FSM") },
	{ "AIFSM",							TOK_REDUNDANTNAME | TOK_REFERENCE(CritterDef, hFSM, 0, "FSM") },
	{ "CombatFSM",						TOK_REFERENCE(CritterDef, hCombatFSM, 0, "FSM") },
	{ "SpawnAnim",						TOK_GLOBAL_NAME | TOK_POOL_STRING | TOK_STRING(CritterDef, pchSpawnAnim, 0), "AnimationLibrary" },
	{ "SpawnLockdownTime",				TOK_F32(CritterDef, fSpawnLockdownTime, 0), NULL },
	{ "SpawnAnimAlternate",				TOK_GLOBAL_NAME | TOK_POOL_STRING | TOK_STRING(CritterDef, pchSpawnAnimAlternate, 0), "AnimationLibrary" },
	{ "SpawnLockdownTimeAlternate",		TOK_F32(CritterDef, fSpawnLockdownTimeAlternate, 0), NULL },
	{ "SpawnWeight",					TOK_F32(CritterDef, fSpawnWeight, 1), NULL },
	{ "PowerConfigs",					TOK_STRUCT(CritterDef, ppPowerConfigs, parse_CritterPowerConfig) },
	{ "lingerDuration",					TOK_F32(CritterDef, lingerDuration, 15), NULL },
	{ "Hue",							TOK_F32(CritterDef, fHue, 0), NULL },
	{ "Untargetable",					TOK_BIT, 0, 8, NULL},
	{ "Unselectable",					TOK_BIT, 0, 8, NULL},
	{ "Invulnerable",					TOK_BIT, 0, 8, NULL},
	{ "Unstoppable",					TOK_BIT, 0, 8, NULL},
	{ "Unkillable",						TOK_BIT, 0, 8, NULL},
	{ "LevelAdjusting",					TOK_BIT, 0, 8, NULL},
	{ "PseudoPlayer",					TOK_BIT, 0, 8, NULL},
	{ "DisableTurnToFace",				TOK_BIT, 0, 8, NULL},
	{ "IgnoreCombatMods",				TOK_BIT, 0, 8, NULL},
	{ "NonCombat",						TOK_BIT, 0, 8, NULL},
	{ "NoPowersAllowed",				TOK_BIT, 0, 8, NULL},
	{ "IgnoreExternalInnates",			TOK_BIT, 0, 8, NULL},
	{ "IgnoreEntCreateHue",				TOK_BIT, 0, 8, NULL},
	{ "DropMyInventory",				TOK_BIT, 0, 8, NULL},
	{ "NoInterpAlphaOnSpawn",			TOK_BIT, 0, 8, NULL},
	{ "UseCapsuleForPowerArcChecks",	TOK_BIT, 0, 8, NULL},
	{ "UseClosestPowerAnimNode",		TOK_BIT, 0, 8, NULL},
	{ "SpecialLargeMonster",			TOK_BIT, 0, 8, NULL},
	{ "IgnoreExternalAnimBits",			TOK_BIT, 0, 8, NULL},
	{ "AlwaysHaveWeaponsReady",			TOK_BIT, 0, 8, NULL},
	{ "Interaction",					TOK_AUTOINT(CritterDef, oldInteractProps, 0), OldInteractionPropertiesEnum },
	{ "InteractionDef",					TOK_REFERENCE(CritterDef, hInteractionDef, 0, "InteractionDef") },
	{ "InteractRange",					TOK_AUTOINT(CritterDef, uInteractRange, 0), NULL },
	{ "Mass",							TOK_F32(CritterDef, fMass, 0), NULL },
	{ "InteractionFlags",				TOK_AUTOINT(CritterDef, eInteractionFlags, 0), kCritterOverrideFlagEnum  ,  TOK_FORMAT_FLAGS},
	{ "Underlings",						TOK_GLOBAL_NAME | TOK_STRINGARRAY(CritterDef, ppUnderlings), "CritterDef" },
	{ "EntityMinSeeAtDistance",			TOK_F32(CritterDef, fEntityMinSeeAtDistance, 0), NULL },
	{ "RidableBlock",					TOK_OPTIONALLATEBINDSTRUCT(CritterDef, pExprRidable) },
	{ "Ridable",						TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(CritterDef, pExprRidable) },
	{ "RidingPower",					TOK_GLOBAL_NAME | TOK_POOL_STRING | TOK_STRING(CritterDef, pchRidingPower, 0), "PowerDef" },
	{ "RidingItem",						TOK_GLOBAL_NAME | TOK_POOL_STRING | TOK_STRING(CritterDef, pchRidingItem, 0), "ItemDef" },
	{ "RidingBit",						TOK_POOL_STRING | TOK_STRING(CritterDef, pchRidingBit, 0), NULL },
	{ "CritterVars",					TOK_STRUCT(CritterDef, ppCritterVars, parse_CritterVar) },
	{ "CritterItems",					TOK_STRUCT(CritterDef, ppCritterItems, parse_DefaultItemDef) },
	{ "CritterLoreEntries",				TOK_STRUCT(CritterDef, ppCritterLoreEntries, parse_CritterLore) },
	{ "OverrideMovementRequesterDef",	TOK_REFERENCE(CritterDef, hOverrideMovementRequesterDef, 0, "MovementRequesterDef") },
	{ "Deprecated",						TOK_AUTOINT(CritterDef, bDeprecated, 0), NULL },
	{ "Gender",							TOK_AUTOINT(CritterDef, eGender, 0), GenderEnum },
	{ "Latebind",						TOK_IGNORE | TOK_IGNORE_STRUCT , 0 },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_CritterDef()
{
	int iSize = sizeof(CritterDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CritterDef, iSize, "CritterDef", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(CritterDef) + 7) / 4;
		CritterDef *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bGenerateRandomCostume = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[33]);
		pTemp->bGenerateRandomCostume = 0;
		pTemp->bRandomDefaultStance = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[34]);
		pTemp->bRandomDefaultStance = 0;
		pTemp->bUntargetable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[58]);
		pTemp->bUntargetable = 0;
		pTemp->bUnselectable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[59]);
		pTemp->bUnselectable = 0;
		pTemp->bInvulnerable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[60]);
		pTemp->bInvulnerable = 0;
		pTemp->bUnstoppable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[61]);
		pTemp->bUnstoppable = 0;
		pTemp->bUnkillable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[62]);
		pTemp->bUnkillable = 0;
		pTemp->bLevelAdjusting = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[63]);
		pTemp->bLevelAdjusting = 0;
		pTemp->bPseudoPlayer = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[64]);
		pTemp->bPseudoPlayer = 0;
		pTemp->bDisableFaceActivate = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[65]);
		pTemp->bDisableFaceActivate = 0;
		pTemp->bIgnoreCombatMods = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[66]);
		pTemp->bIgnoreCombatMods = 0;
		pTemp->bNonCombat = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[67]);
		pTemp->bNonCombat = 0;
		pTemp->bNoPowersAllowed = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[68]);
		pTemp->bNoPowersAllowed = 0;
		pTemp->bIgnoreExternalInnates = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[69]);
		pTemp->bIgnoreExternalInnates = 0;
		pTemp->bIgnoreEntCreateHue = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[70]);
		pTemp->bIgnoreEntCreateHue = 0;
		pTemp->bDropMyInventory = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[71]);
		pTemp->bDropMyInventory = 0;
		pTemp->bNoInterpAlphaOnSpawn = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[72]);
		pTemp->bNoInterpAlphaOnSpawn = 0;
		pTemp->bUseCapsuleForPowerArcChecks = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[73]);
		pTemp->bUseCapsuleForPowerArcChecks = 0;
		pTemp->bUseClosestPowerAnimNode = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[74]);
		pTemp->bUseClosestPowerAnimNode = 0;
		pTemp->bSpecialLargeMonster = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[75]);
		pTemp->bSpecialLargeMonster = 0;
		pTemp->bIgnoreExternalAnimBits = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[76]);
		pTemp->bIgnoreExternalAnimBits = 0;
		pTemp->bAlwaysHaveWeaponsReady = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CritterDef[77]);
		pTemp->bAlwaysHaveWeaponsReady = 0;
	}
	parse_CritterDef[54].param = GET_INTPTR_FROM_FLOAT((float)1);
	parse_CritterDef[56].param = GET_INTPTR_FROM_FLOAT((float)15);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_CritterDef(void)
{
	DoAutoStructLateBind(parse_CritterDef, 85, "Expression");
	DoAutoStructLateBind(parse_CritterDef, 86, "Expression_StructParam");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ref_PowerDef
#define TYPE_parse_ref_PowerDef ref_PowerDef
ParseTable parse_ref_PowerDef[] =
{
	{ "ref_PowerDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ref_PowerDef), 0, NULL, 0, NULL },
	{ "onDeathPower",	TOK_STRUCTPARAM | TOK_REFERENCE(ref_PowerDef, hPowerDef, 0, "PowerDef") },
	{ "\n",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ref_PowerDef()
{
	int iSize = sizeof(ref_PowerDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ref_PowerDef, iSize, "ref_PowerDef", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ref_PowerDef[];
#define TYPE_parse_ref_PowerDef ref_PowerDef
//Structparser.exe autogenerated ParseTable for struct CritterOverrideDef
#define TYPE_parse_CritterOverrideDef CritterOverrideDef
ParseTable parse_CritterOverrideDef[] =
{
	{ "CritterOverrideDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CritterOverrideDef), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Name",				TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_KEY | TOK_STRING(CritterOverrideDef, pchName, 0), NULL },
	{ "FileName",			TOK_POOL_STRING | TOK_CURRENTFILE(CritterOverrideDef, pchFileName), NULL},
	{ "Scope",				TOK_POOL_STRING | TOK_STRING(CritterOverrideDef, pchScope, 0), NULL },
	{ "Mass",				TOK_F32(CritterOverrideDef, fMass, -1), NULL },
	{ "Comment",			TOK_STRING(CritterOverrideDef, pchComment, 0), NULL },
	{ "onDeathPower",		TOK_STRUCT(CritterOverrideDef, ppOnDeathPowers, parse_ref_PowerDef) },
	{ "Flags",				TOK_AUTOINT(CritterOverrideDef, eFlags, kCritterOverrideFlag_None), kCritterOverrideFlagEnum  ,  TOK_FORMAT_FLAGS},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CritterOverrideDef()
{
	int iSize = sizeof(CritterOverrideDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CritterOverrideDef, iSize, "CritterOverrideDef", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_CritterOverrideDef[5].param = GET_INTPTR_FROM_FLOAT((float)-1);
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CritterTags
#define TYPE_parse_CritterTags CritterTags
ParseTable parse_CritterTags[] =
{
	{ "CritterTags", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CritterTags), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "critterTags",	TOK_STRINGARRAY(CritterTags, critterTags), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CritterTags()
{
	int iSize = sizeof(CritterTags);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CritterTags, iSize, "CritterTags", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AlwaysPropSlotRef
#define TYPE_parse_AlwaysPropSlotRef AlwaysPropSlotRef
ParseTable parse_AlwaysPropSlotRef[] =
{
	{ "AlwaysPropSlotRef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AlwaysPropSlotRef), 0, NULL, 0, NULL },
	{ "hPropDef",			TOK_STRUCTPARAM | TOK_REFERENCE(AlwaysPropSlotRef, hPropDef, 0, "AlwaysPropSlotDef") },
	{ "\n",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AlwaysPropSlotRef()
{
	int iSize = sizeof(AlwaysPropSlotRef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AlwaysPropSlotRef, iSize, "AlwaysPropSlotRef", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PTNodeDefRef[];
#define TYPE_parse_PTNodeDefRef PTNodeDefRef
//Structparser.exe autogenerated ParseTable for struct PetDiagNode
#define TYPE_parse_PetDiagNode PetDiagNode
ParseTable parse_PetDiagNode[] =
{
	{ "PetDiagNode", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PetDiagNode), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Category",		TOK_INTARRAY(PetDiagNode, piCategories),  PowerCategoriesEnum},
	{ "Purpose",		TOK_AUTOINT(PetDiagNode, ePurpose, 0), PowerPurposeEnum },
	{ "Count",			TOK_AUTOINT(PetDiagNode, iCount, 1), NULL },
	{ "Replacement",	TOK_STRUCT(PetDiagNode, ppReplacements, parse_PTNodeDefRef) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PetDiagNode()
{
	int iSize = sizeof(PetDiagNode);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PetDiagNode, iSize, "PetDiagNode", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PetDiagNode[];
#define TYPE_parse_PetDiagNode PetDiagNode
//Structparser.exe autogenerated ParseTable for struct PetDiag
#define TYPE_parse_PetDiag PetDiag
ParseTable parse_PetDiag[] =
{
	{ "PetDiag", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PetDiag), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Name",			TOK_STRUCTPARAM | TOK_KEY | TOK_STRING(PetDiag, pchName, 0), NULL },
	{ "Filename",		TOK_POOL_STRING | TOK_CURRENTFILE(PetDiag, pchFilename), NULL},
	{ "PetDiagNode",	TOK_STRUCT(PetDiag, ppNodes, parse_PetDiagNode) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PetDiag()
{
	int iSize = sizeof(PetDiag);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PetDiag, iSize, "PetDiag", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_AlwaysPropSlotRef[];
#define TYPE_parse_AlwaysPropSlotRef AlwaysPropSlotRef
extern ParseTable parse_PTNodeDefRef[];
#define TYPE_parse_PTNodeDefRef PTNodeDefRef
extern ParseTable parse_InteriorDefRef[];
#define TYPE_parse_InteriorDefRef InteriorDefRef
//Structparser.exe autogenerated ParseTable for struct PetDef
#define TYPE_parse_PetDef PetDef
ParseTable parse_PetDef[] =
{
	{ "PetDef", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PetDef), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "PetName",				TOK_STRUCTPARAM | TOK_KEY | TOK_STRING(PetDef, pchPetName, 0), NULL },
	{ "Filename",				TOK_POOL_STRING | TOK_CURRENTFILE(PetDef, pchFilename), NULL},
	{ "CritterDef",				TOK_REFERENCE(PetDef, hCritterDef, 0, "CritterDef") },
	{ "DisplayName",			TOK_EMBEDDEDSTRUCT(PetDef, displayNameMsg, parse_DisplayMessage)},
	{ "Allegiance",				TOK_REFERENCE(PetDef, hAllegiance, 0, "Allegiance") },
	{ "AlwaysPropSlot",			TOK_STRUCT(PetDef, ppAlwaysPropSlot, parse_AlwaysPropSlotRef) },
	{ "EscrowPower",			TOK_STRUCT(PetDef, ppEscrowPowers, parse_PTNodeDefRef) },
	{ "InteriorDef",			TOK_STRUCT(PetDef, ppInteriorDefs, parse_InteriorDefRef) },
	{ "TradeableItem",			TOK_REFERENCE(PetDef, hTradableItem, 0, "ItemDef") },
	{ "MinActivePuppetLevel",	TOK_AUTOINT(PetDef, iMinActivePuppetLevel, 0), NULL },
	{ "CanBePuppet",			TOK_BIT, 0, 8, NULL},
	{ "CanRemove",				TOK_BIT, 0, 8, NULL},
	{ "CritterPet",				TOK_BIT, 0, 8, NULL},
	{ "ChooseRandomName",		TOK_BIT, 0, 8, NULL},
	{ "IsUnique",				TOK_BIT, 0, 8, NULL},
	{ "AutoGrant",				TOK_BIT, 0, 8, NULL},
	{ "DisableTrainingFromPet",	TOK_BIT, 0, 8, NULL},
	{ "PermanentName",			TOK_BIT, 0, 8, NULL},
	{ "AlwaysSubscribe",		TOK_BIT, 0, 8, NULL},
	{ "PetDiag",				TOK_REFERENCE(PetDef, hPetDiag, 0, "PetDiag") },
	{ "CharacterClass",			TOK_REFERENCE(PetDef, hClass, 0, "CharacterClass") },
	{ "AcquireLimit",			TOK_AUTOINT(PetDef, eAcquireLimit, 0), PetAcquireLimitEnum },
	{ "Type",					TOK_IGNORE, 0 },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PetDef()
{
	int iSize = sizeof(PetDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PetDef, iSize, "PetDef", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PetDef) + 7) / 4;
		PetDef *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bCanBePuppet = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PetDef[12]);
		pTemp->bCanBePuppet = 0;
		pTemp->bCanRemove = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PetDef[13]);
		pTemp->bCanRemove = 0;
		pTemp->bCritterPet = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PetDef[14]);
		pTemp->bCritterPet = 0;
		pTemp->bChooseRandomName = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PetDef[15]);
		pTemp->bChooseRandomName = 0;
		pTemp->bIsUnique = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PetDef[16]);
		pTemp->bIsUnique = 0;
		pTemp->bAutoGrant = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PetDef[17]);
		pTemp->bAutoGrant = 0;
		pTemp->bDisableTrainingFromPet = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PetDef[18]);
		pTemp->bDisableTrainingFromPet = 0;
		pTemp->bPermanentName = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PetDef[19]);
		pTemp->bPermanentName = 0;
		pTemp->bAlwaysSubscribe = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PetDef[20]);
		pTemp->bAlwaysSubscribe = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PetDefRef
#define TYPE_parse_PetDefRef PetDefRef
ParseTable parse_PetDefRef[] =
{
	{ "PetDefRef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PetDefRef), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "hPet",		TOK_REFERENCE(PetDefRef, hPet, 0, "PetDef") },
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PetDefRef()
{
	int iSize = sizeof(PetDefRef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PetDefRef, iSize, "PetDefRef", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PetDefRefCont
#define TYPE_parse_PetDefRefCont PetDefRefCont
ParseTable parse_PetDefRefCont[] =
{
	{ "PetDefRefCont", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PetDefRefCont), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "hPet",			TOK_PERSIST | TOK_REFERENCE(PetDefRefCont, hPet, 0, "PetDef") },
	{ "uiPetID",		TOK_PERSIST | TOK_AUTOINT(PetDefRefCont, uiPetID, 0), NULL },
	{ "bPetIsDeceased",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PetDefRefCont, bPetIsDeceased, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PetDefRefCont()
{
	int iSize = sizeof(PetDefRefCont);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PetDefRefCont, iSize, "PetDefRefCont", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InventoryBag[];
#define TYPE_parse_InventoryBag InventoryBag
//Structparser.exe autogenerated ParseTable for struct InteractionLootTracker
#define TYPE_parse_InteractionLootTracker InteractionLootTracker
ParseTable parse_InteractionLootTracker[] =
{
	{ "InteractionLootTracker", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InteractionLootTracker), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "LootBags",				TOK_NO_INDEX | TOK_STRUCT(InteractionLootTracker, eaLootBags, parse_InventoryBag) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InteractionLootTracker()
{
	int iSize = sizeof(InteractionLootTracker);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InteractionLootTracker, iSize, "InteractionLootTracker", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct RolloverTracker
#define TYPE_parse_RolloverTracker RolloverTracker
ParseTable parse_RolloverTracker[] =
{
	{ "RolloverTracker", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(RolloverTracker), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "erRef",						TOK_AUTOINT(RolloverTracker, erRef, 0), NULL },
	{ "uiNextPickupAttemptTime",	TOK_AUTOINT(RolloverTracker, uiNextPickupAttemptTime, 0), NULL },
	{ "attemptCount",				TOK_AUTOINT(RolloverTracker, attemptCount, 0), NULL },
	{ "WasInProximity",				TOK_BIT, 0, 8, NULL},
	{ "LockedAttempts",				TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_RolloverTracker()
{
	int iSize = sizeof(RolloverTracker);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_RolloverTracker, iSize, "RolloverTracker", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(RolloverTracker) + 7) / 4;
		RolloverTracker *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bWasInProximity = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_RolloverTracker[5]);
		pTemp->bWasInProximity = 0;
		pTemp->bLockedAttempts = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_RolloverTracker[6]);
		pTemp->bLockedAttempts = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InteractionLootTracker[];
#define TYPE_parse_InteractionLootTracker InteractionLootTracker
//Structparser.exe autogenerated ParseTable for struct CritterEncounterData
#define TYPE_parse_CritterEncounterData CritterEncounterData
ParseTable parse_CritterEncounterData[] =
{
	{ "CritterEncounterData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CritterEncounterData), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "hContactDefOverride",	TOK_SERVER_ONLY | TOK_REFERENCE(CritterEncounterData, hContactDefOverride, 0, "ContactDef") },
	{ "activeTeamSize",			TOK_AUTOINT(CritterEncounterData, activeTeamSize, 0), NULL },
	{ "activeTeamLevel",		TOK_AUTOINT(CritterEncounterData, activeTeamLevel, 0), NULL },
	{ "LootTracker",			TOK_SERVER_ONLY | TOK_OPTIONALSTRUCT(CritterEncounterData, pLootTracker, parse_InteractionLootTracker) },
	{ "perInteractingPlayers",	TOK_SERVER_ONLY | TOK_INTARRAY(CritterEncounterData, perInteractingPlayers),  NULL},
	{ "EnableSpawnAggroDelay",	TOK_AUTOINT(CritterEncounterData, bEnableSpawnAggroDelay, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CritterEncounterData()
{
	int iSize = sizeof(CritterEncounterData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CritterEncounterData, iSize, "CritterEncounterData", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_RewardTableRef[];
#define TYPE_parse_RewardTableRef RewardTableRef
extern ParseTable parse_CritterEncounterData[];
#define TYPE_parse_CritterEncounterData CritterEncounterData
extern ParseTable parse_InventoryBag[];
#define TYPE_parse_InventoryBag InventoryBag
extern ParseTable parse_RolloverTracker[];
#define TYPE_parse_RolloverTracker RolloverTracker
//Structparser.exe autogenerated ParseTable for struct Critter
#define TYPE_parse_Critter Critter
ParseTable parse_Critter[] =
{
	{ "Critter", 						TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(Critter), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "dirtyBit",						TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(Critter, dirtyBit, 0), NULL },
	{ "displayNameOverride",			TOK_STRING(Critter, displayNameOverride, 0), NULL },
	{ "critterDef",						TOK_PERSIST | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_REFERENCE(Critter, critterDef, 0, "CritterDef") },
	{ "petDef",							TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_REFERENCE(Critter, petDef, 0, "PetDef") },
	{ "critterOverrideDef",				TOK_SERVER_ONLY | TOK_REFERENCE(Critter, critterOverrideDef, 0, "CritterOverrideDef") },
	{ "fNumericRewardScale",			TOK_SERVER_ONLY | TOK_F32(Critter, fNumericRewardScale, 1.0), NULL },
	{ "eaAdditionalRewards",			TOK_SERVER_ONLY | TOK_STRUCT(Critter, eaAdditionalRewards, parse_RewardTableRef) },
	{ "eRewardType",					TOK_SERVER_ONLY | TOK_AUTOINT(Critter, eRewardType, 0), WorldEncounterRewardTypeEnum },
	{ "eRewardLevelType",				TOK_SERVER_ONLY | TOK_AUTOINT(Critter, eRewardLevelType, 0), WorldEncounterRewardLevelTypeEnum },
	{ "iRewardLevel",					TOK_SERVER_ONLY | TOK_AUTOINT(Critter, iRewardLevel, 0), NULL },
	{ "fOverrideSendDistance",			TOK_SERVER_ONLY | TOK_F32(Critter, fOverrideSendDistance, 0), NULL },
	{ "encounterData",					TOK_EMBEDDEDSTRUCT(Critter, encounterData, parse_CritterEncounterData)},
	{ "hSavedPet",						TOK_SERVER_ONLY | TOK_REFERENCE(Critter, hSavedPet, 0, "CopyDict_EntitySavedPet") },
	{ "hSavedPetOwner",					TOK_SERVER_ONLY | TOK_REFERENCE(Critter, hSavedPetOwner, 0, "CopyDict_EntitySavedPet") },
	{ "uiEntCreatePowerID",				TOK_AUTOINT(Critter, uiEntCreatePowerID, 0), NULL },
	{ "uiEntCreateAttribModDefIdx",		TOK_AUTOINT(Critter, uiEntCreateAttribModDefIdx, 0), NULL },
	{ "hDisplayNameMsg",				TOK_REFERENCE(Critter, hDisplayNameMsg, 0, "Message") },
	{ "hDisplaySubNameMsg",				TOK_REFERENCE(Critter, hDisplaySubNameMsg, 0, "Message") },
	{ "hGroupDisplayNameMsg",			TOK_REFERENCE(Critter, hGroupDisplayNameMsg, 0, "Message") },
	{ "pcGroupIcon",					TOK_POOL_STRING | TOK_STRING(Critter, pcGroupIcon, 0), NULL },
	{ "voiceSet",						TOK_POOL_STRING | TOK_STRING(Critter, voiceSet, 0), NULL },
	{ "iEncounterKey",					TOK_AUTOINT(Critter, iEncounterKey, 0), NULL },
	{ "hYoursCostumeRef",				TOK_REFERENCE(Critter, hYoursCostumeRef, 0, "PlayerCostume") },
	{ "hNotYoursCostumeRef",			TOK_REFERENCE(Critter, hNotYoursCostumeRef, 0, "PlayerCostume") },
	{ "eaLootBags",						TOK_STRUCT(Critter, eaLootBags, parse_InventoryBag) },
	{ "pcLootGlowFX",					TOK_POOL_STRING | TOK_CLIENT_ONLY | TOK_STRING(Critter, pcLootGlowFX, 0), NULL },
	{ "StanceWords",					TOK_POOL_STRING | TOK_STRINGARRAY(Critter, ppchStanceWords), NULL },
	{ "ppchStanceWords",				TOK_REDUNDANTNAME | TOK_POOL_STRING | TOK_STRINGARRAY(Critter, ppchStanceWords), NULL },
	{ "eaRolloverTrackers",				TOK_SERVER_ONLY | TOK_STRUCT(Critter, eaRolloverTrackers, parse_RolloverTracker) },
	{ "bDoNotAutoSetLootCostume",		TOK_BIT, 0, 8, NULL},
	{ "bKilled",						TOK_SERVER_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bIsInteractable",				TOK_BIT, 0, 8, NULL},
	{ "bRidable",						TOK_BIT, 0, 8, NULL},
	{ "bPseudoPlayer",					TOK_BIT, 0, 8, NULL},
	{ "bDeathRewardsGiven",				TOK_SERVER_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bIgnoreExternalAnimBits",		TOK_BIT, 0, 8, NULL},
	{ "bUseCapsuleForPowerArcChecks",	TOK_BIT, 0, 8, NULL},
	{ "bUseClosestPowerAnimNode",		TOK_BIT, 0, 8, NULL},
	{ "bAutoLootMe",					TOK_BIT, 0, 8, NULL},
	{ "bSetSpawnAnim",					TOK_BIT, 0, 8, NULL},
	{ "pcRank",							TOK_POOL_STRING | TOK_STRING(Critter, pcRank, 0), NULL },
	{ "pcSubRank",						TOK_POOL_STRING | TOK_STRING(Critter, pcSubRank, 0), NULL },
	{ "eInteractionFlag",				TOK_AUTOINT(Critter, eInteractionFlag, 0), kCritterOverrideFlagEnum  ,  TOK_FORMAT_FLAGS},
	{ "fMass",							TOK_F32(Critter, fMass, 0), NULL },
	{ "uInteractDist",					TOK_AUTOINT(Critter, uInteractDist, 0), NULL },
	{ "eCritterSubType",				TOK_AUTOINT(Critter, eCritterSubType, 0), CritterSubTypeEnum  ,  TOK_FORMAT_FLAGS},
	{ "pcNemesisMinionCostumeSet",		TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRING(Critter, pcNemesisMinionCostumeSet, 0), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_Critter()
{
	int iSize = sizeof(Critter);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_Critter, iSize, "Critter", NULL, "entCritter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(Critter)) + 7) / 4;
		NOCONST(Critter) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bDoNotAutoSetLootCostume = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Critter[31]);
		pTemp->bDoNotAutoSetLootCostume = 0;
		pTemp->bKilled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Critter[32]);
		pTemp->bKilled = 0;
		pTemp->bIsInteractable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Critter[33]);
		pTemp->bIsInteractable = 0;
		pTemp->bRidable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Critter[34]);
		pTemp->bRidable = 0;
		pTemp->bPseudoPlayer = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Critter[35]);
		pTemp->bPseudoPlayer = 0;
		pTemp->bDeathRewardsGiven = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Critter[36]);
		pTemp->bDeathRewardsGiven = 0;
		pTemp->bIgnoreExternalAnimBits = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Critter[37]);
		pTemp->bIgnoreExternalAnimBits = 0;
		pTemp->bUseCapsuleForPowerArcChecks = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Critter[38]);
		pTemp->bUseCapsuleForPowerArcChecks = 0;
		pTemp->bUseClosestPowerAnimNode = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Critter[39]);
		pTemp->bUseClosestPowerAnimNode = 0;
		pTemp->bAutoLootMe = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Critter[40]);
		pTemp->bAutoLootMe = 0;
		pTemp->bSetSpawnAnim = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Critter[41]);
		pTemp->bSetSpawnAnim = 0;
	}
	parse_Critter[7].param = GET_INTPTR_FROM_FLOAT((float)1.0);
	return 0;
};
