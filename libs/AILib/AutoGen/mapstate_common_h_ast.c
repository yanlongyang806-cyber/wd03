#include "textparser.h"

//auto-generated staticdefine for enum ScoreboardState
//autogeneratednocheckin
StaticDefineInt ScoreboardStateEnum[] =
{
	DEFINE_INT
	{ "Init", kScoreboardState_Init},
	{ "Active", kScoreboardState_Active},
	{ "Final", kScoreboardState_Final},
	{ "Intermission", kScoreboardState_Intermission},
	DEFINE_END
};
void autoEnum_fixup_ScoreboardState(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ScoreboardStateEnum, "ScoreboardState");
}

//auto-generated staticdefine for enum PetTargetType
//autogeneratednocheckin
StaticDefineInt PetTargetTypeEnum[] =
{
	DEFINE_INT
	{ "NONE", kPetTargetType_NONE},
	{ "Generic", kPetTargetType_Generic},
	{ "Kill", kPetTargetType_Kill},
	{ "Tank", kPetTargetType_Tank},
	{ "Control", kPetTargetType_Control},
	{ "Protect", kPetTargetType_Protect},
	{ "COUNT", kPetTargetType_COUNT},
	DEFINE_END
};
void autoEnum_fixup_PetTargetType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PetTargetTypeEnum, "PetTargetType");
}
//autogeneratednocheckin
extern ParseTable parse_PVPGroupGameParams[];
#define TYPE_parse_PVPGroupGameParams PVPGroupGameParams
extern ParseTable parse_DOMControlPoint[];
#define TYPE_parse_DOMControlPoint DOMControlPoint
//Structparser.exe autogenerated ParseTable for struct MatchMapState
#define TYPE_parse_MatchMapState MatchMapState
ParseTable parse_MatchMapState[] =
{
	{ "MatchMapState", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MatchMapState), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "ScoreboardName",		TOK_POOL_STRING | TOK_STRING(MatchMapState, pcScoreboardName, 0), NULL },
	{ "State",				TOK_AUTOINT(MatchMapState, eState, 0), ScoreboardStateEnum },
	{ "uCounterTime",		TOK_AUTOINT(MatchMapState, uCounterTime, 0), NULL },
	{ "Countdown",			TOK_AUTOINT(MatchMapState, bCountdown, 0), NULL },
	{ "Overtime",			TOK_AUTOINT(MatchMapState, bOvertime, 0), NULL },
	{ "uTotalMatchTime",	TOK_AUTOINT(MatchMapState, uTotalMatchTime, 0), NULL },
	{ "GroupGameParams",	TOK_STRUCT(MatchMapState, ppGroupGameParams, parse_PVPGroupGameParams) },
	{ "GameSpecific",		TOK_STRUCT(MatchMapState, ppGameSpecific, parse_DOMControlPoint) },
	{ "pvpRules",			TOK_AUTOINT(MatchMapState, pvpRules, 0), PVPPublicGameRulesEnum },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MatchMapState()
{
	int iSize = sizeof(MatchMapState);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MatchMapState, iSize, "MatchMapState", NULL, "mapstate_common.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_GameEvent[];
#define TYPE_parse_GameEvent GameEvent
//Structparser.exe autogenerated ParseTable for struct MapStateValue
#define TYPE_parse_MapStateValue MapStateValue
ParseTable parse_MapStateValue[] =
{
	{ "MapStateValue", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MapStateValue), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Name",			TOK_POOL_STRING | TOK_KEY | TOK_STRING(MapStateValue, pcName, 0), NULL },
	{ "mvValue",		TOK_MULTIVAL(MapStateValue, mvValue), NULL},
	{ "GameEvent",		TOK_SERVER_ONLY | TOK_OPTIONALSTRUCT(MapStateValue, pGameEvent, parse_GameEvent) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MapStateValue()
{
	int iSize = sizeof(MapStateValue);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MapStateValue, iSize, "MapStateValue", NULL, "mapstate_common.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_MapStateValue[];
#define TYPE_parse_MapStateValue MapStateValue
//Structparser.exe autogenerated ParseTable for struct MapStateValueData
#define TYPE_parse_MapStateValueData MapStateValueData
ParseTable parse_MapStateValueData[] =
{
	{ "MapStateValueData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MapStateValueData), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "dirtyBit",			TOK_DIRTY_BIT | TOK_AUTOINT(MapStateValueData, dirtyBit, 0), NULL },
	{ "Values",				TOK_STRUCT(MapStateValueData, eaValues, parse_MapStateValue) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MapStateValueData()
{
	int iSize = sizeof(MapStateValueData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MapStateValueData, iSize, "MapStateValueData", NULL, "mapstate_common.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PetTargetingInfo
#define TYPE_parse_PetTargetingInfo PetTargetingInfo
ParseTable parse_PetTargetingInfo[] =
{
	{ "PetTargetingInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PetTargetingInfo), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "erPet",				TOK_AUTOINT(PetTargetingInfo, erPet, 0), NULL },
	{ "Type",				TOK_AUTOINT(PetTargetingInfo, eType, 0), PetTargetTypeEnum },
	{ "erTarget",			TOK_AUTOINT(PetTargetingInfo, erTarget, 0), NULL },
	{ "Index",				TOK_AUTOINT(PetTargetingInfo, iIndex, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PetTargetingInfo()
{
	int iSize = sizeof(PetTargetingInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PetTargetingInfo, iSize, "PetTargetingInfo", NULL, "mapstate_common.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_MapStateValue[];
#define TYPE_parse_MapStateValue MapStateValue
extern ParseTable parse_PetTargetingInfo[];
#define TYPE_parse_PetTargetingInfo PetTargetingInfo
//Structparser.exe autogenerated ParseTable for struct PlayerMapValues
#define TYPE_parse_PlayerMapValues PlayerMapValues
ParseTable parse_PlayerMapValues[] =
{
	{ "PlayerMapValues", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerMapValues), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "EntID",				TOK_KEY | TOK_AUTOINT(PlayerMapValues, iEntID, 0), NULL },
	{ "Values",				TOK_STRUCT(PlayerMapValues, eaValues, parse_MapStateValue) },
	{ "PetTargetingInfo",	TOK_STRUCT(PlayerMapValues, eaPetTargetingInfo, parse_PetTargetingInfo) },
	{ "uiRespawnCount",		TOK_SERVER_ONLY | TOK_AUTOINT(PlayerMapValues, uiRespawnCount, 0), NULL },
	{ "uiLastRespawnTime",	TOK_SERVER_ONLY | TOK_AUTOINT(PlayerMapValues, uiLastRespawnTime, 0), NULL },
	{ "uTimeInitialized",	TOK_SERVER_ONLY | TOK_AUTOINT(PlayerMapValues, uTimeInitialized, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerMapValues()
{
	int iSize = sizeof(PlayerMapValues);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerMapValues, iSize, "PlayerMapValues", NULL, "mapstate_common.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PlayerMapValues[];
#define TYPE_parse_PlayerMapValues PlayerMapValues
//Structparser.exe autogenerated ParseTable for struct PlayerMapValueData
#define TYPE_parse_PlayerMapValueData PlayerMapValueData
ParseTable parse_PlayerMapValueData[] =
{
	{ "PlayerMapValueData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerMapValueData), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "dirtyBit",			TOK_DIRTY_BIT | TOK_AUTOINT(PlayerMapValueData, dirtyBit, 0), NULL },
	{ "PlayerValues",		TOK_STRUCT(PlayerMapValueData, eaPlayerValues, parse_PlayerMapValues) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerMapValueData()
{
	int iSize = sizeof(PlayerMapValueData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerMapValueData, iSize, "PlayerMapValueData", NULL, "mapstate_common.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct NodeMapStateEntry
#define TYPE_parse_NodeMapStateEntry NodeMapStateEntry
ParseTable parse_NodeMapStateEntry[] =
{
	{ "NodeMapStateEntry", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(NodeMapStateEntry), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "NodeName",			TOK_KEY | TOK_STRING(NodeMapStateEntry, pcNodeName, 0), NULL },
	{ "uEntToWaitFor",		TOK_AUTOINT(NodeMapStateEntry, uEntToWaitFor, 0), NULL },
	{ "Hidden",				TOK_AUTOINT(NodeMapStateEntry, bHidden, 0), NULL },
	{ "Disabled",			TOK_AUTOINT(NodeMapStateEntry, bDisabled, 0), NULL },
	{ "WaitingForEnt",		TOK_CLIENT_ONLY | TOK_AUTOINT(NodeMapStateEntry, iWaitingForEnt, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_NodeMapStateEntry()
{
	int iSize = sizeof(NodeMapStateEntry);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_NodeMapStateEntry, iSize, "NodeMapStateEntry", NULL, "mapstate_common.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_NodeMapStateEntry[];
#define TYPE_parse_NodeMapStateEntry NodeMapStateEntry
//Structparser.exe autogenerated ParseTable for struct NodeMapStateData
#define TYPE_parse_NodeMapStateData NodeMapStateData
ParseTable parse_NodeMapStateData[] =
{
	{ "NodeMapStateData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(NodeMapStateData), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "dirtyBit",			TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(NodeMapStateData, dirtyBit, 0), NULL },
	{ "NodeEntries",		TOK_STRUCT(NodeMapStateData, eaNodeEntries, parse_NodeMapStateEntry) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_NodeMapStateData()
{
	int iSize = sizeof(NodeMapStateData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_NodeMapStateData, iSize, "NodeMapStateData", NULL, "mapstate_common.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PetTargetingInfo[];
#define TYPE_parse_PetTargetingInfo PetTargetingInfo
//Structparser.exe autogenerated ParseTable for struct TeamMapValues
#define TYPE_parse_TeamMapValues TeamMapValues
ParseTable parse_TeamMapValues[] =
{
	{ "TeamMapValues", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(TeamMapValues), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "TeamID",				TOK_KEY | TOK_AUTOINT(TeamMapValues, iTeamID, 0), NULL },
	{ "PetTargetingInfo",	TOK_STRUCT(TeamMapValues, eaPetTargetingInfo, parse_PetTargetingInfo) },
	{ "uiCreatedTime",		TOK_AUTOINT(TeamMapValues, uiCreatedTime, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_TeamMapValues()
{
	int iSize = sizeof(TeamMapValues);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_TeamMapValues, iSize, "TeamMapValues", NULL, "mapstate_common.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_TeamMapValues[];
#define TYPE_parse_TeamMapValues TeamMapValues
//Structparser.exe autogenerated ParseTable for struct TeamMapValueData
#define TYPE_parse_TeamMapValueData TeamMapValueData
ParseTable parse_TeamMapValueData[] =
{
	{ "TeamMapValueData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(TeamMapValueData), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "dirtyBit",			TOK_DIRTY_BIT | TOK_AUTOINT(TeamMapValueData, dirtyBit, 0), NULL },
	{ "TeamValues",			TOK_STRUCT(TeamMapValueData, eaTeamValues, parse_TeamMapValues) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_TeamMapValueData()
{
	int iSize = sizeof(TeamMapValueData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_TeamMapValueData, iSize, "TeamMapValueData", NULL, "mapstate_common.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldVariable[];
#define TYPE_parse_WorldVariable WorldVariable
extern ParseTable parse_WorldVariable[];
#define TYPE_parse_WorldVariable WorldVariable
//Structparser.exe autogenerated ParseTable for struct PublicVariableData
#define TYPE_parse_PublicVariableData PublicVariableData
ParseTable parse_PublicVariableData[] =
{
	{ "PublicVariableData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PublicVariableData), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "dirtyBit",			TOK_DIRTY_BIT | TOK_AUTOINT(PublicVariableData, dirtyBit, 0), NULL },
	{ "PublicVars",			TOK_STRUCT(PublicVariableData, eaPublicVars, parse_WorldVariable) },
	{ "ShardPublicVars",	TOK_STRUCT(PublicVariableData, eaShardPublicVars, parse_WorldVariable) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PublicVariableData()
{
	int iSize = sizeof(PublicVariableData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PublicVariableData, iSize, "PublicVariableData", NULL, "mapstate_common.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct SyncDialogMember
#define TYPE_parse_SyncDialogMember SyncDialogMember
ParseTable parse_SyncDialogMember[] =
{
	{ "SyncDialogMember", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(SyncDialogMember), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "entRef",				TOK_KEY | TOK_AUTOINT(SyncDialogMember, entRef, 0), NULL },
	{ "AwaitingResponse",	TOK_AUTOINT(SyncDialogMember, bAwaitingResponse, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_SyncDialogMember()
{
	int iSize = sizeof(SyncDialogMember);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_SyncDialogMember, iSize, "SyncDialogMember", NULL, "mapstate_common.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_SyncDialogMember[];
#define TYPE_parse_SyncDialogMember SyncDialogMember
extern ParseTable parse_ContactDialogOptionData[];
#define TYPE_parse_ContactDialogOptionData ContactDialogOptionData
//Structparser.exe autogenerated ParseTable for struct SyncDialog
#define TYPE_parse_SyncDialog SyncDialog
ParseTable parse_SyncDialog[] =
{
	{ "SyncDialog", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(SyncDialog), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "uiTeamID",		TOK_KEY | TOK_AUTOINT(SyncDialog, uiTeamID, 0), NULL },
	{ "Members",		TOK_STRUCT(SyncDialog, eaMembers, parse_SyncDialogMember) },
	{ "uiExpireTime",	TOK_AUTOINT(SyncDialog, uiExpireTime, 0), NULL },
	{ "hContactDef",	TOK_SERVER_ONLY | TOK_REFERENCE(SyncDialog, hContactDef, 0, "ContactDef") },
	{ "Data",			TOK_SERVER_ONLY | TOK_OPTIONALSTRUCT(SyncDialog, pData, parse_ContactDialogOptionData) },
	{ "Initiator",		TOK_SERVER_ONLY | TOK_AUTOINT(SyncDialog, iInitiator, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_SyncDialog()
{
	int iSize = sizeof(SyncDialog);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_SyncDialog, iSize, "SyncDialog", NULL, "mapstate_common.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PlayerCostume[];
#define TYPE_parse_PlayerCostume PlayerCostume
//Structparser.exe autogenerated ParseTable for struct NemesisTeamStruct
#define TYPE_parse_NemesisTeamStruct NemesisTeamStruct
ParseTable parse_NemesisTeamStruct[] =
{
	{ "NemesisTeamStruct", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(NemesisTeamStruct), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Id",					TOK_AUTOINT(NemesisTeamStruct, iId, 0), NULL },
	{ "CritterDef",			TOK_REFERENCE(NemesisTeamStruct, hCritter, 0, "CritterDef") },
	{ "CritterGroup",		TOK_REFERENCE(NemesisTeamStruct, hCritterGroup, 0, "CritterGroup") },
	{ "NoNemesis",			TOK_AUTOINT(NemesisTeamStruct, bNoNemesis, 0), NULL },
	{ "NemesisCostumeSet",	TOK_POOL_STRING | TOK_STRING(NemesisTeamStruct, pchNemesisCostumeSet, 0), NULL },
	{ "NemesisName",		TOK_STRING(NemesisTeamStruct, pchNemesisName, 0), NULL },
	{ "NemesisCostume",		TOK_OPTIONALSTRUCT(NemesisTeamStruct, pNemesisCostume, parse_PlayerCostume) },
	{ "NemesisType",		TOK_POOL_STRING | TOK_STRING(NemesisTeamStruct, pchNemesisType, 0), NULL },
	{ "motivation",			TOK_AUTOINT(NemesisTeamStruct, motivation, 0), NemesisMotivationEnum },
	{ "personality",		TOK_AUTOINT(NemesisTeamStruct, personality, 0), NemesisPersonalityEnum },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_NemesisTeamStruct()
{
	int iSize = sizeof(NemesisTeamStruct);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_NemesisTeamStruct, iSize, "NemesisTeamStruct", NULL, "mapstate_common.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_NemesisTeamStruct[];
#define TYPE_parse_NemesisTeamStruct NemesisTeamStruct
//Structparser.exe autogenerated ParseTable for struct NemesisInfoStruct
#define TYPE_parse_NemesisInfoStruct NemesisInfoStruct
ParseTable parse_NemesisInfoStruct[] =
{
	{ "NemesisInfoStruct", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(NemesisInfoStruct), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "LeaderIdx",			TOK_AUTOINT(NemesisInfoStruct, iLeaderIdx, 0), NULL },
	{ "NemesisTeam",		TOK_STRUCT(NemesisInfoStruct, eaNemesisTeam, parse_NemesisTeamStruct) },
	{ "LeaderSet",			TOK_AUTOINT(NemesisInfoStruct, bLeaderSet, 0), NULL },
	{ "LeaderNoNemesis",	TOK_AUTOINT(NemesisInfoStruct, bLeaderNoNemesis, 0), NULL },
	{ "uTimeFirstChecked",	TOK_AUTOINT(NemesisInfoStruct, uTimeFirstChecked, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_NemesisInfoStruct()
{
	int iSize = sizeof(NemesisInfoStruct);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_NemesisInfoStruct, iSize, "NemesisInfoStruct", NULL, "mapstate_common.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_NodeMapStateData[];
#define TYPE_parse_NodeMapStateData NodeMapStateData
extern ParseTable parse_MapStateValueData[];
#define TYPE_parse_MapStateValueData MapStateValueData
extern ParseTable parse_PlayerMapValueData[];
#define TYPE_parse_PlayerMapValueData PlayerMapValueData
extern ParseTable parse_TeamMapValueData[];
#define TYPE_parse_TeamMapValueData TeamMapValueData
extern ParseTable parse_MapStateValueData[];
#define TYPE_parse_MapStateValueData MapStateValueData
extern ParseTable parse_OpenMission[];
#define TYPE_parse_OpenMission OpenMission
extern ParseTable parse_MatchMapState[];
#define TYPE_parse_MatchMapState MatchMapState
extern ParseTable parse_PublicVariableData[];
#define TYPE_parse_PublicVariableData PublicVariableData
extern ParseTable parse_SyncDialog[];
#define TYPE_parse_SyncDialog SyncDialog
extern ParseTable parse_NemesisTeamStruct[];
#define TYPE_parse_NemesisTeamStruct NemesisTeamStruct
//Structparser.exe autogenerated ParseTable for struct MapState
#define TYPE_parse_MapState MapState
ParseTable parse_MapState[] =
{
	{ "MapState", 						TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MapState), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "MapName",						TOK_POOL_STRING | TOK_STRING(MapState, pcMapName, 0), NULL },
	{ "PartitionIdx",					TOK_AUTOINT(MapState, iPartitionIdx, 0), NULL },
	{ "uServerTimeSecondsSince2000",	TOK_AUTOINT(MapState, uServerTimeSecondsSince2000, 0), NULL },
	{ "Paused",							TOK_BIT, 0, 8, NULL},
	{ "BeingDestroyed",					TOK_BIT, 0, 8, NULL},
	{ "PVPQueuesDisabled",				TOK_BIT, 0, 8, NULL},
	{ "SpeedRecharge",					TOK_F32(MapState, fSpeedRecharge, 1), NULL },
	{ "TimeControlTimer",				TOK_F32(MapState, fTimeControlTimer, 0), NULL },
	{ "TimeControlList",				TOK_STRING(MapState, pchTimeControlList, 0), NULL },
	{ "BolsterType",					TOK_AUTOINT(MapState, eBolsterType, kBolsterType_None), BolsterTypeEnum },
	{ "BolsterLevel",					TOK_AUTOINT(MapState, iBolsterLevel, 0), NULL },
	{ "Difficulty",						TOK_AUTOINT(MapState, iDifficulty, 0), NULL },
	{ "NodeData",						TOK_OPTIONALSTRUCT(MapState, pNodeData, parse_NodeMapStateData) },
	{ "MapValues",						TOK_OPTIONALSTRUCT(MapState, pMapValues, parse_MapStateValueData) },
	{ "PlayerValueData",				TOK_OPTIONALSTRUCT(MapState, pPlayerValueData, parse_PlayerMapValueData) },
	{ "TeamValueData",					TOK_OPTIONALSTRUCT(MapState, pTeamValueData, parse_TeamMapValueData) },
	{ "PrototypeValues",				TOK_OPTIONALSTRUCT(MapState, pPrototypeValues, parse_MapStateValueData) },
	{ "OpenMissions",					TOK_STRUCT(MapState, eaOpenMissions, parse_OpenMission) },
	{ "matchState",						TOK_EMBEDDEDSTRUCT(MapState, matchState, parse_MatchMapState)},
	{ "PublicVarData",					TOK_OPTIONALSTRUCT(MapState, pPublicVarData, parse_PublicVariableData) },
	{ "SyncDialogs",					TOK_STRUCT(MapState, eaSyncDialogs, parse_SyncDialog) },
	{ "nemesisInfo", 					TOK_IGNORE | TOK_FLATEMBED },
	{ "LeaderIdx",						TOK_AUTOINT(MapState, nemesisInfo.iLeaderIdx, 0), NULL },
	{ "NemesisTeam",					TOK_STRUCT(MapState, nemesisInfo.eaNemesisTeam, parse_NemesisTeamStruct) },
	{ "LeaderSet",						TOK_AUTOINT(MapState, nemesisInfo.bLeaderSet, 0), NULL },
	{ "LeaderNoNemesis",				TOK_AUTOINT(MapState, nemesisInfo.bLeaderNoNemesis, 0), NULL },
	{ "uTimeFirstChecked",				TOK_AUTOINT(MapState, nemesisInfo.uTimeFirstChecked, 0), NULL },
	{ "CutscenesPlayed",				TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRINGARRAY(MapState, ppchCutscenesPlayed), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_MapState()
{
	int iSize = sizeof(MapState);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MapState, iSize, "MapState", NULL, "mapstate_common.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(MapState) + 7) / 4;
		MapState *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bPaused = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MapState[5]);
		pTemp->bPaused = 0;
		pTemp->bBeingDestroyed = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MapState[6]);
		pTemp->bBeingDestroyed = 0;
		pTemp->bPVPQueuesDisabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MapState[7]);
		pTemp->bPVPQueuesDisabled = 0;
	}
	parse_MapState[8].param = GET_INTPTR_FROM_FLOAT((float)1);
	return 0;
};
