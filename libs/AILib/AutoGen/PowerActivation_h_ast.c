#include "textparser.h"

//auto-generated staticdefine for enum MovementInputBits
//autogeneratednocheckin
StaticDefineInt MovementInputBitsEnum[] =
{
	DEFINE_INT
	{ "Forward", kMovementInputBits_Forward},
	{ "Back", kMovementInputBits_Back},
	{ "Left", kMovementInputBits_Left},
	{ "Right", kMovementInputBits_Right},
	{ "MAX", kMovementInputBits_MAX},
	DEFINE_END
};
void autoEnum_fixup_MovementInputBits(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(MovementInputBitsEnum, "MovementInputBits");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerActivation
#define TYPE_parse_PowerActivation PowerActivation
ParseTable parse_PowerActivation[] =
{
	{ "PowerActivation", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerActivation), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Def",					TOK_SERVER_ONLY | TOK_REFERENCE(PowerActivation, hdef, 0, "PowerDef") },
	{ "Period",					TOK_SERVER_ONLY | TOK_AUTOINT(PowerActivation, uiPeriod, 0), NULL },
	{ "Pulse",					TOK_REDUNDANTNAME | TOK_SERVER_ONLY | TOK_AUTOINT(PowerActivation, uiPeriod, 0), NULL },
	{ "CostPaid",				TOK_SERVER_ONLY | TOK_F32(PowerActivation, fCostPaid, 0), NULL },
	{ "CostPaidSecondary",		TOK_SERVER_ONLY | TOK_F32(PowerActivation, fCostPaidSecondary, 0), NULL },
	{ "PlayedImmuneFX",			TOK_BIT, 0, 8, NULL},
	{ "TimerActivate",			TOK_SERVER_ONLY | TOK_F32(PowerActivation, fTimerActivate, 0), NULL },
	{ "Charged",				TOK_SERVER_ONLY | TOK_F32(PowerActivation, fTimeCharged, 0), NULL },
	{ "ChargedTotal",			TOK_SERVER_ONLY | TOK_F32(PowerActivation, fTimeChargedTotal, 0), NULL },
	{ "Maintained",				TOK_SERVER_ONLY | TOK_F32(PowerActivation, fTimeMaintained, 0), NULL },
	{ "Activated",				TOK_SERVER_ONLY | TOK_F32(PowerActivation, fTimeActivating, 0), NULL },
	{ "Finished",				TOK_SERVER_ONLY | TOK_F32(PowerActivation, fTimeFinished, 0), NULL },
	{ "ChargeRequired",			TOK_SERVER_ONLY | TOK_F32(PowerActivation, fTimeChargeRequired, 0), NULL },
	{ "ChargeRequiredCombo",	TOK_SERVER_ONLY | TOK_F32(PowerActivation, fTimeChargeRequiredCombo, 0), NULL },
	{ "LungeDistance",			TOK_SERVER_ONLY | TOK_F32(PowerActivation, fLungeDistance, 0), NULL },
	{ "ActHitTime",				TOK_F32(PowerActivation, fActHitTime, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PowerActivation()
{
	int iSize = sizeof(PowerActivation);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerActivation, iSize, "PowerActivation", NULL, "PowerActivation.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PowerActivation) + 7) / 4;
		PowerActivation *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bPlayedImmuneFX = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerActivation[7]);
		pTemp->bPlayedImmuneFX = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PowerRef[];
#define TYPE_parse_PowerRef PowerRef
//Structparser.exe autogenerated ParseTable for struct PowerActivationState
#define TYPE_parse_PowerActivationState PowerActivationState
ParseTable parse_PowerActivationState[] =
{
	{ "PowerActivationState", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerActivationState), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "ref",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_EMBEDDEDSTRUCT(PowerActivationState, ref, parse_PowerRef)},
	{ "uchID",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PowerActivationState, uchID, 0), NULL },
	{ "uiPeriod",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PowerActivationState, uiPeriod, 0), NULL },
	{ "fTimerActivate",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(PowerActivationState, fTimerActivate, 0), NULL },
	{ "fTimeCharged",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(PowerActivationState, fTimeCharged, 0), NULL },
	{ "fTimeChargedTotal",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(PowerActivationState, fTimeChargedTotal, 0), NULL },
	{ "fTimeActivating",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(PowerActivationState, fTimeActivating, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerActivationState()
{
	int iSize = sizeof(PowerActivationState);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerActivationState, iSize, "PowerActivationState", NULL, "PowerActivation.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerActivationRequest
#define TYPE_parse_PowerActivationRequest PowerActivationRequest
ParseTable parse_PowerActivationRequest[] =
{
	{ "PowerActivationRequest", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerActivationRequest), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "erTarget",					TOK_AUTOINT(PowerActivationRequest, erTarget, 0), NULL },
	{ "hObjectNodeKey",				TOK_REFERENCE(PowerActivationRequest, hObjectNodeKey, 0, "WorldInteractionNode") },
	{ "vecTarget",					TOK_VEC3(PowerActivationRequest, vecTarget), NULL },
	{ "vecTargetSecondary",			TOK_VEC3(PowerActivationRequest, vecTargetSecondary), NULL },
	{ "vecSourcePos",				TOK_VEC3(PowerActivationRequest, vecSourcePos), NULL },
	{ "vecSourceDir",				TOK_VEC3(PowerActivationRequest, vecSourceDir), NULL },
	{ "ivecTarget",					TOK_IVEC3(PowerActivationRequest, ivecTarget), NULL },
	{ "ivecTargetSecondary",		TOK_IVEC3(PowerActivationRequest, ivecTargetSecondary), NULL },
	{ "ivecSourcePos",				TOK_IVEC3(PowerActivationRequest, ivecSourcePos), NULL },
	{ "ivecSourceDir",				TOK_IVEC3(PowerActivationRequest, ivecSourceDir), NULL },
	{ "uiPowerID",					TOK_AUTOINT(PowerActivationRequest, uiPowerID, 0), NULL },
	{ "PowerName",					TOK_STRING(PowerActivationRequest, pchPowerName, 0), NULL },
	{ "uiTimeQueued",				TOK_AUTOINT(PowerActivationRequest, uiTimeQueued, 0), NULL },
	{ "uiTimeCurrented",			TOK_AUTOINT(PowerActivationRequest, uiTimeCurrented, 0), NULL },
	{ "uiTimeEnterStance",			TOK_AUTOINT(PowerActivationRequest, uiTimeEnterStance, 0), NULL },
	{ "erTargetPicking",			TOK_AUTOINT(PowerActivationRequest, erTargetPicking, 0), NULL },
	{ "Activate",					TOK_BIT, 0, 8, NULL},
	{ "ToggleDeactivate",			TOK_BIT, 0, 8, NULL},
	{ "CancelExisting",				TOK_BIT, 0, 8, NULL},
	{ "UseVecTarget",				TOK_BIT, 0, 8, NULL},
	{ "UseVecSource",				TOK_BIT, 0, 8, NULL},
	{ "UseSourceDir",				TOK_BIT, 0, 8, NULL},
	{ "UseAimTrajectoryPos",		TOK_BIT, 0, 8, NULL},
	{ "AnimateNow",					TOK_BIT, 0, 8, NULL},
	{ "PrimaryPet",					TOK_BIT, 0, 8, NULL},
	{ "AutoCommit",					TOK_BIT, 0, 8, NULL},
	{ "Unpredicted",				TOK_BIT, 0, 8, NULL},
	{ "DontDelayTargeting",			TOK_BIT, 0, 8, NULL},
	{ "UpdateChargeVecTarget",		TOK_BIT, 0, 8, NULL},
	{ "InputDirectionBits",			TOK_BIT, 0, 8, NULL},
	{ "uchActID",					TOK_AUTOINT(PowerActivationRequest, uchActID, 0), NULL },
	{ "puiActIDsCanceled",			TOK_INTARRAY(PowerActivationRequest, puiActIDsCanceled),  NULL},
	{ "ModeDeactivate",				TOK_AUTOINT(PowerActivationRequest, eModeDeactivate, 0), NULL },
	{ "PredictedIdx",				TOK_AUTOINT(PowerActivationRequest, iPredictedIdx, 0), NULL },
	{ "LungePrediction",			TOK_AUTOINT(PowerActivationRequest, iLungePrediction, 0), NULL },
	{ "uiSeq",						TOK_AUTOINT(PowerActivationRequest, uiSeq, 0), NULL },
	{ "uiSeqReset",					TOK_AUTOINT(PowerActivationRequest, uiSeqReset, 0), NULL },
	{ "erConfuseTarget",			TOK_AUTOINT(PowerActivationRequest, erConfuseTarget, 0), NULL },
	{ "perConfuseTargetList",		TOK_INTARRAY(PowerActivationRequest, perConfuseTargetList),  NULL},
	{ "uiConfuseSeed",				TOK_AUTOINT(PowerActivationRequest, uiConfuseSeed, 0), NULL },
	{ "erProximityAssistTarget",	TOK_AUTOINT(PowerActivationRequest, erProximityAssistTarget, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PowerActivationRequest()
{
	int iSize = sizeof(PowerActivationRequest);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerActivationRequest, iSize, "PowerActivationRequest", NULL, "PowerActivation.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PowerActivationRequest) + 7) / 4;
		PowerActivationRequest *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bActivate = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerActivationRequest[18]);
		pTemp->bActivate = 0;
		pTemp->bToggleDeactivate = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerActivationRequest[19]);
		pTemp->bToggleDeactivate = 0;
		pTemp->bCancelExisting = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerActivationRequest[20]);
		pTemp->bCancelExisting = 0;
		pTemp->bUseVecTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerActivationRequest[21]);
		pTemp->bUseVecTarget = 0;
		pTemp->bUseVecSource = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerActivationRequest[22]);
		pTemp->bUseVecSource = 0;
		pTemp->bUseSourceDir = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerActivationRequest[23]);
		pTemp->bUseSourceDir = 0;
		pTemp->bUseAimTrajectoryPos = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerActivationRequest[24]);
		pTemp->bUseAimTrajectoryPos = 0;
		pTemp->bAnimateNow = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerActivationRequest[25]);
		pTemp->bAnimateNow = 0;
		pTemp->bPrimaryPet = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerActivationRequest[26]);
		pTemp->bPrimaryPet = 0;
		pTemp->bAutoCommit = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerActivationRequest[27]);
		pTemp->bAutoCommit = 0;
		pTemp->bUnpredicted = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerActivationRequest[28]);
		pTemp->bUnpredicted = 0;
		pTemp->bDontDelayTargeting = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerActivationRequest[29]);
		pTemp->bDontDelayTargeting = 0;
		pTemp->bUpdateChargeVecTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerActivationRequest[30]);
		pTemp->bUpdateChargeVecTarget = 0;
		pTemp->eInputDirectionBits = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerActivationRequest[31]);
		pTemp->eInputDirectionBits = 0;
	}
	return 0;
};
