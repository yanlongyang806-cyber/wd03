#include "textparser.h"

//auto-generated staticdefine for enum GlobalEntityFlags
//autogeneratednocheckin
StaticDefineInt GlobalEntityFlagsEnum[] =
{
	DEFINE_INT
	{ "ENTITYFLAG_IS_PLAYER", ENTITYFLAG_IS_PLAYER},
	{ "ENTITYFLAG_DEAD", ENTITYFLAG_DEAD},
	{ "ENTITYFLAG_UNTARGETABLE", ENTITYFLAG_UNTARGETABLE},
	{ "ENTITYFLAG_UNSELECTABLE", ENTITYFLAG_UNSELECTABLE},
	{ "ENTITYFLAG_CIVILIAN", ENTITYFLAG_CIVILIAN},
	{ "ENTITYFLAG_CIV_PROCESSING_ONLY", ENTITYFLAG_CIV_PROCESSING_ONLY},
	{ "ENTITYFLAG_PLAYER_DISCONNECTED", ENTITYFLAG_PLAYER_DISCONNECTED},
	{ "ENTITYFLAG_PLAYER_LOGGING_IN", ENTITYFLAG_PLAYER_LOGGING_IN},
	{ "ENTITYFLAG_DONOTSEND", ENTITYFLAG_DONOTSEND},
	{ "ENTITYFLAG_DONOTDRAW", ENTITYFLAG_DONOTDRAW},
	{ "ENTITYFLAG_IGNORE", ENTITYFLAG_IGNORE},
	{ "ENTITYFLAG_DESTROY", ENTITYFLAG_DESTROY},
	{ "ENTITYFLAG_PLAYER_LOGGING_OUT", ENTITYFLAG_PLAYER_LOGGING_OUT},
	{ "ENTITYFLAG_PET_LOGGING_IN", ENTITYFLAG_PET_LOGGING_IN},
	{ "ENTITYFLAG_DONOTFADE", ENTITYFLAG_DONOTFADE},
	{ "ENTITYFLAG_PUPPETPROGRESS", ENTITYFLAG_PUPPETPROGRESS},
	{ "ENTITYFLAG_PLAYER_INVITE_WHITELIST_ENABLED", ENTITYFLAG_PLAYER_INVITE_WHITELIST_ENABLED},
	{ "ENTITYFLAG_PLAYER_TRADE_WHITELIST_ENABLED", ENTITYFLAG_PLAYER_TRADE_WHITELIST_ENABLED},
	{ "ENTITYFLAG_PLAYER_DUEL_WHITELIST_ENABLED", ENTITYFLAG_PLAYER_DUEL_WHITELIST_ENABLED},
	{ "ENTITYFLAG_VANITYPET", ENTITYFLAG_VANITYPET},
	{ "ENTITYFLAG_DOOR_SEQUENCE_IN_PROGRESS", ENTITYFLAG_DOOR_SEQUENCE_IN_PROGRESS},
	{ "ENTITYFLAG_CRITTERPET", ENTITYFLAG_CRITTERPET},
	{ "ENTITYFLAG_PROJECTILE", ENTITYFLAG_PROJECTILE},
	{ "ENTITYFLAG_PET_LOGGING_OUT", ENTITYFLAG_PET_LOGGING_OUT},
	DEFINE_END
};
void autoEnum_fixup_GlobalEntityFlags(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(GlobalEntityFlagsEnum, "GlobalEntityFlags");
}

//auto-generated staticdefine for enum MissionReturnErrorType
//autogeneratednocheckin
StaticDefineInt MissionReturnErrorTypeEnum[] =
{
	DEFINE_INT
	{ "None", MissionReturnErrorType_None},
	{ "InvalidMap", MissionReturnErrorType_InvalidMap},
	{ "InCombat", MissionReturnErrorType_InCombat},
	DEFINE_END
};
void autoEnum_fixup_MissionReturnErrorType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(MissionReturnErrorTypeEnum, "MissionReturnErrorType");
}

//auto-generated staticdefine for enum NeedOrGreedChoice
//autogeneratednocheckin
StaticDefineInt NeedOrGreedChoiceEnum[] =
{
	DEFINE_INT
	{ "None", NeedOrGreedChoice_None},
	{ "Pass", NeedOrGreedChoice_Pass},
	{ "Greed", NeedOrGreedChoice_Greed},
	{ "Need", NeedOrGreedChoice_Need},
	{ "Count", NeedOrGreedChoice_Count},
	DEFINE_END
};
void autoEnum_fixup_NeedOrGreedChoice(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(NeedOrGreedChoiceEnum, "NeedOrGreedChoice");
}

//auto-generated staticdefine for enum TeamState
//autogeneratednocheckin
StaticDefineInt TeamStateEnum[] =
{
	DEFINE_INT
	{ "Member", TeamState_Member},
	{ "Invitee", TeamState_Invitee},
	{ "Requester", TeamState_Requester},
	{ "LoggedOut", TeamState_LoggedOut},
	DEFINE_END
};
void autoEnum_fixup_TeamState(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(TeamStateEnum, "TeamState");
}

//auto-generated staticdefine for enum EntityVisibilityState
//autogeneratednocheckin
StaticDefineInt EntityVisibilityStateEnum[] =
{
	DEFINE_INT
	{ "Unknown", kEntityVisibility_Unknown},
	{ "Visible", kEntityVisibility_Visible},
	{ "Hidden", kEntityVisibility_Hidden},
	DEFINE_END
};
void autoEnum_fixup_EntityVisibilityState(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(EntityVisibilityStateEnum, "EntityVisibilityState");
}

//auto-generated staticdefine for enum OffscreenType
//autogeneratednocheckin
StaticDefineInt OffscreenTypeEnum[] =
{
	DEFINE_INT
	{ "Target", OffscreenType_Target},
	{ "Team", OffscreenType_Team},
	{ "Player", OffscreenType_Player},
	{ "CritterFriendly", OffscreenType_CritterFriendly},
	{ "CritterEnemy", OffscreenType_CritterEnemy},
	DEFINE_END
};
void autoEnum_fixup_OffscreenType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(OffscreenTypeEnum, "OffscreenType");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CurrentHood
#define TYPE_parse_CurrentHood CurrentHood
ParseTable parse_CurrentHood[] =
{
	{ "CurrentHood", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CurrentHood), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Name",			TOK_POOL_STRING | TOK_STRING(CurrentHood, pchName, 0), NULL },
	{ "hMessage",		TOK_REFERENCE(CurrentHood, hMessage, 0, "Message") },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CurrentHood()
{
	int iSize = sizeof(CurrentHood);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CurrentHood, iSize, "CurrentHood", NULL, "Entity.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerTeam
#define TYPE_parse_PlayerTeam PlayerTeam
ParseTable parse_PlayerTeam[] =
{
	{ "PlayerTeam", 						TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerTeam), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "iTeamID",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(PlayerTeam, iTeamID, 0), NULL },
	{ "iRejoinID",						TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(PlayerTeam, iRejoinID, 0), NULL },
	{ "hTeam",							TOK_SELF_ONLY | TOK_REFERENCE(PlayerTeam, hTeam, 0, "CopyDict_TEAM") },
	{ "bMapLocal",						TOK_SELF_ONLY | TOK_BIT, 0, 8, NULL},
	{ "iTimeSinceHandleInit",			TOK_NO_NETSEND | TOK_AUTOINT(PlayerTeam, iTimeSinceHandleInit, 0), NULL },
	{ "iTimeSinceLastUpdate",			TOK_NO_NETSEND | TOK_AUTOINT(PlayerTeam, iTimeSinceLastUpdate, 0), NULL },
	{ "eState",							TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(PlayerTeam, eState, 0), TeamStateEnum },
	{ "pcInviterName",					TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_STRING(PlayerTeam, pcInviterName, 0), NULL },
	{ "pcInviterHandle",				TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_STRING(PlayerTeam, pcInviterHandle, 0), NULL },
	{ "iLogoutTime",					TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(PlayerTeam, iLogoutTime, 0), NULL },
	{ "iVersion",						TOK_NO_NETSEND | TOK_AUTOINT(PlayerTeam, iVersion, 0), NULL },
	{ "iInChat",						TOK_NO_NETSEND | TOK_AUTOINT(PlayerTeam, iInChat, 0), NULL },
	{ "fLastUpdate",					TOK_NO_NETSEND | TOK_F32(PlayerTeam, fLastUpdate, 0), NULL },
	{ "bTriedRejoining",				TOK_NO_NETSEND | TOK_AUTOINT(PlayerTeam, bTriedRejoining, 0), NULL },
	{ "bUpdateTeamPowers",				TOK_NO_NETSEND | TOK_AUTOINT(PlayerTeam, bUpdateTeamPowers, 0), NULL },
	{ "bTeamMissionMapTransfer",		TOK_NO_NETSEND | TOK_AUTOINT(PlayerTeam, bTeamMissionMapTransfer, 0), NULL },
	{ "iNumMatchTries",					TOK_NO_NETSEND | TOK_AUTOINT(PlayerTeam, iNumMatchTries, 0), NULL },
	{ "bInTeamDialog",					TOK_AUTOINT(PlayerTeam, bInTeamDialog, 0), NULL },
	{ "bIsTeamSpokesman",				TOK_AUTOINT(PlayerTeam, bIsTeamSpokesman, 0), NULL },
	{ "eMode",							TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(PlayerTeam, eMode, 0), TeamModeEnum },
	{ "eLootMode",						TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(PlayerTeam, eLootMode, 0), LootModeEnum },
	{ "eLootQuality",					TOK_PERSIST | TOK_SELF_ONLY | TOK_POOL_STRING | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_STRING(PlayerTeam, eLootQuality, 0), NULL },
	{ "iNearbyTeamSize",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_AUTOINT(PlayerTeam, iNearbyTeamSize, 0), NULL },
	{ "pchDestinationMap",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_POOL_STRING | TOK_STRING(PlayerTeam, pchDestinationMap, 0), NULL },
	{ "iTeamSizeTimestamp",				TOK_AUTOINT(PlayerTeam, iTeamSizeTimestamp, 0), NULL },
	{ "iAverageTeamLevel",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_AUTOINT(PlayerTeam, iAverageTeamLevel, 0), NULL },
	{ "iAverageTeamLevelTime",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_AUTOINT(PlayerTeam, iAverageTeamLevelTime, 0), NULL },
	{ "iLastTeamIDForInitialMeeting",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerTeam, iLastTeamIDForInitialMeeting, 0), NULL },
	{ "lastRecruitType",				TOK_PERSIST | TOK_SOMETIMES_TRANSACT | TOK_SERVER_ONLY | TOK_AUTOINT(PlayerTeam, lastRecruitType, 0), NULL },
	{ "dirtyBit",						TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(PlayerTeam, dirtyBit, 0), NULL },
	{ "bAutoAcceptInvites",				TOK_IGNORE, 0 },
	{ "eInviteResponse",				TOK_IGNORE, 0 },
	{ "eEOIForSelf",					TOK_IGNORE, 0 },
	{ "bEOIForOthers",					TOK_IGNORE, 0 },
	{ "bAutoSidekickOnTeamJoin",		TOK_IGNORE, 0 },
	{ "iCompletedMissionsVersion",		TOK_IGNORE, 0 },
	{ "ppchCompletedMissions",			TOK_IGNORE, 0 },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PlayerTeam()
{
	int iSize = sizeof(PlayerTeam);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerTeam, iSize, "PlayerTeam", NULL, "Entity.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(PlayerTeam)) + 7) / 4;
		NOCONST(PlayerTeam) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bMapLocal = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerTeam[5]);
		pTemp->bMapLocal = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PlayerCostume[];
#define TYPE_parse_PlayerCostume PlayerCostume
extern ParseTable parse_PlayerCostume[];
#define TYPE_parse_PlayerCostume PlayerCostume
extern ParseTable parse_PlayerCostume[];
#define TYPE_parse_PlayerCostume PlayerCostume
extern ParseTable parse_PlayerCostume[];
#define TYPE_parse_PlayerCostume PlayerCostume
extern ParseTable parse_PCFXNoPersist[];
#define TYPE_parse_PCFXNoPersist PCFXNoPersist
extern ParseTable parse_CostumeTransformation[];
#define TYPE_parse_CostumeTransformation CostumeTransformation
//Structparser.exe autogenerated ParseTable for struct CostumeRef
#define TYPE_parse_CostumeRef CostumeRef
ParseTable parse_CostumeRef[] =
{
	{ "CostumeRef", 						TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CostumeRef), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "dirtyBit",						TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(CostumeRef, dirtyBit, 0), NULL },
	{ "dirtiedCount",					TOK_AUTOINT(CostumeRef, dirtiedCount, 0), NULL },
	{ "transformation",					TOK_AUTOINT(CostumeRef, transformation, 0), NULL },
	{ "pEffectiveCostume",				TOK_OPTIONALSTRUCT(CostumeRef, pEffectiveCostume, parse_PlayerCostume) },
	{ "pStoredCostume",					TOK_OPTIONALSTRUCT(CostumeRef, pStoredCostume, parse_PlayerCostume) },
	{ "pSubstituteCostume",				TOK_OPTIONALSTRUCT(CostumeRef, pSubstituteCostume, parse_PlayerCostume) },
	{ "hReferencedCostume",				TOK_REFERENCE(CostumeRef, hReferencedCostume, 0, "PlayerCostume") },
	{ "pcDestructibleObjectCostume",	TOK_STRING(CostumeRef, pcDestructibleObjectCostume, 0), NULL },
	{ "pMountCostume",					TOK_OPTIONALSTRUCT(CostumeRef, pMountCostume, parse_PlayerCostume) },
	{ "fMountScaleOverride",			TOK_F32(CostumeRef, fMountScaleOverride, 0), NULL },
	{ "bPredictDismount",				TOK_CLIENT_ONLY | TOK_AUTOINT(CostumeRef, bPredictDismount, 0), NULL },
	{ "hMood",							TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(CostumeRef, hMood, 0, "PCMood") },
	{ "eaAdditionalFX",					TOK_STRUCT(CostumeRef, eaAdditionalFX, parse_PCFXNoPersist) },
	{ "pTransformation",				TOK_OPTIONALSTRUCT(CostumeRef, pTransformation, parse_CostumeTransformation) },
	{ "hReferencedCostume",				TOK_IGNORE, 0 },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CostumeRef()
{
	int iSize = sizeof(CostumeRef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CostumeRef, iSize, "CostumeRef", NULL, "Entity.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct UIVar
#define TYPE_parse_UIVar UIVar
ParseTable parse_UIVar[] =
{
	{ "UIVar", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(UIVar), 0, NULL, 0, NULL },
	{ "{",		TOK_START, 0 },
	{ "Name",	TOK_POOL_STRING | TOK_KEY | TOK_STRING(UIVar, pchName, 0), NULL },
	{ "Value",	TOK_MULTIVAL(UIVar, Value), NULL},
	{ "}",		TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_UIVar()
{
	int iSize = sizeof(UIVar);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_UIVar, iSize, "UIVar", NULL, "Entity.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct EntityVisibilityCache
#define TYPE_parse_EntityVisibilityCache EntityVisibilityCache
ParseTable parse_EntityVisibilityCache[] =
{
	{ "EntityVisibilityCache", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(EntityVisibilityCache), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "uiLastCheckTimeMs",		TOK_AUTOINT(EntityVisibilityCache, uiLastCheckTimeMs, 0), NULL },
	{ "State",					TOK_AUTOINT(EntityVisibilityCache, eState, 0), EntityVisibilityStateEnum },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_EntityVisibilityCache()
{
	int iSize = sizeof(EntityVisibilityCache);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_EntityVisibilityCache, iSize, "EntityVisibilityCache", NULL, "Entity.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ChatBubble
#define TYPE_parse_ChatBubble ChatBubble
ParseTable parse_ChatBubble[] =
{
	{ "ChatBubble", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ChatBubble), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "uiStartTimeMs",	TOK_AUTOINT(ChatBubble, uiStartTimeMs, 0), NULL },
	{ "uiEndTimeMs",	TOK_AUTOINT(ChatBubble, uiEndTimeMs, 0), NULL },
	{ "Message",		TOK_STRING(ChatBubble, pchMessage, 0), NULL },
	{ "hDef",			TOK_REFERENCE(ChatBubble, hDef, 0, "ChatBubbleDef") },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ChatBubble()
{
	int iSize = sizeof(ChatBubble);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ChatBubble, iSize, "ChatBubble", NULL, "Entity.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DamageFloat
#define TYPE_parse_DamageFloat DamageFloat
ParseTable parse_DamageFloat[] =
{
	{ "DamageFloat", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DamageFloat), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "OffsetFrom",			TOK_AUTOINT(DamageFloat, eOffsetFrom, 0), NULL },
	{ "MaxLifetime",		TOK_F32(DamageFloat, fMaxLifetime, 0), NULL },
	{ "Lifetime",			TOK_F32(DamageFloat, fLifetime, 0), NULL },
	{ "Delay",				TOK_F32(DamageFloat, fDelay, 0), NULL },
	{ "v2Pos",				TOK_VEC2(DamageFloat, v2Pos), NULL },
	{ "v2Velocity",			TOK_VEC2(DamageFloat, v2Velocity), NULL },
	{ "v2DestPos",			TOK_VEC2(DamageFloat, v2DestPos), NULL },
	{ "Color",				TOK_AUTOINT(DamageFloat, iColor, 0), NULL },
	{ "Color2",				TOK_AUTOINT(DamageFloat, iColor2, 0), NULL },
	{ "Scale",				TOK_F32(DamageFloat, fScale, 0), NULL },
	{ "MaxPopout",			TOK_F32(DamageFloat, fMaxPopout, 0), NULL },
	{ "Priority",			TOK_F32(DamageFloat, fPriority, 0), NULL },
	{ "Message",			TOK_STRING(DamageFloat, pchMessage, 0), NULL },
	{ "Angle",				TOK_F32(DamageFloat, fAngle, 0), NULL },
	{ "IconOffsetFrom",		TOK_AUTOINT(DamageFloat, eIconOffsetFrom, 0), NULL },
	{ "v2IconPos",			TOK_VEC2(DamageFloat, v2IconPos), NULL },
	{ "v2IconPosOffset",	TOK_VEC2(DamageFloat, v2IconPosOffset), NULL },
	{ "IconColor",			TOK_AUTOINT(DamageFloat, iIconColor, 0), NULL },
	{ "IconScale",			TOK_F32(DamageFloat, fIconScale, 0), NULL },
	{ "IconFade",			TOK_F32(DamageFloat, fIconFade, 0), NULL },
	{ "hFont",				TOK_REFERENCE(DamageFloat, hFont, 0, "UIStyleFont") },
	{ "v2PosOffset",		TOK_VEC2(DamageFloat, v2PosOffset), NULL },
	{ "v2VelocityBase",		TOK_VEC2(DamageFloat, v2VelocityBase), NULL },
	{ "v2Size",				TOK_VEC2(DamageFloat, v2Size), NULL },
	{ "uiPowID",			TOK_AUTOINT(DamageFloat, uiPowID, 0), NULL },
	{ "combatTrackerFlags",	TOK_AUTOINT(DamageFloat, combatTrackerFlags, 0), NULL },
	{ "Crit",				TOK_AUTOINT(DamageFloat, bCrit, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DamageFloat()
{
	int iSize = sizeof(DamageFloat);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DamageFloat, iSize, "DamageFloat", NULL, "Entity.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DamageFloat[];
#define TYPE_parse_DamageFloat DamageFloat
//Structparser.exe autogenerated ParseTable for struct DamageFloatGroup
#define TYPE_parse_DamageFloatGroup DamageFloatGroup
ParseTable parse_DamageFloatGroup[] =
{
	{ "DamageFloatGroup", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DamageFloatGroup), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "DamageFloats",		TOK_STRUCT(DamageFloatGroup, eaDamageFloats, parse_DamageFloat) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DamageFloatGroup()
{
	int iSize = sizeof(DamageFloatGroup);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DamageFloatGroup, iSize, "DamageFloatGroup", NULL, "Entity.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_EncounterUIData[];
#define TYPE_parse_EncounterUIData EncounterUIData
//Structparser.exe autogenerated ParseTable for struct EncounterUIData
#define TYPE_parse_EncounterUIData EncounterUIData
ParseTable parse_EncounterUIData[] =
{
	{ "EncounterUIData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(EncounterUIData), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "erEnt",				TOK_AUTOINT(EncounterUIData, erEnt, 0), NULL },
	{ "Count",				TOK_AUTOINT(EncounterUIData, iCount, 0), NULL },
	{ "Min",				TOK_VEC2(EncounterUIData, vMin), NULL },
	{ "Max",				TOK_VEC2(EncounterUIData, vMax), NULL },
	{ "ScreenDist",			TOK_F32(EncounterUIData, fScreenDist, 0), NULL },
	{ "PosSum",				TOK_VEC3(EncounterUIData, vPosSum), NULL },
	{ "Children",			TOK_STRUCT(EncounterUIData, eaChildren, parse_EncounterUIData) },
	{ "ValidChildren",		TOK_AUTOINT(EncounterUIData, iValidChildren, 0), NULL },
	{ "GenName",			TOK_POOL_STRING | TOK_STRING(EncounterUIData, pchGenName, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_EncounterUIData()
{
	int iSize = sizeof(EncounterUIData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_EncounterUIData, iSize, "EncounterUIData", NULL, "Entity.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_EncounterUIData[];
#define TYPE_parse_EncounterUIData EncounterUIData
//Structparser.exe autogenerated ParseTable for struct OffscreenUIData
#define TYPE_parse_OffscreenUIData OffscreenUIData
ParseTable parse_OffscreenUIData[] =
{
	{ "OffscreenUIData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(OffscreenUIData), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "erEnt",				TOK_AUTOINT(OffscreenUIData, erEnt, 0), NULL },
	{ "Count",				TOK_AUTOINT(OffscreenUIData, iCount, 0), NULL },
	{ "Combined",			TOK_AUTOINT(OffscreenUIData, iCombined, 0), NULL },
	{ "Edge",				TOK_AUTOINT(OffscreenUIData, iEdge, 0), NULL },
	{ "Position",			TOK_F32(OffscreenUIData, fPosition, 0), NULL },
	{ "DistanceIndex",		TOK_AUTOINT(OffscreenUIData, iDistanceIndex, 0), NULL },
	{ "Type",				TOK_AUTOINT(OffscreenUIData, iType, 0), OffscreenTypeEnum },
	{ "EncData",			TOK_UNOWNED | TOK_OPTIONALSTRUCT(OffscreenUIData, pEncData, parse_EncounterUIData) },
	{ "Same",				TOK_AUTOINT(OffscreenUIData, bSame, 0), NULL },
	{ "Encounter",			TOK_AUTOINT(OffscreenUIData, bEncounter, 0), NULL },
	{ "GenName",			TOK_POOL_STRING | TOK_STRING(OffscreenUIData, pchGenName, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_OffscreenUIData()
{
	int iSize = sizeof(OffscreenUIData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_OffscreenUIData, iSize, "OffscreenUIData", NULL, "Entity.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_EntityVisibilityCache[];
#define TYPE_parse_EntityVisibilityCache EntityVisibilityCache
extern ParseTable parse_ChatBubble[];
#define TYPE_parse_ChatBubble ChatBubble
extern ParseTable parse_EncounterUIData[];
#define TYPE_parse_EncounterUIData EncounterUIData
extern ParseTable parse_OffscreenUIData[];
#define TYPE_parse_OffscreenUIData OffscreenUIData
extern ParseTable parse_DamageFloatGroup[];
#define TYPE_parse_DamageFloatGroup DamageFloatGroup
//Structparser.exe autogenerated ParseTable for struct EntityUI
#define TYPE_parse_EntityUI EntityUI
ParseTable parse_EntityUI[] =
{
	{ "EntityUI", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(EntityUI), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "VisCache",					TOK_EMBEDDEDSTRUCT(EntityUI, VisCache, parse_EntityVisibilityCache)},
	{ "Bubbles",					TOK_STRUCT(EntityUI, eaBubbles, parse_ChatBubble) },
	{ "Draw",						TOK_BIT, 0, 8, NULL},
	{ "WasOnscreen",				TOK_BIT, 0, 8, NULL},
	{ "Gen",						TOK_OPTIONALLATEBINDSTRUCT(EntityUI, pGen) },
	{ "EncounterData",				TOK_UNOWNED | TOK_OPTIONALSTRUCT(EntityUI, pEncounterData, parse_EncounterUIData) },
	{ "OffscreenData",				TOK_UNOWNED | TOK_OPTIONALSTRUCT(EntityUI, pOffscreenData, parse_OffscreenUIData) },
	{ "LastOffscreenLoS",			TOK_AUTOINT(EntityUI, bLastOffscreenLoS, 0), NULL },
	{ "uiLastOffscreenLoSCheck",	TOK_AUTOINT(EntityUI, uiLastOffscreenLoSCheck, 0), NULL },
	{ "uiLastDamaged",				TOK_AUTOINT(EntityUI, uiLastDamaged, 0), NULL },
	{ "uiLastFlank",				TOK_AUTOINT(EntityUI, uiLastFlank, 0), NULL },
	{ "uiLastDamagedByPlayer",		TOK_AUTOINT(EntityUI, uiLastDamagedByPlayer, 0), NULL },
	{ "LastDamageAngle",			TOK_F32(EntityUI, fLastDamageAngle, -1), NULL },
	{ "LastDamageTangentAngle",		TOK_F32(EntityUI, fLastDamageTangentAngle, 0), NULL },
	{ "uiLastDamageDirectionTimes",	TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(EntityUI, uiLastDamageDirectionTimes), NULL },
	{ "DamageFloatGroups",			TOK_STRUCT(EntityUI, eaDamageFloatGroups, parse_DamageFloatGroup) },
	{ "uiLastTime",					TOK_CLIENT_ONLY | TOK_AUTOINT(EntityUI, uiLastTime, 0), NULL },
	{ "BoxMin",						TOK_CLIENT_ONLY | TOK_VEC3(EntityUI, vBoxMin), NULL },
	{ "BoxMax",						TOK_CLIENT_ONLY | TOK_VEC3(EntityUI, vBoxMax), NULL },
	{ "vuiLowerAtTime",				TOK_CLIENT_ONLY | TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(EntityUI, vuiLowerAtTime), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_EntityUI()
{
	int iSize = sizeof(EntityUI);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_EntityUI, iSize, "EntityUI", NULL, "Entity.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(EntityUI) + 7) / 4;
		EntityUI *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bDraw = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntityUI[4]);
		pTemp->bDraw = 0;
		pTemp->bWasOnscreen = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntityUI[5]);
		pTemp->bWasOnscreen = 0;
	}
	parse_EntityUI[14].param = GET_INTPTR_FROM_FLOAT((float)-1);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_EntityUI(void)
{
	DoAutoStructLateBind(parse_EntityUI, 6, "UIGen");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct EntityExternalInnate
#define TYPE_parse_EntityExternalInnate EntityExternalInnate
ParseTable parse_EntityExternalInnate[] =
{
	{ "EntityExternalInnate", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(EntityExternalInnate), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "PowersExternalInnate",	TOK_NO_INDEX | TOK_LATEBINDSTRUCT(EntityExternalInnate, ppPowersExternalInnate) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_EntityExternalInnate()
{
	int iSize = sizeof(EntityExternalInnate);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_EntityExternalInnate, iSize, "EntityExternalInnate", NULL, "Entity.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_EntityExternalInnate(void)
{
	DoAutoStructLateBind(parse_EntityExternalInnate, 2, "Power");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct EntityClientTargetFXNode
#define TYPE_parse_EntityClientTargetFXNode EntityClientTargetFXNode
ParseTable parse_EntityClientTargetFXNode[] =
{
	{ "EntityClientTargetFXNode", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(EntityClientTargetFXNode), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "guidTarget",					TOK_AUTOINT(EntityClientTargetFXNode, guidTarget, 0), NULL },
	{ "Range",						TOK_F32(EntityClientTargetFXNode, fRange, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_EntityClientTargetFXNode()
{
	int iSize = sizeof(EntityClientTargetFXNode);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_EntityClientTargetFXNode, iSize, "EntityClientTargetFXNode", NULL, "Entity.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_Player[];
#define TYPE_parse_Player Player
extern ParseTable parse_SavedEntityData[];
#define TYPE_parse_SavedEntityData SavedEntityData
extern ParseTable parse_EntityAttach[];
#define TYPE_parse_EntityAttach EntityAttach
extern ParseTable parse_Inventory[];
#define TYPE_parse_Inventory Inventory
extern ParseTable parse_InventoryV1[];
#define TYPE_parse_InventoryV1 InventoryV1
extern ParseTable parse_SharedBankData[];
#define TYPE_parse_SharedBankData SharedBankData
extern ParseTable parse_PlayerTeam[];
#define TYPE_parse_PlayerTeam PlayerTeam
extern ParseTable parse_EmailV3[];
#define TYPE_parse_EmailV3 EmailV3
extern ParseTable parse_TeamUpRequest[];
#define TYPE_parse_TeamUpRequest TeamUpRequest
extern ParseTable parse_CostumeRef[];
#define TYPE_parse_CostumeRef CostumeRef
extern ParseTable parse_EquippedArt[];
#define TYPE_parse_EquippedArt EquippedArt
extern ParseTable parse_UIVar[];
#define TYPE_parse_UIVar UIVar
extern ParseTable parse_CurrentHood[];
#define TYPE_parse_CurrentHood CurrentHood
extern ParseTable parse_PowerReplace[];
#define TYPE_parse_PowerReplace PowerReplace
extern ParseTable parse_EntityExternalInnate[];
#define TYPE_parse_EntityExternalInnate EntityExternalInnate
extern ParseTable parse_EntityUI[];
#define TYPE_parse_EntityUI EntityUI
//Structparser.exe autogenerated ParseTable for struct Entity
#define TYPE_parse_Entity Entity
ParseTable parse_Entity[] =
{
	{ "Entity", 						TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(Entity), 0, NULL, 0, "HTTP_HEADER_COMMAND = \"GetEntityHTMLHeader\""},
	{ "{",							TOK_START, 0 },
	{ "myContainerID",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_KEY | TOK_AUTOINT(Entity, myContainerID, 0), NULL },
	{ "myEntityType",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(Entity, myEntityType, 0), GlobalTypeEnum },
	{ "myCodeEntityFlags",			TOK_SERVER_ONLY | TOK_NO_NETSEND | TOK_AUTOINT(Entity, myCodeEntityFlags, 0), GlobalEntityFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "myDataEntityFlags",			TOK_SERVER_ONLY | TOK_NO_NETSEND | TOK_AUTOINT(Entity, myDataEntityFlags, 0), GlobalEntityFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "myEntityFlags",				TOK_SERVER_ONLY | TOK_AUTOINT(Entity, myEntityFlags, 0), GlobalEntityFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "mySendFlags",				TOK_SERVER_ONLY | TOK_AUTOINT(Entity, mySendFlags, 0), NULL },
	{ "ServerClientSentThisFrame",	TOK_SERVER_ONLY | TOK_AUTOINT(Entity, ServerClientSentThisFrame, 0), NULL },
	{ "iPartitionIdx_UseAccessor",	TOK_SERVER_ONLY | TOK_AUTOINT(Entity, iPartitionIdx_UseAccessor, 0), NULL },
	{ "pos_use_accessor",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_VEC3(Entity, pos_use_accessor), NULL },
	{ "rot_use_accessor",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_QUATPYR(Entity, rot_use_accessor), NULL },
	{ "invisible",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_BIT, 0, 8, NULL},
	{ "isInvisiblePersistent",		TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_BIT, 0, 8, NULL},
	{ "astrRegion",					TOK_POOL_STRING | TOK_STRING(Entity, astrRegion, 0), NULL },
	{ "debugName",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_FIXEDSTR(Entity, debugName), NULL },
	{ "pPlayer",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(Entity, pPlayer, parse_Player) },
	{ "pChar",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_OPTIONALLATEBINDSTRUCT(Entity, pChar) },
	{ "pSaved",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(Entity, pSaved, parse_SavedEntityData) },
	{ "pAttach",					TOK_OPTIONALSTRUCT(Entity, pAttach, parse_EntityAttach) },
	{ "pCritter",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_OPTIONALLATEBINDSTRUCT(Entity, pCritter) },
	{ "pNemesis",					TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_OPTIONALLATEBINDSTRUCT(Entity, pNemesis) },
	{ "pInventoryV2",				TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(Entity, pInventoryV2, parse_Inventory) },
	{ "pInventoryV1_Deprecated",	TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(Entity, pInventoryV1_Deprecated, parse_InventoryV1) },
	{ "pInventory",					TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(Entity, pInventoryV1_Deprecated, parse_InventoryV1) },
	{ "Inventory",					TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(Entity, pInventoryV1_Deprecated, parse_InventoryV1) },
	{ "pSharedBankData",			TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(Entity, pSharedBankData, parse_SharedBankData) },
	{ "ItemIDMax",					TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_AUTOINT(Entity, ItemIDMax, 0), NULL },
	{ "pTeam",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(Entity, pTeam, parse_PlayerTeam) },
	{ "pEmailV3",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(Entity, pEmailV3, parse_EmailV3) },
	{ "pTeamUpRequest",				TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Entity, pTeamUpRequest, parse_TeamUpRequest) },
	{ "hFaction",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(Entity, hFaction, 0, "CritterFaction") },
	{ "hSubFaction",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(Entity, hSubFaction, 0, "CritterFaction") },
	{ "hFactionOverride",			TOK_REFERENCE(Entity, hFactionOverride, 0, "CritterFaction") },
	{ "hPowerFactionOverride",		TOK_REFERENCE(Entity, hPowerFactionOverride, 0, "CritterFaction") },
	{ "hAllegiance",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(Entity, hAllegiance, 0, "Allegiance") },
	{ "hSubAllegiance",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(Entity, hSubAllegiance, 0, "Allegiance") },
	{ "hWLCostume",					TOK_NO_NETSEND | TOK_REFERENCE(Entity, hWLCostume, 0, "WLCostume") },
	{ "costumeRef",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_EMBEDDEDSTRUCT(Entity, costumeRef, parse_CostumeRef)},
	{ "Gender",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(Entity, eGender, 0), GenderEnum },
	{ "eGender",					TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(Entity, eGender, 0), GenderEnum },
	{ "fHue",						TOK_F32(Entity, fHue, 0), NULL },
	{ "pEquippedArt",				TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Entity, pEquippedArt, parse_EquippedArt) },
	{ "UIVars",						TOK_STRUCT(Entity, UIVars, parse_UIVar) },
	{ "erCreator",					TOK_AUTOINT(Entity, erCreator, 0), NULL },
	{ "erOwner",					TOK_AUTOINT(Entity, erOwner, 0), NULL },
	{ "hCreatorNode",				TOK_REFERENCE(Entity, hCreatorNode, 0, "WorldInteractionNode") },
	{ "erCreatorTarget",			TOK_SERVER_ONLY | TOK_AUTOINT(Entity, erCreatorTarget, 0), NULL },
	{ "Neighborhood",				TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Entity, currentNeighborhood, parse_CurrentHood) },
	{ "currentNeighborhood",		TOK_REDUNDANTNAME | TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Entity, currentNeighborhood, parse_CurrentHood) },
	{ "pGameEventInfo",				TOK_SERVER_ONLY | TOK_OPTIONALLATEBINDSTRUCT(Entity, pGameEventInfo) },
	{ "aibase",						TOK_SERVER_ONLY | TOK_UNOWNED | TOK_OPTIONALLATEBINDSTRUCT(Entity, aibase) },
	{ "ai",							TOK_REDUNDANTNAME | TOK_SERVER_ONLY | TOK_UNOWNED | TOK_OPTIONALLATEBINDSTRUCT(Entity, aibase) },
	{ "uiPowerReplaceIDMax",		TOK_SELF_ONLY | TOK_AUTOINT(Entity, uiPowerReplaceIDMax, 0), NULL },
	{ "ppPowerReplaces",			TOK_SELF_ONLY | TOK_STRUCT(Entity, ppPowerReplaces, parse_PowerReplace) },
	{ "externalInnate",				TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Entity, externalInnate, parse_EntityExternalInnate) },
	{ "iAICombatTeamID",			TOK_AUTOINT(Entity, iAICombatTeamID, 0), NULL },
	{ "uiUpdateInactiveEntUI",		TOK_CLIENT_ONLY | TOK_AUTOINT(Entity, uiUpdateInactiveEntUI, 0), NULL },
	{ "pEntUI",						TOK_CLIENT_ONLY | TOK_OPTIONALSTRUCT(Entity, pEntUI, parse_EntityUI) },
	{ "fEntitySendDistance",		TOK_F32(Entity, fEntitySendDistance, 0), NULL },
	{ "fEntityMinSeeAtDistance",	TOK_F32(Entity, fEntityMinSeeAtDistance, 0), NULL },
	{ "bFadeOutAndThenRemove",		TOK_CLIENT_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bNoInterpAlpha",				TOK_CLIENT_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bNoInterpAlphaOnSpawn",		TOK_BIT, 0, 8, NULL},
	{ "bPreserveAlpha",				TOK_CLIENT_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bImperceptible",				TOK_CLIENT_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bForceFadeOut",				TOK_CLIENT_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bInCutscene",				TOK_CLIENT_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bDeadBodyFaded",				TOK_CLIENT_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bDeathPredicted",			TOK_CLIENT_ONLY | TOK_BIT, 0, 8, NULL},
	{ "factionDirtiedCount",		TOK_AUTOINT(Entity, factionDirtiedCount, 0), NULL },
	{ "fAlpha",						TOK_CLIENT_ONLY | TOK_F32(Entity, fAlpha, 0), NULL },
	{ "fHideTime",					TOK_CLIENT_ONLY | TOK_F32(Entity, fHideTime, 0), NULL },
	{ "fCameraCollisionFade",		TOK_CLIENT_ONLY | TOK_F32(Entity, fCameraCollisionFade, 1), NULL },
	{ "astrMissionToGrant",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRING(Entity, astrMissionToGrant, 0), NULL },
	{ "lastProjSpecificLogTime",	TOK_SERVER_ONLY | TOK_AUTOINT(Entity, lastProjSpecificLogTime, 0), NULL },
	{ "estrProjSpecificLogString",	TOK_ESTRING | TOK_SERVER_ONLY | TOK_STRING(Entity, estrProjSpecificLogString, 0), NULL },
	{ "iSeedNumber",				TOK_SERVER_ONLY | TOK_AUTOINT(Entity, iSeedNumber, 0), NULL },
	{ "iBoxNumber",					TOK_SERVER_ONLY | TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(Entity, iBoxNumber), NULL },
	{ "bNeedsChatMailFixup",		TOK_PERSIST | TOK_BIT, 0, 8, NULL},
	{ "FixupVersion",				TOK_PERSIST | TOK_AUTOINT(Entity, FixupVersion, 0), NULL },
	{ "dirtyBit",					TOK_DIRTY_BIT | TOK_SERVER_ONLY | TOK_AUTOINT(Entity, dirtyBit, 0), NULL },
	{ "Dump Container on Clone", 	TOK_COMMAND, 0, (intptr_t)"ServerMonDumpEntity $FIELD(myEntityType) $FIELD(myContainerID)", NULL, 0, " commandExpr = \"\\q$SERVERTYPE\\q = \\qCloneObjectDB\\q\" " },
	{ "Dump Container", 				TOK_COMMAND, 0, (intptr_t)"ServerMonDumpEntity $FIELD(myEntityType) $FIELD(myContainerID)", NULL, 0, " commandExpr = \"\\q$SERVERTYPE\\q = \\qObjectDB\\q\" " },
	{ "Apply Transaction", 			TOK_COMMAND, 0, (intptr_t)"ServerMonTransactionOnEntity $FIELD(myEntityType) $FIELD(myContainerID) $STRING(Transaction String)$CONFIRM(Really apply this transaction?)" },
	{ "Send Message", 				TOK_COMMAND, 0, (intptr_t)"BroadcastMessageToPlayer $FIELD(myContainerID) $STRING(Message To Send)$NORETURN", NULL, 0, " commandExpr = \"\\q$FIELD(myEntityType)\\q = \\qEntityPlayer\\q\" " },
	{ "Set Access Level", 			TOK_COMMAND, 0, (intptr_t)"SetAccessLevelByContainerID $FIELD(myContainerID) $INT(New Access Level) $CONFIRM(Really set the access level?)", NULL, 0, " commandExpr = \"\\q$FIELD(myEntityType)\\q = \\qEntityPlayer\\q AND \\q$SERVERTYPE\\q = \\qGameServer\\q\" " },
	{ "Boot player", 				TOK_COMMAND, 0, (intptr_t)"ForceLogout $FIELD(myEntityType) $FIELD(myContainerID) $CONFIRM(Really boot this player?)", NULL, 0, " commandExpr = \"\\q$FIELD(myEntityType)\\q = \\qEntityPlayer\\q AND \\q$SERVERTYPE\\q = \\qGameServer\\q\" " },
	{ "Check Container Location", 	TOK_COMMAND, 0, (intptr_t)"DebugCheckContainerLoc $FIELD(myEntityType) $FIELD(myContainerID)", NULL, 0, " commandExpr = \"\\q$SERVERTYPE\\q = \\qObjectDB\\q\" " },
	{ "Get RAM Usage", 				TOK_COMMAND, 0, (intptr_t)"ServerMonGetEntityRAMUsage $FIELD(myEntityType) $FIELD(myContainerID) $INT(Should allocate a bunch of extra copies then free them to test RAM reporting)", NULL, 0, " commandExpr = \"\\q$SERVERTYPE\\q = \\qObjectDB\\q OR \\q$SERVERTYPE\\q = \\qCloneObjectDB\\q\" " },
	{ "hAlignment",					TOK_IGNORE, 0 },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_Entity()
{
	int iSize = sizeof(Entity);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_Entity, iSize, "Entity", NULL, "Entity.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	assertmsgf(offsetof(Entity, pCreationComment) != 0, "Creation comment field for Entity has offset 0. It can't be the first field in the struct");
	SetCreationCommentOffsetInTPIInfoColumn(parse_Entity, offsetof(Entity, pCreationComment));

//if compiling fails on the next line, it's because your creation comment field does\n//not exist, or is not a char*
	if (0) { ((Entity*)0x0)->pCreationComment = ""; };


	{
		int iSizeInWords = (sizeof(NOCONST(Entity)) + 7) / 4;
		NOCONST(Entity) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->isInvisiblePersistent = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Entity[12]);
		pTemp->isInvisiblePersistent = 0;
		pTemp->isInvisiblePersistent = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Entity[13]);
		pTemp->isInvisiblePersistent = 0;
		pTemp->bFadeOutAndThenRemove = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Entity[61]);
		pTemp->bFadeOutAndThenRemove = 0;
		pTemp->bNoInterpAlpha = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Entity[62]);
		pTemp->bNoInterpAlpha = 0;
		pTemp->bNoInterpAlphaOnSpawn = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Entity[63]);
		pTemp->bNoInterpAlphaOnSpawn = 0;
		pTemp->bPreserveAlpha = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Entity[64]);
		pTemp->bPreserveAlpha = 0;
		pTemp->bImperceptible = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Entity[65]);
		pTemp->bImperceptible = 0;
		pTemp->bForceFadeOut = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Entity[66]);
		pTemp->bForceFadeOut = 0;
		pTemp->bInCutscene = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Entity[67]);
		pTemp->bInCutscene = 0;
		pTemp->bDeadBodyFaded = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Entity[68]);
		pTemp->bDeadBodyFaded = 0;
		pTemp->bDeathPredicted = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Entity[69]);
		pTemp->bDeathPredicted = 0;
		pTemp->bNeedsChatMailFixup = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Entity[79]);
		pTemp->bNeedsChatMailFixup = 0;
	}
	parse_Entity[73].param = GET_INTPTR_FROM_FLOAT((float)1);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_Entity(void)
{
	DoAutoStructLateBind(parse_Entity, 17, "Character");
	DoAutoStructLateBind(parse_Entity, 20, "Critter");
	DoAutoStructLateBind(parse_Entity, 21, "Nemesis");
	DoAutoStructLateBind(parse_Entity, 50, "GameEventParticipant");
	DoAutoStructLateBind(parse_Entity, 51, "AIVarsBase");
	DoAutoStructLateBind(parse_Entity, 52, "AIVarsBase");
}
