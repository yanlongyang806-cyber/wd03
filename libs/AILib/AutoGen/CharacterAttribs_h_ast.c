#include "textparser.h"

//auto-generated staticdefine for enum AttribPoolTargetClamping
//autogeneratednocheckin
StaticDefineInt AttribPoolTargetClampingEnum[] =
{
	DEFINE_INT
	{ "None", kAttribPoolTargetClamp_None},
	{ "Max", kAttribPoolTargetClamp_Max},
	{ "Min", kAttribPoolTargetClamp_Min},
	DEFINE_END
};
void autoEnum_fixup_AttribPoolTargetClamping(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AttribPoolTargetClampingEnum, "AttribPoolTargetClamping");
}

//auto-generated staticdefine for enum AIAvoidVolumeType
//autogeneratednocheckin
StaticDefineInt AIAvoidVolumeTypeEnum[] =
{
	DEFINE_INT
	{ "AVOID", AIAvoidVolumeType_AVOID},
	{ "ENEMY_AVOID", AIAvoidVolumeType_ENEMY_AVOID},
	{ "ATTRACT", AIAvoidVolumeType_ATTRACT},
	DEFINE_END
};
void autoEnum_fixup_AIAvoidVolumeType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AIAvoidVolumeTypeEnum, "AIAvoidVolumeType");
}

//auto-generated staticdefine for enum ApplyPowerEntity
//autogeneratednocheckin
StaticDefineInt ApplyPowerEntityEnum[] =
{
	DEFINE_INT
	{ "ModOwner", kApplyPowerEntity_ModOwner},
	{ "Owner", kApplyPowerEntity_ModOwner},
	{ "ModSource", kApplyPowerEntity_ModSource},
	{ "Source", kApplyPowerEntity_ModSource},
	{ "ModSourceCreator", kApplyPowerEntity_ModSourceCreator},
	{ "ModSourceTargetDual", kApplyPowerEntity_ModSourceTargetDual},
	{ "ModTarget", kApplyPowerEntity_ModTarget},
	{ "Target", kApplyPowerEntity_ModTarget},
	{ "Random", kApplyPowerEntity_Random},
	{ "RandomNotSource", kApplyPowerEntity_RandomNotSource},
	{ "ApplicationTarget", kApplyPowerEntity_ApplicationTarget},
	{ "RandomNotApplicationTarget", kApplyPowerEntity_RandomNotApplicationTarget},
	{ "ClosestNotSource", kApplyPowerEntity_ClosestNotSource},
	{ "ClosestNotSourceOrTarget", kApplyPowerEntity_ClosestNotSourceOrTarget},
	{ "ClosestNotTarget", kApplyPowerEntity_ClosestNotTarget},
	{ "HeldObject", kApplyPowerEntity_HeldObject},
	DEFINE_END
};
void autoEnum_fixup_ApplyPowerEntity(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ApplyPowerEntityEnum, "ApplyPowerEntity");
}

//auto-generated staticdefine for enum AttribModExpireOrder
//autogeneratednocheckin
StaticDefineInt AttribModExpireOrderEnum[] =
{
	DEFINE_INT
	{ "Unset", kAttribModExpireOrder_Unset},
	{ "DurationLeast", kAttribModExpireOrder_DurationLeast},
	{ "DurationMost", kAttribModExpireOrder_DurationMost},
	{ "DurationUsedLeast", kAttribModExpireOrder_DurationUsedLeast},
	{ "DurationUsedMost", kAttribModExpireOrder_DurationUsedMost},
	DEFINE_END
};
void autoEnum_fixup_AttribModExpireOrder(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AttribModExpireOrderEnum, "AttribModExpireOrder");
}

//auto-generated staticdefine for enum AttribModHealAspect
//autogeneratednocheckin
StaticDefineInt AttribModHealAspectEnum[] =
{
	DEFINE_INT
	{ "Magnitude", kAttribModHealAspect_Magnitude},
	{ "Duration", kAttribModHealAspect_Duration},
	{ "Health", kAttribModHealAspect_Health},
	DEFINE_END
};
void autoEnum_fixup_AttribModHealAspect(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AttribModHealAspectEnum, "AttribModHealAspect");
}

//auto-generated staticdefine for enum AttribModShareAspect
//autogeneratednocheckin
StaticDefineInt AttribModShareAspectEnum[] =
{
	DEFINE_INT
	{ "Magnitude", kAttribModShareAspect_Magnitude},
	{ "Duration", kAttribModShareAspect_Duration},
	{ "Health", kAttribModShareAspect_Health},
	DEFINE_END
};
void autoEnum_fixup_AttribModShareAspect(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AttribModShareAspectEnum, "AttribModShareAspect");
}

//auto-generated staticdefine for enum DamageTriggerEntity
//autogeneratednocheckin
StaticDefineInt DamageTriggerEntityEnum[] =
{
	DEFINE_INT
	{ "Self", kDamageTriggerEntity_Self},
	{ "SelfOwner", kDamageTriggerEntity_SelfOwner},
	{ "DamageOwner", kDamageTriggerEntity_DamageOwner},
	{ "DamageSource", kDamageTriggerEntity_DamageSource},
	{ "DamageTarget", kDamageTriggerEntity_DamageTarget},
	{ "TriggerOwner", kDamageTriggerEntity_TriggerOwner},
	{ "TriggerSource", kDamageTriggerEntity_TriggerSource},
	DEFINE_END
};
void autoEnum_fixup_DamageTriggerEntity(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(DamageTriggerEntityEnum, "DamageTriggerEntity");
}

//auto-generated staticdefine for enum EntCreateTeam
//autogeneratednocheckin
StaticDefineInt EntCreateTeamEnum[] =
{
	DEFINE_INT
	{ "Owner", kEntCreateTeam_Owner},
	{ "Source", kEntCreateTeam_Source},
	{ "Target", kEntCreateTeam_Target},
	{ "None", kEntCreateTeam_None},
	DEFINE_END
};
void autoEnum_fixup_EntCreateTeam(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(EntCreateTeamEnum, "EntCreateTeam");
}

//auto-generated staticdefine for enum EntCreateStrength
//autogeneratednocheckin
StaticDefineInt EntCreateStrengthEnum[] =
{
	DEFINE_INT
	{ "Locked", kEntCreateStrength_Locked},
	{ "Independent", kEntCreateStrength_Independent},
	DEFINE_END
};
void autoEnum_fixup_EntCreateStrength(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(EntCreateStrengthEnum, "EntCreateStrength");
}

//auto-generated staticdefine for enum EntCreateType
//autogeneratednocheckin
StaticDefineInt EntCreateTypeEnum[] =
{
	DEFINE_INT
	{ "Critter", kEntCreateType_Critter},
	{ "CritterOfGroup", kEntCreateType_CritterOfGroup},
	{ "Nemesis", kEntCreateType_Nemesis},
	DEFINE_END
};
void autoEnum_fixup_EntCreateType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(EntCreateTypeEnum, "EntCreateType");
}

//auto-generated staticdefine for enum EntCreateFaceType
//autogeneratednocheckin
StaticDefineInt EntCreateFaceTypeEnum[] =
{
	DEFINE_INT
	{ "RelativeToCreator", kEntCreateFaceType_RelativeToCreator},
	{ "Absolute", kEntCreateFaceType_Absolute},
	{ "RelativeToTarget", kEntCreateFaceType_RelativeToTarget},
	{ "FaceCreator", kEntCreateFaceType_FaceCreator},
	{ "FaceTarget", kEntCreateFaceType_FaceTarget},
	DEFINE_END
};
void autoEnum_fixup_EntCreateFaceType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(EntCreateFaceTypeEnum, "EntCreateFaceType");
}

//auto-generated staticdefine for enum FlagAttributeFlags
//autogeneratednocheckin
StaticDefineInt FlagAttributeFlagsEnum[] =
{
	DEFINE_INT
	{ "Untargetable", kFlagAttributeFlags_Untargetable},
	{ "Unkillable", kFlagAttributeFlags_Unkillable},
	{ "Unselectable", kFlagAttributeFlags_Unselectable},
	DEFINE_END
};
void autoEnum_fixup_FlagAttributeFlags(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(FlagAttributeFlagsEnum, "FlagAttributeFlags");
}

//auto-generated staticdefine for enum KillType
//autogeneratednocheckin
StaticDefineInt KillTypeEnum[] =
{
	DEFINE_INT
	{ "Silent", kKillType_Silent},
	{ "Irresponsible", kKillType_Irresponsible},
	{ "Responsible", kKillType_Responsible},
	DEFINE_END
};
void autoEnum_fixup_KillType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(KillTypeEnum, "KillType");
}

//auto-generated staticdefine for enum KillTriggerEntity
//autogeneratednocheckin
StaticDefineInt KillTriggerEntityEnum[] =
{
	DEFINE_INT
	{ "Self", kKillTriggerEntity_Self},
	{ "Victim", kKillTriggerEntity_Victim},
	DEFINE_END
};
void autoEnum_fixup_KillTriggerEntity(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(KillTriggerEntityEnum, "KillTriggerEntity");
}

//auto-generated staticdefine for enum PowerRechargeApply
//autogeneratednocheckin
StaticDefineInt PowerRechargeApplyEnum[] =
{
	DEFINE_INT
	{ "SetAlways", kPowerRechargeApply_SetAlways},
	{ "SetIfLarger", kPowerRechargeApply_SetIfLarger},
	{ "SetIfSmaller", kPowerRechargeApply_SetIfSmaller},
	{ "Add", kPowerRechargeApply_Add},
	DEFINE_END
};
void autoEnum_fixup_PowerRechargeApply(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PowerRechargeApplyEnum, "PowerRechargeApply");
}

//auto-generated staticdefine for enum AttibModTeleportTarget
//autogeneratednocheckin
StaticDefineInt AttibModTeleportTargetEnum[] =
{
	DEFINE_INT
	{ "Self", kAttibModTeleportTarget_Self},
	{ "Target", kAttibModTeleportTarget_Target},
	{ "OwnedProjectile", kAttibModTeleportTarget_OwnedProjectile},
	{ "Expression", kAttibModTeleportTarget_Expression},
	DEFINE_END
};
void autoEnum_fixup_AttibModTeleportTarget(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AttibModTeleportTargetEnum, "AttibModTeleportTarget");
}

//auto-generated staticdefine for enum TeleportFaceType
//autogeneratednocheckin
StaticDefineInt TeleportFaceTypeEnum[] =
{
	DEFINE_INT
	{ "Current", kTeleportFaceType_Current},
	{ "FaceTarget", kTeleportFaceType_FaceTarget},
	{ "MatchTargetOrientation", kTeleportFaceType_MatchTargetOrientation},
	{ "Absolute", kTeleportFaceType_Absolute},
	DEFINE_END
};
void autoEnum_fixup_TeleportFaceType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(TeleportFaceTypeEnum, "TeleportFaceType");
}

//auto-generated staticdefine for enum TeleportOffsetOrientation
//autogeneratednocheckin
StaticDefineInt TeleportOffsetOrientationEnum[] =
{
	DEFINE_INT
	{ "TeleportTargetFacing", kTeleportOffsetOrientation_TeleportTargetFacing},
	{ "CurrentFacing", kTeleportOffsetOrientation_CurrentFacing},
	{ "RelativeFromTeleportTarget", kTeleportOffsetOrientation_RelativeFromTeleportTarget},
	{ "TeleportTargetMovementRotation", kTeleportOffsetOrientation_TeleportTargetMovementRotation},
	DEFINE_END
};
void autoEnum_fixup_TeleportOffsetOrientation(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(TeleportOffsetOrientationEnum, "TeleportOffsetOrientation");
}

//auto-generated staticdefine for enum TriggerComplexEntity
//autogeneratednocheckin
StaticDefineInt TriggerComplexEntityEnum[] =
{
	DEFINE_INT
	{ "ModTarget", kTriggerComplexEntity_ModTarget},
	{ "ModSource", kTriggerComplexEntity_ModSource},
	{ "ModOwner", kTriggerComplexEntity_ModOwner},
	{ "EventOther", kTriggerComplexEntity_EventOther},
	DEFINE_END
};
void autoEnum_fixup_TriggerComplexEntity(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(TriggerComplexEntityEnum, "TriggerComplexEntity");
}

//auto-generated staticdefine for enum TriggerSimpleEntity
//autogeneratednocheckin
StaticDefineInt TriggerSimpleEntityEnum[] =
{
	DEFINE_INT
	{ "ModTarget", kTriggerSimpleEntity_ModTarget},
	{ "ModSource", kTriggerSimpleEntity_ModSource},
	{ "ModOwner", kTriggerSimpleEntity_ModOwner},
	DEFINE_END
};
void autoEnum_fixup_TriggerSimpleEntity(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(TriggerSimpleEntityEnum, "TriggerSimpleEntity");
}

//auto-generated staticdefine for enum AIAggroTotalScaleApplyType
//autogeneratednocheckin
StaticDefineInt AIAggroTotalScaleApplyTypeEnum[] =
{
	DEFINE_INT
	{ "Self", kAIAggroTotalScaleApplyType_Self},
	{ "Owner", kAIAggroTotalScaleApplyType_Owner},
	DEFINE_END
};
void autoEnum_fixup_AIAggroTotalScaleApplyType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AIAggroTotalScaleApplyTypeEnum, "AIAggroTotalScaleApplyType");
}

//auto-generated staticdefine for enum CombatAdvantageType
//autogeneratednocheckin
StaticDefineInt CombatAdvantageTypeEnum[] =
{
	DEFINE_INT
	{ "Advantage", kCombatAdvantageApplyType_Advantage},
	{ "Disadvantage", kCombatAdvantageApplyType_Disadvantage},
	DEFINE_END
};
void autoEnum_fixup_CombatAdvantageType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(CombatAdvantageTypeEnum, "CombatAdvantageType");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DamageTypeNames
#define TYPE_parse_DamageTypeNames DamageTypeNames
ParseTable parse_DamageTypeNames[] =
{
	{ "DamageTypeNames", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DamageTypeNames), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "DamageName",			TOK_STRINGARRAY(DamageTypeNames, ppchNames), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DamageTypeNames()
{
	int iSize = sizeof(DamageTypeNames);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DamageTypeNames, iSize, "DamageTypeNames", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DataDefinedAttributes
#define TYPE_parse_DataDefinedAttributes DataDefinedAttributes
ParseTable parse_DataDefinedAttributes[] =
{
	{ "DataDefinedAttributes", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DataDefinedAttributes), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Attribute",				TOK_STRINGARRAY(DataDefinedAttributes, ppchAttributes), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DataDefinedAttributes()
{
	int iSize = sizeof(DataDefinedAttributes);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DataDefinedAttributes, iSize, "DataDefinedAttributes", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_CombatPoolTarget[];
#define TYPE_parse_CombatPoolTarget CombatPoolTarget
//Structparser.exe autogenerated ParseTable for struct AttribPool
#define TYPE_parse_AttribPool AttribPool
ParseTable parse_AttribPool[] =
{
	{ "AttribPool", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribPool), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Name",					TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_KEY | TOK_STRING(AttribPool, pchName, 0), NULL },
	{ "combatPool", 				TOK_IGNORE | TOK_FLATEMBED },
	{ "Init",					TOK_AUTOINT(AttribPool, combatPool.eInit, 0), CombatPoolPointEnum },
	{ "Bound",					TOK_AUTOINT(AttribPool, combatPool.eBound, 0), CombatPoolBoundEnum },
	{ "Target",					TOK_OPTIONALSTRUCT(AttribPool, combatPool.pTarget, parse_CombatPoolTarget) },
	{ "AttribCur",				TOK_AUTOINT(AttribPool, eAttribCur, 0), AttribTypeEnum },
	{ "AttribMin",				TOK_AUTOINT(AttribPool, eAttribMin, 0), AttribTypeEnum },
	{ "AttribMax",				TOK_AUTOINT(AttribPool, eAttribMax, 0), AttribTypeEnum },
	{ "AttribTarget",			TOK_AUTOINT(AttribPool, eAttribTarget, 0), AttribTypeEnum },
	{ "AttribRegenRate",		TOK_AUTOINT(AttribPool, eAttribRegenRate, 0), AttribTypeEnum },
	{ "AttribRegen",			TOK_REDUNDANTNAME | TOK_AUTOINT(AttribPool, eAttribRegenRate, 0), AttribTypeEnum },
	{ "AttribRegenMag",			TOK_AUTOINT(AttribPool, eAttribRegenMag, 0), AttribTypeEnum },
	{ "AttribDecayRate",		TOK_AUTOINT(AttribPool, eAttribDecayRate, 0), AttribTypeEnum },
	{ "AttribDecay",			TOK_REDUNDANTNAME | TOK_AUTOINT(AttribPool, eAttribDecayRate, 0), AttribTypeEnum },
	{ "AttribDecayMag",			TOK_AUTOINT(AttribPool, eAttribDecayMag, 0), AttribTypeEnum },
	{ "AttribDamage",			TOK_INTARRAY(AttribPool, peAttribDamage),  AttribTypeEnum},
	{ "AttribHeal",				TOK_INTARRAY(AttribPool, peAttribHeal),  AttribTypeEnum},
	{ "TargetClamp",			TOK_AUTOINT(AttribPool, eTargetClamp, kAttribPoolTargetClamp_None), AttribPoolTargetClampingEnum },
	{ "Persist",				TOK_BIT, 0, 8, NULL},
	{ "TargetNotCalculated",	TOK_BIT, 0, 8, NULL},
	{ "AutoFill",				TOK_BIT, 0, 8, NULL},
	{ "DoNotEmpty",				TOK_BIT, 0, 8, NULL},
	{ "TickWhileDead",			TOK_BIT, 0, 8, NULL},
	{ "TickDisabledInCombat",	TOK_BIT, 0, 8, NULL},
	{ "AbsorbsBasicDamage",		TOK_BIT, 0, 8, NULL},
	{ "FillOnRespawn",			TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AttribPool()
{
	int iSize = sizeof(AttribPool);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribPool, iSize, "AttribPool", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AttribPool) + 7) / 4;
		AttribPool *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bPersist = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribPool[20]);
		pTemp->bPersist = 0;
		pTemp->bTargetNotCalculated = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribPool[21]);
		pTemp->bTargetNotCalculated = 0;
		pTemp->bAutoFill = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribPool[22]);
		pTemp->bAutoFill = 0;
		pTemp->bDoNotEmpty = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribPool[23]);
		pTemp->bDoNotEmpty = 0;
		pTemp->bTickWhileDead = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribPool[24]);
		pTemp->bTickWhileDead = 0;
		pTemp->bTickDisabledInCombat = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribPool[25]);
		pTemp->bTickDisabledInCombat = 0;
		pTemp->bAbsorbsBasicDamage = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribPool[26]);
		pTemp->bAbsorbsBasicDamage = 0;
		pTemp->bFillOnRespawn = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribPool[27]);
		pTemp->bFillOnRespawn = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribPool[];
#define TYPE_parse_AttribPool AttribPool
//Structparser.exe autogenerated ParseTable for struct AttribPools
#define TYPE_parse_AttribPools AttribPools
ParseTable parse_AttribPools[] =
{
	{ "AttribPools", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribPools), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Pool",			TOK_STRUCT(AttribPools, ppPools, parse_AttribPool) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AttribPools()
{
	int iSize = sizeof(AttribPools);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribPools, iSize, "AttribPools", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct SavedAttribute
#define TYPE_parse_SavedAttribute SavedAttribute
ParseTable parse_SavedAttribute[] =
{
	{ "SavedAttribute", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(SavedAttribute), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "pchAttrib",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_STRING(SavedAttribute, pchAttrib, 0), NULL },
	{ "fValue",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_F32(SavedAttribute, fValue, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_SavedAttribute()
{
	int iSize = sizeof(SavedAttribute);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_SavedAttribute, iSize, "SavedAttribute", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct TempAttribute
#define TYPE_parse_TempAttribute TempAttribute
ParseTable parse_TempAttribute[] =
{
	{ "TempAttribute", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(TempAttribute), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Attrib",			TOK_STRING(TempAttribute, pchAttrib, 0), NULL },
	{ "Value",			TOK_F32(TempAttribute, fValue, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_TempAttribute()
{
	int iSize = sizeof(TempAttribute);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_TempAttribute, iSize, "TempAttribute", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_TempAttribute[];
#define TYPE_parse_TempAttribute TempAttribute
//Structparser.exe autogenerated ParseTable for struct TempAttributes
#define TYPE_parse_TempAttributes TempAttributes
ParseTable parse_TempAttributes[] =
{
	{ "TempAttributes", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(TempAttributes), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Attributes",		TOK_STRUCT(TempAttributes, ppAttributes, parse_TempAttribute) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_TempAttributes()
{
	int iSize = sizeof(TempAttributes);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_TempAttributes, iSize, "TempAttributes", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AssignedStats[];
#define TYPE_parse_AssignedStats AssignedStats
//Structparser.exe autogenerated ParseTable for struct AttribStatsPresetOverrides
#define TYPE_parse_AttribStatsPresetOverrides AttribStatsPresetOverrides
ParseTable parse_AttribStatsPresetOverrides[] =
{
	{ "AttribStatsPresetOverrides", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribStatsPresetOverrides), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "TotalPoints",				TOK_STRUCTPARAM | TOK_AUTOINT(AttribStatsPresetOverrides, iTotalPoints, 0), NULL },
	{ "AttribStats",				TOK_STRUCT(AttribStatsPresetOverrides, ppAttribStats, parse_AssignedStats) },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AttribStatsPresetOverrides()
{
	int iSize = sizeof(AttribStatsPresetOverrides);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribStatsPresetOverrides, iSize, "AttribStatsPresetOverrides", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_AssignedStats[];
#define TYPE_parse_AssignedStats AssignedStats
extern ParseTable parse_AttribStatsPresetOverrides[];
#define TYPE_parse_AttribStatsPresetOverrides AttribStatsPresetOverrides
//Structparser.exe autogenerated ParseTable for struct AttribStatsPresetDef
#define TYPE_parse_AttribStatsPresetDef AttribStatsPresetDef
ParseTable parse_AttribStatsPresetDef[] =
{
	{ "AttribStatsPresetDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribStatsPresetDef), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Name",					TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_KEY | TOK_STRING(AttribStatsPresetDef, pchName, 0), NULL },
	{ "DisplayName",			TOK_OPTIONALSTRUCT(AttribStatsPresetDef, pDisplayMessage, parse_DisplayMessage) },
	{ "AttribStats",			TOK_STRUCT(AttribStatsPresetDef, ppAttribStats, parse_AssignedStats) },
	{ "Override",				TOK_STRUCT(AttribStatsPresetDef, ppOverrides, parse_AttribStatsPresetOverrides) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AttribStatsPresetDef()
{
	int iSize = sizeof(AttribStatsPresetDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribStatsPresetDef, iSize, "AttribStatsPresetDef", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct AIAvoidParams
#define TYPE_parse_AIAvoidParams AIAvoidParams
ParseTable parse_AIAvoidParams[] =
{
	{ "AIAvoidParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIAvoidParams), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Type",			TOK_OBJECTTYPE | TOK_AUTOINT(AIAvoidParams, params.eType, kAttribType_AIAvoid), AttribTypeEnum },
	{ "Radius",			TOK_F32(AIAvoidParams, fRadius, 0), NULL },
	{ "VolumeType",		TOK_AUTOINT(AIAvoidParams, eVolumeType, 0), AIAvoidVolumeTypeEnum },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AIAvoidParams()
{
	int iSize = sizeof(AIAvoidParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIAvoidParams, iSize, "AIAvoidParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "AIAvoidParams", parse_AIAvoidParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct AICommandParams
#define TYPE_parse_AICommandParams AICommandParams
ParseTable parse_AICommandParams[] =
{
	{ "AICommandParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICommandParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(AICommandParams, params.eType, kAttribType_AICommand), AttribTypeEnum },
	{ "Expression",			TOK_OPTIONALLATEBINDSTRUCT(AICommandParams, pExpr) },
	{ "exprblock",			TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AICommandParams, pExpr) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AICommandParams()
{
	int iSize = sizeof(AICommandParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICommandParams, iSize, "AICommandParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "AICommandParams", parse_AICommandParams, iSize);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_AICommandParams(void)
{
	DoAutoStructLateBind(parse_AICommandParams, 3, "Expression");
	DoAutoStructLateBind(parse_AICommandParams, 4, "Expression");
}
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct AISoftAvoidParams
#define TYPE_parse_AISoftAvoidParams AISoftAvoidParams
ParseTable parse_AISoftAvoidParams[] =
{
	{ "AISoftAvoidParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AISoftAvoidParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(AISoftAvoidParams, params.eType, kAttribType_AISoftAvoid), AttribTypeEnum },
	{ "Radius",				TOK_F32(AISoftAvoidParams, fRadius, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AISoftAvoidParams()
{
	int iSize = sizeof(AISoftAvoidParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AISoftAvoidParams, iSize, "AISoftAvoidParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "AISoftAvoidParams", parse_AISoftAvoidParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct PVPSpecialActionParams
#define TYPE_parse_PVPSpecialActionParams PVPSpecialActionParams
ParseTable parse_PVPSpecialActionParams[] =
{
	{ "PVPSpecialActionParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PVPSpecialActionParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(PVPSpecialActionParams, params.eType, kAttribType_PVPSpecialAction), AttribTypeEnum },
	{ "Action",					TOK_AUTOINT(PVPSpecialActionParams, eAction, 0), PVPSpecialActionsEnum },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_PVPSpecialActionParams()
{
	int iSize = sizeof(PVPSpecialActionParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PVPSpecialActionParams, iSize, "PVPSpecialActionParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "PVPSpecialActionParams", parse_PVPSpecialActionParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct ApplyPowerParams
#define TYPE_parse_ApplyPowerParams ApplyPowerParams
ParseTable parse_ApplyPowerParams[] =
{
	{ "ApplyPowerParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ApplyPowerParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(ApplyPowerParams, params.eType, kAttribType_ApplyPower), AttribTypeEnum },
	{ "Def",				TOK_REFERENCE(ApplyPowerParams, hDef, 0, "PowerDef") },
	{ "Source",				TOK_AUTOINT(ApplyPowerParams, eSource, 0), ApplyPowerEntityEnum },
	{ "Target",				TOK_AUTOINT(ApplyPowerParams, eTarget, 0), ApplyPowerEntityEnum },
	{ "UseOwnerTargetType",	TOK_BIT, 0, 8, NULL},
	{ "CanMiss",			TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_ApplyPowerParams()
{
	int iSize = sizeof(ApplyPowerParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ApplyPowerParams, iSize, "ApplyPowerParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "ApplyPowerParams", parse_ApplyPowerParams, iSize);
	{
		int iSizeInWords = (sizeof(ApplyPowerParams) + 7) / 4;
		ApplyPowerParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bUseOwnerTargetType = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ApplyPowerParams[6]);
		pTemp->bUseOwnerTargetType = 0;
		pTemp->bCanMiss = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ApplyPowerParams[7]);
		pTemp->bCanMiss = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct AttribModDamageParams
#define TYPE_parse_AttribModDamageParams AttribModDamageParams
ParseTable parse_AttribModDamageParams[] =
{
	{ "AttribModDamageParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribModDamageParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(AttribModDamageParams, params.eType, kAttribType_AttribModDamage), AttribTypeEnum },
	{ "DamageType",				TOK_AUTOINT(AttribModDamageParams, offattribDamageType, 0), AttribTypeEnum },
	{ "Affects",				TOK_INTARRAY(AttribModDamageParams, puiAffectsAttribTypes),  AttribTypeEnum},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AttribModDamageParams()
{
	int iSize = sizeof(AttribModDamageParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribModDamageParams, iSize, "AttribModDamageParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "AttribModDamageParams", parse_AttribModDamageParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct AttribModExpireParams
#define TYPE_parse_AttribModExpireParams AttribModExpireParams
ParseTable parse_AttribModExpireParams[] =
{
	{ "AttribModExpireParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribModExpireParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(AttribModExpireParams, params.eType, kAttribType_AttribModExpire), AttribTypeEnum },
	{ "Order",					TOK_AUTOINT(AttribModExpireParams, eOrder, 0), AttribModExpireOrderEnum },
	{ "GroupByApplication",		TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AttribModExpireParams()
{
	int iSize = sizeof(AttribModExpireParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribModExpireParams, iSize, "AttribModExpireParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "AttribModExpireParams", parse_AttribModExpireParams, iSize);
	{
		int iSizeInWords = (sizeof(AttribModExpireParams) + 7) / 4;
		AttribModExpireParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bGroupByApplication = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModExpireParams[4]);
		pTemp->bGroupByApplication = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct AttribModFragilityScaleParams
#define TYPE_parse_AttribModFragilityScaleParams AttribModFragilityScaleParams
ParseTable parse_AttribModFragilityScaleParams[] =
{
	{ "AttribModFragilityScaleParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribModFragilityScaleParams), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "Type",							TOK_OBJECTTYPE | TOK_AUTOINT(AttribModFragilityScaleParams, params.eType, kAttribType_AttribModFragilityScale), AttribTypeEnum },
	{ "ScaleIn",						TOK_REFERENCE(AttribModFragilityScaleParams, hScaleIn, 0, "FragileScaleSet") },
	{ "ScaleOut",						TOK_REFERENCE(AttribModFragilityScaleParams, hScaleOut, 0, "FragileScaleSet") },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AttribModFragilityScaleParams()
{
	int iSize = sizeof(AttribModFragilityScaleParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribModFragilityScaleParams, iSize, "AttribModFragilityScaleParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "AttribModFragilityScaleParams", parse_AttribModFragilityScaleParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct AttribModHealParams
#define TYPE_parse_AttribModHealParams AttribModHealParams
ParseTable parse_AttribModHealParams[] =
{
	{ "AttribModHealParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribModHealParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(AttribModHealParams, params.eType, kAttribType_AttribModHeal), AttribTypeEnum },
	{ "Aspect",					TOK_AUTOINT(AttribModHealParams, eAspect, 0), AttribModHealAspectEnum },
	{ "CountsAsHeal",			TOK_AUTOINT(AttribModHealParams, bCountsAsHeal, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AttribModHealParams()
{
	int iSize = sizeof(AttribModHealParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribModHealParams, iSize, "AttribModHealParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "AttribModHealParams", parse_AttribModHealParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct AttribModKnockbackParams
#define TYPE_parse_AttribModKnockbackParams AttribModKnockbackParams
ParseTable parse_AttribModKnockbackParams[] =
{
	{ "AttribModKnockbackParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribModKnockbackParams), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Type",						TOK_OBJECTTYPE | TOK_AUTOINT(AttribModKnockbackParams, params.eType, kAttribType_KnockBack), AttribTypeEnum },
	{ "InstantFacePlant",			TOK_AUTOINT(AttribModKnockbackParams, bInstantFacePlant, 0), NULL },
	{ "OmitProne",					TOK_AUTOINT(AttribModKnockbackParams, bOmitProne, 0), NULL },
	{ "Timer",						TOK_F32(AttribModKnockbackParams, fTimer, 0), NULL },
	{ "IgnoreTravelTime",			TOK_AUTOINT(AttribModKnockbackParams, bIgnoreTravelTime, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AttribModKnockbackParams()
{
	int iSize = sizeof(AttribModKnockbackParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribModKnockbackParams, iSize, "AttribModKnockbackParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "AttribModKnockbackParams", parse_AttribModKnockbackParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct AttribModKnockupParams
#define TYPE_parse_AttribModKnockupParams AttribModKnockupParams
ParseTable parse_AttribModKnockupParams[] =
{
	{ "AttribModKnockupParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribModKnockupParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(AttribModKnockupParams, params.eType, kAttribType_KnockUp), AttribTypeEnum },
	{ "InstantFacePlant",		TOK_AUTOINT(AttribModKnockupParams, bInstantFacePlant, 0), NULL },
	{ "OmitProne",				TOK_AUTOINT(AttribModKnockupParams, bOmitProne, 0), NULL },
	{ "Timer",					TOK_F32(AttribModKnockupParams, fTimer, 0), NULL },
	{ "IgnoreTravelTime",		TOK_AUTOINT(AttribModKnockupParams, bIgnoreTravelTime, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AttribModKnockupParams()
{
	int iSize = sizeof(AttribModKnockupParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribModKnockupParams, iSize, "AttribModKnockupParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "AttribModKnockupParams", parse_AttribModKnockupParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct AttribModShareParams
#define TYPE_parse_AttribModShareParams AttribModShareParams
ParseTable parse_AttribModShareParams[] =
{
	{ "AttribModShareParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribModShareParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(AttribModShareParams, params.eType, kAttribType_AttribModShare), AttribTypeEnum },
	{ "Aspect",					TOK_AUTOINT(AttribModShareParams, eAspect, 0), AttribModShareAspectEnum },
	{ "ExprBlockShare",			TOK_OPTIONALLATEBINDSTRUCT(AttribModShareParams, pExprShare) },
	{ "ExprBlockContribution",	TOK_OPTIONALLATEBINDSTRUCT(AttribModShareParams, pExprContribution) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AttribModShareParams()
{
	int iSize = sizeof(AttribModShareParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribModShareParams, iSize, "AttribModShareParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "AttribModShareParams", parse_AttribModShareParams, iSize);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_AttribModShareParams(void)
{
	DoAutoStructLateBind(parse_AttribModShareParams, 4, "Expression");
	DoAutoStructLateBind(parse_AttribModShareParams, 5, "Expression");
}
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct AttribOverrideParams
#define TYPE_parse_AttribOverrideParams AttribOverrideParams
ParseTable parse_AttribOverrideParams[] =
{
	{ "AttribOverrideParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribOverrideParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(AttribOverrideParams, params.eType, kAttribType_AttribOverride), AttribTypeEnum },
	{ "Attrib",					TOK_AUTOINT(AttribOverrideParams, offAttrib, -1), AttribTypeEnum },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AttribOverrideParams()
{
	int iSize = sizeof(AttribOverrideParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribOverrideParams, iSize, "AttribOverrideParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "AttribOverrideParams", parse_AttribOverrideParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct BecomeCritterParams
#define TYPE_parse_BecomeCritterParams BecomeCritterParams
ParseTable parse_BecomeCritterParams[] =
{
	{ "BecomeCritterParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(BecomeCritterParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(BecomeCritterParams, params.eType, kAttribType_BecomeCritter), AttribTypeEnum },
	{ "Critter",				TOK_REFERENCE(BecomeCritterParams, hCritter, 0, "CritterDef") },
	{ "Class",					TOK_REFERENCE(BecomeCritterParams, hClass, 0, "CharacterClass") },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_BecomeCritterParams()
{
	int iSize = sizeof(BecomeCritterParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_BecomeCritterParams, iSize, "BecomeCritterParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "BecomeCritterParams", parse_BecomeCritterParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct DamageTriggerParams
#define TYPE_parse_DamageTriggerParams DamageTriggerParams
ParseTable parse_DamageTriggerParams[] =
{
	{ "DamageTriggerParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DamageTriggerParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(DamageTriggerParams, params.eType, kAttribType_DamageTrigger), AttribTypeEnum },
	{ "Attrib",					TOK_AUTOINT(DamageTriggerParams, offAttrib, -1), AttribTypeEnum },
	{ "Def",					TOK_REFERENCE(DamageTriggerParams, hDef, 0, "PowerDef") },
	{ "Target",					TOK_AUTOINT(DamageTriggerParams, eTarget, 0), DamageTriggerEntityEnum },
	{ "ExprChanceBlock",		TOK_OPTIONALLATEBINDSTRUCT(DamageTriggerParams, pExprChance) },
	{ "Chance",					TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(DamageTriggerParams, pExprChance) },
	{ "Heal",					TOK_BIT, 0, 8, NULL},
	{ "Outgoing",				TOK_BIT, 0, 8, NULL},
	{ "MagnitudeIsCharges",		TOK_BIT, 0, 8, NULL},
	{ "OwnedByDamager",			TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_DamageTriggerParams()
{
	int iSize = sizeof(DamageTriggerParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DamageTriggerParams, iSize, "DamageTriggerParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "DamageTriggerParams", parse_DamageTriggerParams, iSize);
	{
		int iSizeInWords = (sizeof(DamageTriggerParams) + 7) / 4;
		DamageTriggerParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bHeal = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_DamageTriggerParams[8]);
		pTemp->bHeal = 0;
		pTemp->bOutgoing = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_DamageTriggerParams[9]);
		pTemp->bOutgoing = 0;
		pTemp->bMagnitudeIsCharges = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_DamageTriggerParams[10]);
		pTemp->bMagnitudeIsCharges = 0;
		pTemp->bOwnedByDamager = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_DamageTriggerParams[11]);
		pTemp->bOwnedByDamager = 0;
	}
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_DamageTriggerParams(void)
{
	DoAutoStructLateBind(parse_DamageTriggerParams, 6, "Expression");
	DoAutoStructLateBind(parse_DamageTriggerParams, 7, "Expression_StructParam");
}
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct DisableTacticalMovementParams
#define TYPE_parse_DisableTacticalMovementParams DisableTacticalMovementParams
ParseTable parse_DisableTacticalMovementParams[] =
{
	{ "DisableTacticalMovementParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DisableTacticalMovementParams), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "Type",							TOK_OBJECTTYPE | TOK_AUTOINT(DisableTacticalMovementParams, params.eType, kAttribType_DisableTacticalMovement), AttribTypeEnum },
	{ "Flags",							TOK_AUTOINT(DisableTacticalMovementParams, eFlags, 0), TacticalDisableFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_DisableTacticalMovementParams()
{
	int iSize = sizeof(DisableTacticalMovementParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DisableTacticalMovementParams, iSize, "DisableTacticalMovementParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "DisableTacticalMovementParams", parse_DisableTacticalMovementParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct EntAttachParams
#define TYPE_parse_EntAttachParams EntAttachParams
ParseTable parse_EntAttachParams[] =
{
	{ "EntAttachParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(EntAttachParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(EntAttachParams, params.eType, kAttribType_EntAttach), AttribTypeEnum },
	{ "CostumeName",		TOK_GLOBAL_NAME | TOK_STRING(EntAttachParams, pchCostumeName, 0), "PlayerCostumetity" },
	{ "AttachBone",			TOK_STRING(EntAttachParams, pchAttachBone, 0), NULL },
	{ "ExtraBit",			TOK_STRING(EntAttachParams, pchExtraBit, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_EntAttachParams()
{
	int iSize = sizeof(EntAttachParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_EntAttachParams, iSize, "EntAttachParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "EntAttachParams", parse_EntAttachParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct EntCreateParams
#define TYPE_parse_EntCreateParams EntCreateParams
ParseTable parse_EntCreateParams[] =
{
	{ "EntCreateParams", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(EntCreateParams), 0, NULL, 0, NULL },
	{ "{",									TOK_START, 0 },
	{ "Type",								TOK_OBJECTTYPE | TOK_AUTOINT(EntCreateParams, params.eType, kAttribType_EntCreate), AttribTypeEnum },
	{ "CreateType",							TOK_AUTOINT(EntCreateParams, eCreateType, kEntCreateType_Critter), EntCreateTypeEnum },
	{ "Critter",							TOK_REFERENCE(EntCreateParams, hCritter, 0, "CritterDef") },
	{ "CritterGroup",						TOK_REFERENCE(EntCreateParams, hCritterGroup, 0, "CritterGroup") },
	{ "Team",								TOK_AUTOINT(EntCreateParams, eTeam, kEntCreateTeam_Owner), EntCreateTeamEnum },
	{ "Strength",							TOK_AUTOINT(EntCreateParams, eStrength, kEntCreateStrength_Locked), EntCreateStrengthEnum },
	{ "Rank",								TOK_POOL_STRING | TOK_STRING(EntCreateParams, pcRank, 0), NULL },
	{ "SubRank",							TOK_POOL_STRING | TOK_STRING(EntCreateParams, pcSubRank, 0), NULL },
	{ "ExprBlockDistanceFront",				TOK_OPTIONALLATEBINDSTRUCT(EntCreateParams, pExprDistanceFront) },
	{ "ExprBlockDistanceRight",				TOK_OPTIONALLATEBINDSTRUCT(EntCreateParams, pExprDistanceRight) },
	{ "ExprBlockDistanceAbove",				TOK_OPTIONALLATEBINDSTRUCT(EntCreateParams, pExprDistanceAbove) },
	{ "ExprBlockFacing",					TOK_OPTIONALLATEBINDSTRUCT(EntCreateParams, pExprFacing) },
	{ "Facing",								TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(EntCreateParams, pExprFacing) },
	{ "FSM",								TOK_GLOBAL_NAME | TOK_STRING(EntCreateParams, pchFSM, 0), "FSM" },
	{ "CostumeDefault",						TOK_AUTOINT(EntCreateParams, iCostumeDefault, 0), NULL },
	{ "FaceType",							TOK_AUTOINT(EntCreateParams, eFaceType, 0), EntCreateFaceTypeEnum },
	{ "FaceAbsolute",						TOK_REDUNDANTNAME | TOK_AUTOINT(EntCreateParams, eFaceType, 0), EntCreateFaceTypeEnum },
	{ "ModsOwnedByOwner",					TOK_BIT, 0, 8, NULL},
	{ "Teleport",							TOK_BIT, 0, 8, NULL},
	{ "OffsetUsesPitchAndRoll",				TOK_BIT, 0, 8, NULL},
	{ "AdjustOffsetByPitch",				TOK_REDUNDANTNAME | TOK_BIT, 0, 8, NULL},
	{ "UseFacingPitch",						TOK_BIT, 0, 8, NULL},
	{ "UseCreatorPitch",					TOK_REDUNDANTNAME | TOK_BIT, 0, 8, NULL},
	{ "UseFacingRoll",						TOK_BIT, 0, 8, NULL},
	{ "UseMainTarget",						TOK_BIT, 0, 8, NULL},
	{ "SurviveCharacterDeathExpiration",	TOK_BIT, 0, 8, NULL},
	{ "DieOnExpire",						TOK_BIT, 0, 8, NULL},
	{ "CanCustomizeCostume",				TOK_BIT, 0, 8, NULL},
	{ "UseTargetPositionWhenNoTarget",		TOK_BIT, 0, 8, NULL},
	{ "UseCreatorsDisplayName",				TOK_BIT, 0, 8, NULL},
	{ "UseCreatorsPuppetDisplayName",		TOK_BIT, 0, 8, NULL},
	{ "Persistent",							TOK_BIT, 0, 8, NULL},
	{ "CreateAtTargetedEntityPos",			TOK_BIT, 0, 8, NULL},
	{ "UseTargetPositionAsAIVarsTargetPos",	TOK_BIT, 0, 8, NULL},
	{ "ClampToGround",						TOK_BIT, 0, 8, NULL},
	{ "UseOwnersFaction",					TOK_BIT, 0, 8, NULL},
	{ "AlwaysRerollCrits",					TOK_BIT, 0, 8, NULL},
	{ "BoneGroup",							TOK_STRING(EntCreateParams, pcBoneGroup, 0), NULL },
	{ "Skeleton",							TOK_REFERENCE(EntCreateParams, hSkeleton, 0, "CostumeSkeleton") },
	{ "}",									TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_EntCreateParams()
{
	int iSize = sizeof(EntCreateParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_EntCreateParams, iSize, "EntCreateParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "EntCreateParams", parse_EntCreateParams, iSize);
	{
		int iSizeInWords = (sizeof(EntCreateParams) + 7) / 4;
		EntCreateParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bModsOwnedByOwner = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[19]);
		pTemp->bModsOwnedByOwner = 0;
		pTemp->bTryTeleportFirst = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[20]);
		pTemp->bTryTeleportFirst = 0;
		pTemp->bOffsetUsesPitchAndRoll = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[21]);
		pTemp->bOffsetUsesPitchAndRoll = 0;
		pTemp->bOffsetUsesPitchAndRoll = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[22]);
		pTemp->bOffsetUsesPitchAndRoll = 0;
		pTemp->bUseFacingPitch = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[23]);
		pTemp->bUseFacingPitch = 0;
		pTemp->bUseFacingPitch = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[24]);
		pTemp->bUseFacingPitch = 0;
		pTemp->bUseFacingRoll = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[25]);
		pTemp->bUseFacingRoll = 0;
		pTemp->bUseMainTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[26]);
		pTemp->bUseMainTarget = 0;
		pTemp->bSurviveCharacterDeathExpiration = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[27]);
		pTemp->bSurviveCharacterDeathExpiration = 0;
		pTemp->bDieOnExpire = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[28]);
		pTemp->bDieOnExpire = 0;
		pTemp->bCanCustomizeCostume = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[29]);
		pTemp->bCanCustomizeCostume = 0;
		pTemp->bUseTargetPositionWhenNoTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[30]);
		pTemp->bUseTargetPositionWhenNoTarget = 0;
		pTemp->bUseCreatorsDisplayName = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[31]);
		pTemp->bUseCreatorsDisplayName = 0;
		pTemp->bUseCreatorsPuppetDisplayName = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[32]);
		pTemp->bUseCreatorsPuppetDisplayName = 0;
		pTemp->bPersistent = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[33]);
		pTemp->bPersistent = 0;
		pTemp->bCreateAtTargetedEntityPos = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[34]);
		pTemp->bCreateAtTargetedEntityPos = 0;
		pTemp->bUseTargetPositionAsAIVarsTargetPos = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[35]);
		pTemp->bUseTargetPositionAsAIVarsTargetPos = 0;
		pTemp->bClampToGround = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[36]);
		pTemp->bClampToGround = 0;
		pTemp->bUseOwnersFaction = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[37]);
		pTemp->bUseOwnersFaction = 0;
		pTemp->bAlwaysRerollCrits = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntCreateParams[38]);
		pTemp->bAlwaysRerollCrits = 0;
	}
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_EntCreateParams(void)
{
	DoAutoStructLateBind(parse_EntCreateParams, 10, "Expression");
	DoAutoStructLateBind(parse_EntCreateParams, 11, "Expression");
	DoAutoStructLateBind(parse_EntCreateParams, 12, "Expression");
	DoAutoStructLateBind(parse_EntCreateParams, 13, "Expression");
	DoAutoStructLateBind(parse_EntCreateParams, 14, "Expression");
}
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct EntCreateVanityParams
#define TYPE_parse_EntCreateVanityParams EntCreateVanityParams
ParseTable parse_EntCreateVanityParams[] =
{
	{ "EntCreateVanityParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(EntCreateVanityParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(EntCreateVanityParams, params.eType, kAttribType_EntCreateVanity), AttribTypeEnum },
	{ "Critter",				TOK_REFERENCE(EntCreateVanityParams, hCritter, 0, "CritterDef") },
	{ "ExprBlockDistanceFront",	TOK_OPTIONALLATEBINDSTRUCT(EntCreateVanityParams, pExprDistanceFront) },
	{ "ExprBlockDistanceRight",	TOK_OPTIONALLATEBINDSTRUCT(EntCreateVanityParams, pExprDistanceRight) },
	{ "ExprBlockDistanceAbove",	TOK_OPTIONALLATEBINDSTRUCT(EntCreateVanityParams, pExprDistanceAbove) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_EntCreateVanityParams()
{
	int iSize = sizeof(EntCreateVanityParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_EntCreateVanityParams, iSize, "EntCreateVanityParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "EntCreateVanityParams", parse_EntCreateVanityParams, iSize);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_EntCreateVanityParams(void)
{
	DoAutoStructLateBind(parse_EntCreateVanityParams, 4, "Expression");
	DoAutoStructLateBind(parse_EntCreateVanityParams, 5, "Expression");
	DoAutoStructLateBind(parse_EntCreateVanityParams, 6, "Expression");
}
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct FactionParams
#define TYPE_parse_FactionParams FactionParams
ParseTable parse_FactionParams[] =
{
	{ "FactionParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FactionParams), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Type",			TOK_OBJECTTYPE | TOK_AUTOINT(FactionParams, params.eType, kAttribType_Faction), AttribTypeEnum },
	{ "Faction",		TOK_REFERENCE(FactionParams, hFaction, 0, "CritterFaction") },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FactionParams()
{
	int iSize = sizeof(FactionParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FactionParams, iSize, "FactionParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "FactionParams", parse_FactionParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct FlagParams
#define TYPE_parse_FlagParams FlagParams
ParseTable parse_FlagParams[] =
{
	{ "FlagParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FlagParams), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "Type",		TOK_OBJECTTYPE | TOK_AUTOINT(FlagParams, params.eType, kAttribType_Flag), AttribTypeEnum },
	{ "Flags",		TOK_AUTOINT(FlagParams, eFlags, 0), FlagAttributeFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FlagParams()
{
	int iSize = sizeof(FlagParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FlagParams, iSize, "FlagParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "FlagParams", parse_FlagParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct FlightParams
#define TYPE_parse_FlightParams FlightParams
ParseTable parse_FlightParams[] =
{
	{ "FlightParams", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FlightParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(FlightParams, params.eType, kAttribType_Flight), AttribTypeEnum },
	{ "DisableFakeRoll",	TOK_BIT, 0, 8, NULL},
	{ "IgnorePitch",		TOK_BIT, 0, 8, NULL},
	{ "UseJumpBit",			TOK_BIT, 0, 8, NULL},
	{ "ConstantFoward",		TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FlightParams()
{
	int iSize = sizeof(FlightParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FlightParams, iSize, "FlightParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "FlightParams", parse_FlightParams, iSize);
	{
		int iSizeInWords = (sizeof(FlightParams) + 7) / 4;
		FlightParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bDisableFakeRoll = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FlightParams[3]);
		pTemp->bDisableFakeRoll = 0;
		pTemp->bIgnorePitch = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FlightParams[4]);
		pTemp->bIgnorePitch = 0;
		pTemp->bUseJumpBit = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FlightParams[5]);
		pTemp->bUseJumpBit = 0;
		pTemp->bConstantForward = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FlightParams[6]);
		pTemp->bConstantForward = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct GrantPowerParams
#define TYPE_parse_GrantPowerParams GrantPowerParams
ParseTable parse_GrantPowerParams[] =
{
	{ "GrantPowerParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(GrantPowerParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(GrantPowerParams, params.eType, kAttribType_GrantPower), AttribTypeEnum },
	{ "hDef",				TOK_REFERENCE(GrantPowerParams, hDef, 0, "PowerDef") },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_GrantPowerParams()
{
	int iSize = sizeof(GrantPowerParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_GrantPowerParams, iSize, "GrantPowerParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "GrantPowerParams", parse_GrantPowerParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct GrantRewardParams
#define TYPE_parse_GrantRewardParams GrantRewardParams
ParseTable parse_GrantRewardParams[] =
{
	{ "GrantRewardParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(GrantRewardParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(GrantRewardParams, params.eType, kAttribType_GrantReward), AttribTypeEnum },
	{ "RewardTable",		TOK_REFERENCE(GrantRewardParams, hRewardTable, 0, "RewardTable") },
	{ "Level",				TOK_IGNORE, 0 },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_GrantRewardParams()
{
	int iSize = sizeof(GrantRewardParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_GrantRewardParams, iSize, "GrantRewardParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "GrantRewardParams", parse_GrantRewardParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct IncludeEnhancementParams
#define TYPE_parse_IncludeEnhancementParams IncludeEnhancementParams
ParseTable parse_IncludeEnhancementParams[] =
{
	{ "IncludeEnhancementParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(IncludeEnhancementParams), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Type",						TOK_OBJECTTYPE | TOK_AUTOINT(IncludeEnhancementParams, params.eType, kAttribType_IncludeEnhancement), AttribTypeEnum },
	{ "hDef",						TOK_REFERENCE(IncludeEnhancementParams, hDef, 0, "PowerDef") },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_IncludeEnhancementParams()
{
	int iSize = sizeof(IncludeEnhancementParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_IncludeEnhancementParams, iSize, "IncludeEnhancementParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "IncludeEnhancementParams", parse_IncludeEnhancementParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct InterruptParams
#define TYPE_parse_InterruptParams InterruptParams
ParseTable parse_InterruptParams[] =
{
	{ "InterruptParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InterruptParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(InterruptParams, params.eType, kAttribType_Interrupt), AttribTypeEnum },
	{ "RechargePercent",	TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_InterruptParams()
{
	int iSize = sizeof(InterruptParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InterruptParams, iSize, "InterruptParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "InterruptParams", parse_InterruptParams, iSize);
	{
		int iSizeInWords = (sizeof(InterruptParams) + 7) / 4;
		InterruptParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bRechargePercent = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_InterruptParams[3]);
		pTemp->bRechargePercent = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct KillParams
#define TYPE_parse_KillParams KillParams
ParseTable parse_KillParams[] =
{
	{ "KillParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(KillParams), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "Type",		TOK_OBJECTTYPE | TOK_AUTOINT(KillParams, params.eType, kAttribType_Kill), AttribTypeEnum },
	{ "KillType",	TOK_AUTOINT(KillParams, eKillType, kKillType_Silent), KillTypeEnum },
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_KillParams()
{
	int iSize = sizeof(KillParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_KillParams, iSize, "KillParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "KillParams", parse_KillParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct KillTriggerParams
#define TYPE_parse_KillTriggerParams KillTriggerParams
ParseTable parse_KillTriggerParams[] =
{
	{ "KillTriggerParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(KillTriggerParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(KillTriggerParams, params.eType, kAttribType_KillTrigger), AttribTypeEnum },
	{ "Def",				TOK_REFERENCE(KillTriggerParams, hDef, 0, "PowerDef") },
	{ "Target",				TOK_AUTOINT(KillTriggerParams, eTarget, 0), KillTriggerEntityEnum },
	{ "Chance",				TOK_F32(KillTriggerParams, fChance, 1), NULL },
	{ "MagnitudeIsCharges",	TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_KillTriggerParams()
{
	int iSize = sizeof(KillTriggerParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_KillTriggerParams, iSize, "KillTriggerParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "KillTriggerParams", parse_KillTriggerParams, iSize);
	{
		int iSizeInWords = (sizeof(KillTriggerParams) + 7) / 4;
		KillTriggerParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bMagnitudeIsCharges = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_KillTriggerParams[6]);
		pTemp->bMagnitudeIsCharges = 0;
	}
	parse_KillTriggerParams[5].param = GET_INTPTR_FROM_FLOAT((float)1);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct KnockToParams
#define TYPE_parse_KnockToParams KnockToParams
ParseTable parse_KnockToParams[] =
{
	{ "KnockToParams", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(KnockToParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(KnockToParams, params.eType, kAttribType_KnockTo), AttribTypeEnum },
	{ "DistanceFront",		TOK_F32(KnockToParams, fDistanceFront, 0), NULL },
	{ "DistanceRight",		TOK_F32(KnockToParams, fDistanceRight, 0), NULL },
	{ "DistanceAbove",		TOK_F32(KnockToParams, fDistanceAbove, 0), NULL },
	{ "InstantFacePlant",	TOK_AUTOINT(KnockToParams, bInstantFacePlant, 0), NULL },
	{ "OmitProne",			TOK_AUTOINT(KnockToParams, bOmitProne, 0), NULL },
	{ "Timer",				TOK_F32(KnockToParams, fTimer, 0), NULL },
	{ "IgnoreTravelTime",	TOK_AUTOINT(KnockToParams, bIgnoreTravelTime, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_KnockToParams()
{
	int iSize = sizeof(KnockToParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_KnockToParams, iSize, "KnockToParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "KnockToParams", parse_KnockToParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct MissionEventParams
#define TYPE_parse_MissionEventParams MissionEventParams
ParseTable parse_MissionEventParams[] =
{
	{ "MissionEventParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MissionEventParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(MissionEventParams, params.eType, kAttribType_MissionEvent), AttribTypeEnum },
	{ "EventName",			TOK_STRING(MissionEventParams, pchEventName, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_MissionEventParams()
{
	int iSize = sizeof(MissionEventParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MissionEventParams, iSize, "MissionEventParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "MissionEventParams", parse_MissionEventParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct ModifyCostumeParams
#define TYPE_parse_ModifyCostumeParams ModifyCostumeParams
ParseTable parse_ModifyCostumeParams[] =
{
	{ "ModifyCostumeParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ModifyCostumeParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(ModifyCostumeParams, params.eType, kAttribType_ModifyCostume), AttribTypeEnum },
	{ "Area",					TOK_AUTOINT(ModifyCostumeParams, eArea, 0), kCostumeValueAreaEnum },
	{ "Mode",					TOK_AUTOINT(ModifyCostumeParams, eMode, 0), kCostumeValueModeEnum },
	{ "Value",					TOK_F32(ModifyCostumeParams, fValue, 0), NULL },
	{ "MinValue",				TOK_F32(ModifyCostumeParams, fMinValue, 0), NULL },
	{ "MaxValue",				TOK_F32(ModifyCostumeParams, fMaxValue, 0), NULL },
	{ "Priority",				TOK_AUTOINT(ModifyCostumeParams, iPriority, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_ModifyCostumeParams()
{
	int iSize = sizeof(ModifyCostumeParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ModifyCostumeParams, iSize, "ModifyCostumeParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "ModifyCostumeParams", parse_ModifyCostumeParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct NotifyParams
#define TYPE_parse_NotifyParams NotifyParams
ParseTable parse_NotifyParams[] =
{
	{ "NotifyParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(NotifyParams), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Type",			TOK_OBJECTTYPE | TOK_AUTOINT(NotifyParams, params.eType, kAttribType_Notify), AttribTypeEnum },
	{ "MessageKey",		TOK_POOL_STRING | TOK_STRING(NotifyParams, pchMessageKey, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_NotifyParams()
{
	int iSize = sizeof(NotifyParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_NotifyParams, iSize, "NotifyParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "NotifyParams", parse_NotifyParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct PlacateParams
#define TYPE_parse_PlacateParams PlacateParams
ParseTable parse_PlacateParams[] =
{
	{ "PlacateParams", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlacateParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(PlacateParams, params.eType, kAttribType_Placate), AttribTypeEnum },
	{ "SteatlhPlacater",	TOK_AUTOINT(PlacateParams, bStealthPlacater, true), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_PlacateParams()
{
	int iSize = sizeof(PlacateParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlacateParams, iSize, "PlacateParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "PlacateParams", parse_PlacateParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct PowerModeParams
#define TYPE_parse_PowerModeParams PowerModeParams
ParseTable parse_PowerModeParams[] =
{
	{ "PowerModeParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerModeParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(PowerModeParams, params.eType, kAttribType_PowerMode), AttribTypeEnum },
	{ "PowerMode",			TOK_AUTOINT(PowerModeParams, iPowerMode, 0), PowerModeEnum },
	{ "MissionEvent",		TOK_BIT, 0, 8, NULL},
	{ "CombatEvent",		TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_PowerModeParams()
{
	int iSize = sizeof(PowerModeParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerModeParams, iSize, "PowerModeParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "PowerModeParams", parse_PowerModeParams, iSize);
	{
		int iSizeInWords = (sizeof(PowerModeParams) + 7) / 4;
		PowerModeParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bMissionEvent = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerModeParams[4]);
		pTemp->bMissionEvent = 0;
		pTemp->bCombatEvent = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerModeParams[5]);
		pTemp->bCombatEvent = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct PowerRechargeParams
#define TYPE_parse_PowerRechargeParams PowerRechargeParams
ParseTable parse_PowerRechargeParams[] =
{
	{ "PowerRechargeParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerRechargeParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(PowerRechargeParams, params.eType, kAttribType_PowerRecharge), AttribTypeEnum },
	{ "Apply",					TOK_AUTOINT(PowerRechargeParams, eApply, 0), PowerRechargeApplyEnum },
	{ "Percent",				TOK_BIT, 0, 8, NULL},
	{ "AffectsGlobalCooldown",	TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_PowerRechargeParams()
{
	int iSize = sizeof(PowerRechargeParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerRechargeParams, iSize, "PowerRechargeParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "PowerRechargeParams", parse_PowerRechargeParams, iSize);
	{
		int iSizeInWords = (sizeof(PowerRechargeParams) + 7) / 4;
		PowerRechargeParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bPercent = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerRechargeParams[4]);
		pTemp->bPercent = 0;
		pTemp->bAffectsGlobalCooldown = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerRechargeParams[5]);
		pTemp->bAffectsGlobalCooldown = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct PowerShieldParams
#define TYPE_parse_PowerShieldParams PowerShieldParams
ParseTable parse_PowerShieldParams[] =
{
	{ "PowerShieldParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerShieldParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(PowerShieldParams, params.eType, kAttribType_PowerShield), AttribTypeEnum },
	{ "Ratio",				TOK_F32(PowerShieldParams, fRatio, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_PowerShieldParams()
{
	int iSize = sizeof(PowerShieldParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerShieldParams, iSize, "PowerShieldParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "PowerShieldParams", parse_PowerShieldParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct PVPFlagParams
#define TYPE_parse_PVPFlagParams PVPFlagParams
ParseTable parse_PVPFlagParams[] =
{
	{ "PVPFlagParams", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PVPFlagParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(PVPFlagParams, params.eType, kAttribType_PVPFlag), AttribTypeEnum },
	{ "GroupName",			TOK_POOL_STRING | TOK_STRING(PVPFlagParams, pchGroupName, 0), NULL },
	{ "SubGroupName",		TOK_POOL_STRING | TOK_STRING(PVPFlagParams, pchSubGroupName, 0), NULL },
	{ "Radius",				TOK_F32(PVPFlagParams, fRadius, 0), NULL },
	{ "AllowHeal",			TOK_BIT, 0, 8, NULL},
	{ "TeamHeal",			TOK_BIT, 0, 8, NULL},
	{ "AllowExternCombat",	TOK_BIT, 0, 8, NULL},
	{ "Global",				TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_PVPFlagParams()
{
	int iSize = sizeof(PVPFlagParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PVPFlagParams, iSize, "PVPFlagParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "PVPFlagParams", parse_PVPFlagParams, iSize);
	{
		int iSizeInWords = (sizeof(PVPFlagParams) + 7) / 4;
		PVPFlagParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bAllowHeal = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PVPFlagParams[6]);
		pTemp->bAllowHeal = 0;
		pTemp->bTeamHeal = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PVPFlagParams[7]);
		pTemp->bTeamHeal = 0;
		pTemp->bAllowExternCombat = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PVPFlagParams[8]);
		pTemp->bAllowExternCombat = 0;
		pTemp->bGlobal = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PVPFlagParams[9]);
		pTemp->bGlobal = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct ProjectileCreateParams
#define TYPE_parse_ProjectileCreateParams ProjectileCreateParams
ParseTable parse_ProjectileCreateParams[] =
{
	{ "ProjectileCreateParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ProjectileCreateParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(ProjectileCreateParams, params.eType, kAttribType_ProjectileCreate), AttribTypeEnum },
	{ "ProjectileDef",			TOK_REFERENCE(ProjectileCreateParams, hProjectileDef, 0, "ProjectileEntityDef") },
	{ "CreateDistanceForward",	TOK_F32(ProjectileCreateParams, fCreateDistanceForward, 0), NULL },
	{ "CreateDistanceRight",	TOK_F32(ProjectileCreateParams, fCreateDistanceRight, 0), NULL },
	{ "CreateDistanceUp",		TOK_F32(ProjectileCreateParams, fCreateDistanceUp, 0), NULL },
	{ "DirectionYawOffset",		TOK_F32(ProjectileCreateParams, fDirectionYawOffset, 0), NULL },
	{ "DirectionPitchOffset",	TOK_F32(ProjectileCreateParams, fDirectionPitchOffset, 0), NULL },
	{ "SnapToGroundOnCreate",	TOK_BIT, 0, 8, NULL},
	{ "UseAimingTrajectory",	TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_ProjectileCreateParams()
{
	int iSize = sizeof(ProjectileCreateParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ProjectileCreateParams, iSize, "ProjectileCreateParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "ProjectileCreateParams", parse_ProjectileCreateParams, iSize);
	{
		int iSizeInWords = (sizeof(ProjectileCreateParams) + 7) / 4;
		ProjectileCreateParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bSnapToGroundOnCreate = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ProjectileCreateParams[9]);
		pTemp->bSnapToGroundOnCreate = 0;
		pTemp->bUseAimingTrajectory = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ProjectileCreateParams[10]);
		pTemp->bUseAimingTrajectory = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct RemovePowerParams
#define TYPE_parse_RemovePowerParams RemovePowerParams
ParseTable parse_RemovePowerParams[] =
{
	{ "RemovePowerParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(RemovePowerParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(RemovePowerParams, params.eType, kAttribType_RemovePower), AttribTypeEnum },
	{ "hDef",				TOK_REFERENCE(RemovePowerParams, hDef, 0, "PowerDef") },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_RemovePowerParams()
{
	int iSize = sizeof(RemovePowerParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_RemovePowerParams, iSize, "RemovePowerParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "RemovePowerParams", parse_RemovePowerParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct RewardModifierParams
#define TYPE_parse_RewardModifierParams RewardModifierParams
ParseTable parse_RewardModifierParams[] =
{
	{ "RewardModifierParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(RewardModifierParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(RewardModifierParams, params.eType, kAttribType_RewardModifier), AttribTypeEnum },
	{ "hNumeric",				TOK_REFERENCE(RewardModifierParams, hNumeric, 0, "ItemDef") },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_RewardModifierParams()
{
	int iSize = sizeof(RewardModifierParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_RewardModifierParams, iSize, "RewardModifierParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "RewardModifierParams", parse_RewardModifierParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct SetCostumeParams
#define TYPE_parse_SetCostumeParams SetCostumeParams
ParseTable parse_SetCostumeParams[] =
{
	{ "SetCostumeParams", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(SetCostumeParams), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Type",						TOK_OBJECTTYPE | TOK_AUTOINT(SetCostumeParams, params.eType, kAttribType_SetCostume), AttribTypeEnum },
	{ "Mode",						TOK_AUTOINT(SetCostumeParams, eMode, 0), kCostumeDisplayModeEnum },
	{ "Priority",					TOK_AUTOINT(SetCostumeParams, iPriority, 0), NULL },
	{ "CostumeName",				TOK_REFERENCE(SetCostumeParams, hCostume, 0, "PlayerCostume") },
	{ "BoneGroup",					TOK_STRING(SetCostumeParams, pcBoneGroup, 0), NULL },
	{ "Skeleton",					TOK_REFERENCE(SetCostumeParams, hSkeleton, 0, "CostumeSkeleton") },
	{ "TurnRateScale",				TOK_F32(SetCostumeParams, fTurnRateScale, 0), NULL },
	{ "CopyCostumeFromSourceEnt",	TOK_AUTOINT(SetCostumeParams, bCopyCostumeFromSourceEnt, 0), NULL },
	{ "AsMount",					TOK_AUTOINT(SetCostumeParams, bMount, 0), NULL },
	{ "MountScaleOverride",			TOK_F32(SetCostumeParams, fMountScaleOverride, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_SetCostumeParams()
{
	int iSize = sizeof(SetCostumeParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_SetCostumeParams, iSize, "SetCostumeParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "SetCostumeParams", parse_SetCostumeParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct ShieldParams
#define TYPE_parse_ShieldParams ShieldParams
ParseTable parse_ShieldParams[] =
{
	{ "ShieldParams", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ShieldParams), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "Type",							TOK_OBJECTTYPE | TOK_AUTOINT(ShieldParams, params.eType, kAttribType_Shield), AttribTypeEnum },
	{ "Attrib",							TOK_AUTOINT(ShieldParams, offAttrib, -1), AttribTypeEnum },
	{ "ExprBlockMaxDamageAbsorbed",		TOK_OPTIONALLATEBINDSTRUCT(ShieldParams, pExprMaxDamageAbsorbed) },
	{ "PercentIgnored",					TOK_F32(ShieldParams, fPercentIgnored, 0), NULL },
	{ "PercentDamageIgnored",			TOK_REDUNDANTNAME | TOK_F32(ShieldParams, fPercentIgnored, 0), NULL },
	{ "Charges",						TOK_AUTOINT(ShieldParams, uiCharges, 0), NULL },
	{ "Priority",						TOK_AUTOINT(ShieldParams, iPriority, 0), NULL },
	{ "HitFX",							TOK_POOL_STRING | TOK_STRING(ShieldParams, pchHitFX, 0), NULL },
	{ "ScaleMaxAbsorbedByProportion",	TOK_BIT, 0, 8, NULL},
	{ "DamageCredit",					TOK_BIT, 0, 8, NULL},
	{ "DamageTriggersTrackers",			TOK_BIT, 0, 8, NULL},
	{ "IgnoreShieldSensitivity",		TOK_AUTOINT(ShieldParams, bIgnoreShieldSensitivity, 0), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_ShieldParams()
{
	int iSize = sizeof(ShieldParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ShieldParams, iSize, "ShieldParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "ShieldParams", parse_ShieldParams, iSize);
	{
		int iSizeInWords = (sizeof(ShieldParams) + 7) / 4;
		ShieldParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bScaleMaxAbsorbedByProportion = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ShieldParams[10]);
		pTemp->bScaleMaxAbsorbedByProportion = 0;
		pTemp->bDamageCredit = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ShieldParams[11]);
		pTemp->bDamageCredit = 0;
		pTemp->bDamageTriggersTrackers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ShieldParams[12]);
		pTemp->bDamageTriggersTrackers = 0;
	}
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_ShieldParams(void)
{
	DoAutoStructLateBind(parse_ShieldParams, 4, "Expression");
}
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct SpeedCooldownParams
#define TYPE_parse_SpeedCooldownParams SpeedCooldownParams
ParseTable parse_SpeedCooldownParams[] =
{
	{ "SpeedCooldownParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(SpeedCooldownParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(SpeedCooldownParams, params.eType, kAttribType_SpeedCooldownCategory), AttribTypeEnum },
	{ "PowerCategory",			TOK_AUTOINT(SpeedCooldownParams, ePowerCategory, 0), PowerCategoriesEnum },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_SpeedCooldownParams()
{
	int iSize = sizeof(SpeedCooldownParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_SpeedCooldownParams, iSize, "SpeedCooldownParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "SpeedCooldownParams", parse_SpeedCooldownParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct SubtargetSetParams
#define TYPE_parse_SubtargetSetParams SubtargetSetParams
ParseTable parse_SubtargetSetParams[] =
{
	{ "SubtargetSetParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(SubtargetSetParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(SubtargetSetParams, params.eType, kAttribType_SubtargetSet), AttribTypeEnum },
	{ "Category",			TOK_REFERENCE(SubtargetSetParams, hCategory, 0, "PowerSubtargetCategory") },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_SubtargetSetParams()
{
	int iSize = sizeof(SubtargetSetParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_SubtargetSetParams, iSize, "SubtargetSetParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "SubtargetSetParams", parse_SubtargetSetParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct TeleportParams
#define TYPE_parse_TeleportParams TeleportParams
ParseTable parse_TeleportParams[] =
{
	{ "TeleportParams", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(TeleportParams), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Type",						TOK_OBJECTTYPE | TOK_AUTOINT(TeleportParams, params.eType, kAttribType_Teleport), AttribTypeEnum },
	{ "TeleportTarget",				TOK_AUTOINT(TeleportParams, eTeleportTarget, 0), AttibModTeleportTargetEnum },
	{ "ExprBlockTeleportTarget",	TOK_OPTIONALLATEBINDSTRUCT(TeleportParams, pTeleportTargetExpr) },
	{ "exprblock",					TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(TeleportParams, pTeleportTargetExpr) },
	{ "FacingType",					TOK_AUTOINT(TeleportParams, eFacingType, 0), TeleportFaceTypeEnum },
	{ "ProjectileTags",				TOK_STRUCTPARAM | TOK_INTARRAY(TeleportParams, piProjectileTags),  PowerTagsEnum},
	{ "TeleportOffsetOrientation",	TOK_AUTOINT(TeleportParams, eTeleportOffsetOrientation, 0), TeleportOffsetOrientationEnum },
	{ "OffsetForward",				TOK_F32(TeleportParams, fOffsetForward, 0), NULL },
	{ "OffsetRight",				TOK_F32(TeleportParams, fOffsetRight, 0), NULL },
	{ "OffsetUp",					TOK_F32(TeleportParams, fOffsetUp, 0), NULL },
	{ "ExprBlockDistanceFront",		TOK_OPTIONALLATEBINDSTRUCT(TeleportParams, pExprDistanceFront) },
	{ "ExprBlockDistanceRight",		TOK_OPTIONALLATEBINDSTRUCT(TeleportParams, pExprDistanceRight) },
	{ "ExprBlockDistanceAbove",		TOK_OPTIONALLATEBINDSTRUCT(TeleportParams, pExprDistanceAbove) },
	{ "FacingYawOffset",			TOK_F32(TeleportParams, fFacingYawOffset, 0), NULL },
	{ "OffsetUsesPitch",			TOK_BIT, 0, 8, NULL},
	{ "OffsetUsesRoll",				TOK_BIT, 0, 8, NULL},
	{ "ClientViewTeleport",			TOK_BIT, 0, 8, NULL},
	{ "FacingUsePitch",				TOK_BIT, 0, 8, NULL},
	{ "DontAttemptGroundSnap",		TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_TeleportParams()
{
	int iSize = sizeof(TeleportParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_TeleportParams, iSize, "TeleportParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "TeleportParams", parse_TeleportParams, iSize);
	{
		int iSizeInWords = (sizeof(TeleportParams) + 7) / 4;
		TeleportParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bOffsetUsesPitch = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_TeleportParams[16]);
		pTemp->bOffsetUsesPitch = 0;
		pTemp->bOffsetUsesRoll = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_TeleportParams[17]);
		pTemp->bOffsetUsesRoll = 0;
		pTemp->bClientViewTeleport = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_TeleportParams[18]);
		pTemp->bClientViewTeleport = 0;
		pTemp->bFacingUsePitch = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_TeleportParams[19]);
		pTemp->bFacingUsePitch = 0;
		pTemp->bDontAttemptGroundSnap = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_TeleportParams[20]);
		pTemp->bDontAttemptGroundSnap = 0;
	}
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_TeleportParams(void)
{
	DoAutoStructLateBind(parse_TeleportParams, 4, "Expression");
	DoAutoStructLateBind(parse_TeleportParams, 5, "Expression");
	DoAutoStructLateBind(parse_TeleportParams, 12, "Expression");
	DoAutoStructLateBind(parse_TeleportParams, 13, "Expression");
	DoAutoStructLateBind(parse_TeleportParams, 14, "Expression");
}
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct TeleThrowParams
#define TYPE_parse_TeleThrowParams TeleThrowParams
ParseTable parse_TeleThrowParams[] =
{
	{ "TeleThrowParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(TeleThrowParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(TeleThrowParams, params.eType, kAttribType_TeleThrow), AttribTypeEnum },
	{ "Radius",				TOK_F32(TeleThrowParams, fRadius, 0), NULL },
	{ "Def",				TOK_REFERENCE(TeleThrowParams, hDef, 0, "PowerDef") },
	{ "DefFallback",		TOK_REFERENCE(TeleThrowParams, hDefFallback, 0, "PowerDef") },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_TeleThrowParams()
{
	int iSize = sizeof(TeleThrowParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_TeleThrowParams, iSize, "TeleThrowParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "TeleThrowParams", parse_TeleThrowParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct SwingingParams
#define TYPE_parse_SwingingParams SwingingParams
ParseTable parse_SwingingParams[] =
{
	{ "SwingingParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(SwingingParams), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Type",			TOK_OBJECTTYPE | TOK_AUTOINT(SwingingParams, params.eType, kAttribType_Swinging), AttribTypeEnum },
	{ "SwingingFx",		TOK_REFERENCE(SwingingParams, hSwingingFx, 0, "DynFxInfo") },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_SwingingParams()
{
	int iSize = sizeof(SwingingParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_SwingingParams, iSize, "SwingingParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "SwingingParams", parse_SwingingParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct TriggerComplexParams
#define TYPE_parse_TriggerComplexParams TriggerComplexParams
ParseTable parse_TriggerComplexParams[] =
{
	{ "TriggerComplexParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(TriggerComplexParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(TriggerComplexParams, params.eType, kAttribType_TriggerComplex), AttribTypeEnum },
	{ "Events",					TOK_INTARRAY(TriggerComplexParams, piCombatEvents),  CombatEventEnum},
	{ "Def",					TOK_REFERENCE(TriggerComplexParams, hDef, 0, "PowerDef") },
	{ "Source",					TOK_AUTOINT(TriggerComplexParams, eSource, 0), TriggerComplexEntityEnum },
	{ "Target",					TOK_AUTOINT(TriggerComplexParams, eTarget, 0), TriggerComplexEntityEnum },
	{ "ExprChanceBlock",		TOK_OPTIONALLATEBINDSTRUCT(TriggerComplexParams, pExprChance) },
	{ "Chance",					TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(TriggerComplexParams, pExprChance) },
	{ "MagnitudeIsCharges",		TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_TriggerComplexParams()
{
	int iSize = sizeof(TriggerComplexParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_TriggerComplexParams, iSize, "TriggerComplexParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "TriggerComplexParams", parse_TriggerComplexParams, iSize);
	{
		int iSizeInWords = (sizeof(TriggerComplexParams) + 7) / 4;
		TriggerComplexParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bMagnitudeIsCharges = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_TriggerComplexParams[9]);
		pTemp->bMagnitudeIsCharges = 0;
	}
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_TriggerComplexParams(void)
{
	DoAutoStructLateBind(parse_TriggerComplexParams, 7, "Expression");
	DoAutoStructLateBind(parse_TriggerComplexParams, 8, "Expression_StructParam");
}
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct TriggerSimpleParams
#define TYPE_parse_TriggerSimpleParams TriggerSimpleParams
ParseTable parse_TriggerSimpleParams[] =
{
	{ "TriggerSimpleParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(TriggerSimpleParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(TriggerSimpleParams, params.eType, kAttribType_TriggerSimple), AttribTypeEnum },
	{ "Events",					TOK_INTARRAY(TriggerSimpleParams, piCombatEvents),  CombatEventEnum},
	{ "Def",					TOK_REFERENCE(TriggerSimpleParams, hDef, 0, "PowerDef") },
	{ "Source",					TOK_AUTOINT(TriggerSimpleParams, eSource, 0), TriggerSimpleEntityEnum },
	{ "Target",					TOK_AUTOINT(TriggerSimpleParams, eTarget, 0), TriggerSimpleEntityEnum },
	{ "ExprChanceBlock",		TOK_OPTIONALLATEBINDSTRUCT(TriggerSimpleParams, pExprChance) },
	{ "Chance",					TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(TriggerSimpleParams, pExprChance) },
	{ "MagnitudeIsCharges",		TOK_BIT, 0, 8, NULL},
	{ "RespondOncePerTick",		TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_TriggerSimpleParams()
{
	int iSize = sizeof(TriggerSimpleParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_TriggerSimpleParams, iSize, "TriggerSimpleParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "TriggerSimpleParams", parse_TriggerSimpleParams, iSize);
	{
		int iSizeInWords = (sizeof(TriggerSimpleParams) + 7) / 4;
		TriggerSimpleParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bMagnitudeIsCharges = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_TriggerSimpleParams[9]);
		pTemp->bMagnitudeIsCharges = 0;
		pTemp->bRespondOncePerTick = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_TriggerSimpleParams[10]);
		pTemp->bRespondOncePerTick = 0;
	}
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_TriggerSimpleParams(void)
{
	DoAutoStructLateBind(parse_TriggerSimpleParams, 7, "Expression");
	DoAutoStructLateBind(parse_TriggerSimpleParams, 8, "Expression_StructParam");
}
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct WarpToParams
#define TYPE_parse_WarpToParams WarpToParams
ParseTable parse_WarpToParams[] =
{
	{ "WarpToParams", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WarpToParams), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Type",						TOK_OBJECTTYPE | TOK_AUTOINT(WarpToParams, params.eType, kAttribType_WarpTo), AttribTypeEnum },
	{ "Map",						TOK_POOL_STRING | TOK_STRING(WarpToParams, cpchMap, 0), NULL },
	{ "Spawn",						TOK_POOL_STRING | TOK_STRING(WarpToParams, cpchSpawn, 0), NULL },
	{ "TransitionOverride",			TOK_REFERENCE(WarpToParams, hTransOverride, 0, "DoorTransitionSequenceDef") },
	{ "DisallowSameMapTransfer",	TOK_BIT, 0, 8, NULL},
	{ "AllowedInQueueMap",			TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_WarpToParams()
{
	int iSize = sizeof(WarpToParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WarpToParams, iSize, "WarpToParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "WarpToParams", parse_WarpToParams, iSize);
	{
		int iSizeInWords = (sizeof(WarpToParams) + 7) / 4;
		WarpToParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bDisallowSameMapTransfer = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_WarpToParams[6]);
		pTemp->bDisallowSameMapTransfer = 0;
		pTemp->bAllowedInQueueMap = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_WarpToParams[7]);
		pTemp->bAllowedInQueueMap = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct ItemDurabilityParams
#define TYPE_parse_ItemDurabilityParams ItemDurabilityParams
ParseTable parse_ItemDurabilityParams[] =
{
	{ "ItemDurabilityParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemDurabilityParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(ItemDurabilityParams, params.eType, kAttribType_ItemDurability), AttribTypeEnum },
	{ "BagID",					TOK_AUTOINT(ItemDurabilityParams, eBagID, 0), InvBagIDsEnum },
	{ "SlotNum",				TOK_AUTOINT(ItemDurabilityParams, iSlotNum, -1), NULL },
	{ "hSlotDef",				TOK_REFERENCE(ItemDurabilityParams, hSlotDef, 0, "InventorySlotIDDef") },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_ItemDurabilityParams()
{
	int iSize = sizeof(ItemDurabilityParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemDurabilityParams, iSize, "ItemDurabilityParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "ItemDurabilityParams", parse_ItemDurabilityParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct AIAggroTotalScaleParams
#define TYPE_parse_AIAggroTotalScaleParams AIAggroTotalScaleParams
ParseTable parse_AIAggroTotalScaleParams[] =
{
	{ "AIAggroTotalScaleParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIAggroTotalScaleParams), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Type",						TOK_OBJECTTYPE | TOK_AUTOINT(AIAggroTotalScaleParams, params.eType, kAttribType_AIAggroTotalScale), AttribTypeEnum },
	{ "ApplyType",					TOK_AUTOINT(AIAggroTotalScaleParams, eApplyType, kAIAggroTotalScaleApplyType_Self), AIAggroTotalScaleApplyTypeEnum },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AIAggroTotalScaleParams()
{
	int iSize = sizeof(AIAggroTotalScaleParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIAggroTotalScaleParams, iSize, "AIAggroTotalScaleParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "AIAggroTotalScaleParams", parse_AIAggroTotalScaleParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct CombatAdvantageParams
#define TYPE_parse_CombatAdvantageParams CombatAdvantageParams
ParseTable parse_CombatAdvantageParams[] =
{
	{ "CombatAdvantageParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CombatAdvantageParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(CombatAdvantageParams, params.eType, kAttribType_CombatAdvantage), AttribTypeEnum },
	{ "AdvantageType",			TOK_AUTOINT(CombatAdvantageParams, eAdvantageType, 0), CombatAdvantageTypeEnum },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_CombatAdvantageParams()
{
	int iSize = sizeof(CombatAdvantageParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CombatAdvantageParams, iSize, "CombatAdvantageParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "CombatAdvantageParams", parse_CombatAdvantageParams, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct ConstantForceParams
#define TYPE_parse_ConstantForceParams ConstantForceParams
ParseTable parse_ConstantForceParams[] =
{
	{ "ConstantForceParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ConstantForceParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(ConstantForceParams, params.eType, kAttribType_ConstantForce), AttribTypeEnum },
	{ "ExprBlockYawOffset",		TOK_OPTIONALLATEBINDSTRUCT(ConstantForceParams, pExprYawOffset) },
	{ "ModOwnerRelative",		TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_ConstantForceParams()
{
	int iSize = sizeof(ConstantForceParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ConstantForceParams, iSize, "ConstantForceParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "ConstantForceParams", parse_ConstantForceParams, iSize);
	{
		int iSizeInWords = (sizeof(ConstantForceParams) + 7) / 4;
		ConstantForceParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bModOwnerRelative = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ConstantForceParams[4]);
		pTemp->bModOwnerRelative = 0;
	}
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_ConstantForceParams(void)
{
	DoAutoStructLateBind(parse_ConstantForceParams, 3, "Expression");
}
//autogeneratednocheckin
extern ParseTable parse_AttribModDefParams[];
#define TYPE_parse_AttribModDefParams AttribModDefParams
//Structparser.exe autogenerated ParseTable for struct DynamicAttribParams
#define TYPE_parse_DynamicAttribParams DynamicAttribParams
ParseTable parse_DynamicAttribParams[] =
{
	{ "DynamicAttribParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynamicAttribParams), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(DynamicAttribParams, params.eType, kAttribType_DynamicAttrib), AttribTypeEnum },
	{ "ExprAttribType",			TOK_OPTIONALLATEBINDSTRUCT(DynamicAttribParams, pExprAttrib) },
	{ "AttribMessageKey",		TOK_STRING(DynamicAttribParams, cpchAttribMessageKey, 0), NULL },
	{ "DoNoCache",				TOK_AUTOINT(DynamicAttribParams, bDoNoCache, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AttribModDefParams[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_DynamicAttribParams()
{
	int iSize = sizeof(DynamicAttribParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynamicAttribParams, iSize, "DynamicAttribParams", NULL, "CharacterAttribs.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AttribModDefParams, "DynamicAttribParams", parse_DynamicAttribParams, iSize);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_DynamicAttribParams(void)
{
	DoAutoStructLateBind(parse_DynamicAttribParams, 3, "Expression");
}
