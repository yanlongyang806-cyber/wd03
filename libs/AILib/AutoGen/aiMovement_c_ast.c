#include "textparser.h"

//auto-generated staticdefine for enum AIMovementRotationType
//autogeneratednocheckin
StaticDefineInt AIMovementRotationTypeEnum[] =
{
	DEFINE_INT
	{ "NONE", AI_MOVEMENT_ROTATION_NONE},
	{ "POS", AI_MOVEMENT_ROTATION_POS},
	{ "ROT", AI_MOVEMENT_ROTATION_ROT},
	{ "ENTREF", AI_MOVEMENT_ROTATION_ENTREF},
	DEFINE_END
};
void autoEnum_fixup_AIMovementRotationType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AIMovementRotationTypeEnum, "AIMovementRotationType");
}

//auto-generated staticdefine for enum AIMovementReferencePosType
//autogeneratednocheckin
StaticDefineInt AIMovementReferencePosTypeEnum[] =
{
	DEFINE_INT
	{ "WAYPOINT", AIM_RPT_WAYPOINT},
	{ "OTHER", AIM_RPT_OTHER},
	DEFINE_END
};
void autoEnum_fixup_AIMovementReferencePosType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AIMovementReferencePosTypeEnum, "AIMovementReferencePosType");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIMovementAnimFXHandle
#define TYPE_parse_AIMovementAnimFXHandle AIMovementAnimFXHandle
ParseTable parse_AIMovementAnimFXHandle[] =
{
	{ "AIMovementAnimFXHandle", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMovementAnimFXHandle), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "name",					TOK_POOL_STRING | TOK_STRING(AIMovementAnimFXHandle, name, 0), NULL },
	{ "bitHandle",				TOK_AUTOINT(AIMovementAnimFXHandle, bitHandle, 0), NULL },
	{ "timeStamp",				TOK_AUTOINT(AIMovementAnimFXHandle, timeStamp, 0), NULL },
	{ "mmfxHandle",				TOK_AUTOINT(AIMovementAnimFXHandle, mmfxHandle, 0), NULL },
	{ "aiMovementHandle",		TOK_AUTOINT(AIMovementAnimFXHandle, aiMovementHandle, 0), NULL },
	{ "destroyAfterOneTick",	TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIMovementAnimFXHandle()
{
	int iSize = sizeof(AIMovementAnimFXHandle);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMovementAnimFXHandle, iSize, "AIMovementAnimFXHandle", NULL, "aiMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIMovementAnimFXHandle) + 7) / 4;
		AIMovementAnimFXHandle *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->destroyAfterOneTick = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementAnimFXHandle[7]);
		pTemp->destroyAfterOneTick = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_NavPathWaypoint[];
#define TYPE_parse_NavPathWaypoint NavPathWaypoint
//Structparser.exe autogenerated ParseTable for struct AIMovementToFGRefine
#define TYPE_parse_AIMovementToFGRefine AIMovementToFGRefine
ParseTable parse_AIMovementToFGRefine[] =
{
	{ "AIMovementToFGRefine", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMovementToFGRefine), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "refineInsertWp",			TOK_UNOWNED | TOK_OPTIONALSTRUCT(AIMovementToFGRefine, refineInsertWp, parse_NavPathWaypoint) },
	{ "refineStartPos",			TOK_VEC3(AIMovementToFGRefine, refineStartPos), NULL },
	{ "refineTarget",			TOK_VEC3(AIMovementToFGRefine, refineTarget), NULL },
	{ "useRefineStartPos",		TOK_AUTOINT(AIMovementToFGRefine, useRefineStartPos, 0), NULL },
	{ "caller_fname",			TOK_UNOWNED | TOK_STRING(AIMovementToFGRefine, caller_fname, 0), NULL },
	{ "line",					TOK_AUTOINT(AIMovementToFGRefine, line, 0), NULL },
	{ "useRefineTargetPos",		TOK_BIT, 0, 8, NULL},
	{ "refineInsertReverse",	TOK_BIT, 0, 8, NULL},
	{ "pathResetOnRefine",		TOK_BIT, 0, 8, NULL},
	{ "requestRefine",			TOK_BIT, 0, 8, NULL},
	{ "refineAgain",			TOK_BIT, 0, 8, NULL},
	{ "outOfAvoidArea",			TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIMovementToFGRefine()
{
	int iSize = sizeof(AIMovementToFGRefine);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMovementToFGRefine, iSize, "AIMovementToFGRefine", NULL, "aiMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIMovementToFGRefine) + 7) / 4;
		AIMovementToFGRefine *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->useRefineTargetPos = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToFGRefine[8]);
		pTemp->useRefineTargetPos = 0;
		pTemp->refineInsertReverse = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToFGRefine[9]);
		pTemp->refineInsertReverse = 0;
		pTemp->pathResetOnRefine = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToFGRefine[10]);
		pTemp->pathResetOnRefine = 0;
		pTemp->requestRefine = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToFGRefine[11]);
		pTemp->requestRefine = 0;
		pTemp->refineAgain = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToFGRefine[12]);
		pTemp->refineAgain = 0;
		pTemp->outOfAvoidArea = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToFGRefine[13]);
		pTemp->outOfAvoidArea = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIMovementQueuedDoor
#define TYPE_parse_AIMovementQueuedDoor AIMovementQueuedDoor
ParseTable parse_AIMovementQueuedDoor[] =
{
	{ "AIMovementQueuedDoor", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMovementQueuedDoor), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "pos",					TOK_VEC3(AIMovementQueuedDoor, pos), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIMovementQueuedDoor()
{
	int iSize = sizeof(AIMovementQueuedDoor);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMovementQueuedDoor, iSize, "AIMovementQueuedDoor", NULL, "aiMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIMovementUpdateToFGUpdated
#define TYPE_parse_AIMovementUpdateToFGUpdated AIMovementUpdateToFGUpdated
ParseTable parse_AIMovementUpdateToFGUpdated[] =
{
	{ "AIMovementUpdateToFGUpdated", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMovementUpdateToFGUpdated), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "movementCompleted",				TOK_BIT, 0, 8, NULL},
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIMovementUpdateToFGUpdated()
{
	int iSize = sizeof(AIMovementUpdateToFGUpdated);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMovementUpdateToFGUpdated, iSize, "AIMovementUpdateToFGUpdated", NULL, "aiMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIMovementUpdateToFGUpdated) + 7) / 4;
		AIMovementUpdateToFGUpdated *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->movementCompleted = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdateToFGUpdated[2]);
		pTemp->movementCompleted = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIMovementUpdateToFGUpdated[];
#define TYPE_parse_AIMovementUpdateToFGUpdated AIMovementUpdateToFGUpdated
//Structparser.exe autogenerated ParseTable for struct AIMovementUpdateToFG
#define TYPE_parse_AIMovementUpdateToFG AIMovementUpdateToFG
ParseTable parse_AIMovementUpdateToFG[] =
{
	{ "AIMovementUpdateToFG", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMovementUpdateToFG), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "movementCompleted",		TOK_BIT, 0, 8, NULL},
	{ "updated",				TOK_EMBEDDEDSTRUCT(AIMovementUpdateToFG, updated, parse_AIMovementUpdateToFGUpdated)},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIMovementUpdateToFG()
{
	int iSize = sizeof(AIMovementUpdateToFG);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMovementUpdateToFG, iSize, "AIMovementUpdateToFG", NULL, "aiMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIMovementUpdateToFG) + 7) / 4;
		AIMovementUpdateToFG *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->movementCompleted = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdateToFG[2]);
		pTemp->movementCompleted = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_NavPathWaypoint[];
#define TYPE_parse_NavPathWaypoint NavPathWaypoint
extern ParseTable parse_NavPathWaypoint[];
#define TYPE_parse_NavPathWaypoint NavPathWaypoint
extern ParseTable parse_NavPathWaypoint[];
#define TYPE_parse_NavPathWaypoint NavPathWaypoint
extern ParseTable parse_NavPathWaypoint[];
#define TYPE_parse_NavPathWaypoint NavPathWaypoint
extern ParseTable parse_NavPathWaypoint[];
#define TYPE_parse_NavPathWaypoint NavPathWaypoint
extern ParseTable parse_AIDebugLogEntry[];
#define TYPE_parse_AIDebugLogEntry AIDebugLogEntry
extern ParseTable parse_AIMovementAnimFXHandle[];
#define TYPE_parse_AIMovementAnimFXHandle AIMovementAnimFXHandle
extern ParseTable parse_AIMovementToFGRefine[];
#define TYPE_parse_AIMovementToFGRefine AIMovementToFGRefine
extern ParseTable parse_AIMovementQueuedDoor[];
#define TYPE_parse_AIMovementQueuedDoor AIMovementQueuedDoor
extern ParseTable parse_AIMovementUpdateToFG[];
#define TYPE_parse_AIMovementUpdateToFG AIMovementUpdateToFG
//Structparser.exe autogenerated ParseTable for struct AIMovementToFG
#define TYPE_parse_AIMovementToFG AIMovementToFG
ParseTable parse_AIMovementToFG[] =
{
	{ "AIMovementToFG", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMovementToFG), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "splineTarget",		TOK_VEC3(AIMovementToFG, splineTarget), NULL },
	{ "distMovedSinceSync",	TOK_F32(AIMovementToFG, distMovedSinceSync, 0), NULL },
	{ "wpPassed",			TOK_UNOWNED | TOK_STRUCT(AIMovementToFG, wpPassed, parse_NavPathWaypoint) },
	{ "wpBadConn",			TOK_UNOWNED | TOK_STRUCT(AIMovementToFG, wpBadConn, parse_NavPathWaypoint) },
	{ "wpBadConnReset",		TOK_UNOWNED | TOK_STRUCT(AIMovementToFG, wpBadConnReset, parse_NavPathWaypoint) },
	{ "wpDestroy",			TOK_UNOWNED | TOK_STRUCT(AIMovementToFG, wpDestroy, parse_NavPathWaypoint) },
	{ "wpDebugCurPath",		TOK_UNOWNED | TOK_STRUCT(AIMovementToFG, wpDebugCurPath, parse_NavPathWaypoint) },
	{ "wpDebugCurWp",		TOK_AUTOINT(AIMovementToFG, wpDebugCurWp, 0), NULL },
	{ "logEntries",			TOK_STRUCT(AIMovementToFG, logEntries, parse_AIDebugLogEntry) },
	{ "animFxDestroy",		TOK_UNOWNED | TOK_STRUCT(AIMovementToFG, animFxDestroy, parse_AIMovementAnimFXHandle) },
	{ "refine",				TOK_EMBEDDEDSTRUCT(AIMovementToFG, refine, parse_AIMovementToFGRefine)},
	{ "queuedDoor",			TOK_OPTIONALSTRUCT(AIMovementToFG, queuedDoor, parse_AIMovementQueuedDoor) },
	{ "id",					TOK_AUTOINT(AIMovementToFG, id, 0), NULL },
	{ "updateToFG",			TOK_EMBEDDEDSTRUCT(AIMovementToFG, updateToFG, parse_AIMovementUpdateToFG)},
	{ "enabled",			TOK_BIT, 0, 8, NULL},
	{ "deleteOldPath",		TOK_BIT, 0, 8, NULL},
	{ "turnOnFlight",		TOK_BIT, 0, 8, NULL},
	{ "turnOffFlight",		TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIMovementToFG()
{
	int iSize = sizeof(AIMovementToFG);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMovementToFG, iSize, "AIMovementToFG", NULL, "aiMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIMovementToFG) + 7) / 4;
		AIMovementToFG *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->enabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToFG[16]);
		pTemp->enabled = 0;
		pTemp->deleteOldPath = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToFG[17]);
		pTemp->deleteOldPath = 0;
		pTemp->turnOnFlight = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToFG[18]);
		pTemp->turnOnFlight = 0;
		pTemp->turnOffFlight = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToFG[19]);
		pTemp->turnOffFlight = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIMovementUpdate
#define TYPE_parse_AIMovementUpdate AIMovementUpdate
ParseTable parse_AIMovementUpdate[] =
{
	{ "AIMovementUpdate", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMovementUpdate), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "sleeping",			TOK_BIT, 0, 8, NULL},
	{ "path",				TOK_BIT, 0, 8, NULL},
	{ "orders",				TOK_BIT, 0, 8, NULL},
	{ "metaorders",			TOK_BIT, 0, 8, NULL},
	{ "animBits",			TOK_BIT, 0, 8, NULL},
	{ "animHold",			TOK_BIT, 0, 8, NULL},
	{ "followTargetPos",	TOK_BIT, 0, 8, NULL},
	{ "config",				TOK_BIT, 0, 8, NULL},
	{ "rotation",			TOK_BIT, 0, 8, NULL},
	{ "refine",				TOK_BIT, 0, 8, NULL},
	{ "avoid",				TOK_BIT, 0, 8, NULL},
	{ "doorComplete",		TOK_BIT, 0, 8, NULL},
	{ "flying",				TOK_BIT, 0, 8, NULL},
	{ "debugForceProcess",	TOK_BIT, 0, 8, NULL},
	{ "teleportDisabled",	TOK_BIT, 0, 8, NULL},
	{ "rotationDisabled",	TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIMovementUpdate()
{
	int iSize = sizeof(AIMovementUpdate);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMovementUpdate, iSize, "AIMovementUpdate", NULL, "aiMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIMovementUpdate) + 7) / 4;
		AIMovementUpdate *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->sleeping = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdate[2]);
		pTemp->sleeping = 0;
		pTemp->path = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdate[3]);
		pTemp->path = 0;
		pTemp->orders = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdate[4]);
		pTemp->orders = 0;
		pTemp->metaorders = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdate[5]);
		pTemp->metaorders = 0;
		pTemp->animBits = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdate[6]);
		pTemp->animBits = 0;
		pTemp->animHold = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdate[7]);
		pTemp->animHold = 0;
		pTemp->followTargetPos = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdate[8]);
		pTemp->followTargetPos = 0;
		pTemp->config = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdate[9]);
		pTemp->config = 0;
		pTemp->rotation = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdate[10]);
		pTemp->rotation = 0;
		pTemp->refine = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdate[11]);
		pTemp->refine = 0;
		pTemp->avoid = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdate[12]);
		pTemp->avoid = 0;
		pTemp->doorComplete = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdate[13]);
		pTemp->doorComplete = 0;
		pTemp->flying = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdate[14]);
		pTemp->flying = 0;
		pTemp->debugForceProcess = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdate[15]);
		pTemp->debugForceProcess = 0;
		pTemp->teleportDisabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdate[16]);
		pTemp->teleportDisabled = 0;
		pTemp->rotationDisabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementUpdate[17]);
		pTemp->rotationDisabled = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIMovementRotationInfo
#define TYPE_parse_AIMovementRotationInfo AIMovementRotationInfo
ParseTable parse_AIMovementRotationInfo[] =
{
	{ "AIMovementRotationInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMovementRotationInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "type",					TOK_AUTOINT(AIMovementRotationInfo, type, 0), AIMovementRotationTypeEnum },
	{ "finalFacePos",			TOK_REDUNDANTNAME | TOK_VEC3(AIMovementRotationInfo, finalFacePos), NULL },
	{ "finalFaceEntRef",		TOK_REDUNDANTNAME | TOK_AUTOINT(AIMovementRotationInfo, finalFaceEntRef, 0), NULL },
	{ "finalFaceRot",			TOK_QUATPYR(AIMovementRotationInfo, finalFaceRot), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIMovementRotationInfo()
{
	int iSize = sizeof(AIMovementRotationInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMovementRotationInfo, iSize, "AIMovementRotationInfo", NULL, "aiMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIMovementOrders
#define TYPE_parse_AIMovementOrders AIMovementOrders
ParseTable parse_AIMovementOrders[] =
{
	{ "AIMovementOrders", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMovementOrders), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "movementType",		TOK_AUTOINT(AIMovementOrders, movementType, 0), AIMovementOrderTypeEnum },
	{ "entDetail",			TOK_AUTOINT(AIMovementOrders, entDetail, 0), AIMovementOrderEntDetailEnum },
	{ "targetRef",			TOK_AUTOINT(AIMovementOrders, targetRef, 0), NULL },
	{ "targetPos",			TOK_VEC3(AIMovementOrders, targetPos), NULL },
	{ "targetOffset",		TOK_VEC3(AIMovementOrders, targetOffset), NULL },
	{ "useOffset",			TOK_BIT, 0, 8, NULL},
	{ "pathfindResult",		TOK_BIT, 0, 8, NULL},
	{ "offsetRotRelative",	TOK_BIT, 0, 8, NULL},
	{ "stopWithinRange",	TOK_BIT, 0, 8, NULL},
	{ "settled",			TOK_BIT, 0, 8, NULL},
	{ "settledPos",			TOK_VEC3(AIMovementOrders, settledPos), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIMovementOrders()
{
	int iSize = sizeof(AIMovementOrders);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMovementOrders, iSize, "AIMovementOrders", NULL, "aiMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIMovementOrders) + 7) / 4;
		AIMovementOrders *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->useOffset = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementOrders[7]);
		pTemp->useOffset = 0;
		pTemp->pathfindResult = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementOrders[8]);
		pTemp->pathfindResult = 0;
		pTemp->offsetRotRelative = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementOrders[9]);
		pTemp->offsetRotRelative = 0;
		pTemp->stopWithinRange = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementOrders[10]);
		pTemp->stopWithinRange = 0;
		pTemp->settled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementOrders[11]);
		pTemp->settled = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIMovementMetaOrders
#define TYPE_parse_AIMovementMetaOrders AIMovementMetaOrders
ParseTable parse_AIMovementMetaOrders[] =
{
	{ "AIMovementMetaOrders", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMovementMetaOrders), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "distWalk",				TOK_F32(AIMovementMetaOrders, distWalk, 0), NULL },
	{ "distRun",				TOK_F32(AIMovementMetaOrders, distRun, 0), NULL },
	{ "speedCheat",				TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIMovementMetaOrders()
{
	int iSize = sizeof(AIMovementMetaOrders);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMovementMetaOrders, iSize, "AIMovementMetaOrders", NULL, "aiMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIMovementMetaOrders) + 7) / 4;
		AIMovementMetaOrders *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->speedCheat = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementMetaOrders[4]);
		pTemp->speedCheat = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIMovementUpdate[];
#define TYPE_parse_AIMovementUpdate AIMovementUpdate
extern ParseTable parse_AIMovementConfigSettings[];
#define TYPE_parse_AIMovementConfigSettings AIMovementConfigSettings
extern ParseTable parse_AIMovementRotationInfo[];
#define TYPE_parse_AIMovementRotationInfo AIMovementRotationInfo
extern ParseTable parse_AIMovementOrders[];
#define TYPE_parse_AIMovementOrders AIMovementOrders
extern ParseTable parse_AIMovementMetaOrders[];
#define TYPE_parse_AIMovementMetaOrders AIMovementMetaOrders
extern ParseTable parse_AIMovementAnimFXHandle[];
#define TYPE_parse_AIMovementAnimFXHandle AIMovementAnimFXHandle
extern ParseTable parse_AIMovementAnimFXHandle[];
#define TYPE_parse_AIMovementAnimFXHandle AIMovementAnimFXHandle
extern ParseTable parse_NavPath[];
#define TYPE_parse_NavPath NavPath
extern ParseTable parse_NavPath[];
#define TYPE_parse_NavPath NavPath
extern ParseTable parse_NavPathWaypoint[];
#define TYPE_parse_NavPathWaypoint NavPathWaypoint
extern ParseTable parse_NavPathWaypoint[];
#define TYPE_parse_NavPathWaypoint NavPathWaypoint
extern ParseTable parse_NavPathWaypoint[];
#define TYPE_parse_NavPathWaypoint NavPathWaypoint
//Structparser.exe autogenerated ParseTable for struct AIMovementFG
#define TYPE_parse_AIMovementFG AIMovementFG
ParseTable parse_AIMovementFG[] =
{
	{ "AIMovementFG", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMovementFG), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "updated",				TOK_EMBEDDEDSTRUCT(AIMovementFG, updated, parse_AIMovementUpdate)},
	{ "config",					TOK_EMBEDDEDSTRUCT(AIMovementFG, config, parse_AIMovementConfigSettings)},
	{ "rotation",				TOK_EMBEDDEDSTRUCT(AIMovementFG, rotation, parse_AIMovementRotationInfo)},
	{ "orders",					TOK_EMBEDDEDSTRUCT(AIMovementFG, orders, parse_AIMovementOrders)},
	{ "metaorders",				TOK_EMBEDDEDSTRUCT(AIMovementFG, metaorders, parse_AIMovementMetaOrders)},
	{ "splineTarget",			TOK_VEC3(AIMovementFG, splineTarget), NULL },
	{ "lastWPPos",				TOK_VEC3(AIMovementFG, lastWPPos), NULL },
	{ "animHold",				TOK_UNOWNED | TOK_INTARRAY(AIMovementFG, animHold),  NULL},
	{ "animFxAdd",				TOK_UNOWNED | TOK_STRUCT(AIMovementFG, animFxAdd, parse_AIMovementAnimFXHandle) },
	{ "animFxCancel",			TOK_UNOWNED | TOK_STRUCT(AIMovementFG, animFxCancel, parse_AIMovementAnimFXHandle) },
	{ "pathNormal",				TOK_EMBEDDEDSTRUCT(AIMovementFG, pathNormal, parse_NavPath)},
	{ "pathRefine",				TOK_EMBEDDEDSTRUCT(AIMovementFG, pathRefine, parse_NavPath)},
	{ "refineInsertWp",			TOK_UNOWNED | TOK_OPTIONALSTRUCT(AIMovementFG, refineInsertWp, parse_NavPathWaypoint) },
	{ "flags",					TOK_AUTOINT(AIMovementFG, flags, 0), NULL },
	{ "refineId",				TOK_AUTOINT(AIMovementFG, refineId, 0), NULL },
	{ "id",						TOK_AUTOINT(AIMovementFG, id, 0), NULL },
	{ "doMove",					TOK_BIT, 0, 8, NULL},
	{ "pathReset",				TOK_BIT, 0, 8, NULL},
	{ "needsTeleport",			TOK_BIT, 0, 8, NULL},
	{ "sleeping",				TOK_BIT, 0, 8, NULL},
	{ "refineInsertReverse",	TOK_BIT, 0, 8, NULL},
	{ "refineAgain",			TOK_BIT, 0, 8, NULL},
	{ "flying",					TOK_BIT, 0, 8, NULL},
	{ "debugForceProcess",		TOK_BIT, 0, 8, NULL},
	{ "teleportDisabled",		TOK_BIT, 0, 8, NULL},
	{ "rotationDisabled",		TOK_BIT, 0, 8, NULL},
	{ "wpPassed",				TOK_UNOWNED | TOK_STRUCT(AIMovementFG, wpPassed, parse_NavPathWaypoint) },
	{ "wpDestroy",				TOK_UNOWNED | TOK_STRUCT(AIMovementFG, wpDestroy, parse_NavPathWaypoint) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIMovementFG()
{
	int iSize = sizeof(AIMovementFG);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMovementFG, iSize, "AIMovementFG", NULL, "aiMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIMovementFG) + 7) / 4;
		AIMovementFG *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->doMove = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementFG[18]);
		pTemp->doMove = 0;
		pTemp->pathReset = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementFG[19]);
		pTemp->pathReset = 0;
		pTemp->needsTeleport = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementFG[20]);
		pTemp->needsTeleport = 0;
		pTemp->sleeping = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementFG[21]);
		pTemp->sleeping = 0;
		pTemp->refineInsertReverse = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementFG[22]);
		pTemp->refineInsertReverse = 0;
		pTemp->refineAgain = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementFG[23]);
		pTemp->refineAgain = 0;
		pTemp->flying = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementFG[24]);
		pTemp->flying = 0;
		pTemp->debugForceProcess = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementFG[25]);
		pTemp->debugForceProcess = 0;
		pTemp->teleportDisabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementFG[26]);
		pTemp->teleportDisabled = 0;
		pTemp->rotationDisabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementFG[27]);
		pTemp->rotationDisabled = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIMovementUpdate[];
#define TYPE_parse_AIMovementUpdate AIMovementUpdate
extern ParseTable parse_AIMovementConfigSettings[];
#define TYPE_parse_AIMovementConfigSettings AIMovementConfigSettings
extern ParseTable parse_AIMovementRotationInfo[];
#define TYPE_parse_AIMovementRotationInfo AIMovementRotationInfo
extern ParseTable parse_AIMovementOrders[];
#define TYPE_parse_AIMovementOrders AIMovementOrders
extern ParseTable parse_AIMovementMetaOrders[];
#define TYPE_parse_AIMovementMetaOrders AIMovementMetaOrders
extern ParseTable parse_AIMovementAnimFXHandle[];
#define TYPE_parse_AIMovementAnimFXHandle AIMovementAnimFXHandle
extern ParseTable parse_AIMovementAnimFXHandle[];
#define TYPE_parse_AIMovementAnimFXHandle AIMovementAnimFXHandle
extern ParseTable parse_NavPathWaypoint[];
#define TYPE_parse_NavPathWaypoint NavPathWaypoint
extern ParseTable parse_NavPathWaypoint[];
#define TYPE_parse_NavPathWaypoint NavPathWaypoint
extern ParseTable parse_NavPathWaypoint[];
#define TYPE_parse_NavPathWaypoint NavPathWaypoint
//Structparser.exe autogenerated ParseTable for struct AIMovementToBG
#define TYPE_parse_AIMovementToBG AIMovementToBG
ParseTable parse_AIMovementToBG[] =
{
	{ "AIMovementToBG", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMovementToBG), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "updated",				TOK_EMBEDDEDSTRUCT(AIMovementToBG, updated, parse_AIMovementUpdate)},
	{ "config",					TOK_EMBEDDEDSTRUCT(AIMovementToBG, config, parse_AIMovementConfigSettings)},
	{ "rotation",				TOK_EMBEDDEDSTRUCT(AIMovementToBG, rotation, parse_AIMovementRotationInfo)},
	{ "orders",					TOK_EMBEDDEDSTRUCT(AIMovementToBG, orders, parse_AIMovementOrders)},
	{ "metaorders",				TOK_EMBEDDEDSTRUCT(AIMovementToBG, metaorders, parse_AIMovementMetaOrders)},
	{ "animHold",				TOK_UNOWNED | TOK_INTARRAY(AIMovementToBG, animHold),  NULL},
	{ "animFxAdd",				TOK_UNOWNED | TOK_STRUCT(AIMovementToBG, animFxAdd, parse_AIMovementAnimFXHandle) },
	{ "animFxCancel",			TOK_UNOWNED | TOK_STRUCT(AIMovementToBG, animFxCancel, parse_AIMovementAnimFXHandle) },
	{ "waypointsPath",			TOK_UNOWNED | TOK_STRUCT(AIMovementToBG, waypointsPath, parse_NavPathWaypoint) },
	{ "curWaypoint",			TOK_AUTOINT(AIMovementToBG, curWaypoint, 0), NULL },
	{ "waypointsRefine",		TOK_UNOWNED | TOK_STRUCT(AIMovementToBG, waypointsRefine, parse_NavPathWaypoint) },
	{ "refineInsertWp",			TOK_UNOWNED | TOK_OPTIONALSTRUCT(AIMovementToBG, refineInsertWp, parse_NavPathWaypoint) },
	{ "flags",					TOK_AUTOINT(AIMovementToBG, flags, 0), NULL },
	{ "id",						TOK_AUTOINT(AIMovementToBG, id, 0), NULL },
	{ "circular",				TOK_BIT, 0, 8, NULL},
	{ "pingpong",				TOK_BIT, 0, 8, NULL},
	{ "pingpongRev",			TOK_BIT, 0, 8, NULL},
	{ "pathReset",				TOK_BIT, 0, 8, NULL},
	{ "doMove",					TOK_BIT, 0, 8, NULL},
	{ "sleeping",				TOK_BIT, 0, 8, NULL},
	{ "refineInsertReverse",	TOK_BIT, 0, 8, NULL},
	{ "refineAgain",			TOK_BIT, 0, 8, NULL},
	{ "flying",					TOK_BIT, 0, 8, NULL},
	{ "canFly",					TOK_BIT, 0, 8, NULL},
	{ "alwaysFlying",			TOK_BIT, 0, 8, NULL},
	{ "debugForceProcess",		TOK_BIT, 0, 8, NULL},
	{ "teleportDisabled",		TOK_BIT, 0, 8, NULL},
	{ "rotationDisabled",		TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIMovementToBG()
{
	int iSize = sizeof(AIMovementToBG);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMovementToBG, iSize, "AIMovementToBG", NULL, "aiMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIMovementToBG) + 7) / 4;
		AIMovementToBG *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->circular = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToBG[16]);
		pTemp->circular = 0;
		pTemp->pingpong = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToBG[17]);
		pTemp->pingpong = 0;
		pTemp->pingpongRev = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToBG[18]);
		pTemp->pingpongRev = 0;
		pTemp->pathReset = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToBG[19]);
		pTemp->pathReset = 0;
		pTemp->doMove = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToBG[20]);
		pTemp->doMove = 0;
		pTemp->sleeping = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToBG[21]);
		pTemp->sleeping = 0;
		pTemp->refineInsertReverse = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToBG[22]);
		pTemp->refineInsertReverse = 0;
		pTemp->refineAgain = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToBG[23]);
		pTemp->refineAgain = 0;
		pTemp->flying = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToBG[24]);
		pTemp->flying = 0;
		pTemp->canFly = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToBG[25]);
		pTemp->canFly = 0;
		pTemp->alwaysFlying = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToBG[26]);
		pTemp->alwaysFlying = 0;
		pTemp->debugForceProcess = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToBG[27]);
		pTemp->debugForceProcess = 0;
		pTemp->teleportDisabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToBG[28]);
		pTemp->teleportDisabled = 0;
		pTemp->rotationDisabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementToBG[29]);
		pTemp->rotationDisabled = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIMovementConfigSettings[];
#define TYPE_parse_AIMovementConfigSettings AIMovementConfigSettings
extern ParseTable parse_AIMovementRotationInfo[];
#define TYPE_parse_AIMovementRotationInfo AIMovementRotationInfo
extern ParseTable parse_AIMovementToFGRefine[];
#define TYPE_parse_AIMovementToFGRefine AIMovementToFGRefine
extern ParseTable parse_AIMovementOrders[];
#define TYPE_parse_AIMovementOrders AIMovementOrders
extern ParseTable parse_AIMovementMetaOrders[];
#define TYPE_parse_AIMovementMetaOrders AIMovementMetaOrders
extern ParseTable parse_AIMovementAnimFXHandle[];
#define TYPE_parse_AIMovementAnimFXHandle AIMovementAnimFXHandle
extern ParseTable parse_AIMovementUpdateToFG[];
#define TYPE_parse_AIMovementUpdateToFG AIMovementUpdateToFG
//Structparser.exe autogenerated ParseTable for struct AIMovementBG
#define TYPE_parse_AIMovementBG AIMovementBG
ParseTable parse_AIMovementBG[] =
{
	{ "AIMovementBG", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMovementBG), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "config",							TOK_EMBEDDEDSTRUCT(AIMovementBG, config, parse_AIMovementConfigSettings)},
	{ "rotation",						TOK_EMBEDDEDSTRUCT(AIMovementBG, rotation, parse_AIMovementRotationInfo)},
	{ "refine",							TOK_EMBEDDEDSTRUCT(AIMovementBG, refine, parse_AIMovementToFGRefine)},
	{ "orders",							TOK_EMBEDDEDSTRUCT(AIMovementBG, orders, parse_AIMovementOrders)},
	{ "metaorders",						TOK_EMBEDDEDSTRUCT(AIMovementBG, metaorders, parse_AIMovementMetaOrders)},
	{ "targetVelAvg",					TOK_VEC3(AIMovementBG, targetVelAvg), NULL },
	{ "lastTargetEntPos",				TOK_VEC3(AIMovementBG, lastTargetEntPos), NULL },
	{ "targetEntPos",					TOK_VEC3(AIMovementBG, targetEntPos), NULL },
	{ "targetPos",						TOK_VEC3(AIMovementBG, targetPos), NULL },
	{ "splineTarget",					TOK_VEC3(AIMovementBG, splineTarget), NULL },
	{ "splineSource",					TOK_VEC3(AIMovementBG, splineSource), NULL },
	{ "lastPos",						TOK_VEC3(AIMovementBG, lastPos), NULL },
	{ "dir",							TOK_VEC3(AIMovementBG, dir), NULL },
	{ "targetPosLastFrame",				TOK_VEC3(AIMovementBG, targetPosLastFrame), NULL },
	{ "faceRot",						TOK_QUATPYR(AIMovementBG, faceRot), NULL },
	{ "jumpPos",						TOK_VEC3(AIMovementBG, jumpPos), NULL },
	{ "animHold",						TOK_UNOWNED | TOK_INTARRAY(AIMovementBG, animHold),  NULL},
	{ "animFxList",						TOK_UNOWNED | TOK_STRUCT(AIMovementBG, animFxList, parse_AIMovementAnimFXHandle) },
	{ "flags",							TOK_AUTOINT(AIMovementBG, flags, 0), NULL },
	{ "recentMinDistToTarget",			TOK_F32(AIMovementBG, recentMinDistToTarget, 0), NULL },
	{ "recentMaxVelDotToTarget",		TOK_F32(AIMovementBG, recentMaxVelDotToTarget, 0), NULL },
	{ "overrideSpeed",					TOK_F32(AIMovementBG, overrideSpeed, 0), NULL },
	{ "id",								TOK_AUTOINT(AIMovementBG, id, 0), NULL },
	{ "stuckCounter",					TOK_AUTOINT(AIMovementBG, stuckCounter, 0), NULL },
	{ "refineRequestWait",				TOK_AUTOINT(AIMovementBG, refineRequestWait, 0), NULL },
	{ "timeLastShortcutCheck",			TOK_AUTOINT(AIMovementBG, timeLastShortcutCheck, 0), NULL },
	{ "timeLastRefineCheck",			TOK_AUTOINT(AIMovementBG, timeLastRefineCheck, 0), NULL },
	{ "timeLastJump",					TOK_AUTOINT(AIMovementBG, timeLastJump, 0), NULL },
	{ "timeLastSpline",					TOK_AUTOINT(AIMovementBG, timeLastSpline, 0), NULL },
	{ "timeLastGroundCheck",			TOK_AUTOINT(AIMovementBG, timeLastGroundCheck, 0), NULL },
	{ "timeLastReachableCheck",			TOK_AUTOINT(AIMovementBG, timeLastReachableCheck, 0), NULL },
	{ "timeLastTargetDistCheck",		TOK_AUTOINT(AIMovementBG, timeLastTargetDistCheck, 0), NULL },
	{ "timeLastProcess",				TOK_AUTOINT(AIMovementBG, timeLastProcess, 0), NULL },
	{ "spcTimeLastCheckedCombatOffset",	TOK_AUTOINT(AIMovementBG, spcTimeLastCheckedCombatOffset, 0), NULL },
	{ "spcTimeInRangeOfCombatOffset",	TOK_AUTOINT(AIMovementBG, spcTimeInRangeOfCombatOffset, 0), NULL },
	{ "posLastTargetDistCheck",			TOK_VEC3(AIMovementBG, posLastTargetDistCheck), NULL },
	{ "refPosType",						TOK_AUTOINT(AIMovementBG, refPosType, 0), AIMovementReferencePosTypeEnum },
	{ "updateToFG",						TOK_EMBEDDEDSTRUCT(AIMovementBG, updateToFG, parse_AIMovementUpdateToFG)},
	{ "combatOffsetCheckCounter",		TOK_AUTOINT(AIMovementBG, combatOffsetCheckCounter, 0), NULL },
	{ "doMove",							TOK_BIT, 0, 8, NULL},
	{ "doMoveDone",						TOK_BIT, 0, 8, NULL},
	{ "refineRequested",				TOK_BIT, 0, 8, NULL},
	{ "runningDoor",					TOK_BIT, 0, 8, NULL},
	{ "sleeping",						TOK_BIT, 0, 8, NULL},
	{ "doTeleport",						TOK_BIT, 0, 8, NULL},
	{ "skipStuckDetection",				TOK_BIT, 0, 8, NULL},
	{ "flying",							TOK_BIT, 0, 8, NULL},
	{ "canFly",							TOK_BIT, 0, 8, NULL},
	{ "shouldFly",						TOK_BIT, 0, 8, NULL},
	{ "flyingOnGround",					TOK_BIT, 0, 8, NULL},
	{ "alwaysFlying",					TOK_BIT, 0, 8, NULL},
	{ "splining",						TOK_BIT, 0, 8, NULL},
	{ "targetUnreachable",				TOK_BIT, 0, 8, NULL},
	{ "debugForceProcess",				TOK_BIT, 0, 8, NULL},
	{ "approachingNext",				TOK_BIT, 0, 8, NULL},
	{ "walking",						TOK_BIT, 0, 8, NULL},
	{ "running",						TOK_BIT, 0, 8, NULL},
	{ "usePosLastTargetDistCheck",		TOK_BIT, 0, 8, NULL},
	{ "teleportDisabled",				TOK_BIT, 0, 8, NULL},
	{ "reachedOffset",					TOK_BIT, 0, 8, NULL},
	{ "triedMovingLastFrame",			TOK_BIT, 0, 8, NULL},
	{ "animHoldClear",					TOK_BIT, 0, 8, NULL},
	{ "rotationDisabled",				TOK_BIT, 0, 8, NULL},
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIMovementBG()
{
	int iSize = sizeof(AIMovementBG);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMovementBG, iSize, "AIMovementBG", NULL, "aiMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIMovementBG) + 7) / 4;
		AIMovementBG *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->doMove = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[41]);
		pTemp->doMove = 0;
		pTemp->doMoveDone = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[42]);
		pTemp->doMoveDone = 0;
		pTemp->refineRequested = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[43]);
		pTemp->refineRequested = 0;
		pTemp->runningDoor = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[44]);
		pTemp->runningDoor = 0;
		pTemp->sleeping = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[45]);
		pTemp->sleeping = 0;
		pTemp->doTeleport = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[46]);
		pTemp->doTeleport = 0;
		pTemp->skipStuckDetection = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[47]);
		pTemp->skipStuckDetection = 0;
		pTemp->flying = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[48]);
		pTemp->flying = 0;
		pTemp->canFly = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[49]);
		pTemp->canFly = 0;
		pTemp->shouldFly = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[50]);
		pTemp->shouldFly = 0;
		pTemp->flyingOnGround = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[51]);
		pTemp->flyingOnGround = 0;
		pTemp->alwaysFlying = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[52]);
		pTemp->alwaysFlying = 0;
		pTemp->splining = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[53]);
		pTemp->splining = 0;
		pTemp->targetUnreachable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[54]);
		pTemp->targetUnreachable = 0;
		pTemp->debugForceProcess = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[55]);
		pTemp->debugForceProcess = 0;
		pTemp->approachingNext = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[56]);
		pTemp->approachingNext = 0;
		pTemp->walking = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[57]);
		pTemp->walking = 0;
		pTemp->running = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[58]);
		pTemp->running = 0;
		pTemp->usePosLastTargetDistCheck = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[59]);
		pTemp->usePosLastTargetDistCheck = 0;
		pTemp->teleportDisabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[60]);
		pTemp->teleportDisabled = 0;
		pTemp->reachedOffset = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[61]);
		pTemp->reachedOffset = 0;
		pTemp->triedMovingLastFrame = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[62]);
		pTemp->triedMovingLastFrame = 0;
		pTemp->animHoldClear = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[63]);
		pTemp->animHoldClear = 0;
		pTemp->rotationDisabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIMovementBG[64]);
		pTemp->rotationDisabled = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIMovementLocalBG
#define TYPE_parse_AIMovementLocalBG AIMovementLocalBG
ParseTable parse_AIMovementLocalBG[] =
{
	{ "AIMovementLocalBG", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMovementLocalBG), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "unused",				TOK_AUTOINT(AIMovementLocalBG, unused, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIMovementLocalBG()
{
	int iSize = sizeof(AIMovementLocalBG);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMovementLocalBG, iSize, "AIMovementLocalBG", NULL, "aiMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIMovementSync
#define TYPE_parse_AIMovementSync AIMovementSync
ParseTable parse_AIMovementSync[] =
{
	{ "AIMovementSync", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMovementSync), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "unused",			TOK_AUTOINT(AIMovementSync, unused, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIMovementSync()
{
	int iSize = sizeof(AIMovementSync);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMovementSync, iSize, "AIMovementSync", NULL, "aiMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
