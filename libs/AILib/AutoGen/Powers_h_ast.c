#include "textparser.h"

//auto-generated staticdefine for enum PowerType
//autogeneratednocheckin
StaticDefineInt PowerTypeEnum[] =
{
	DEFINE_INT
	{ "Combo", kPowerType_Combo},
	{ "Click", kPowerType_Click},
	{ "Instant", kPowerType_Instant},
	{ "Maintained", kPowerType_Maintained},
	{ "Toggle", kPowerType_Toggle},
	{ "Passive", kPowerType_Passive},
	{ "Innate", kPowerType_Innate},
	{ "Enhancement", kPowerType_Enhancement},
	DEFINE_END
};
void autoEnum_fixup_PowerType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PowerTypeEnum, "PowerType");
}

//auto-generated staticdefine for enum EffectArea
//autogeneratednocheckin
StaticDefineInt EffectAreaEnum[] =
{
	DEFINE_INT
	{ "Character", kEffectArea_Character},
	{ "Location", kEffectArea_Location},
	{ "Cylinder", kEffectArea_Cylinder},
	{ "Cone", kEffectArea_Cone},
	{ "Sphere", kEffectArea_Sphere},
	{ "Team", kEffectArea_Team},
	{ "Volume", kEffectArea_Volume},
	{ "Map", kEffectArea_Map},
	DEFINE_END
};
void autoEnum_fixup_EffectArea(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(EffectAreaEnum, "EffectArea");
}

//auto-generated staticdefine for enum EffectAreaSort
//autogeneratednocheckin
StaticDefineInt EffectAreaSortEnum[] =
{
	DEFINE_INT
	{ "Primary_Dist", kEffectAreaSort_Primary_Dist},
	{ "Dist", kEffectAreaSort_Dist},
	{ "Primary_Random", kEffectAreaSort_Primary_Random},
	{ "Random", kEffectAreaSort_Random},
	{ "HardTarget_Dist", kEffectAreaSort_HardTarget_Dist},
	{ "HardTarget_Random", kEffectAreaSort_HardTarget_Random},
	DEFINE_END
};
void autoEnum_fixup_EffectAreaSort(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(EffectAreaSortEnum, "EffectAreaSort");
}

//auto-generated staticdefine for enum PowerEnterCombatType
//autogeneratednocheckin
StaticDefineInt PowerEnterCombatTypeEnum[] =
{
	DEFINE_INT
	{ "Default", kPowerEnterCombatType_Default},
	{ "Always", kPowerEnterCombatType_Always},
	{ "Never", kPowerEnterCombatType_Never},
	DEFINE_END
};
void autoEnum_fixup_PowerEnterCombatType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PowerEnterCombatTypeEnum, "PowerEnterCombatType");
}

//auto-generated staticdefine for enum PowerRequireValidTarget
//autogeneratednocheckin
StaticDefineInt PowerRequireValidTargetEnum[] =
{
	DEFINE_INT
	{ "Default", kPowerRequireValidTarget_Default},
	{ "Never", kPowerRequireValidTarget_Never},
	{ "Always", kPowerRequireValidTarget_Always},
	DEFINE_END
};
void autoEnum_fixup_PowerRequireValidTarget(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PowerRequireValidTargetEnum, "PowerRequireValidTarget");
}

//auto-generated staticdefine for enum TargetVisibility
//autogeneratednocheckin
StaticDefineInt TargetVisibilityEnum[] =
{
	DEFINE_INT
	{ "LineOfSight", kTargetVisibility_LineOfSight},
	{ "None", kTargetVisibility_None},
	DEFINE_END
};
void autoEnum_fixup_TargetVisibility(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(TargetVisibilityEnum, "TargetVisibility");
}

//auto-generated staticdefine for enum TargetTracking
//autogeneratednocheckin
StaticDefineInt TargetTrackingEnum[] =
{
	DEFINE_INT
	{ "Full", kTargetTracking_Full},
	{ "UntilCurrent", kTargetTracking_UntilCurrent},
	{ "UntilFirstApply", kTargetTracking_UntilFirstApply},
	DEFINE_END
};
void autoEnum_fixup_TargetTracking(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(TargetTrackingEnum, "TargetTracking");
}

//auto-generated staticdefine for enum TargetType
//autogeneratednocheckin
StaticDefineInt TargetTypeEnum[] =
{
	DEFINE_INT
	{ "Alive", kTargetType_Alive},
	{ "Self", kTargetType_Self},
	{ "Player", kTargetType_Player},
	{ "Critter", kTargetType_Critter},
	{ "Friend", kTargetType_Friend},
	{ "Foe", kTargetType_Foe},
	{ "Neutral", kTargetType_Neutral},
	{ "Teammate", kTargetType_Teammate},
	{ "PrimaryPet", kTargetType_PrimaryPet},
	{ "Owner", kTargetType_Owner},
	{ "Creator", kTargetType_Creator},
	{ "Owned", kTargetType_Owned},
	{ "Created", kTargetType_Created},
	{ "Destructible", kTargetType_Destructible},
	{ "PseudoPlayer", kTargetType_PseudoPlayer},
	{ "Untargetable", kTargetType_Untargetable},
	{ "NearDeath", kTargetType_NearDeath},
	{ "Ridable", kTargetType_Ridable},
	{ "Critterpet", kTargetType_Critterpet},
	DEFINE_END
};
void autoEnum_fixup_TargetType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(TargetTypeEnum, "TargetType");
}

//auto-generated staticdefine for enum EnhancementAttachUnownedType
//autogeneratednocheckin
StaticDefineInt EnhancementAttachUnownedTypeEnum[] =
{
	DEFINE_INT
	{ "Never", kEnhancementAttachUnownedType_Never},
	{ "AlwaysIfAttached", kEnhancementAttachUnownedType_AlwaysIfAttached},
	{ "CheckAttachExpr", kEnhancementAttachUnownedType_CheckAttachExpr},
	DEFINE_END
};
void autoEnum_fixup_EnhancementAttachUnownedType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(EnhancementAttachUnownedTypeEnum, "EnhancementAttachUnownedType");
}

//auto-generated staticdefine for enum PowerAITags
//autogeneratednocheckin
extern DefineContext *g_pDefinePowerAITags;
StaticDefineInt PowerAITagsEnum[] =
{
	DEFINE_INT
	{ "Attack", kPowerAITag_Attack},
	{ "Heal", kPowerAITag_Heal},
	{ "Shield_Heal", kPowerAITag_Shield_Heal},
	{ "Buff", kPowerAITag_Buff},
	{ "Cure", kPowerAITag_Cure},
	{ "Control", kPowerAITag_Control},
	{ "Lunge", kPowerAITag_Lunge},
	{ "Flight", kPowerAITag_Flight},
	{ "Resurrect", kPowerAITag_Resurrect},
	{ "AreaEffect", kPowerAITag_AreaEffect},
	{ "OutOfCombat", kPowerAITag_OutOfCombat},
	{ "UseTargetPos", kPowerAITag_UseTargetPos},
	{ "UseWithinPreferredMax", kPowerAITag_UseWithinPreferredMax},
	DEFINE_EMBEDDYNAMIC_INT(g_pDefinePowerAITags)
	DEFINE_END
};
void autoEnum_fixup_PowerAITags(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PowerAITagsEnum, "PowerAITags");
}

//auto-generated staticdefine for enum PowerTacticalMovementMode
//autogeneratednocheckin
StaticDefineInt PowerTacticalMovementModeEnum[] =
{
	DEFINE_INT
	{ "Aim", kPowerTacticalMovementMode_Aim},
	{ "Roll", kPowerTacticalMovementMode_Roll},
	DEFINE_END
};
void autoEnum_fixup_PowerTacticalMovementMode(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PowerTacticalMovementModeEnum, "PowerTacticalMovementMode");
}

//auto-generated staticdefine for enum PowerActivateRules
//autogeneratednocheckin
StaticDefineInt PowerActivateRulesEnum[] =
{
	DEFINE_INT
	{ "None", kPowerActivateRules_None},
	{ "SourceDead", kPowerActivateRules_SourceDead},
	{ "SourceAlive", kPowerActivateRules_SourceAlive},
	DEFINE_END
};
void autoEnum_fixup_PowerActivateRules(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PowerActivateRulesEnum, "PowerActivateRules");
}
//autogeneratednocheckin
extern ParseTable parse_PEPowerDefGroup[];
#define TYPE_parse_PEPowerDefGroup PEPowerDefGroup
extern ParseTable parse_PowerDef[];
#define TYPE_parse_PowerDef PowerDef
//Structparser.exe autogenerated ParseTable for struct PEPowerDefGroup
#define TYPE_parse_PEPowerDefGroup PEPowerDefGroup
ParseTable parse_PEPowerDefGroup[] =
{
	{ "PEPowerDefGroup", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PEPowerDefGroup), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Name",				TOK_STRING(PEPowerDefGroup, pchName, 0), NULL },
	{ "Groups",				TOK_STRUCT(PEPowerDefGroup, ppGroups, parse_PEPowerDefGroup) },
	{ "Powers",				TOK_STRUCT(PEPowerDefGroup, ppPowers, parse_PowerDef) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PEPowerDefGroup()
{
	int iSize = sizeof(PEPowerDefGroup);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PEPowerDefGroup, iSize, "PEPowerDefGroup", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PEInhNode[];
#define TYPE_parse_PEInhNode PEInhNode
extern ParseTable parse_PowerDef[];
#define TYPE_parse_PowerDef PowerDef
//Structparser.exe autogenerated ParseTable for struct PEInhNode
#define TYPE_parse_PEInhNode PEInhNode
ParseTable parse_PEInhNode[] =
{
	{ "PEInhNode", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PEInhNode), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "Name",		TOK_STRING(PEInhNode, pchName, 0), NULL },
	{ "Children",	TOK_STRUCT(PEInhNode, ppChildren, parse_PEInhNode) },
	{ "PowerDef",	TOK_OPTIONALSTRUCT(PEInhNode, pPowerDef, parse_PowerDef) },
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PEInhNode()
{
	int iSize = sizeof(PEInhNode);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PEInhNode, iSize, "PEInhNode", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerPurposeNames
#define TYPE_parse_PowerPurposeNames PowerPurposeNames
ParseTable parse_PowerPurposeNames[] =
{
	{ "PowerPurposeNames", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerPurposeNames), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "PowerPurposeName",	TOK_STRINGARRAY(PowerPurposeNames, ppchNames), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerPurposeNames()
{
	int iSize = sizeof(PowerPurposeNames);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerPurposeNames, iSize, "PowerPurposeNames", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ModStackGroupNames
#define TYPE_parse_ModStackGroupNames ModStackGroupNames
ParseTable parse_ModStackGroupNames[] =
{
	{ "ModStackGroupNames", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ModStackGroupNames), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "AttribModStackGroup",	TOK_STRINGARRAY(ModStackGroupNames, ppchNames), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ModStackGroupNames()
{
	int iSize = sizeof(ModStackGroupNames);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ModStackGroupNames, iSize, "ModStackGroupNames", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerCategory
#define TYPE_parse_PowerCategory PowerCategory
ParseTable parse_PowerCategory[] =
{
	{ "PowerCategory", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerCategory), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "Name",							TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(PowerCategory, pchName, 0), NULL },
	{ "PreferredTray",					TOK_AUTOINT(PowerCategory, iPreferredTray, 0), NULL },
	{ "TimeCooldown",					TOK_F32(PowerCategory, fTimeCooldown, 0), NULL },
	{ "TimeCooldownOutOfCombat",		TOK_F32(PowerCategory, fTimeCooldownOutOfCombat, -1), NULL },
	{ "RequiredItemCategories",			TOK_INTARRAY(PowerCategory, piRequiredItemCategories),  ItemCategoryEnum},
	{ "SortGroup",						TOK_AUTOINT(PowerCategory, iSortGroup, 0), NULL },
	{ "MatchTacticalMode",				TOK_AUTOINT(PowerCategory, eMatchTacticalMode, 0), PowerTacticalMovementModeEnum  ,  TOK_FORMAT_FLAGS},
	{ "SlottingRequired",				TOK_BIT, 0, 8, NULL},
	{ "ToggleExclusive",				TOK_BIT, 0, 8, NULL},
	{ "AutoAttackServer",				TOK_BIT, 0, 8, NULL},
	{ "AutoAttackEnabler",				TOK_BIT, 0, 8, NULL},
	{ "AutoAttackDisabler",				TOK_BIT, 0, 8, NULL},
	{ "WeaponBased",					TOK_BIT, 0, 8, NULL},
	{ "HasAutoSlotPriority",			TOK_BIT, 0, 8, NULL},
	{ "IgnoreTargetPitch",				TOK_BIT, 0, 8, NULL},
	{ "DisplayAttribModsAsBaseStat",	TOK_BIT, 0, 8, NULL},
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PowerCategory()
{
	int iSize = sizeof(PowerCategory);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerCategory, iSize, "PowerCategory", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PowerCategory) + 7) / 4;
		PowerCategory *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bSlottingRequired = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerCategory[9]);
		pTemp->bSlottingRequired = 0;
		pTemp->bToggleExclusive = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerCategory[10]);
		pTemp->bToggleExclusive = 0;
		pTemp->bAutoAttackServer = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerCategory[11]);
		pTemp->bAutoAttackServer = 0;
		pTemp->bAutoAttackEnabler = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerCategory[12]);
		pTemp->bAutoAttackEnabler = 0;
		pTemp->bAutoAttackDisabler = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerCategory[13]);
		pTemp->bAutoAttackDisabler = 0;
		pTemp->bWeaponBased = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerCategory[14]);
		pTemp->bWeaponBased = 0;
		pTemp->bHasAutoSlotPriority = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerCategory[15]);
		pTemp->bHasAutoSlotPriority = 0;
		pTemp->bIgnoreTargetPitch = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerCategory[16]);
		pTemp->bIgnoreTargetPitch = 0;
		pTemp->bDisplayAttribModsAsBaseStat = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerCategory[17]);
		pTemp->bDisplayAttribModsAsBaseStat = 0;
	}
	parse_PowerCategory[5].param = GET_INTPTR_FROM_FLOAT((float)-1);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PowerCategory[];
#define TYPE_parse_PowerCategory PowerCategory
//Structparser.exe autogenerated ParseTable for struct PowerCategories
#define TYPE_parse_PowerCategories PowerCategories
ParseTable parse_PowerCategories[] =
{
	{ "PowerCategories", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerCategories), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "PowerCategory",		TOK_STRUCT(PowerCategories, ppCategories, parse_PowerCategory) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerCategories()
{
	int iSize = sizeof(PowerCategories);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerCategories, iSize, "PowerCategories", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerConfig
#define TYPE_parse_PowerConfig PowerConfig
ParseTable parse_PowerConfig[] =
{
	{ "PowerConfig", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerConfig), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "LockPowersIfNotinPowerhouse",	TOK_AUTOINT(PowerConfig, bLockPowersIfNotinPowerhouse, 0), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerConfig()
{
	int iSize = sizeof(PowerConfig);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerConfig, iSize, "PowerConfig", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerTagNames
#define TYPE_parse_PowerTagNames PowerTagNames
ParseTable parse_PowerTagNames[] =
{
	{ "PowerTagNames", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerTagNames), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "PowerTag",		TOK_STRINGARRAY(PowerTagNames, ppchNames), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerTagNames()
{
	int iSize = sizeof(PowerTagNames);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerTagNames, iSize, "PowerTagNames", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerAITagNames
#define TYPE_parse_PowerAITagNames PowerAITagNames
ParseTable parse_PowerAITagNames[] =
{
	{ "PowerAITagNames", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerAITagNames), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "PowerAITag",			TOK_STRINGARRAY(PowerAITagNames, ppchNames), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerAITagNames()
{
	int iSize = sizeof(PowerAITagNames);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerAITagNames, iSize, "PowerAITagNames", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct TargetTypePair
#define TYPE_parse_TargetTypePair TargetTypePair
ParseTable parse_TargetTypePair[] =
{
	{ "TargetTypePair", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(TargetTypePair), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Require",		TOK_AUTOINT(TargetTypePair, eRequire, 0), TargetTypeEnum  ,  TOK_FORMAT_FLAGS},
	{ "Exclude",		TOK_AUTOINT(TargetTypePair, eExclude, 0), TargetTypeEnum  ,  TOK_FORMAT_FLAGS},
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_TargetTypePair()
{
	int iSize = sizeof(TargetTypePair);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_TargetTypePair, iSize, "TargetTypePair", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_TargetTypePair[];
#define TYPE_parse_TargetTypePair TargetTypePair
//Structparser.exe autogenerated ParseTable for struct PowerTarget
#define TYPE_parse_PowerTarget PowerTarget
ParseTable parse_PowerTarget[] =
{
	{ "PowerTarget", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerTarget), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Name",						TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_KEY | TOK_STRING(PowerTarget, pchName, 0), NULL },
	{ "Require",					TOK_AUTOINT(PowerTarget, eRequire, 0), TargetTypeEnum  ,  TOK_FORMAT_FLAGS},
	{ "Exclude",					TOK_AUTOINT(PowerTarget, eExclude, 0), TargetTypeEnum  ,  TOK_FORMAT_FLAGS},
	{ "Or",							TOK_STRUCT(PowerTarget, ppOrPairs, parse_TargetTypePair) },
	{ "msgDescription",				TOK_REFERENCE(PowerTarget, hMsgDescription, 0, "Message") },
	{ "File",						TOK_POOL_STRING | TOK_CURRENTFILE(PowerTarget, cpchFile), NULL},
	{ "DoNotTargetUnlessRequired",	TOK_BIT, 0, 8, NULL},
	{ "NeverTargetIfNotRequired",	TOK_REDUNDANTNAME | TOK_BIT, 0, 8, NULL},
	{ "UseLocationHitIfNoTarget",	TOK_BIT, 0, 8, NULL},
	{ "FaceActivateSticky",			TOK_BIT, 0, 8, NULL},
	{ "FaceDuringPowerActivation",	TOK_REDUNDANTNAME | TOK_BIT, 0, 8, NULL},
	{ "RequireSelf",				TOK_BIT, 0, 8, NULL},
	{ "AllowSelf",					TOK_BIT, 0, 8, NULL},
	{ "AllowFoe",					TOK_BIT, 0, 8, NULL},
	{ "AllowFriend",				TOK_BIT, 0, 8, NULL},
	{ "AllowNearDeath",				TOK_BIT, 0, 8, NULL},
	{ "SafeForSelfOnly",			TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PowerTarget()
{
	int iSize = sizeof(PowerTarget);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerTarget, iSize, "PowerTarget", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PowerTarget) + 7) / 4;
		PowerTarget *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bDoNotTargetUnlessRequired = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerTarget[8]);
		pTemp->bDoNotTargetUnlessRequired = 0;
		pTemp->bDoNotTargetUnlessRequired = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerTarget[9]);
		pTemp->bDoNotTargetUnlessRequired = 0;
		pTemp->bUseLocationHitIfNoTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerTarget[10]);
		pTemp->bUseLocationHitIfNoTarget = 0;
		pTemp->bFaceActivateSticky = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerTarget[11]);
		pTemp->bFaceActivateSticky = 0;
		pTemp->bFaceActivateSticky = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerTarget[12]);
		pTemp->bFaceActivateSticky = 0;
		pTemp->bRequireSelf = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerTarget[13]);
		pTemp->bRequireSelf = 0;
		pTemp->bAllowSelf = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerTarget[14]);
		pTemp->bAllowSelf = 0;
		pTemp->bAllowFoe = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerTarget[15]);
		pTemp->bAllowFoe = 0;
		pTemp->bAllowFriend = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerTarget[16]);
		pTemp->bAllowFriend = 0;
		pTemp->bAllowNearDeath = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerTarget[17]);
		pTemp->bAllowNearDeath = 0;
		pTemp->bSafeForSelfOnly = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerTarget[18]);
		pTemp->bSafeForSelfOnly = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerCombo
#define TYPE_parse_PowerCombo PowerCombo
ParseTable parse_PowerCombo[] =
{
	{ "PowerCombo", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerCombo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Key",					TOK_KEY | TOK_AUTOINT(PowerCombo, iKey, 0), NULL },
	{ "Power",					TOK_STRUCTPARAM | TOK_REFERENCE(PowerCombo, hPower, 0, "PowerDef") },
	{ "ComboOrder",				TOK_F32(PowerCombo, fOrder, 0), NULL },
	{ "ExprBlockRequires",		TOK_OPTIONALLATEBINDSTRUCT(PowerCombo, pExprRequires) },
	{ "RequiresBlock",			TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerCombo, pExprRequires) },
	{ "Requires",				TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerCombo, pExprRequires) },
	{ "ModeRequire",			TOK_INTARRAY(PowerCombo, piModeRequire),  PowerModeEnum},
	{ "ModeExclude",			TOK_INTARRAY(PowerCombo, piModeExclude),  PowerModeEnum},
	{ "PercentChargeRequired",	TOK_F32(PowerCombo, fPercentChargeRequired, 0), NULL },
	{ "TimeChargeRequired",		TOK_REDUNDANTNAME | TOK_F32(PowerCombo, fPercentChargeRequired, 0), NULL },
	{ "ExprBlockTargetClient",	TOK_OPTIONALLATEBINDSTRUCT(PowerCombo, pExprTargetClient) },
	{ "TargetClient",			TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerCombo, pExprTargetClient) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerCombo()
{
	int iSize = sizeof(PowerCombo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerCombo, iSize, "PowerCombo", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_PowerCombo(void)
{
	DoAutoStructLateBind(parse_PowerCombo, 5, "Expression");
	DoAutoStructLateBind(parse_PowerCombo, 6, "Expression");
	DoAutoStructLateBind(parse_PowerCombo, 7, "Expression_StructParam");
	DoAutoStructLateBind(parse_PowerCombo, 12, "Expression");
	DoAutoStructLateBind(parse_PowerCombo, 13, "Expression_StructParam");
}
//autogeneratednocheckin
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
//Structparser.exe autogenerated ParseTable for struct PowerEmit
#define TYPE_parse_PowerEmit PowerEmit
ParseTable parse_PowerEmit[] =
{
	{ "PowerEmit", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerEmit), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Name",			TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_KEY | TOK_STRING(PowerEmit, cpchName, 0), NULL },
	{ "Bits",			TOK_POOL_STRING | TOK_STRINGARRAY(PowerEmit, ppchBits), NULL },
	{ "msgDisplayName",	TOK_EMBEDDEDSTRUCT(PowerEmit, msgDisplayName, parse_DisplayMessage)},
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerEmit()
{
	int iSize = sizeof(PowerEmit);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerEmit, iSize, "PowerEmit", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerPropDef
#define TYPE_parse_PowerPropDef PowerPropDef
ParseTable parse_PowerPropDef[] =
{
	{ "PowerPropDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerPropDef), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "PropPower",		TOK_AUTOINT(PowerPropDef, bPropPower, 0), NULL },
	{ "CharacterType",	TOK_INTARRAY(PowerPropDef, eCharacterTypes),  CharClassTypesEnum},
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerPropDef()
{
	int iSize = sizeof(PowerPropDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerPropDef, iSize, "PowerPropDef", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerConditionalTags
#define TYPE_parse_PowerConditionalTags PowerConditionalTags
ParseTable parse_PowerConditionalTags[] =
{
	{ "PowerConditionalTags", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerConditionalTags), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Tags",					TOK_STRUCTPARAM | TOK_INTARRAY(PowerConditionalTags, piTags),  PowerTagsEnum},
	{ "AttribIndex",			TOK_AUTOINT(PowerConditionalTags, iAttribIndex, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerConditionalTags()
{
	int iSize = sizeof(PowerConditionalTags);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerConditionalTags, iSize, "PowerConditionalTags", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InheritanceData[];
#define TYPE_parse_InheritanceData InheritanceData
extern ParseTable parse_PowerTagsStruct[];
#define TYPE_parse_PowerTagsStruct PowerTagsStruct
extern ParseTable parse_PowerConditionalTags[];
#define TYPE_parse_PowerConditionalTags PowerConditionalTags
extern ParseTable parse_PowerPropDef[];
#define TYPE_parse_PowerPropDef PowerPropDef
extern ParseTable parse_AttribModDef[];
#define TYPE_parse_AttribModDef AttribModDef
extern ParseTable parse_AttribModDef[];
#define TYPE_parse_AttribModDef AttribModDef
extern ParseTable parse_AttribModDef[];
#define TYPE_parse_AttribModDef AttribModDef
extern ParseTable parse_AttribModDef[];
#define TYPE_parse_AttribModDef AttribModDef
extern ParseTable parse_PowerCombo[];
#define TYPE_parse_PowerCombo PowerCombo
extern ParseTable parse_PowerCombo[];
#define TYPE_parse_PowerCombo PowerCombo
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
//Structparser.exe autogenerated ParseTable for struct PowerDef
#define TYPE_parse_PowerDef PowerDef
ParseTable parse_PowerDef[] =
{
	{ "PowerDef", 								TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerDef), 0, NULL, 0, NULL },
	{ "{",										TOK_START, 0 },
	{ "Inheritance",							TOK_INHERITANCE_STRUCT | TOK_SERVER_ONLY | TOK_OPTIONALSTRUCT(PowerDef, pInheritance, parse_InheritanceData) },
	{ "Name",									TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_KEY | TOK_STRING(PowerDef, pchName, 0), NULL },
	{ "Tags",									TOK_NO_TEXT_SAVE | TOK_EMBEDDEDSTRUCT(PowerDef, tags, parse_PowerTagsStruct)},
	{ "Categories",								TOK_INTARRAY(PowerDef, piCategories),  PowerCategoriesEnum},
	{ "ConditionalTags",						TOK_NO_TEXT_SAVE | TOK_STRUCT(PowerDef, eaConditionalTags, parse_PowerConditionalTags) },
	{ "PowerProp",								TOK_EMBEDDEDSTRUCT(PowerDef, powerProp, parse_PowerPropDef)},
	{ "AttribCost",								TOK_AUTOINT(PowerDef, eAttribCost, -1), AttribTypeEnum },
	{ "ExprBlockCost",							TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprCost) },
	{ "ExprCostBlock",							TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprCost) },
	{ "ExprCost",								TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprCost) },
	{ "ExprBlockCostPeriodic",					TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprCostPeriodic) },
	{ "ExprCostPeriodic",						TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprCostPeriodic) },
	{ "ExprBlockCostSecondary",					TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprCostSecondary) },
	{ "ExprBlockCostPeriodicSecondary",			TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprCostPeriodicSecondary) },
	{ "CostPowerMode",							TOK_AUTOINT(PowerDef, iCostPowerMode, 0), PowerModeEnum },
	{ "CostRecipe",								TOK_REFERENCE(PowerDef, hCostRecipe, 0, "ItemDef") },
	{ "TargetMain",								TOK_REFERENCE(PowerDef, hTargetMain, 0, "PowerTarget") },
	{ "TargetAffected",							TOK_REFERENCE(PowerDef, hTargetAffected, 0, "PowerTarget") },
	{ "TargetArc",								TOK_F32(PowerDef, fTargetArc, 0), NULL },
	{ "MaxTargetsHit",							TOK_AUTOINT(PowerDef, iMaxTargetsHit, 0), NULL },
	{ "ExprBlockRadius",						TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprRadius) },
	{ "ExprRadiusBlock",						TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprRadius) },
	{ "ExprRadius",								TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprRadius) },
	{ "ExprBlockInnerRadius",					TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprInnerRadius) },
	{ "ExprInnerRadiusBlock",					TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprInnerRadius) },
	{ "ExprInnerRadius",						TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprInnerRadius) },
	{ "ExprBlockArc",							TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprArc) },
	{ "ArcBlock",								TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprArc) },
	{ "ExprArcBlock",							TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprArc) },
	{ "ExprArc",								TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprArc) },
	{ "Arc",									TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprArc) },
	{ "Yaw",									TOK_F32(PowerDef, fYaw, 0), NULL },
	{ "Pitch",									TOK_F32(PowerDef, fPitch, 0), NULL },
	{ "FrontOffset",							TOK_F32(PowerDef, fFrontOffset, 0), NULL },
	{ "RightOffset",							TOK_F32(PowerDef, fRightOffset, 0), NULL },
	{ "UpOffset",								TOK_F32(PowerDef, fUpOffset, 0), NULL },
	{ "Range",									TOK_F32(PowerDef, fRange, 0), NULL },
	{ "RangeMin",								TOK_F32(PowerDef, fRangeMin, 0), NULL },
	{ "RangeSecondary",							TOK_F32(PowerDef, fRangeSecondary, 0), NULL },
	{ "StartingRadius",							TOK_F32(PowerDef, fStartingRadius, 0), NULL },
	{ "TimeCharge",								TOK_F32(PowerDef, fTimeCharge, 0), NULL },
	{ "TimeActivate",							TOK_F32(PowerDef, fTimeActivate, 0), NULL },
	{ "TimeActivatePeriod",						TOK_F32(PowerDef, fTimeActivatePeriod, 0), NULL },
	{ "PeriodsMax",								TOK_AUTOINT(PowerDef, uiPeriodsMax, 0), NULL },
	{ "TimePreactivate",						TOK_F32(PowerDef, fTimePreactivate, 0), NULL },
	{ "TimeMaintain",							TOK_NO_TEXT_SAVE | TOK_F32(PowerDef, fTimeMaintain, 0), NULL },
	{ "TimeRecharge",							TOK_F32(PowerDef, fTimeRecharge, 0), NULL },
	{ "TimeOverride",							TOK_F32(PowerDef, fTimeOverride, 0), NULL },
	{ "TimeOverrideReactivePower",				TOK_F32(PowerDef, fTimeOverrideReactivePower, 0), NULL },
	{ "TimeAllowQueue",							TOK_F32(PowerDef, fTimeAllowQueue, -1), NULL },
	{ "TotalCastPeriod",						TOK_NO_TEXT_SAVE | TOK_F32(PowerDef, fTotalCastPeriod, 0), NULL },
	{ "TimePostMaintain",						TOK_F32(PowerDef, fTimePostMaintain, 0), NULL },
	{ "ExprBlockRequiresQueue",					TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprRequiresQueue) },
	{ "ExprBlockRequiresCharge",				TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprRequiresCharge) },
	{ "ExprRequiresChargeBlock",				TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprRequiresCharge) },
	{ "ExprRequiresCharge",						TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprRequiresCharge) },
	{ "ChargeRequire",							TOK_F32(PowerDef, fChargeRequire, 0), NULL },
	{ "PowerModesRequired",						TOK_INTARRAY(PowerDef, piPowerModesRequired),  PowerModeEnum},
	{ "PowerModesDisallowed",					TOK_INTARRAY(PowerDef, piPowerModesDisallowed),  PowerModeEnum},
	{ "CombatEvents",							TOK_INTARRAY(PowerDef, piCombatEvents),  CombatEventEnum},
	{ "CombatEventTime",						TOK_F32(PowerDef, fCombatEventTime, 0), NULL },
	{ "ExprBlockRequiresApply",					TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprRequiresApply) },
	{ "Charges",								TOK_AUTOINT(PowerDef, iCharges, 0), NULL },
	{ "ChargeRefillInterval",					TOK_F32(PowerDef, fChargeRefillInterval, 0), NULL },
	{ "LifetimeReal",							TOK_F32(PowerDef, fLifetimeReal, 0), NULL },
	{ "LifetimeGame",							TOK_F32(PowerDef, fLifetimeGame, 0), NULL },
	{ "LifetimeUsage",							TOK_F32(PowerDef, fLifetimeUsage, 0), NULL },
	{ "AttribKeyBlock",							TOK_AUTOINT(PowerDef, iAttribKeyBlock, 0), NULL },
	{ "AttribMod",								TOK_SERVER_ONLY | TOK_STRUCT(PowerDef, ppMods, parse_AttribModDef) },
	{ "",										TOK_SERVER_ONLY | TOK_NO_INDEX | TOK_STRUCT(PowerDef, ppOrderedMods, parse_AttribModDef) },
	{ "OrderedModsClient",						TOK_NO_INDEX | TOK_NO_TEXT_SAVE | TOK_STRUCT(PowerDef, ppOrderedModsClient, parse_AttribModDef) },
	{ "SpecialModsClient",						TOK_NO_INDEX | TOK_NO_TEXT_SAVE | TOK_STRUCT(PowerDef, ppSpecialModsClient, parse_AttribModDef) },
	{ "Combo",									TOK_STRUCT(PowerDef, ppCombos, parse_PowerCombo) },
	{ "",										TOK_NO_INDEX | TOK_STRUCT(PowerDef, ppOrderedCombos, parse_PowerCombo) },
	{ "AttribIgnore",							TOK_INTARRAY(PowerDef, piAttribIgnore),  AttribTypeEnum},
	{ "AttribDepend",							TOK_SERVER_ONLY | TOK_NO_TEXT_SAVE | TOK_INTARRAY(PowerDef, piAttribDepend),  NULL},
	{ "ExprBlockEnhanceAttach",					TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprEnhanceAttach) },
	{ "ExprEnhanceBlock",						TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprEnhanceAttach) },
	{ "ExprEnhance",							TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprEnhanceAttach) },
	{ "ExprBlockEnhanceApply",					TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprEnhanceApply) },
	{ "ExprEnhanceApplyBlock",					TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprEnhanceApply) },
	{ "ExprEnhanceEntCreate",					TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprEnhanceEntCreate) },
	{ "ExprEnhanceEntCreateBlock",				TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprEnhanceEntCreate) },
	{ "AttribHit",								TOK_AUTOINT(PowerDef, eAttribHit, -1), AttribTypeEnum },
	{ "AttribMiss",								TOK_AUTOINT(PowerDef, eAttribMiss, -1), AttribTypeEnum },
	{ "PreActivatePowerDef",					TOK_REFERENCE(PowerDef, hPreActivatePowerDef, 0, "PowerDef") },
	{ "AnimFX",									TOK_REFERENCE(PowerDef, hFX, 0, "PowerAnimFX") },
	{ "HueOverride",							TOK_F32(PowerDef, fHueOverride, 0), NULL },
	{ "EmitOverride",							TOK_REFERENCE(PowerDef, hEmitOverride, 0, "PowerEmit") },
	{ "IconName",								TOK_POOL_STRING | TOK_STRING(PowerDef, pchIconName, 0), NULL },
	{ "Purpose",								TOK_AUTOINT(PowerDef, ePurpose, 0), PowerPurposeEnum },
	{ "CursorLocationTargetRadius",				TOK_F32(PowerDef, fCursorLocationTargetRadius, 0), NULL },
	{ "msgDisplayName",							TOK_EMBEDDEDSTRUCT(PowerDef, msgDisplayName, parse_DisplayMessage)},
	{ "msgDescription",							TOK_EMBEDDEDSTRUCT(PowerDef, msgDescription, parse_DisplayMessage)},
	{ "msgDescriptionLong",						TOK_EMBEDDEDSTRUCT(PowerDef, msgDescriptionLong, parse_DisplayMessage)},
	{ "msgDescriptionFlavor",					TOK_EMBEDDEDSTRUCT(PowerDef, msgDescriptionFlavor, parse_DisplayMessage)},
	{ "msgAttribOverride",						TOK_EMBEDDEDSTRUCT(PowerDef, msgAttribOverride, parse_DisplayMessage)},
	{ "msgAutoDesc",							TOK_EMBEDDEDSTRUCT(PowerDef, msgAutoDesc, parse_DisplayMessage)},
	{ "msgRankChange",							TOK_EMBEDDEDSTRUCT(PowerDef, msgRankChange, parse_DisplayMessage)},
	{ "RequiresQueueFailMsgKey",				TOK_POOL_STRING | TOK_STRING(PowerDef, pchRequiresQueueFailMsgKey, 0), NULL },
	{ "TooltipDamagePowerDef",					TOK_REFERENCE(PowerDef, hTooltipDamagePowerDef, 0, "PowerDef") },
	{ "ExprHideAutoDesc",						TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprHideAutoDesc) },
	{ "AITags",									TOK_SERVER_ONLY | TOK_AUTOINT(PowerDef, eAITags, 0), PowerAITagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "AIMinRange",								TOK_SERVER_ONLY | TOK_AUTOINT(PowerDef, iAIMinRange, 0), NULL },
	{ "AIMaxRange",								TOK_SERVER_ONLY | TOK_AUTOINT(PowerDef, iAIMaxRange, 0), NULL },
	{ "AIPowerConfigDef",						TOK_GLOBAL_NAME | TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRING(PowerDef, pchAIPowerConfigDef, 0), "AIPowerConfigDef" },
	{ "AIPowerConfigDefInst",					TOK_SERVER_ONLY | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pAIPowerConfigDefInst) },
	{ "ExprBlockAICommand",						TOK_SERVER_ONLY | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprAICommand) },
	{ "ExprAICommand",							TOK_REDUNDANTNAME | TOK_SERVER_ONLY | TOK_OPTIONALLATEBINDSTRUCT(PowerDef, pExprAICommand) },
	{ "Group",									TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRING(PowerDef, pchGroup, 0), NULL },
	{ "IndexTags",								TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRING(PowerDef, pchIndexTags, 0), NULL },
	{ "Notes",									TOK_SERVER_ONLY | TOK_CASE_SENSITIVE | TOK_STRING(PowerDef, pchNotes, 0), NULL },
	{ "File",									TOK_SERVER_ONLY | TOK_POOL_STRING | TOK_CURRENTFILE(PowerDef, pchFile), NULL},
	{ "uiVersion",								TOK_SERVER_ONLY | TOK_NO_TEXT_SAVE | TOK_AUTOINT(PowerDef, uiVersion, 0), NULL },
	{ "ForceBinningAgain",						TOK_REDUNDANTNAME | TOK_SERVER_ONLY | TOK_NO_TEXT_SAVE | TOK_AUTOINT(PowerDef, uiVersion, 0), NULL },
	{ "CriticalChanceAttrib",					TOK_SERVER_ONLY | TOK_NO_TEXT_SAVE | TOK_AUTOINT(PowerDef, eCriticalChanceAttrib, -1), AttribTypeEnum },
	{ "CriticalSeverityAttrib",					TOK_SERVER_ONLY | TOK_NO_TEXT_SAVE | TOK_AUTOINT(PowerDef, eCriticalSeverityAttrib, -1), AttribTypeEnum },
	{ "Interrupts",								TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, PowerInterruptionEnum ,  TOK_FORMAT_FLAGS, " SPECIAL_DEFAULT = \"21\" "},
	{ "Error",									TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, PowerErrorEnum},
	{ "AffectedRequiresPerceivance",			TOK_AUTOINT(PowerDef, bAffectedRequiresPerceivance, 0), NULL },
	{ "TrackTarget",							TOK_AUTOINT(PowerDef, bTrackTarget, 1), NULL },
	{ "Type",									TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, PowerTypeEnum, 0 , " SPECIAL_DEFAULT = \"5\" "},
	{ "TargetVisibilityMain",					TOK_BIT, 0, 8, TargetVisibilityEnum},
	{ "TargetVisibilityAffected",				TOK_BIT, 0, 8, TargetVisibilityEnum},
	{ "Tracking",								TOK_BIT, 0, 8, TargetTrackingEnum},
	{ "EffectArea",								TOK_BIT, 0, 8, EffectAreaEnum},
	{ "EffectAreaSort",							TOK_BIT, 0, 8, EffectAreaSortEnum},
	{ "SourceEnterCombat",						TOK_BIT, 0, 8, PowerEnterCombatTypeEnum},
	{ "SetsCombat",								TOK_REDUNDANTNAME | TOK_BIT, 0, 8, PowerEnterCombatTypeEnum},
	{ "RequireValidTarget",						TOK_BIT, 0, 8, PowerRequireValidTargetEnum},
	{ "UnrestrictedTargeting",					TOK_REDUNDANTNAME | TOK_BIT, 0, 8, PowerRequireValidTargetEnum},
	{ "ActivateRules",							TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, PowerActivateRulesEnum ,  TOK_FORMAT_FLAGS, " SPECIAL_DEFAULT = \"2\" "},
	{ "ActivateWhileDead",						TOK_REDUNDANTNAME | TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, PowerActivateRulesEnum ,  TOK_FORMAT_FLAGS, " SPECIAL_DEFAULT = \"2\" "},
	{ "EnhancementAttachUnowned",				TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, EnhancementAttachUnownedTypeEnum, 0 , " SPECIAL_DEFAULT = \"2\" "},
	{ "Unpredicted",							TOK_BIT, 0, 8, NULL},
	{ "ActivateWhileMundane",					TOK_BIT, 0, 8, NULL},
	{ "Overrides",								TOK_BIT, 0, 8, NULL},
	{ "InstantDeactivation",					TOK_BIT, 0, 8, NULL},
	{ "RechargeDisabled",						TOK_BIT, 0, 8, NULL},
	{ "RechargeRequiresHit",					TOK_BIT, 0, 8, NULL},
	{ "RechargeRequiresCombat",					TOK_BIT, 0, 8, NULL},
	{ "ForceRechargeOnInterrupt",				TOK_BIT, 0, 8, NULL},
	{ "CooldownGlobalNotChecked",				TOK_BIT, 0, 8, NULL},
	{ "CooldownGlobalNotApplied",				TOK_BIT, 0, 8, NULL},
	{ "ChargesSetCooldownWhenEmpty",			TOK_BIT, 0, 8, NULL},
	{ "AutoReapply",							TOK_BIT, 0, 8, NULL},
	{ "DeactivationLeavesMods",					TOK_SERVER_ONLY | TOK_BIT, 0, 8, NULL},
	{ "DeactivationDisablesMods",				TOK_SERVER_ONLY | TOK_BIT, 0, 8, NULL},
	{ "ModsExpireWithoutPower",					TOK_SERVER_ONLY | TOK_BIT, 0, 8, NULL},
	{ "AlwaysQueue",							TOK_BIT, 0, 8, NULL},
	{ "DisableTargetEnterCombat",				TOK_BIT, 0, 8, NULL},
	{ "HitChanceIgnore",						TOK_BIT, 0, 8, NULL},
	{ "IgnoreAccuracy",							TOK_REDUNDANTNAME | TOK_BIT, 0, 8, NULL},
	{ "HitChanceOneTime",						TOK_BIT, 0, 8, NULL},
	{ "DoNotAutoSlot",							TOK_BIT, 0, 8, NULL},
	{ "HideInUI",								TOK_BIT, 0, 8, NULL},
	{ "SimpleProjectileMotion",					TOK_BIT, 0, 8, NULL},
	{ "AlwaysHitGround",						TOK_REDUNDANTNAME | TOK_BIT, 0, 8, NULL},
	{ "EnhanceCopyLevel",						TOK_BIT, 0, 8, NULL},
	{ "EnhancePowerFields",						TOK_BIT, 0, 8, NULL},
	{ "AreaEffectOffsetsRootRelative",			TOK_BIT, 0, 8, NULL},
	{ "SlottingRequired",						TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "ToggleExclusive",						TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "AutoAttackServer",						TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "AutoAttackEnabler",						TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "AutoAttackDisabler",						TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "WeaponBased",							TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "SelfOnce",								TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "MissMods",								TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "ComboToggle",							TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "ComboTargetRules",						TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "ApplyObjectDeath",						TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "LimitedUse",								TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "EnhancementExtension",					TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "EnhanceExtend",							TOK_REDUNDANTNAME | TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "RequiresCooldown",						TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "SafeForSelfOnly",						TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "MultiAttribPower",						TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "ModsIgnoreStrength",						TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "HasEffectAreaOffsets",					TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "HasEffectAreaPositionOffsets",			TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "HasProjectileCreateAttrib",				TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "HasTeleportAttrib",						TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "HasWarpAttrib",							TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "HasPredictedMods",						TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "HasAttribApplyUnownedPowers",			TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "DelayTargetingOnQueuedActivation",		TOK_BIT, 0, 8, NULL},
	{ "UseCameraTargetingVecTargetAssist",		TOK_BIT, 0, 8, NULL},
	{ "DoNotAllowCancelBeforeHitFrame",			TOK_BIT, 0, 8, NULL},
	{ "UpdateChargeTargetOnDeactivate",			TOK_BIT, 0, 8, NULL},
	{ "ChargeAllowIndefiniteCharging",			TOK_BIT, 0, 8, NULL},
	{ "DisableConfuseTargeting",				TOK_BIT, 0, 8, NULL},
	{ "ActivationImmunity",						TOK_BIT, 0, 8, NULL},
	{ "ForceHideDamageFloats",					TOK_BIT, 0, 8, NULL},
	{ "IgnoreShieldCheck",						TOK_BIT, 0, 8, NULL},
	{ "RechargeWhileOffline",					TOK_BIT, 0, 8, NULL},
	{ "CancelPreActivatePower",					TOK_BIT, 0, 8, NULL},
	{ "EffectAreaCentered",						TOK_BIT, 0, 8, NULL},
	{ "EffectAreaIgnoreSourceCapsule",			TOK_BIT, 0, 8, NULL},
	{ "DisallowWhileRooted",					TOK_BIT, 0, 8, NULL},
	{ "CheckComboBeforeToggle",					TOK_BIT, 0, 8, NULL},
	{ "NoDeactivateOnDeath",					TOK_BIT, 0, 8, NULL},
	{ "GenerateUniqueApplyID",					TOK_BIT, 0, 8, NULL},
	{ "NeverAttachEnhancements",				TOK_BIT, 0, 8, NULL},
	{ "DeactivatesPowerOnDisable",				TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "msgActivateSource",						TOK_IGNORE, 0 },
	{ "msgActivateBroadcast",					TOK_IGNORE, 0 },
	{ "msgHitSource",							TOK_IGNORE, 0 },
	{ "msgHitTarget",							TOK_IGNORE, 0 },
	{ "ModSubtargetAccuracy",					TOK_IGNORE, 0 },
	{ "bUnrestrictedTargeting_GetTarget",		TOK_IGNORE, 0 },
	{ "DeactivateMaintainOnFailedApplication",	TOK_IGNORE, 0 },
	{ "}",										TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PowerDef()
{
	int iSize = sizeof(PowerDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerDef, iSize, "PowerDef", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PowerDef) + 7) / 4;
		PowerDef *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->eInterrupts = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[119]);
		pTemp->eInterrupts = 0;
		pTemp->eError = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[120]);
		pTemp->eError = 0;
		pTemp->eType = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[123]);
		pTemp->eType = 0;
		pTemp->eTargetVisibilityMain = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[124]);
		pTemp->eTargetVisibilityMain = 0;
		pTemp->eTargetVisibilityAffected = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[125]);
		pTemp->eTargetVisibilityAffected = 0;
		pTemp->eTracking = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[126]);
		pTemp->eTracking = 0;
		pTemp->eEffectArea = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[127]);
		pTemp->eEffectArea = 0;
		pTemp->eEffectAreaSort = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[128]);
		pTemp->eEffectAreaSort = 0;
		pTemp->eSourceEnterCombat = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[129]);
		pTemp->eSourceEnterCombat = 0;
		pTemp->eSourceEnterCombat = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[130]);
		pTemp->eSourceEnterCombat = 0;
		pTemp->eRequireValidTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[131]);
		pTemp->eRequireValidTarget = 0;
		pTemp->eRequireValidTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[132]);
		pTemp->eRequireValidTarget = 0;
		pTemp->eActivateRules = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[133]);
		pTemp->eActivateRules = 0;
		pTemp->eActivateRules = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[134]);
		pTemp->eActivateRules = 0;
		pTemp->eEnhancementAttachUnowned = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[135]);
		pTemp->eEnhancementAttachUnowned = 0;
		pTemp->bUnpredicted = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[136]);
		pTemp->bUnpredicted = 0;
		pTemp->bActivateWhileMundane = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[137]);
		pTemp->bActivateWhileMundane = 0;
		pTemp->bOverrides = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[138]);
		pTemp->bOverrides = 0;
		pTemp->bInstantDeactivation = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[139]);
		pTemp->bInstantDeactivation = 0;
		pTemp->bRechargeDisabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[140]);
		pTemp->bRechargeDisabled = 0;
		pTemp->bRechargeRequiresHit = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[141]);
		pTemp->bRechargeRequiresHit = 0;
		pTemp->bRechargeRequiresCombat = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[142]);
		pTemp->bRechargeRequiresCombat = 0;
		pTemp->bForceRechargeOnInterrupt = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[143]);
		pTemp->bForceRechargeOnInterrupt = 0;
		pTemp->bCooldownGlobalNotChecked = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[144]);
		pTemp->bCooldownGlobalNotChecked = 0;
		pTemp->bCooldownGlobalNotApplied = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[145]);
		pTemp->bCooldownGlobalNotApplied = 0;
		pTemp->bChargesSetCooldownWhenEmpty = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[146]);
		pTemp->bChargesSetCooldownWhenEmpty = 0;
		pTemp->bAutoReapply = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[147]);
		pTemp->bAutoReapply = 0;
		pTemp->bDeactivationLeavesMods = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[148]);
		pTemp->bDeactivationLeavesMods = 0;
		pTemp->bDeactivationDisablesMods = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[149]);
		pTemp->bDeactivationDisablesMods = 0;
		pTemp->bModsExpireWithoutPower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[150]);
		pTemp->bModsExpireWithoutPower = 0;
		pTemp->bAlwaysQueue = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[151]);
		pTemp->bAlwaysQueue = 0;
		pTemp->bDisableTargetEnterCombat = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[152]);
		pTemp->bDisableTargetEnterCombat = 0;
		pTemp->bHitChanceIgnore = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[153]);
		pTemp->bHitChanceIgnore = 0;
		pTemp->bHitChanceIgnore = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[154]);
		pTemp->bHitChanceIgnore = 0;
		pTemp->bHitChanceOneTime = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[155]);
		pTemp->bHitChanceOneTime = 0;
		pTemp->bDoNotAutoSlot = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[156]);
		pTemp->bDoNotAutoSlot = 0;
		pTemp->bHideInUI = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[157]);
		pTemp->bHideInUI = 0;
		pTemp->bSimpleProjectileMotion = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[158]);
		pTemp->bSimpleProjectileMotion = 0;
		pTemp->bSimpleProjectileMotion = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[159]);
		pTemp->bSimpleProjectileMotion = 0;
		pTemp->bEnhanceCopyLevel = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[160]);
		pTemp->bEnhanceCopyLevel = 0;
		pTemp->bEnhancePowerFields = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[161]);
		pTemp->bEnhancePowerFields = 0;
		pTemp->bAreaEffectOffsetsRootRelative = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[162]);
		pTemp->bAreaEffectOffsetsRootRelative = 0;
		pTemp->bSlottingRequired = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[163]);
		pTemp->bSlottingRequired = 0;
		pTemp->bToggleExclusive = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[164]);
		pTemp->bToggleExclusive = 0;
		pTemp->bAutoAttackServer = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[165]);
		pTemp->bAutoAttackServer = 0;
		pTemp->bAutoAttackEnabler = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[166]);
		pTemp->bAutoAttackEnabler = 0;
		pTemp->bAutoAttackDisabler = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[167]);
		pTemp->bAutoAttackDisabler = 0;
		pTemp->bWeaponBased = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[168]);
		pTemp->bWeaponBased = 0;
		pTemp->bSelfOnce = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[169]);
		pTemp->bSelfOnce = 0;
		pTemp->bMissMods = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[170]);
		pTemp->bMissMods = 0;
		pTemp->bComboToggle = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[171]);
		pTemp->bComboToggle = 0;
		pTemp->bComboTargetRules = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[172]);
		pTemp->bComboTargetRules = 0;
		pTemp->bApplyObjectDeath = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[173]);
		pTemp->bApplyObjectDeath = 0;
		pTemp->bLimitedUse = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[174]);
		pTemp->bLimitedUse = 0;
		pTemp->bEnhancementExtension = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[175]);
		pTemp->bEnhancementExtension = 0;
		pTemp->bEnhancementExtension = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[176]);
		pTemp->bEnhancementExtension = 0;
		pTemp->bRequiresCooldown = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[177]);
		pTemp->bRequiresCooldown = 0;
		pTemp->bSafeForSelfOnly = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[178]);
		pTemp->bSafeForSelfOnly = 0;
		pTemp->bMultiAttribPower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[179]);
		pTemp->bMultiAttribPower = 0;
		pTemp->bModsIgnoreStrength = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[180]);
		pTemp->bModsIgnoreStrength = 0;
		pTemp->bHasEffectAreaOffsets = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[181]);
		pTemp->bHasEffectAreaOffsets = 0;
		pTemp->bHasEffectAreaPositionOffsets = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[182]);
		pTemp->bHasEffectAreaPositionOffsets = 0;
		pTemp->bHasProjectileCreateAttrib = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[183]);
		pTemp->bHasProjectileCreateAttrib = 0;
		pTemp->bHasTeleportAttrib = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[184]);
		pTemp->bHasTeleportAttrib = 0;
		pTemp->bHasWarpAttrib = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[185]);
		pTemp->bHasWarpAttrib = 0;
		pTemp->bHasPredictedMods = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[186]);
		pTemp->bHasPredictedMods = 0;
		pTemp->bHasAttribApplyUnownedPowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[187]);
		pTemp->bHasAttribApplyUnownedPowers = 0;
		pTemp->bDelayTargetingOnQueuedActivation = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[188]);
		pTemp->bDelayTargetingOnQueuedActivation = 0;
		pTemp->bUseCameraTargetingVecTargetAssist = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[189]);
		pTemp->bUseCameraTargetingVecTargetAssist = 0;
		pTemp->bDoNotAllowCancelBeforeHitFrame = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[190]);
		pTemp->bDoNotAllowCancelBeforeHitFrame = 0;
		pTemp->bUpdateChargeTargetOnDeactivate = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[191]);
		pTemp->bUpdateChargeTargetOnDeactivate = 0;
		pTemp->bChargeAllowIndefiniteCharging = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[192]);
		pTemp->bChargeAllowIndefiniteCharging = 0;
		pTemp->bDisableConfuseTargeting = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[193]);
		pTemp->bDisableConfuseTargeting = 0;
		pTemp->bActivationImmunity = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[194]);
		pTemp->bActivationImmunity = 0;
		pTemp->bForceHideDamageFloats = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[195]);
		pTemp->bForceHideDamageFloats = 0;
		pTemp->bIgnoreShieldCheck = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[196]);
		pTemp->bIgnoreShieldCheck = 0;
		pTemp->bRechargeWhileOffline = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[197]);
		pTemp->bRechargeWhileOffline = 0;
		pTemp->bCancelPreActivatePower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[198]);
		pTemp->bCancelPreActivatePower = 0;
		pTemp->bEffectAreaCentered = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[199]);
		pTemp->bEffectAreaCentered = 0;
		pTemp->bEffectAreaIgnoreSourceCapsule = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[200]);
		pTemp->bEffectAreaIgnoreSourceCapsule = 0;
		pTemp->bDisallowWhileRooted = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[201]);
		pTemp->bDisallowWhileRooted = 0;
		pTemp->bCheckComboBeforeToggle = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[202]);
		pTemp->bCheckComboBeforeToggle = 0;
		pTemp->bNoDeactivateOnDeath = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[203]);
		pTemp->bNoDeactivateOnDeath = 0;
		pTemp->bGenerateUniqueApplyID = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[204]);
		pTemp->bGenerateUniqueApplyID = 0;
		pTemp->bNeverAttachEnhancements = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[205]);
		pTemp->bNeverAttachEnhancements = 0;
		pTemp->bDeactivatesPowerOnDisable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerDef[206]);
		pTemp->bDeactivatesPowerOnDisable = 0;
	}
	parse_PowerDef[51].param = GET_INTPTR_FROM_FLOAT((float)-1);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_PowerDef(void)
{
	DoAutoStructLateBind(parse_PowerDef, 9, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 10, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 11, "Expression_StructParam");
	DoAutoStructLateBind(parse_PowerDef, 12, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 13, "Expression_StructParam");
	DoAutoStructLateBind(parse_PowerDef, 14, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 15, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 22, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 23, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 24, "Expression_StructParam");
	DoAutoStructLateBind(parse_PowerDef, 25, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 26, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 27, "Expression_StructParam");
	DoAutoStructLateBind(parse_PowerDef, 28, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 29, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 30, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 31, "Expression_StructParam");
	DoAutoStructLateBind(parse_PowerDef, 32, "Expression_StructParam");
	DoAutoStructLateBind(parse_PowerDef, 54, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 55, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 56, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 57, "Expression_StructParam");
	DoAutoStructLateBind(parse_PowerDef, 63, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 78, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 79, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 80, "Expression_StructParam");
	DoAutoStructLateBind(parse_PowerDef, 81, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 82, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 83, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 84, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 103, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 108, "AIPowerConfigDef");
	DoAutoStructLateBind(parse_PowerDef, 109, "Expression");
	DoAutoStructLateBind(parse_PowerDef, 110, "Expression_StructParam");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerAttribEnhancements
#define TYPE_parse_PowerAttribEnhancements PowerAttribEnhancements
ParseTable parse_PowerAttribEnhancements[] =
{
	{ "PowerAttribEnhancements", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerAttribEnhancements), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "AttribIdx",						TOK_AUTOINT(PowerAttribEnhancements, iAttribIdx, 0), NULL },
	{ "puiEnhancementIDs",				TOK_INTARRAY(PowerAttribEnhancements, puiEnhancementIDs),  NULL},
	{ "puiExpirationEnhancementIDs",	TOK_INTARRAY(PowerAttribEnhancements, puiExpirationEnhancementIDs),  NULL},
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerAttribEnhancements()
{
	int iSize = sizeof(PowerAttribEnhancements);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerAttribEnhancements, iSize, "PowerAttribEnhancements", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_Power[];
#define TYPE_parse_Power Power
extern ParseTable parse_Power[];
#define TYPE_parse_Power Power
extern ParseTable parse_PowerAttribEnhancements[];
#define TYPE_parse_PowerAttribEnhancements PowerAttribEnhancements
//Structparser.exe autogenerated ParseTable for struct Power
#define TYPE_parse_Power Power
ParseTable parse_Power[] =
{
	{ "Power", 						TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(Power), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "hDef",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(Power, hDef, 0, "PowerDef") },
	{ "uiID",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_KEY | TOK_AUTOINT(Power, uiID, 0), NULL },
	{ "uiTimeCreated",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(Power, uiTimeCreated, 0), NULL },
	{ "iLevel",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(Power, iLevel, 0), NULL },
	{ "fHue",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_F32(Power, fHue, 0), NULL },
	{ "hEmit",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(Power, hEmit, 0, "PowerEmit") },
	{ "iEntCreateCostume",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(Power, iEntCreateCostume, 0), NULL },
	{ "iChargesUsed",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_AUTOINT(Power, iChargesUsed, 0), NULL },
	{ "iChargesUsedTransact",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(Power, iChargesUsedTransact, 0), NULL },
	{ "fLifetimeGameUsed",			TOK_PERSIST | TOK_SOMETIMES_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_F32(Power, fLifetimeGameUsed, 0), NULL },
	{ "fLifetimeUsageUsed",			TOK_PERSIST | TOK_SOMETIMES_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_F32(Power, fLifetimeUsageUsed, 0), NULL },
	{ "fTimeRecharge",				TOK_PERSIST | TOK_SOMETIMES_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_F32(Power, fTimeRecharge, 0), NULL },
	{ "fTimeChargeRefill",			TOK_PERSIST | TOK_SOMETIMES_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_F32(Power, fTimeChargeRefill, 0), NULL },
	{ "ppSubPowers",				TOK_NO_INDEX | TOK_STRUCT(Power, ppSubPowers, parse_Power) },
	{ "ppSubCombatStatePowers",		TOK_STRUCT(Power, ppSubCombatStatePowers, parse_Power) },
	{ "iLevelAdjustment",			TOK_NO_NETSEND | TOK_AUTOINT(Power, iLevelAdjustment, 0), NULL },
	{ "fYaw",						TOK_NO_NETSEND | TOK_F32(Power, fYaw, 0), NULL },
	{ "uiReplacementID",			TOK_NO_NETSEND | TOK_AUTOINT(Power, uiReplacementID, 0), NULL },
	{ "uiSrcEquipSlot",				TOK_NO_NETSEND | TOK_AUTOINT(Power, uiSrcEquipSlot, 0), NULL },
	{ "uiPowerSlotReplacementID",	TOK_NO_NETSEND | TOK_AUTOINT(Power, uiPowerSlotReplacementID, 0), NULL },
	{ "fTableScale",				TOK_F32(Power, fTableScale, 1), NULL },
	{ "puiEnhancementIDs",			TOK_INTARRAY(Power, puiEnhancementIDs),  NULL},
	{ "ppAttribEnhancements",		TOK_SERVER_ONLY | TOK_STRUCT(Power, ppAttribEnhancements, parse_PowerAttribEnhancements) },
	{ "fEnhancedRange",				TOK_NO_NETSEND | TOK_F32(Power, fEnhancedRange, 0), NULL },
	{ "fEnhancedRadius",			TOK_F32(Power, fEnhancedRadius, 0), NULL },
	{ "bHideInUI",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_BIT, 0, 8, NULL},
	{ "bActive",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_Power()
{
	int iSize = sizeof(Power);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_Power, iSize, "Power", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(Power)) + 7) / 4;
		NOCONST(Power) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bHideInUI = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Power[27]);
		pTemp->bHideInUI = 0;
		pTemp->bActive = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Power[28]);
		pTemp->bActive = 0;
	}
	parse_Power[22].param = GET_INTPTR_FROM_FLOAT((float)1);
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerRef
#define TYPE_parse_PowerRef PowerRef
ParseTable parse_PowerRef[] =
{
	{ "PowerRef", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerRef), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "uiID",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_AUTOINT(PowerRef, uiID, 0), NULL },
	{ "iIdxSub",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_AUTOINT(PowerRef, iIdxSub, 0), NULL },
	{ "uiSrcEquipSlot",	TOK_AUTOINT(PowerRef, uiSrcEquipSlot, 0), NULL },
	{ "iLinkedSub",		TOK_AUTOINT(PowerRef, iLinkedSub, 0), NULL },
	{ "hdef",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_REFERENCE(PowerRef, hdef, 0, "PowerDef") },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
typedef struct MemoryPoolImp *MemoryPool;
extern MemoryPool memPoolPowerRef;
int autoStruct_fixup_PowerRef()
{
	int iSize = sizeof(PowerRef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerRef, iSize, "PowerRef", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	ParserSetTPIUsesSingleThreadedMemPool(parse_PowerRef, &memPoolPowerRef);
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CooldownTimer
#define TYPE_parse_CooldownTimer CooldownTimer
ParseTable parse_CooldownTimer[] =
{
	{ "CooldownTimer", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CooldownTimer), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "iPowerCategory",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_KEY | TOK_AUTOINT(CooldownTimer, iPowerCategory, 0), NULL },
	{ "fCooldown",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(CooldownTimer, fCooldown, 0), NULL },
	{ "pchCategory",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(CooldownTimer, pchCategory, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
typedef struct MemoryPoolImp *MemoryPool;
extern MemoryPool memPoolCooldownTimer;
int autoStruct_fixup_CooldownTimer()
{
	int iSize = sizeof(CooldownTimer);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CooldownTimer, iSize, "CooldownTimer", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	ParserSetTPIUsesSingleThreadedMemPool(parse_CooldownTimer, &memPoolCooldownTimer);
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerIDList
#define TYPE_parse_PowerIDList PowerIDList
ParseTable parse_PowerIDList[] =
{
	{ "PowerIDList", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerIDList), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "eaiPowerIDs",	TOK_INTARRAY(PowerIDList, eaiPowerIDs),  NULL},
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerIDList()
{
	int iSize = sizeof(PowerIDList);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerIDList, iSize, "PowerIDList", NULL, "Powers.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
