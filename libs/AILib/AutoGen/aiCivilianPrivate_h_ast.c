#include "textparser.h"

//auto-generated staticdefine for enum EAICivilianType
//autogeneratednocheckin
StaticDefineInt EAICivilianTypeEnum[] =
{
	DEFINE_INT
	{ "NULL", EAICivilianType_NULL},
	{ "PERSON", EAICivilianType_PERSON},
	{ "CAR", EAICivilianType_CAR},
	{ "TROLLEY", EAICivilianType_TROLLEY},
	{ "COUNT", EAICivilianType_COUNT},
	DEFINE_END
};
void autoEnum_fixup_EAICivilianType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(EAICivilianTypeEnum, "EAICivilianType");
}

//auto-generated staticdefine for enum CivGenState
//autogeneratednocheckin
StaticDefineInt CivGenStateEnum[] =
{
	DEFINE_INT
	{ "NONE", CGS_NONE},
	{ "GRID", CGS_GRID},
	{ "EDGE", CGS_EDGE},
	{ "EDGE2", CGS_EDGE2},
	{ "EDGE3", CGS_EDGE3},
	{ "LINE", CGS_LINE},
	{ "LINE2", CGS_LINE2},
	{ "LINE3", CGS_LINE3},
	{ "POSTLINE", CGS_POSTLINE},
	{ "PAIR", CGS_PAIR},
	{ "PAIR2", CGS_PAIR2},
	{ "LANE", CGS_LANE},
	{ "LEG", CGS_LEG},
	{ "LEG2", CGS_LEG2},
	{ "LEG3", CGS_LEG3},
	{ "LEG4", CGS_LEG4},
	{ "INT0", CGS_INT0},
	{ "INT1", CGS_INT1},
	{ "INT2", CGS_INT2},
	{ "INT3", CGS_INT3},
	{ "INT4", CGS_INT4},
	{ "SPLIT", CGS_SPLIT},
	{ "MIN", CGS_MIN},
	{ "COPLANAR", CGS_COPLANAR},
	{ "CROSSWALK", CGS_CROSSWALK},
	{ "PATHPOINTS", CGS_PATHPOINTS},
	{ "CURVEFITTING", CGS_CURVEFITTING},
	{ "FIN", CGS_FIN},
	{ "FILE", CGS_FILE},
	{ "DONE", CGS_DONE},
	{ "COUNT", CGS_COUNT},
	DEFINE_END
};
void autoEnum_fixup_CivGenState(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(CivGenStateEnum, "CivGenState");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AICivilianPathLeg
#define TYPE_parse_AICivilianPathLeg AICivilianPathLeg
ParseTable parse_AICivilianPathLeg[] =
{
	{ "AICivilianPathLeg", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivilianPathLeg), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "index",							TOK_AUTOINT(AICivilianPathLeg, index, 0), NULL },
	{ "start",							TOK_VEC3(AICivilianPathLeg, start), NULL },
	{ "end",							TOK_VEC3(AICivilianPathLeg, end), NULL },
	{ "dir",							TOK_VEC3(AICivilianPathLeg, dir), NULL },
	{ "len",							TOK_F32(AICivilianPathLeg, len, 0), NULL },
	{ "perp",							TOK_VEC3(AICivilianPathLeg, perp), NULL },
	{ "width",							TOK_F32(AICivilianPathLeg, width, 0), NULL },
	{ "max_lanes",						TOK_AUTOINT(AICivilianPathLeg, max_lanes, 0), NULL },
	{ "median_width",					TOK_F32(AICivilianPathLeg, median_width, 0), NULL },
	{ "lane_width",						TOK_F32(AICivilianPathLeg, lane_width, 0), NULL },
	{ "leg_set",						TOK_AUTOINT(AICivilianPathLeg, leg_set, 0), NULL },
	{ "SkewedAngle_Start",				TOK_F32(AICivilianPathLeg, fSkewedAngle_Start, 0), NULL },
	{ "SkewedLength_Start",				TOK_F32(AICivilianPathLeg, fSkewedLength_Start, 0), NULL },
	{ "type",							TOK_AUTOINT(AICivilianPathLeg, type, 0), NULL },
	{ "deleted",						TOK_AUTOINT(AICivilianPathLeg, deleted, 0), CivGenStateEnum },
	{ "deleteReason",					TOK_POOL_STRING | TOK_STRING(AICivilianPathLeg, deleteReason, 0), NULL },
	{ "nextByIndex",					TOK_AUTOINT(AICivilianPathLeg, nextByIndex, 0), NULL },
	{ "prevByIndex",					TOK_AUTOINT(AICivilianPathLeg, prevByIndex, 0), NULL },
	{ "nextIntByIndex",					TOK_AUTOINT(AICivilianPathLeg, nextIntByIndex, 0), NULL },
	{ "prevIntByIndex",					TOK_AUTOINT(AICivilianPathLeg, prevIntByIndex, 0), NULL },
	{ "midIntsByIndex",					TOK_INTARRAY(AICivilianPathLeg, midIntsByIndex),  NULL},
	{ "CrosswalkLegsByIndex",			TOK_INTARRAY(AICivilianPathLeg, eaCrosswalkLegsByIndex),  NULL},
	{ "crosswalkNearestRoadByIndex",	TOK_AUTOINT(AICivilianPathLeg, crosswalkNearestRoadByIndex, 0), NULL },
	{ "crosswalkRoadStartDist",			TOK_F32(AICivilianPathLeg, crosswalkRoadStartDist, 0), NULL },
	{ "LegTag",							TOK_POOL_STRING | TOK_STRING(AICivilianPathLeg, pchLegTag, 0), NULL },
	{ "IsGroundCoplanar",				TOK_BIT, 0, 8, NULL},
	{ "IsCrosswalk",					TOK_BIT, 0, 8, NULL},
	{ "IsXingStopLight",				TOK_BIT, 0, 8, NULL},
	{ "Skewed_Start",					TOK_BIT, 0, 8, NULL},
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
typedef struct MemoryPoolImp *MemoryPool;
extern MemoryPool memPoolAICivilianPathLeg;
int autoStruct_fixup_AICivilianPathLeg()
{
	int iSize = sizeof(AICivilianPathLeg);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivilianPathLeg, iSize, "AICivilianPathLeg", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	ParserSetTPIUsesSingleThreadedMemPool(parse_AICivilianPathLeg, &memPoolAICivilianPathLeg);
	{
		int iSizeInWords = (sizeof(AICivilianPathLeg) + 7) / 4;
		AICivilianPathLeg *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bIsGroundCoplanar = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianPathLeg[27]);
		pTemp->bIsGroundCoplanar = 0;
		pTemp->bIsCrosswalk = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianPathLeg[28]);
		pTemp->bIsCrosswalk = 0;
		pTemp->bIsXingStopLight = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianPathLeg[29]);
		pTemp->bIsXingStopLight = 0;
		pTemp->bSkewed_Start = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianPathLeg[30]);
		pTemp->bSkewed_Start = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PathLegStopLight
#define TYPE_parse_PathLegStopLight PathLegStopLight
ParseTable parse_PathLegStopLight[] =
{
	{ "PathLegStopLight", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PathLegStopLight), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "hStopLight",			TOK_REFERENCE(PathLegStopLight, hStopLight, 0, "WorldInteractionNode") },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PathLegStopLight()
{
	int iSize = sizeof(PathLegStopLight);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PathLegStopLight, iSize, "PathLegStopLight", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PathLegStopLight[];
#define TYPE_parse_PathLegStopLight PathLegStopLight
//Structparser.exe autogenerated ParseTable for struct PathLegIntersect
#define TYPE_parse_PathLegIntersect PathLegIntersect
ParseTable parse_PathLegIntersect[] =
{
	{ "PathLegIntersect", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PathLegIntersect), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "legByIndex",			TOK_AUTOINT(PathLegIntersect, legByIndex, 0), NULL },
	{ "crosswalkByIndex",	TOK_AUTOINT(PathLegIntersect, crosswalkByIndex, 0), NULL },
	{ "intersect",			TOK_VEC3(PathLegIntersect, intersect), NULL },
	{ "StopLights",			TOK_STRUCT(PathLegIntersect, eaStopLights, parse_PathLegStopLight) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PathLegIntersect()
{
	int iSize = sizeof(PathLegIntersect);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PathLegIntersect, iSize, "PathLegIntersect", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PathLegIntersect[];
#define TYPE_parse_PathLegIntersect PathLegIntersect
//Structparser.exe autogenerated ParseTable for struct AICivilianPathIntersection
#define TYPE_parse_AICivilianPathIntersection AICivilianPathIntersection
ParseTable parse_AICivilianPathIntersection[] =
{
	{ "AICivilianPathIntersection", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivilianPathIntersection), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "min",						TOK_VEC3(AICivilianPathIntersection, min), NULL },
	{ "max",						TOK_VEC3(AICivilianPathIntersection, max), NULL },
	{ "index",						TOK_AUTOINT(AICivilianPathIntersection, index, 0), NULL },
	{ "legIntersects",				TOK_STRUCT(AICivilianPathIntersection, legIntersects, parse_PathLegIntersect) },
	{ "isectionType",				TOK_AUTOINT(AICivilianPathIntersection, isectionType, 0), NULL },
	{ "IsMidIntersection",			TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AICivilianPathIntersection()
{
	int iSize = sizeof(AICivilianPathIntersection);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivilianPathIntersection, iSize, "AICivilianPathIntersection", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AICivilianPathIntersection) + 7) / 4;
		AICivilianPathIntersection *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bIsMidIntersection = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianPathIntersection[7]);
		pTemp->bIsMidIntersection = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AICivilianPathPointIntersection
#define TYPE_parse_AICivilianPathPointIntersection AICivilianPathPointIntersection
ParseTable parse_AICivilianPathPointIntersection[] =
{
	{ "AICivilianPathPointIntersection", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivilianPathPointIntersection), 0, NULL, 0, NULL },
	{ "{",									TOK_START, 0 },
	{ "myIndex",							TOK_AUTOINT(AICivilianPathPointIntersection, myIndex, 0), NULL },
	{ "PathPointIndicies",					TOK_INTARRAY(AICivilianPathPointIntersection, eaPathPointIndicies),  NULL},
	{ "}",									TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivilianPathPointIntersection()
{
	int iSize = sizeof(AICivilianPathPointIntersection);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivilianPathPointIntersection, iSize, "AICivilianPathPointIntersection", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AICivilianPathPoint
#define TYPE_parse_AICivilianPathPoint AICivilianPathPoint
ParseTable parse_AICivilianPathPoint[] =
{
	{ "AICivilianPathPoint", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivilianPathPoint), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Pos",						TOK_VEC3(AICivilianPathPoint, vPos), NULL },
	{ "myIndex",					TOK_AUTOINT(AICivilianPathPoint, myIndex, 0), NULL },
	{ "nextPathPointIndex",			TOK_AUTOINT(AICivilianPathPoint, nextPathPointIndex, 0), NULL },
	{ "intersectionIndex",			TOK_AUTOINT(AICivilianPathPoint, intersectionIndex, 0), NULL },
	{ "pathPointIntersectionIndex",	TOK_AUTOINT(AICivilianPathPoint, pathPointIntersectionIndex, 0), NULL },
	{ "IsReversalPoint",			TOK_AUTOINT(AICivilianPathPoint, bIsReversalPoint, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivilianPathPoint()
{
	int iSize = sizeof(AICivilianPathPoint);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivilianPathPoint, iSize, "AICivilianPathPoint", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AICivIntersectionCurve
#define TYPE_parse_AICivIntersectionCurve AICivIntersectionCurve
ParseTable parse_AICivIntersectionCurve[] =
{
	{ "AICivIntersectionCurve", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivIntersectionCurve), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "CurvePoint",				TOK_VEC3(AICivIntersectionCurve, vCurvePoint), NULL },
	{ "legSourceIndex",			TOK_AUTOINT(AICivIntersectionCurve, legSourceIndex, 0), NULL },
	{ "legDestIndex",			TOK_AUTOINT(AICivIntersectionCurve, legDestIndex, 0), NULL },
	{ "sourceLane",				TOK_AUTOINT(AICivIntersectionCurve, sourceLane, 0), NULL },
	{ "destLane",				TOK_AUTOINT(AICivIntersectionCurve, destLane, 0), NULL },
	{ "RightTurn",				TOK_AUTOINT(AICivIntersectionCurve, bRightTurn, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivIntersectionCurve()
{
	int iSize = sizeof(AICivIntersectionCurve);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivIntersectionCurve, iSize, "AICivIntersectionCurve", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CivilianGenerator
#define TYPE_parse_CivilianGenerator CivilianGenerator
ParseTable parse_CivilianGenerator[] =
{
	{ "CivilianGenerator", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CivilianGenerator), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "world_pos",			TOK_VEC3(CivilianGenerator, world_pos), NULL },
	{ "type",				TOK_AUTOINT(CivilianGenerator, type, 0), EAICivilianTypeEnum },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CivilianGenerator()
{
	int iSize = sizeof(CivilianGenerator);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CivilianGenerator, iSize, "CivilianGenerator", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CivilianPathBox
#define TYPE_parse_CivilianPathBox CivilianPathBox
ParseTable parse_CivilianPathBox[] =
{
	{ "CivilianPathBox", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CivilianPathBox), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "local_min",			TOK_VEC3(CivilianPathBox, local_min), NULL },
	{ "local_max",			TOK_VEC3(CivilianPathBox, local_max), NULL },
	{ "rot_world_mat",		TOK_MAT4PYR_ROT(CivilianPathBox, world_mat), NULL },
	{ "pos_world_mat",		TOK_MAT4PYR_POS(CivilianPathBox, world_mat), NULL },
	{ "person",				TOK_BIT, 0, 8, NULL},
	{ "car",				TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_CivilianPathBox()
{
	int iSize = sizeof(CivilianPathBox);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CivilianPathBox, iSize, "CivilianPathBox", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(CivilianPathBox) + 7) / 4;
		CivilianPathBox *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->person = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CivilianPathBox[6]);
		pTemp->person = 0;
		pTemp->car = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CivilianPathBox[7]);
		pTemp->car = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AICivilianPathMapInfo
#define TYPE_parse_AICivilianPathMapInfo AICivilianPathMapInfo
ParseTable parse_AICivilianPathMapInfo[] =
{
	{ "AICivilianPathMapInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivilianPathMapInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "mapCRC",					TOK_AUTOINT(AICivilianPathMapInfo, mapCRC, 0), NULL },
	{ "procVersion",			TOK_AUTOINT(AICivilianPathMapInfo, procVersion, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivilianPathMapInfo()
{
	int iSize = sizeof(AICivilianPathMapInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivilianPathMapInfo, iSize, "AICivilianPathMapInfo", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AICivEmoteReactInfo
#define TYPE_parse_AICivEmoteReactInfo AICivEmoteReactInfo
ParseTable parse_AICivEmoteReactInfo[] =
{
	{ "AICivEmoteReactInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivEmoteReactInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "EmoteName",				TOK_POOL_STRING | TOK_STRING(AICivEmoteReactInfo, pszEmoteName, 0), NULL },
	{ "FSM",					TOK_POOL_STRING | TOK_STRING(AICivEmoteReactInfo, pszFsm, 0), NULL },
	{ "AnimReactions",			TOK_POOL_STRING | TOK_STRINGARRAY(AICivEmoteReactInfo, eaAnimReactions), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivEmoteReactInfo()
{
	int iSize = sizeof(AICivEmoteReactInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivEmoteReactInfo, iSize, "AICivEmoteReactInfo", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AICivEmoteReactInfo[];
#define TYPE_parse_AICivEmoteReactInfo AICivEmoteReactInfo
//Structparser.exe autogenerated ParseTable for struct AICivEmoteReactDef
#define TYPE_parse_AICivEmoteReactDef AICivEmoteReactDef
ParseTable parse_AICivEmoteReactDef[] =
{
	{ "AICivEmoteReactDef", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivEmoteReactDef), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "DefaultFSM",				TOK_POOL_STRING | TOK_STRING(AICivEmoteReactDef, pszDefaultFsm, 0), NULL },
	{ "DefaultAnimReactions",	TOK_POOL_STRING | TOK_STRINGARRAY(AICivEmoteReactDef, eaDefaultAnimReactions), NULL },
	{ "EmoteReaction",			TOK_STRUCT(AICivEmoteReactDef, eaEmoteReaction, parse_AICivEmoteReactInfo) },
	{ "Radius",					TOK_F32(AICivEmoteReactDef, fRadius, 20), NULL },
	{ "MaxCivsToReact",			TOK_AUTOINT(AICivEmoteReactDef, iMaxCivsToReact, 1), NULL },
	{ "UseSelectedCivOnly",		TOK_AUTOINT(AICivEmoteReactDef, bUseSelectedCivOnly, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivEmoteReactDef()
{
	int iSize = sizeof(AICivEmoteReactDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivEmoteReactDef, iSize, "AICivEmoteReactDef", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_AICivEmoteReactDef[5].param = GET_INTPTR_FROM_FLOAT((float)20);
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIPedestrianOnClickInfo
#define TYPE_parse_AIPedestrianOnClickInfo AIPedestrianOnClickInfo
ParseTable parse_AIPedestrianOnClickInfo[] =
{
	{ "AIPedestrianOnClickInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIPedestrianOnClickInfo), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "FSM",						TOK_POOL_STRING | TOK_STRING(AIPedestrianOnClickInfo, pchFsm, 0), NULL },
	{ "weight",						TOK_AUTOINT(AIPedestrianOnClickInfo, weight, 1), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIPedestrianOnClickInfo()
{
	int iSize = sizeof(AIPedestrianOnClickInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIPedestrianOnClickInfo, iSize, "AIPedestrianOnClickInfo", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIPedestrianOnClickInfo[];
#define TYPE_parse_AIPedestrianOnClickInfo AIPedestrianOnClickInfo
//Structparser.exe autogenerated ParseTable for struct AIPedestrianOnClickDef
#define TYPE_parse_AIPedestrianOnClickDef AIPedestrianOnClickDef
ParseTable parse_AIPedestrianOnClickDef[] =
{
	{ "AIPedestrianOnClickDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIPedestrianOnClickDef), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "OnClickInfo",			TOK_STRUCT(AIPedestrianOnClickDef, eaOnClickInfo, parse_AIPedestrianOnClickInfo) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIPedestrianOnClickDef()
{
	int iSize = sizeof(AIPedestrianOnClickDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIPedestrianOnClickDef, iSize, "AIPedestrianOnClickDef", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AICivilianDef
#define TYPE_parse_AICivilianDef AICivilianDef
ParseTable parse_AICivilianDef[] =
{
	{ "AICivilianDef", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivilianDef), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "CivilianDefName",	TOK_POOL_STRING | TOK_STRING(AICivilianDef, pchCivDefName, 0), NULL },
	{ "CritterDef",			TOK_POOL_STRING | TOK_STRING(AICivilianDef, pchCritterDef, 0), NULL },
	{ "MinimumSpeed",		TOK_F32(AICivilianDef, fSpeedMin, 5), NULL },
	{ "SpeedRange",			TOK_F32(AICivilianDef, fSpeedRange, 5.6), NULL },
	{ "SpawnChanceWeight",	TOK_AUTOINT(AICivilianDef, iSpawnChanceWeight, 1), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivilianDef()
{
	int iSize = sizeof(AICivilianDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivilianDef, iSize, "AICivilianDef", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_AICivilianDef[4].param = GET_INTPTR_FROM_FLOAT((float)5);
	parse_AICivilianDef[5].param = GET_INTPTR_FROM_FLOAT((float)5.6);
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AICivPedestrianScaredParams
#define TYPE_parse_AICivPedestrianScaredParams AICivPedestrianScaredParams
ParseTable parse_AICivPedestrianScaredParams[] =
{
	{ "AICivPedestrianScaredParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivPedestrianScaredParams), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "PedestrainScaredMessage",		TOK_POOL_STRING | TOK_STRING(AICivPedestrianScaredParams, pchScaredPedestrianMessage, 0), NULL },
	{ "ScaredTime",						TOK_F32(AICivPedestrianScaredParams, fScaredTime, 14), NULL },
	{ "RescareTime",					TOK_F32(AICivPedestrianScaredParams, fRescareTime, 20), NULL },
	{ "CowerChance",					TOK_F32(AICivPedestrianScaredParams, fCowerChance, 0.25), NULL },
	{ "CowerTime",						TOK_F32(AICivPedestrianScaredParams, fCowerTime, 4), NULL },
	{ "MessageChance",					TOK_F32(AICivPedestrianScaredParams, fMessageChance, 0.6), NULL },
	{ "MinimumSpeed",					TOK_F32(AICivPedestrianScaredParams, fMinimumSpeed, 13), NULL },
	{ "SpeedRange",						TOK_F32(AICivPedestrianScaredParams, fSpeedRange, 3), NULL },
	{ "ScaredHeight",					TOK_F32(AICivPedestrianScaredParams, fScaredHeight, 15.f), NULL },
	{ "UseCritterSpeed",				TOK_BIT, 0, 8, NULL},
	{ "ExprBlockOnScared",				TOK_OPTIONALLATEBINDSTRUCT(AICivPedestrianScaredParams, pExprOnScared) },
	{ "ExprOnScared",					TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AICivPedestrianScaredParams, pExprOnScared) },
	{ "usedFields",						TOK_USEDFIELD | TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(AICivPedestrianScaredParams, usedFields), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AICivPedestrianScaredParams()
{
	int iSize = sizeof(AICivPedestrianScaredParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivPedestrianScaredParams, iSize, "AICivPedestrianScaredParams", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AICivPedestrianScaredParams) + 7) / 4;
		AICivPedestrianScaredParams *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bUseCritterSpeed = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivPedestrianScaredParams[11]);
		pTemp->bUseCritterSpeed = 0;
	}
	parse_AICivPedestrianScaredParams[3].param = GET_INTPTR_FROM_FLOAT((float)14);
	parse_AICivPedestrianScaredParams[4].param = GET_INTPTR_FROM_FLOAT((float)20);
	parse_AICivPedestrianScaredParams[5].param = GET_INTPTR_FROM_FLOAT((float)0.25);
	parse_AICivPedestrianScaredParams[6].param = GET_INTPTR_FROM_FLOAT((float)4);
	parse_AICivPedestrianScaredParams[7].param = GET_INTPTR_FROM_FLOAT((float)0.6);
	parse_AICivPedestrianScaredParams[8].param = GET_INTPTR_FROM_FLOAT((float)13);
	parse_AICivPedestrianScaredParams[9].param = GET_INTPTR_FROM_FLOAT((float)3);
	parse_AICivPedestrianScaredParams[10].param = GET_INTPTR_FROM_FLOAT((float)15.f);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_AICivPedestrianScaredParams(void)
{
	DoAutoStructLateBind(parse_AICivPedestrianScaredParams, 12, "Expression");
	DoAutoStructLateBind(parse_AICivPedestrianScaredParams, 13, "Expression_StructParam");
}
//autogeneratednocheckin
extern ParseTable parse_AIPedestrianOnClickDef[];
#define TYPE_parse_AIPedestrianOnClickDef AIPedestrianOnClickDef
//Structparser.exe autogenerated ParseTable for struct AICivPedestrianDef
#define TYPE_parse_AICivPedestrianDef AICivPedestrianDef
ParseTable parse_AICivPedestrianDef[] =
{
	{ "AICivPedestrianDef", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivPedestrianDef), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "base", 						TOK_IGNORE | TOK_FLATEMBED },
	{ "CivilianDefName",			TOK_POOL_STRING | TOK_STRING(AICivPedestrianDef, base.pchCivDefName, 0), NULL },
	{ "CritterDef",					TOK_POOL_STRING | TOK_STRING(AICivPedestrianDef, base.pchCritterDef, 0), NULL },
	{ "MinimumSpeed",				TOK_F32(AICivPedestrianDef, base.fSpeedMin, 5), NULL },
	{ "SpeedRange",					TOK_F32(AICivPedestrianDef, base.fSpeedRange, 5.6), NULL },
	{ "SpawnChanceWeight",			TOK_AUTOINT(AICivPedestrianDef, base.iSpawnChanceWeight, 1), NULL },
	{ "FearBehaviorFSMOverride",	TOK_POOL_STRING | TOK_STRING(AICivPedestrianDef, pchFearBehaviorFSMOverride, 0), NULL },
	{ "AnimListDefault",			TOK_POOL_STRING | TOK_STRING(AICivPedestrianDef, pchAnimListDefault, 0), NULL },
	{ "PedestrianChatterMessage",	TOK_POOL_STRING | TOK_STRING(AICivPedestrianDef, pchPedestrianChatterMessage, 0), NULL },
	{ "ExprBlockOnScared",			TOK_OPTIONALLATEBINDSTRUCT(AICivPedestrianDef, pExprOnScared) },
	{ "ExprOnScared",				TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AICivPedestrianDef, pExprOnScared) },
	{ "onClick",					TOK_EMBEDDEDSTRUCT(AICivPedestrianDef, onClick, parse_AIPedestrianOnClickDef)},
	{ "usedFields",					TOK_USEDFIELD | TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(AICivPedestrianDef, usedFields), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivPedestrianDef()
{
	int iSize = sizeof(AICivPedestrianDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivPedestrianDef, iSize, "AICivPedestrianDef", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_AICivPedestrianDef[5].param = GET_INTPTR_FROM_FLOAT((float)5);
	parse_AICivPedestrianDef[6].param = GET_INTPTR_FROM_FLOAT((float)5.6);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_AICivPedestrianDef(void)
{
	DoAutoStructLateBind(parse_AICivPedestrianDef, 11, "Expression");
	DoAutoStructLateBind(parse_AICivPedestrianDef, 12, "Expression_StructParam");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AICivPedestrianPOIParams
#define TYPE_parse_AICivPedestrianPOIParams AICivPedestrianPOIParams
ParseTable parse_AICivPedestrianPOIParams[] =
{
	{ "AICivPedestrianPOIParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivPedestrianPOIParams), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "AmbientAnimDuration",		TOK_F32(AICivPedestrianPOIParams, fAmbientAnimDuration, 0), NULL },
	{ "AmbientJobCooldownTime",		TOK_F32(AICivPedestrianPOIParams, fAmbientJobCooldownTime, 20.f), NULL },
	{ "AmbientJobCalloutRange",		TOK_F32(AICivPedestrianPOIParams, fAmbientJobCalloutRange, 40.f), NULL },
	{ "AmbientJobCheckLineOfSight",	TOK_AUTOINT(AICivPedestrianPOIParams, bAmbientJobCheckLineOfSight, 1), NULL },
	{ "usedFields",					TOK_USEDFIELD | TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(AICivPedestrianPOIParams, usedFields), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivPedestrianPOIParams()
{
	int iSize = sizeof(AICivPedestrianPOIParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivPedestrianPOIParams, iSize, "AICivPedestrianPOIParams", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_AICivPedestrianPOIParams[3].param = GET_INTPTR_FROM_FLOAT((float)20.f);
	parse_AICivPedestrianPOIParams[4].param = GET_INTPTR_FROM_FLOAT((float)40.f);
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AICivPedestrianWanderParams
#define TYPE_parse_AICivPedestrianWanderParams AICivPedestrianWanderParams
ParseTable parse_AICivPedestrianWanderParams[] =
{
	{ "AICivPedestrianWanderParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivPedestrianWanderParams), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "WanderTimeMin",					TOK_F32(AICivPedestrianWanderParams, fWanderTimeMin, 20.f), NULL },
	{ "WanderTimeRange",				TOK_F32(AICivPedestrianWanderParams, fWanderTimeRange, 10.f), NULL },
	{ "TimeAtPointAvg",					TOK_F32(AICivPedestrianWanderParams, fTimeAtPointAvg, 3.f), NULL },
	{ "usedFields",						TOK_USEDFIELD | TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(AICivPedestrianWanderParams, usedFields), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivPedestrianWanderParams()
{
	int iSize = sizeof(AICivPedestrianWanderParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivPedestrianWanderParams, iSize, "AICivPedestrianWanderParams", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_AICivPedestrianWanderParams[2].param = GET_INTPTR_FROM_FLOAT((float)20.f);
	parse_AICivPedestrianWanderParams[3].param = GET_INTPTR_FROM_FLOAT((float)10.f);
	parse_AICivPedestrianWanderParams[4].param = GET_INTPTR_FROM_FLOAT((float)3.f);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AICivPedestrianDef[];
#define TYPE_parse_AICivPedestrianDef AICivPedestrianDef
extern ParseTable parse_AICivPedestrianScaredParams[];
#define TYPE_parse_AICivPedestrianScaredParams AICivPedestrianScaredParams
extern ParseTable parse_AICivPedestrianPOIParams[];
#define TYPE_parse_AICivPedestrianPOIParams AICivPedestrianPOIParams
extern ParseTable parse_AICivPedestrianWanderParams[];
#define TYPE_parse_AICivPedestrianWanderParams AICivPedestrianWanderParams
extern ParseTable parse_AICivEmoteReactDef[];
#define TYPE_parse_AICivEmoteReactDef AICivEmoteReactDef
extern ParseTable parse_AIPedestrianOnClickDef[];
#define TYPE_parse_AIPedestrianOnClickDef AIPedestrianOnClickDef
//Structparser.exe autogenerated ParseTable for struct AICivPedestrianTypeDef
#define TYPE_parse_AICivPedestrianTypeDef AICivPedestrianTypeDef
ParseTable parse_AICivPedestrianTypeDef[] =
{
	{ "AICivPedestrianTypeDef", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivPedestrianTypeDef), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "CivDef",						TOK_STRUCT(AICivPedestrianTypeDef, eaCivDefs, parse_AICivPedestrianDef) },
	{ "scaredParams",				TOK_EMBEDDEDSTRUCT(AICivPedestrianTypeDef, scaredParams, parse_AICivPedestrianScaredParams)},
	{ "POIParams",					TOK_EMBEDDEDSTRUCT(AICivPedestrianTypeDef, POIParams, parse_AICivPedestrianPOIParams)},
	{ "wanderParams",				TOK_EMBEDDEDSTRUCT(AICivPedestrianTypeDef, wanderParams, parse_AICivPedestrianWanderParams)},
	{ "emoteReaction",				TOK_OPTIONALSTRUCT(AICivPedestrianTypeDef, emoteReaction, parse_AICivEmoteReactDef) },
	{ "onClick",					TOK_OPTIONALSTRUCT(AICivPedestrianTypeDef, onClick, parse_AIPedestrianOnClickDef) },
	{ "PedestrianChatterMessage",	TOK_POOL_STRING | TOK_STRING(AICivPedestrianTypeDef, pchPedestrianChatterMessage, 0), NULL },
	{ "PlayerKillCritterFSM",		TOK_POOL_STRING | TOK_STRING(AICivPedestrianTypeDef, pchPlayerKillCritterFSM, 0), NULL },
	{ "UseStrictDistribution",		TOK_AUTOINT(AICivPedestrianTypeDef, bUseStrictDistribution, 0), NULL },
	{ "usedFields",					TOK_USEDFIELD | TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(AICivPedestrianTypeDef, usedFields), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivPedestrianTypeDef()
{
	int iSize = sizeof(AICivPedestrianTypeDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivPedestrianTypeDef, iSize, "AICivPedestrianTypeDef", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AICivilianDef[];
#define TYPE_parse_AICivilianDef AICivilianDef
//Structparser.exe autogenerated ParseTable for struct AICivVehicleTypeDef
#define TYPE_parse_AICivVehicleTypeDef AICivVehicleTypeDef
ParseTable parse_AICivVehicleTypeDef[] =
{
	{ "AICivVehicleTypeDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivVehicleTypeDef), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "CivDef",					TOK_STRUCT(AICivVehicleTypeDef, eaCivDefs, parse_AICivilianDef) },
	{ "CarHonkSoundName",		TOK_POOL_STRING | TOK_STRING(AICivVehicleTypeDef, pchCarHonkSoundName, 0), NULL },
	{ "usedFields",				TOK_USEDFIELD | TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(AICivVehicleTypeDef, usedFields), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivVehicleTypeDef()
{
	int iSize = sizeof(AICivVehicleTypeDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivVehicleTypeDef, iSize, "AICivVehicleTypeDef", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AICivLegDef
#define TYPE_parse_AICivLegDef AICivLegDef
ParseTable parse_AICivLegDef[] =
{
	{ "AICivLegDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivLegDef), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Name",			TOK_POOL_STRING | TOK_REQUIRED | TOK_STRING(AICivLegDef, pchName, 0), NULL },
	{ "LegUseChance",	TOK_F32(AICivLegDef, fLegUseChance, 1), NULL },
	{ "usedFields",		TOK_USEDFIELD | TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(AICivLegDef, usedFields), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivLegDef()
{
	int iSize = sizeof(AICivLegDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivLegDef, iSize, "AICivLegDef", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_AICivLegDef[3].param = GET_INTPTR_FROM_FLOAT((float)1);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AICivLegDef[];
#define TYPE_parse_AICivLegDef AICivLegDef
//Structparser.exe autogenerated ParseTable for struct AICivMapDefLegInfo
#define TYPE_parse_AICivMapDefLegInfo AICivMapDefLegInfo
ParseTable parse_AICivMapDefLegInfo[] =
{
	{ "AICivMapDefLegInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivMapDefLegInfo), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "LegDef",				TOK_STRUCT(AICivMapDefLegInfo, eaLegDef, parse_AICivLegDef) },
	{ "usedFields",			TOK_USEDFIELD | TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(AICivMapDefLegInfo, usedFields), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivMapDefLegInfo()
{
	int iSize = sizeof(AICivMapDefLegInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivMapDefLegInfo, iSize, "AICivMapDefLegInfo", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AICivPedestrianTypeDef[];
#define TYPE_parse_AICivPedestrianTypeDef AICivPedestrianTypeDef
extern ParseTable parse_AICivVehicleTypeDef[];
#define TYPE_parse_AICivVehicleTypeDef AICivVehicleTypeDef
extern ParseTable parse_AICivVehicleTypeDef[];
#define TYPE_parse_AICivVehicleTypeDef AICivVehicleTypeDef
extern ParseTable parse_AICivMapDefLegInfo[];
#define TYPE_parse_AICivMapDefLegInfo AICivMapDefLegInfo
//Structparser.exe autogenerated ParseTable for struct AICivilianMapDef
#define TYPE_parse_AICivilianMapDef AICivilianMapDef
ParseTable parse_AICivilianMapDef[] =
{
	{ "AICivilianMapDef", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivilianMapDef), 0, NULL, 0, NULL },
	{ "{",									TOK_START, 0 },
	{ "Name",								TOK_KEY | TOK_STRING(AICivilianMapDef, pchName, 0), NULL },
	{ "inheritConfigs",						TOK_INHERITANCE_STRUCT | TOK_STRINGARRAY(AICivilianMapDef, inheritConfigs), NULL },
	{ "InheritConfig",						TOK_REDUNDANTNAME | TOK_INHERITANCE_STRUCT | TOK_STRINGARRAY(AICivilianMapDef, inheritConfigs), NULL },
	{ "pedestrian",							TOK_EMBEDDEDSTRUCT(AICivilianMapDef, pedestrian, parse_AICivPedestrianTypeDef)},
	{ "npc",								TOK_REDUNDANTNAME | TOK_EMBEDDEDSTRUCT(AICivilianMapDef, pedestrian, parse_AICivPedestrianTypeDef)},
	{ "car",								TOK_EMBEDDEDSTRUCT(AICivilianMapDef, car, parse_AICivVehicleTypeDef)},
	{ "trolley",							TOK_EMBEDDEDSTRUCT(AICivilianMapDef, trolley, parse_AICivVehicleTypeDef)},
	{ "leg",								TOK_EMBEDDEDSTRUCT(AICivilianMapDef, legInfo, parse_AICivMapDefLegInfo)},
	{ "npcs",								TOK_AUTOINT(AICivilianMapDef, desired[0], 0), NULL },
	{ "cars",								TOK_AUTOINT(AICivilianMapDef, desired[1], 0), NULL },
	{ "trolleys",							TOK_AUTOINT(AICivilianMapDef, desired[2], 0), NULL },
	{ "unitsPerNPC",						TOK_AUTOINT(AICivilianMapDef, desiredUnitsPerType[0], 0), NULL },
	{ "unitsPerCar",						TOK_AUTOINT(AICivilianMapDef, desiredUnitsPerType[1], 0), NULL },
	{ "unitsPerTrolley",					TOK_AUTOINT(AICivilianMapDef, desiredUnitsPerType[2], 0), NULL },
	{ "carLaneWidth",						TOK_F32(AICivilianMapDef, carLaneWidth, 20), NULL },
	{ "PedestrianFaction",					TOK_POOL_STRING | TOK_STRING(AICivilianMapDef, pszPedestrianFaction, 0), NULL },
	{ "EnableLegsWhenPlayerEntersRegion",	TOK_BIT, 0, 8, NULL},
	{ "Filename",							TOK_POOL_STRING | TOK_CURRENTFILE(AICivilianMapDef, pchFilename), NULL},
	{ "usedFields",							TOK_USEDFIELD | TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(AICivilianMapDef, usedFields), NULL },
	{ "}",									TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AICivilianMapDef()
{
	int iSize = sizeof(AICivilianMapDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivilianMapDef, iSize, "AICivilianMapDef", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AICivilianMapDef) + 7) / 4;
		AICivilianMapDef *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bEnableLegsWhenPlayerEntersRegion = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMapDef[18]);
		pTemp->bEnableLegsWhenPlayerEntersRegion = 0;
	}
	parse_AICivilianMapDef[16].param = GET_INTPTR_FROM_FLOAT((float)20);
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AICivilianWaypoint
#define TYPE_parse_AICivilianWaypoint AICivilianWaypoint
ParseTable parse_AICivilianWaypoint[] =
{
	{ "AICivilianWaypoint", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivilianWaypoint), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "pos",					TOK_VEC3(AICivilianWaypoint, pos), NULL },
	{ "medianDist",				TOK_F32(AICivilianWaypoint, medianDist, 0), NULL },
	{ "distFromLeg",			TOK_F32(AICivilianWaypoint, distFromLeg, 0), NULL },
	{ "lane",					TOK_AUTOINT(AICivilianWaypoint, lane, 0), NULL },
	{ "car_street_isect_type",	TOK_BIT, 0, 8, NULL},
	{ "car_move_type",			TOK_BIT, 0, 8, NULL},
	{ "IsLeg",					TOK_BIT, 0, 8, NULL},
	{ "IsUTurn",				TOK_BIT, 0, 8, NULL},
	{ "Reverse",				TOK_BIT, 0, 8, NULL},
	{ "Stop",					TOK_BIT, 0, 8, NULL},
	{ "WasStop",				TOK_BIT, 0, 8, NULL},
	{ "IsCrosswalk",			TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AICivilianWaypoint()
{
	int iSize = sizeof(AICivilianWaypoint);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivilianWaypoint, iSize, "AICivilianWaypoint", NULL, "aiCivilianPrivate.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AICivilianWaypoint) + 7) / 4;
		AICivilianWaypoint *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->car_street_isect_type = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianWaypoint[6]);
		pTemp->car_street_isect_type = 0;
		pTemp->car_move_type = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianWaypoint[7]);
		pTemp->car_move_type = 0;
		pTemp->bIsLeg = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianWaypoint[8]);
		pTemp->bIsLeg = 0;
		pTemp->bIsUTurn = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianWaypoint[9]);
		pTemp->bIsUTurn = 0;
		pTemp->bReverse = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianWaypoint[10]);
		pTemp->bReverse = 0;
		pTemp->bStop = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianWaypoint[11]);
		pTemp->bStop = 0;
		pTemp->bWasStop = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianWaypoint[12]);
		pTemp->bWasStop = 0;
		pTemp->bIsCrosswalk = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianWaypoint[13]);
		pTemp->bIsCrosswalk = 0;
	}
	return 0;
};
