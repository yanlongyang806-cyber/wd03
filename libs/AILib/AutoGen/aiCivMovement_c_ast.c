#include "textparser.h"
//autogeneratednocheckin
extern ParseTable parse_AICivilianWaypoint[];
#define TYPE_parse_AICivilianWaypoint AICivilianWaypoint
//Structparser.exe autogenerated ParseTable for struct AICivilianMovementToBG
#define TYPE_parse_AICivilianMovementToBG AICivilianMovementToBG
ParseTable parse_AICivilianMovementToBG[] =
{
	{ "AICivilianMovementToBG", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivilianMovementToBG), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "SpeedMinimum",				TOK_F32(AICivilianMovementToBG, fSpeedMinimum, 0), NULL },
	{ "SpeedRange",					TOK_F32(AICivilianMovementToBG, fSpeedRange, 0), NULL },
	{ "AddedWaypoints",				TOK_UNOWNED | TOK_STRUCT(AICivilianMovementToBG, eaAddedWaypoints, parse_AICivilianWaypoint) },
	{ "CivType",					TOK_AUTOINT(AICivilianMovementToBG, eCivType, 0), EAICivilianTypeEnum },
	{ "FinalRotation",				TOK_F32(AICivilianMovementToBG, fFinalRotation, 0), NULL },
	{ "CritterSpeedOverride",		TOK_F32(AICivilianMovementToBG, fCritterSpeedOverride, 0), NULL },
	{ "clearWaypointID",			TOK_AUTOINT(AICivilianMovementToBG, clearWaypointID, 0), NULL },
	{ "pause",						TOK_BIT, 0, 8, NULL},
	{ "DoCollision",				TOK_BIT, 0, 8, NULL},
	{ "UseFinalRotation",			TOK_BIT, 0, 8, NULL},
	{ "UseOverrideCritterSpeed",	TOK_BIT, 0, 8, NULL},
	{ "HasAddedWaypoints",			TOK_BIT, 0, 8, NULL},
	{ "UpdatedPause",				TOK_BIT, 0, 8, NULL},
	{ "UpdatedMovementOptions",		TOK_BIT, 0, 8, NULL},
	{ "UpdatedFinalRotation",		TOK_BIT, 0, 8, NULL},
	{ "Initialization",				TOK_BIT, 0, 8, NULL},
	{ "SetCritterSpeed",			TOK_BIT, 0, 8, NULL},
	{ "UseCritterSpeedUpdated",		TOK_BIT, 0, 8, NULL},
	{ "Disable",					TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AICivilianMovementToBG()
{
	int iSize = sizeof(AICivilianMovementToBG);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivilianMovementToBG, iSize, "AICivilianMovementToBG", NULL, "aiCivMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AICivilianMovementToBG) + 7) / 4;
		AICivilianMovementToBG *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->pause = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementToBG[9]);
		pTemp->pause = 0;
		pTemp->bDoCollision = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementToBG[10]);
		pTemp->bDoCollision = 0;
		pTemp->bUseFinalRotation = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementToBG[11]);
		pTemp->bUseFinalRotation = 0;
		pTemp->bUseOverrideCritterSpeed = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementToBG[12]);
		pTemp->bUseOverrideCritterSpeed = 0;
		pTemp->bHasAddedWaypoints = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementToBG[13]);
		pTemp->bHasAddedWaypoints = 0;
		pTemp->bUpdatedPause = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementToBG[14]);
		pTemp->bUpdatedPause = 0;
		pTemp->bUpdatedMovementOptions = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementToBG[15]);
		pTemp->bUpdatedMovementOptions = 0;
		pTemp->bUpdatedFinalRotation = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementToBG[16]);
		pTemp->bUpdatedFinalRotation = 0;
		pTemp->bInitialization = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementToBG[17]);
		pTemp->bInitialization = 0;
		pTemp->bSetCritterSpeed = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementToBG[18]);
		pTemp->bSetCritterSpeed = 0;
		pTemp->bUseCritterSpeedUpdated = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementToBG[19]);
		pTemp->bUseCritterSpeedUpdated = 0;
		pTemp->bDisable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementToBG[20]);
		pTemp->bDisable = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AICivilianMovementToFG
#define TYPE_parse_AICivilianMovementToFG AICivilianMovementToFG
ParseTable parse_AICivilianMovementToFG[] =
{
	{ "AICivilianMovementToFG", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivilianMovementToFG), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "numReachedWp",			TOK_AUTOINT(AICivilianMovementToFG, numReachedWp, 0), NULL },
	{ "releasedWaypointsID",	TOK_AUTOINT(AICivilianMovementToFG, releasedWaypointsID, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivilianMovementToFG()
{
	int iSize = sizeof(AICivilianMovementToFG);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivilianMovementToFG, iSize, "AICivilianMovementToFG", NULL, "aiCivMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AICivilianMovementToBG[];
#define TYPE_parse_AICivilianMovementToBG AICivilianMovementToBG
extern ParseTable parse_AICivilianMovementToFG[];
#define TYPE_parse_AICivilianMovementToFG AICivilianMovementToFG
//Structparser.exe autogenerated ParseTable for struct AICivilianMovementFG
#define TYPE_parse_AICivilianMovementFG AICivilianMovementFG
ParseTable parse_AICivilianMovementFG[] =
{
	{ "AICivilianMovementFG", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivilianMovementFG), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "toBG",					TOK_EMBEDDEDSTRUCT(AICivilianMovementFG, toBG, parse_AICivilianMovementToBG)},
	{ "toFG",					TOK_EMBEDDEDSTRUCT(AICivilianMovementFG, toFG, parse_AICivilianMovementToFG)},
	{ "spcClearedWaypoints",	TOK_AUTOINT(AICivilianMovementFG, spcClearedWaypoints, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivilianMovementFG()
{
	int iSize = sizeof(AICivilianMovementFG);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivilianMovementFG, iSize, "AICivilianMovementFG", NULL, "aiCivMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AICivilianMovementToBG[];
#define TYPE_parse_AICivilianMovementToBG AICivilianMovementToBG
extern ParseTable parse_AICivilianMovementToFG[];
#define TYPE_parse_AICivilianMovementToFG AICivilianMovementToFG
extern ParseTable parse_AICivilianWaypoint[];
#define TYPE_parse_AICivilianWaypoint AICivilianWaypoint
//Structparser.exe autogenerated ParseTable for struct AICivilianMovementBG
#define TYPE_parse_AICivilianMovementBG AICivilianMovementBG
ParseTable parse_AICivilianMovementBG[] =
{
	{ "AICivilianMovementBG", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivilianMovementBG), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "toBG",					TOK_EMBEDDEDSTRUCT(AICivilianMovementBG, toBG, parse_AICivilianMovementToBG)},
	{ "toFG",					TOK_EMBEDDEDSTRUCT(AICivilianMovementBG, toFG, parse_AICivilianMovementToFG)},
	{ "CurveWp",				TOK_VEC3(AICivilianMovementBG, vCurveWp), NULL },
	{ "qLastRot",				TOK_QUATPYR(AICivilianMovementBG, qLastRot), NULL },
	{ "MoveDir",				TOK_VEC3(AICivilianMovementBG, vMoveDir), NULL },
	{ "MoveDirLast",			TOK_VEC3(AICivilianMovementBG, vMoveDirLast), NULL },
	{ "Normal",					TOK_VEC3(AICivilianMovementBG, vNormal), NULL },
	{ "NormalLast",				TOK_VEC3(AICivilianMovementBG, vNormalLast), NULL },
	{ "forcedTurnCountdown",	TOK_AUTOINT(AICivilianMovementBG, forcedTurnCountdown, 0), NULL },
	{ "rot_avCurveControlPoints",TOK_MAT4PYR_ROT(AICivilianMovementBG, avCurveControlPoints), NULL },
	{ "pos_avCurveControlPoints",TOK_MAT4PYR_POS(AICivilianMovementBG, avCurveControlPoints), NULL },
	{ "CurCurveT",				TOK_F32(AICivilianMovementBG, fCurCurveT, 0), NULL },
	{ "numWaypointsInCurve",	TOK_AUTOINT(AICivilianMovementBG, numWaypointsInCurve, 0), NULL },
	{ "Waypoints",				TOK_UNOWNED | TOK_STRUCT(AICivilianMovementBG, eaWaypoints, parse_AICivilianWaypoint) },
	{ "curWpIdx",				TOK_AUTOINT(AICivilianMovementBG, curWpIdx, 0), NULL },
	{ "CurSpeed",				TOK_F32(AICivilianMovementBG, fCurSpeed, 0), NULL },
	{ "CurDesiredSpeed",		TOK_F32(AICivilianMovementBG, fCurDesiredSpeed, 0), NULL },
	{ "CurFacing",				TOK_F32(AICivilianMovementBG, fCurFacing, 0), NULL },
	{ "LastFacingDiff",			TOK_F32(AICivilianMovementBG, fLastFacingDiff, 0), NULL },
	{ "timeLastRaycast",		TOK_AUTOINT(AICivilianMovementBG, timeLastRaycast, 0), NULL },
	{ "timeLastSpeedVar",		TOK_AUTOINT(AICivilianMovementBG, timeLastSpeedVar, 0), NULL },
	{ "InterpToGroundDist",		TOK_F32(AICivilianMovementBG, fInterpToGroundDist, 0), NULL },
	{ "stanceHandle",			TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(AICivilianMovementBG, stanceHandle), NULL },
	{ "handlesRotationChange",	TOK_BIT, 0, 8, NULL},
	{ "speedMinimumNearZero",	TOK_BIT, 0, 8, NULL},
	{ "speedNearZero",			TOK_BIT, 0, 8, NULL},
	{ "CurWpIsGroundAligned",	TOK_BIT, 0, 8, NULL},
	{ "CheckGroundAlignment",	TOK_BIT, 0, 8, NULL},
	{ "CurWpIsCurve",			TOK_BIT, 0, 8, NULL},
	{ "SkippedMovement",		TOK_BIT, 0, 8, NULL},
	{ "hasStanceMask",			TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AICivilianMovementBG()
{
	int iSize = sizeof(AICivilianMovementBG);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivilianMovementBG, iSize, "AICivilianMovementBG", NULL, "aiCivMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AICivilianMovementBG) + 7) / 4;
		AICivilianMovementBG *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->handlesRotationChange = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementBG[25]);
		pTemp->handlesRotationChange = 0;
		pTemp->speedMinimumNearZero = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementBG[26]);
		pTemp->speedMinimumNearZero = 0;
		pTemp->speedNearZero = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementBG[27]);
		pTemp->speedNearZero = 0;
		pTemp->bCurWpIsGroundAligned = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementBG[28]);
		pTemp->bCurWpIsGroundAligned = 0;
		pTemp->bCheckGroundAlignment = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementBG[29]);
		pTemp->bCheckGroundAlignment = 0;
		pTemp->bCurWpIsCurve = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementBG[30]);
		pTemp->bCurWpIsCurve = 0;
		pTemp->bSkippedMovement = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementBG[31]);
		pTemp->bSkippedMovement = 0;
		pTemp->hasStanceMask = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AICivilianMovementBG[32]);
		pTemp->hasStanceMask = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AICivilianMovementLocalBG
#define TYPE_parse_AICivilianMovementLocalBG AICivilianMovementLocalBG
ParseTable parse_AICivilianMovementLocalBG[] =
{
	{ "AICivilianMovementLocalBG", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivilianMovementLocalBG), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "unused",						TOK_AUTOINT(AICivilianMovementLocalBG, unused, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivilianMovementLocalBG()
{
	int iSize = sizeof(AICivilianMovementLocalBG);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivilianMovementLocalBG, iSize, "AICivilianMovementLocalBG", NULL, "aiCivMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AICivilianMovementSync
#define TYPE_parse_AICivilianMovementSync AICivilianMovementSync
ParseTable parse_AICivilianMovementSync[] =
{
	{ "AICivilianMovementSync", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AICivilianMovementSync), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "unused",					TOK_AUTOINT(AICivilianMovementSync, unused, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AICivilianMovementSync()
{
	int iSize = sizeof(AICivilianMovementSync);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AICivilianMovementSync, iSize, "AICivilianMovementSync", NULL, "aiCivMovement.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
