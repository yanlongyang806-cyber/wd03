#include "textparser.h"
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIMMExposureLevelDef
#define TYPE_parse_AIMMExposureLevelDef AIMMExposureLevelDef
ParseTable parse_AIMMExposureLevelDef[] =
{
	{ "AIMMExposureLevelDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMMExposureLevelDef), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "SpawnCooldown",			TOK_F32(AIMMExposureLevelDef, fSpawnCooldown, 10), NULL },
	{ "NumEncounters",			TOK_AUTOINT(AIMMExposureLevelDef, iNumEncounters, 0), NULL },
	{ "AllowedTiersMin",		TOK_AUTOINT(AIMMExposureLevelDef, iAllowedTiersMin, 0), NULL },
	{ "AllowedTiersMax",		TOK_AUTOINT(AIMMExposureLevelDef, iAllowedTiersMax, 0), NULL },
	{ "ExposureRange",			TOK_F32(AIMMExposureLevelDef, fExposureRange, 20), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIMMExposureLevelDef()
{
	int iSize = sizeof(AIMMExposureLevelDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMMExposureLevelDef, iSize, "AIMMExposureLevelDef", NULL, "aiMastermind.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_AIMMExposureLevelDef[2].param = GET_INTPTR_FROM_FLOAT((float)10);
	parse_AIMMExposureLevelDef[6].param = GET_INTPTR_FROM_FLOAT((float)20);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIMMExposureLevelDef[];
#define TYPE_parse_AIMMExposureLevelDef AIMMExposureLevelDef
//Structparser.exe autogenerated ParseTable for struct AIMastermindExposeDef
#define TYPE_parse_AIMastermindExposeDef AIMastermindExposeDef
ParseTable parse_AIMastermindExposeDef[] =
{
	{ "AIMastermindExposeDef", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMastermindExposeDef), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "EncounterTiers",					TOK_POOL_STRING | TOK_STRINGARRAY(AIMastermindExposeDef, eapcEncounterTiers), NULL },
	{ "ExposeLevel",					TOK_STRUCT(AIMastermindExposeDef, eaExposeLevels, parse_AIMMExposureLevelDef) },
	{ "SpawnSearchRadius",				TOK_F32(AIMastermindExposeDef, fSpawnSearchRadius, 150), NULL },
	{ "SpawnMinLockoutRadius",			TOK_F32(AIMastermindExposeDef, fSpawnMinLockoutRadius, 20), NULL },
	{ "PlayerPosUpdateFrequency",		TOK_F32(AIMastermindExposeDef, fPlayerPosUpdateFrequency, 5), NULL },
	{ "SentEncounterDespawnTimeout",	TOK_F32(AIMastermindExposeDef, fSentEncounterDespawnTimeout, 30), NULL },
	{ "ExposeAttribName",				TOK_POOL_STRING | TOK_STRING(AIMastermindExposeDef, pchExposeAttribName, 0), NULL },
	{ "UseLOSChecksByDefault",			TOK_AUTOINT(AIMastermindExposeDef, bUseLOSChecksByDefault, 0), NULL },
	{ "HiddenPowerMode",				TOK_POOL_STRING | TOK_STRING(AIMastermindExposeDef, pchHiddenPowerMode, 0), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIMastermindExposeDef()
{
	int iSize = sizeof(AIMastermindExposeDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMastermindExposeDef, iSize, "AIMastermindExposeDef", NULL, "aiMastermind.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_AIMastermindExposeDef[4].param = GET_INTPTR_FROM_FLOAT((float)150);
	parse_AIMastermindExposeDef[5].param = GET_INTPTR_FROM_FLOAT((float)20);
	parse_AIMastermindExposeDef[6].param = GET_INTPTR_FROM_FLOAT((float)5);
	parse_AIMastermindExposeDef[7].param = GET_INTPTR_FROM_FLOAT((float)30);
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIMMHeatExprCallbacks
#define TYPE_parse_AIMMHeatExprCallbacks AIMMHeatExprCallbacks
ParseTable parse_AIMMHeatExprCallbacks[] =
{
	{ "AIMMHeatExprCallbacks", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMMHeatExprCallbacks), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "OnPlayerDeath",			TOK_OPTIONALLATEBINDSTRUCT(AIMMHeatExprCallbacks, pExprOnPlayerDeath) },
	{ "ExprOnPlayerDeath",		TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AIMMHeatExprCallbacks, pExprOnPlayerDeath) },
	{ "OnWipe",					TOK_OPTIONALLATEBINDSTRUCT(AIMMHeatExprCallbacks, pExprOnWipe) },
	{ "ExprOnWipe",				TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AIMMHeatExprCallbacks, pExprOnWipe) },
	{ "PerTick",				TOK_OPTIONALLATEBINDSTRUCT(AIMMHeatExprCallbacks, pExprPerTick) },
	{ "ExprPerTick",			TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AIMMHeatExprCallbacks, pExprPerTick) },
	{ "CanSendWave",			TOK_OPTIONALLATEBINDSTRUCT(AIMMHeatExprCallbacks, pExprCanSendWave) },
	{ "ExprCanSendWave",		TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AIMMHeatExprCallbacks, pExprCanSendWave) },
	{ "ShouldForceWave",		TOK_OPTIONALLATEBINDSTRUCT(AIMMHeatExprCallbacks, pExprShouldForceWave) },
	{ "ExprShouldForceWave",	TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AIMMHeatExprCallbacks, pExprShouldForceWave) },
	{ "EnteredNewRoom",			TOK_OPTIONALLATEBINDSTRUCT(AIMMHeatExprCallbacks, pExprEnteredNewRoom) },
	{ "ExprEnteredNewRoom",		TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AIMMHeatExprCallbacks, pExprEnteredNewRoom) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIMMHeatExprCallbacks()
{
	int iSize = sizeof(AIMMHeatExprCallbacks);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMMHeatExprCallbacks, iSize, "AIMMHeatExprCallbacks", NULL, "aiMastermind.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_AIMMHeatExprCallbacks(void)
{
	DoAutoStructLateBind(parse_AIMMHeatExprCallbacks, 2, "Expression");
	DoAutoStructLateBind(parse_AIMMHeatExprCallbacks, 3, "Expression_StructParam");
	DoAutoStructLateBind(parse_AIMMHeatExprCallbacks, 4, "Expression");
	DoAutoStructLateBind(parse_AIMMHeatExprCallbacks, 5, "Expression_StructParam");
	DoAutoStructLateBind(parse_AIMMHeatExprCallbacks, 6, "Expression");
	DoAutoStructLateBind(parse_AIMMHeatExprCallbacks, 7, "Expression_StructParam");
	DoAutoStructLateBind(parse_AIMMHeatExprCallbacks, 8, "Expression");
	DoAutoStructLateBind(parse_AIMMHeatExprCallbacks, 9, "Expression_StructParam");
	DoAutoStructLateBind(parse_AIMMHeatExprCallbacks, 10, "Expression");
	DoAutoStructLateBind(parse_AIMMHeatExprCallbacks, 11, "Expression_StructParam");
	DoAutoStructLateBind(parse_AIMMHeatExprCallbacks, 12, "Expression");
	DoAutoStructLateBind(parse_AIMMHeatExprCallbacks, 13, "Expression_StructParam");
}
//autogeneratednocheckin
extern ParseTable parse_AIMMHeatExprCallbacks[];
#define TYPE_parse_AIMMHeatExprCallbacks AIMMHeatExprCallbacks
//Structparser.exe autogenerated ParseTable for struct AIMMHeatLevelDef
#define TYPE_parse_AIMMHeatLevelDef AIMMHeatLevelDef
ParseTable parse_AIMMHeatLevelDef[] =
{
	{ "AIMMHeatLevelDef", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMMHeatLevelDef), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "SpawnPeriod",				TOK_F32(AIMMHeatLevelDef, fSpawnPeriod, 10.f), NULL },
	{ "SpawnFailedResetTime",		TOK_F32(AIMMHeatLevelDef, fSpawnFailedResetTime, 10.f), NULL },
	{ "IdleTimeForceSpawn",			TOK_F32(AIMMHeatLevelDef, fIdleTimeForceSpawn, 0), NULL },
	{ "HealthPercentThreshold",		TOK_F32(AIMMHeatLevelDef, fHealthPercentThreshold, 0), NULL },
	{ "DifficultyValueThreshold",	TOK_F32(AIMMHeatLevelDef, fDifficultyValueThreshold, 1), NULL },
	{ "AllowedTiersMin",			TOK_AUTOINT(AIMMHeatLevelDef, iAllowedTiersMin, 0), NULL },
	{ "AllowedTiersMax",			TOK_AUTOINT(AIMMHeatLevelDef, iAllowedTiersMax, 0), NULL },
	{ "TierSpawnOrder",				TOK_INTARRAY(AIMMHeatLevelDef, eaiTierSpawnOrder),  NULL},
	{ "ExpressionCallbacks",		TOK_EMBEDDEDSTRUCT(AIMMHeatLevelDef, exprCallbacks, parse_AIMMHeatExprCallbacks)},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIMMHeatLevelDef()
{
	int iSize = sizeof(AIMMHeatLevelDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMMHeatLevelDef, iSize, "AIMMHeatLevelDef", NULL, "aiMastermind.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_AIMMHeatLevelDef[2].param = GET_INTPTR_FROM_FLOAT((float)10.f);
	parse_AIMMHeatLevelDef[3].param = GET_INTPTR_FROM_FLOAT((float)10.f);
	parse_AIMMHeatLevelDef[6].param = GET_INTPTR_FROM_FLOAT((float)1);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIMMHeatLevelDef[];
#define TYPE_parse_AIMMHeatLevelDef AIMMHeatLevelDef
extern ParseTable parse_AIMMHeatExprCallbacks[];
#define TYPE_parse_AIMMHeatExprCallbacks AIMMHeatExprCallbacks
//Structparser.exe autogenerated ParseTable for struct AIMMHeatDef
#define TYPE_parse_AIMMHeatDef AIMMHeatDef
ParseTable parse_AIMMHeatDef[] =
{
	{ "AIMMHeatDef", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMMHeatDef), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "EncounterTeirs",			TOK_POOL_STRING | TOK_STRINGARRAY(AIMMHeatDef, eapcEncounterTiers), NULL },
	{ "HeatLevel",				TOK_STRUCT(AIMMHeatDef, eaHeatLevels, parse_AIMMHeatLevelDef) },
	{ "ExpressionCallbacks",	TOK_EMBEDDEDSTRUCT(AIMMHeatDef, exprCallbacks, parse_AIMMHeatExprCallbacks)},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIMMHeatDef()
{
	int iSize = sizeof(AIMMHeatDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMMHeatDef, iSize, "AIMMHeatDef", NULL, "aiMastermind.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIConfigMod[];
#define TYPE_parse_AIConfigMod AIConfigMod
extern ParseTable parse_AIMMHeatDef[];
#define TYPE_parse_AIMMHeatDef AIMMHeatDef
extern ParseTable parse_AIMastermindExposeDef[];
#define TYPE_parse_AIMastermindExposeDef AIMastermindExposeDef
//Structparser.exe autogenerated ParseTable for struct AIMastermindDef
#define TYPE_parse_AIMastermindDef AIMastermindDef
ParseTable parse_AIMastermindDef[] =
{
	{ "AIMastermindDef", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMastermindDef), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "ConfigMod",					TOK_STRUCT(AIMastermindDef, configMods, parse_AIConfigMod) },
	{ "SentEncounterFSMOverride",	TOK_POOL_STRING | TOK_STRING(AIMastermindDef, pchSentEncounterFSMOverride, 0), NULL },
	{ "HeatDef",					TOK_OPTIONALSTRUCT(AIMastermindDef, pHeatDef, parse_AIMMHeatDef) },
	{ "ExposeDef",					TOK_OPTIONALSTRUCT(AIMastermindDef, pExposeDef, parse_AIMastermindExposeDef) },
	{ "Name",						TOK_STRUCTPARAM | TOK_KEY | TOK_STRING(AIMastermindDef, pchName, 0), NULL },
	{ "Filename",					TOK_POOL_STRING | TOK_CURRENTFILE(AIMastermindDef, pchFilename), NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIMastermindDef()
{
	int iSize = sizeof(AIMastermindDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMastermindDef, iSize, "AIMastermindDef", NULL, "aiMastermind.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
