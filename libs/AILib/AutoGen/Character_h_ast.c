#include "textparser.h"

//auto-generated staticdefine for enum CharacterTrainingType
//autogeneratednocheckin
StaticDefineInt CharacterTrainingTypeEnum[] =
{
	DEFINE_INT
	{ "Give", CharacterTrainingType_Give},
	{ "Replace", CharacterTrainingType_Replace},
	{ "ReplaceEscrow", CharacterTrainingType_ReplaceEscrow},
	DEFINE_END
};
void autoEnum_fixup_CharacterTrainingType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(CharacterTrainingTypeEnum, "CharacterTrainingType");
}

//auto-generated staticdefine for enum InnateAttribModSource
//autogeneratednocheckin
StaticDefineInt InnateAttribModSourceEnum[] =
{
	DEFINE_INT
	{ "None", InnateAttribModSource_None},
	{ "Power", InnateAttribModSource_Power},
	{ "Item", InnateAttribModSource_Item},
	{ "StatPoint", InnateAttribModSource_StatPoint},
	DEFINE_END
};
void autoEnum_fixup_InnateAttribModSource(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(InnateAttribModSourceEnum, "InnateAttribModSource");
}
//autogeneratednocheckin
extern ParseTable parse_Power[];
#define TYPE_parse_Power Power
//Structparser.exe autogenerated ParseTable for struct ModArray
#define TYPE_parse_ModArray ModArray
ParseTable parse_ModArray[] =
{
	{ "ModArray", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ModArray), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Mods",						TOK_LATEBINDSTRUCT(ModArray, ppMods) },
	{ "ppMods",						TOK_REDUNDANTNAME | TOK_LATEBINDSTRUCT(ModArray, ppMods) },
	{ "ppModsPending",				TOK_SERVER_ONLY | TOK_LATEBINDSTRUCT(ModArray, ppModsPending) },
	{ "ppPowers",					TOK_STRUCT(ModArray, ppPowers, parse_Power) },
	{ "ppModsSaved",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_LATEBINDSTRUCT(ModArray, ppModsSaved) },
	{ "bHasBasicDisableAffects",	TOK_BIT, 0, 8, NULL},
	{ "ppMods",						TOK_IGNORE, 0 },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_ModArray()
{
	int iSize = sizeof(ModArray);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ModArray, iSize, "ModArray", NULL, "Character.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(ModArray)) + 7) / 4;
		NOCONST(ModArray) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bHasBasicDisableAffects = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ModArray[7]);
		pTemp->bHasBasicDisableAffects = 0;
	}
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_ModArray(void)
{
	DoAutoStructLateBind(parse_ModArray, 2, "AttribMod");
	DoAutoStructLateBind(parse_ModArray, 3, "AttribMod");
	DoAutoStructLateBind(parse_ModArray, 4, "AttribMod");
	DoAutoStructLateBind(parse_ModArray, 6, "AttribMod");
}
//autogeneratednocheckin
extern ParseTable parse_CombatTrackerNet[];
#define TYPE_parse_CombatTrackerNet CombatTrackerNet
extern ParseTable parse_CombatTrackerNet[];
#define TYPE_parse_CombatTrackerNet CombatTrackerNet
//Structparser.exe autogenerated ParseTable for struct CombatTrackerNetList
#define TYPE_parse_CombatTrackerNetList CombatTrackerNetList
ParseTable parse_CombatTrackerNetList[] =
{
	{ "CombatTrackerNetList", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CombatTrackerNetList), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Dirty",					TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(CombatTrackerNetList, bDirty, 0), NULL },
	{ "id",						TOK_BIT, 0, 8, NULL},
	{ "Touched",				TOK_SERVER_ONLY | TOK_BIT, 0, 8, NULL},
	{ "Events",					TOK_STRUCT(CombatTrackerNetList, ppEvents, parse_CombatTrackerNet) },
	{ "EventsBuffer",			TOK_NO_NETSEND | TOK_STRUCT(CombatTrackerNetList, ppEventsBuffer, parse_CombatTrackerNet) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_CombatTrackerNetList()
{
	int iSize = sizeof(CombatTrackerNetList);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CombatTrackerNetList, iSize, "CombatTrackerNetList", NULL, "Character.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(CombatTrackerNetList) + 7) / 4;
		CombatTrackerNetList *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->id = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CombatTrackerNetList[3]);
		pTemp->id = 0;
		pTemp->bTouched = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_CombatTrackerNetList[4]);
		pTemp->bTouched = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct LevelCombatControl
#define TYPE_parse_LevelCombatControl LevelCombatControl
ParseTable parse_LevelCombatControl[] =
{
	{ "LevelCombatControl", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(LevelCombatControl), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "iLevelForce",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(LevelCombatControl, iLevelForce, 0), NULL },
	{ "erLink",					TOK_AUTOINT(LevelCombatControl, erLink, 0), NULL },
	{ "cidLinkPlayer",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(LevelCombatControl, cidLinkPlayer, 0), NULL },
	{ "bLinkRequiresTeam",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_BIT, 0, 8, NULL},
	{ "uiTimestampInDanger",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(LevelCombatControl, uiTimestampInDanger, 0), NULL },
	{ "uiTimestampInvalid",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(LevelCombatControl, uiTimestampInvalid, 0), NULL },
	{ "iLevelInvalid",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(LevelCombatControl, iLevelInvalid, 0), NULL },
	{ "fMaxRange",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(LevelCombatControl, fMaxRange, 0), NULL },
	{ "uiSidekickingPowerID",	TOK_SERVER_ONLY | TOK_AUTOINT(LevelCombatControl, uiSidekickingPowerID, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_LevelCombatControl()
{
	int iSize = sizeof(LevelCombatControl);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_LevelCombatControl, iSize, "LevelCombatControl", NULL, "Character.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(LevelCombatControl)) + 7) / 4;
		NOCONST(LevelCombatControl) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bLinkRequiresTeam = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_LevelCombatControl[5]);
		pTemp->bLinkRequiresTeam = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct NearDeathConfig
#define TYPE_parse_NearDeathConfig NearDeathConfig
ParseTable parse_NearDeathConfig[] =
{
	{ "NearDeathConfig", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(NearDeathConfig), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Chance",				TOK_SERVER_ONLY | TOK_F32(NearDeathConfig, fChance, 0), NULL },
	{ "Time",				TOK_F32(NearDeathConfig, fTime, 0), NULL },
	{ "PowerModeRequired",	TOK_SERVER_ONLY | TOK_AUTOINT(NearDeathConfig, ePowerModeRequired, 0), PowerModeEnum },
	{ "Bits",				TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRINGARRAY(NearDeathConfig, ppchBits), NULL },
	{ "StanceWords",		TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRINGARRAY(NearDeathConfig, pchAnimStanceWords), NULL },
	{ "DyingTimeAttrib",	TOK_AUTOINT(NearDeathConfig, eDyingTimeAttrib, -1), AttribTypeEnum },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_NearDeathConfig()
{
	int iSize = sizeof(NearDeathConfig);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_NearDeathConfig, iSize, "NearDeathConfig", NULL, "Character.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct NearDeath
#define TYPE_parse_NearDeath NearDeath
ParseTable parse_NearDeath[] =
{
	{ "NearDeath", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(NearDeath), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Timer",						TOK_F32(NearDeath, fTimer, 0), NULL },
	{ "perHostileInteracts",		TOK_INTARRAY(NearDeath, perHostileInteracts),  NULL},
	{ "perFriendlyInteracts",		TOK_INTARRAY(NearDeath, perFriendlyInteracts),  NULL},
	{ "erKiller",					TOK_AUTOINT(NearDeath, erKiller, 0), NULL },
	{ "erKillerSource",				TOK_AUTOINT(NearDeath, erKillerSource, 0), NULL },
	{ "hKillingBlowDef",			TOK_REFERENCE(NearDeath, hKillingBlowDef, 0, "PowerDef") },
	{ "KillingAttribMod",			TOK_AUTOINT(NearDeath, iKillingAttribMod, 0), NULL },
	{ "FatalDamageAmount",			TOK_F32(NearDeath, fFatalDamageAmount, 0), NULL },
	{ "FatalDamageAmountNoResist",	TOK_F32(NearDeath, fFatalDamageAmountNoResist, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_NearDeath()
{
	int iSize = sizeof(NearDeath);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_NearDeath, iSize, "NearDeath", NULL, "Character.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CharacterPointSpent
#define TYPE_parse_CharacterPointSpent CharacterPointSpent
ParseTable parse_CharacterPointSpent[] =
{
	{ "CharacterPointSpent", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CharacterPointSpent), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "pchPoint",				TOK_PERSIST | TOK_POOL_STRING_DB | TOK_SUBSCRIBE | TOK_KEY | TOK_STRING(CharacterPointSpent, pchPoint, 0), NULL },
	{ "iSpent",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(CharacterPointSpent, iSpent, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CharacterPointSpent()
{
	int iSize = sizeof(CharacterPointSpent);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CharacterPointSpent, iSize, "CharacterPointSpent", NULL, "Character.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CharacterTraining
#define TYPE_parse_CharacterTraining CharacterTraining
ParseTable parse_CharacterTraining[] =
{
	{ "CharacterTraining", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CharacterTraining), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "uiCompleteTime",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(CharacterTraining, uiCompleteTime, 0), NULL },
	{ "uiStartTime",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(CharacterTraining, uiStartTime, 0), NULL },
	{ "uiBuyerType",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(CharacterTraining, uiBuyerType, 0), NULL },
	{ "uiBuyerID",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(CharacterTraining, uiBuyerID, 0), NULL },
	{ "uiItemID",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(CharacterTraining, uiItemID, 0), NULL },
	{ "hNewNodeDef",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(CharacterTraining, hNewNodeDef, 0, "PTNodeDef") },
	{ "hOldNodeDef",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(CharacterTraining, hOldNodeDef, 0, "PTNodeDef") },
	{ "iNewNodeRank",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(CharacterTraining, iNewNodeRank, 0), NULL },
	{ "iRefundAmount",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(CharacterTraining, iRefundAmount, 0), NULL },
	{ "pchRefundNumeric",	TOK_PERSIST | TOK_POOL_STRING | TOK_SUBSCRIBE | TOK_STRING(CharacterTraining, pchRefundNumeric, 0), NULL },
	{ "eType",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(CharacterTraining, eType, 0), CharacterTrainingTypeEnum },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CharacterTraining()
{
	int iSize = sizeof(CharacterTraining);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CharacterTraining, iSize, "CharacterTraining", NULL, "Character.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CharacterChargeData
#define TYPE_parse_CharacterChargeData CharacterChargeData
ParseTable parse_CharacterChargeData[] =
{
	{ "CharacterChargeData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CharacterChargeData), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "hMsgName",				TOK_REFERENCE(CharacterChargeData, hMsgName, 0, "Message") },
	{ "TimeCharge",				TOK_F32(CharacterChargeData, fTimeCharge, 0), NULL },
	{ "uiTimestamp",			TOK_AUTOINT(CharacterChargeData, uiTimestamp, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CharacterChargeData()
{
	int iSize = sizeof(CharacterChargeData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CharacterChargeData, iSize, "CharacterChargeData", NULL, "Character.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InnateAttribMod
#define TYPE_parse_InnateAttribMod InnateAttribMod
ParseTable parse_InnateAttribMod[] =
{
	{ "InnateAttribMod", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InnateAttribMod), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Source",				TOK_SELF_ONLY | TOK_AUTOINT(InnateAttribMod, eSource, 0), InnateAttribModSourceEnum },
	{ "Attrib",				TOK_SELF_ONLY | TOK_AUTOINT(InnateAttribMod, eAttrib, 0), AttribTypeEnum },
	{ "Aspect",				TOK_SELF_ONLY | TOK_AUTOINT(InnateAttribMod, eAspect, 0), AttribAspectEnum },
	{ "hPowerDef",			TOK_SELF_ONLY | TOK_REFERENCE(InnateAttribMod, hPowerDef, 0, "PowerDef") },
	{ "hItemDef",			TOK_SELF_ONLY | TOK_REFERENCE(InnateAttribMod, hItemDef, 0, "ItemDef") },
	{ "Mag",				TOK_SELF_ONLY | TOK_F32(InnateAttribMod, fMag, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InnateAttribMod()
{
	int iSize = sizeof(InnateAttribMod);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InnateAttribMod, iSize, "InnateAttribMod", NULL, "Character.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InnateAttribMod[];
#define TYPE_parse_InnateAttribMod InnateAttribMod
//Structparser.exe autogenerated ParseTable for struct InnateAttribModData
#define TYPE_parse_InnateAttribModData InnateAttribModData
ParseTable parse_InnateAttribModData[] =
{
	{ "InnateAttribModData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InnateAttribModData), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "InnateAttribMods",		TOK_SELF_ONLY | TOK_STRUCT(InnateAttribModData, ppInnateAttribMods, parse_InnateAttribMod) },
	{ "dirtyBit",				TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(InnateAttribModData, dirtyBit, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InnateAttribModData()
{
	int iSize = sizeof(InnateAttribModData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InnateAttribModData, iSize, "InnateAttribModData", NULL, "Character.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_LevelCombatControl[];
#define TYPE_parse_LevelCombatControl LevelCombatControl
extern ParseTable parse_AdditionalCharacterPath[];
#define TYPE_parse_AdditionalCharacterPath AdditionalCharacterPath
extern ParseTable parse_PowerSlotSet[];
#define TYPE_parse_PowerSlotSet PowerSlotSet
extern ParseTable parse_CombatReactivePowerInfo[];
#define TYPE_parse_CombatReactivePowerInfo CombatReactivePowerInfo
extern ParseTable parse_CombatPowerStateSwitchingInfo[];
#define TYPE_parse_CombatPowerStateSwitchingInfo CombatPowerStateSwitchingInfo
extern ParseTable parse_PowerTree[];
#define TYPE_parse_PowerTree PowerTree
extern ParseTable parse_PowerTreeClientInfoList[];
#define TYPE_parse_PowerTreeClientInfoList PowerTreeClientInfoList
extern ParseTable parse_CharacterPointSpent[];
#define TYPE_parse_CharacterPointSpent CharacterPointSpent
extern ParseTable parse_AssignedStats[];
#define TYPE_parse_AssignedStats AssignedStats
extern ParseTable parse_SavedAttribStats[];
#define TYPE_parse_SavedAttribStats SavedAttribStats
extern ParseTable parse_SavedAttribute[];
#define TYPE_parse_SavedAttribute SavedAttribute
extern ParseTable parse_PowerStatBonusData[];
#define TYPE_parse_PowerStatBonusData PowerStatBonusData
extern ParseTable parse_InnateAttribModData[];
#define TYPE_parse_InnateAttribModData InnateAttribModData
extern ParseTable parse_ModArray[];
#define TYPE_parse_ModArray ModArray
extern ParseTable parse_AttribModNet[];
#define TYPE_parse_AttribModNet AttribModNet
extern ParseTable parse_AttribAccrualSet[];
#define TYPE_parse_AttribAccrualSet AttribAccrualSet
extern ParseTable parse_CharacterTraining[];
#define TYPE_parse_CharacterTraining CharacterTraining
extern ParseTable parse_CombatEventState[];
#define TYPE_parse_CombatEventState CombatEventState
extern ParseTable parse_PowerModes[];
#define TYPE_parse_PowerModes PowerModes
extern ParseTable parse_CooldownTimer[];
#define TYPE_parse_CooldownTimer CooldownTimer
extern ParseTable parse_CooldownRateModifier[];
#define TYPE_parse_CooldownRateModifier CooldownRateModifier
extern ParseTable parse_CombatAdvantageNode[];
#define TYPE_parse_CombatAdvantageNode CombatAdvantageNode
extern ParseTable parse_CharacterChargeData[];
#define TYPE_parse_CharacterChargeData CharacterChargeData
extern ParseTable parse_PowerSubtargetChoice[];
#define TYPE_parse_PowerSubtargetChoice PowerSubtargetChoice
extern ParseTable parse_CombatTrackerNetList[];
#define TYPE_parse_CombatTrackerNetList CombatTrackerNetList
extern ParseTable parse_PowerSubtargetNet[];
#define TYPE_parse_PowerSubtargetNet PowerSubtargetNet
extern ParseTable parse_CharacterAITargetInfo[];
#define TYPE_parse_CharacterAITargetInfo CharacterAITargetInfo
extern ParseTable parse_PVPDuelState[];
#define TYPE_parse_PVPDuelState PVPDuelState
extern ParseTable parse_PVPFlag[];
#define TYPE_parse_PVPFlag PVPFlag
extern ParseTable parse_PVPTeamFlag[];
#define TYPE_parse_PVPTeamFlag PVPTeamFlag
extern ParseTable parse_NearDeath[];
#define TYPE_parse_NearDeath NearDeath
extern ParseTable parse_Item[];
#define TYPE_parse_Item Item
extern ParseTable parse_PowerActivationState[];
#define TYPE_parse_PowerActivationState PowerActivationState
//Structparser.exe autogenerated ParseTable for struct Character
#define TYPE_parse_Character Character
ParseTable parse_Character[] =
{
	{ "Character", 						TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(Character), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "dirtyID",						TOK_SELF_ONLY | TOK_AUTOINT(Character, dirtyID, 0), NULL },
	{ "dirtyClientMatchID",				TOK_CLIENT_ONLY | TOK_AUTOINT(Character, dirtyClientMatchID, 0), NULL },
	{ "iLevelExp",						TOK_PUPPET_NO_COPY | TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(Character, iLevelExp, 0), NULL },
	{ "iLevelCombat",					TOK_AUTOINT(Character, iLevelCombat, 0), NULL },
	{ "pLevelCombatControl",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_OPTIONALSTRUCT(Character, pLevelCombatControl, parse_LevelCombatControl) },
	{ "hClass",							TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(Character, hClass, 0, "CharacterClass") },
	{ "hClassTemporary",				TOK_REFERENCE(Character, hClassTemporary, 0, "CharacterClass") },
	{ "puiTempClassPowers",				TOK_SERVER_ONLY | TOK_INTARRAY(Character, puiTempClassPowers),  NULL},
	{ "hPath",							TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(Character, hPath, 0, "CharacterPath") },
	{ "ppSecondaryPaths",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_STRUCT(Character, ppSecondaryPaths, parse_AdditionalCharacterPath) },
	{ "hSpecies",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(Character, hSpecies, 0, "Species") },
	{ "pCustomSpecies",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_OPTIONALLATEBINDSTRUCT(Character, pCustomSpecies) },
	{ "uiPowerIDMax",					TOK_PERSIST | TOK_SELF_ONLY | TOK_AUTOINT(Character, uiPowerIDMax, 0), NULL },
	{ "ppPowersPersonal",				TOK_PERSIST | TOK_SELF_ONLY | TOK_LATEBINDSTRUCT(Character, ppPowersPersonal) },
	{ "ppPowersClass",					TOK_PERSIST | TOK_SELF_ONLY | TOK_LATEBINDSTRUCT(Character, ppPowersClass) },
	{ "ppPowersSpecies",				TOK_PERSIST | TOK_SELF_ONLY | TOK_LATEBINDSTRUCT(Character, ppPowersSpecies) },
	{ "ppPowersTemporary",				TOK_SELF_ONLY | TOK_LATEBINDSTRUCT(Character, ppPowersTemporary) },
	{ "ppPowersPropagation",			TOK_SELF_ONLY | TOK_NO_INDEX | TOK_LATEBINDSTRUCT(Character, ppPowersPropagation) },
	{ "ppPowersSCP",					TOK_SELF_ONLY | TOK_LATEBINDSTRUCT(Character, ppPowersSCP) },
	{ "pSlots",							TOK_PERSIST | TOK_SOMETIMES_TRANSACT | TOK_SELF_ONLY | TOK_OPTIONALLATEBINDSTRUCT(Character, pSlots) },
	{ "pSlotSetBecomeCritter",			TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Character, pSlotSetBecomeCritter, parse_PowerSlotSet) },
	{ "pCombatReactivePowerInfo",		TOK_OPTIONALSTRUCT(Character, pCombatReactivePowerInfo, parse_CombatReactivePowerInfo) },
	{ "pCombatPowerStateInfo",			TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Character, pCombatPowerStateInfo, parse_CombatPowerStateSwitchingInfo) },
	{ "ppPowerTrees",					TOK_PUPPET_NO_COPY | TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_STRUCT(Character, ppPowerTrees, parse_PowerTree) },
	{ "pClientPowerTreeInfo",			TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(Character, pClientPowerTreeInfo, parse_PowerTreeClientInfoList) },
	{ "ppPointSpentPowerTrees",			TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_STRUCT(Character, ppPointSpentPowerTrees, parse_CharacterPointSpent) },
	{ "uiPowerTreeModCount",			TOK_PUPPET_NO_COPY | TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_AUTOINT(Character, uiPowerTreeModCount, 0), NULL },
	{ "uiLastFreeRespecTime",			TOK_PERSIST | TOK_SELF_ONLY | TOK_AUTOINT(Character, uiLastFreeRespecTime, 0), NULL },
	{ "uiLastForcedRespecTime",			TOK_PERSIST | TOK_SERVER_ONLY | TOK_AUTOINT(Character, uiLastForcedRespecTime, 0), NULL },
	{ "eaiTypeLastFreeRespecTime",		TOK_PERSIST | TOK_SELF_ONLY | TOK_INTARRAY(Character, eaiTypeLastFreeRespecTime),  NULL},
	{ "ppAssignedStats",				TOK_PERSIST | TOK_SELF_ONLY | TOK_STRUCT(Character, ppAssignedStats, parse_AssignedStats) },
	{ "ppSavedAttribStats",				TOK_PERSIST | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_STRUCT(Character, ppSavedAttribStats, parse_SavedAttribStats) },
	{ "pchAttribStatsPreset",			TOK_PERSIST | TOK_SELF_ONLY | TOK_POOL_STRING | TOK_STRING(Character, pchCurrentAttribStatsPreset, 0), NULL },
	{ "pchCurrentAttribStatsPreset",	TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SELF_ONLY | TOK_POOL_STRING | TOK_STRING(Character, pchCurrentAttribStatsPreset, 0), NULL },
	{ "pchCurrentAttribStatsPreset",	TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SELF_ONLY | TOK_POOL_STRING | TOK_STRING(Character, pchCurrentAttribStatsPreset, 0), NULL },
	{ "ppSavedAttributes",				TOK_PERSIST | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_STRUCT(Character, ppSavedAttributes, parse_SavedAttribute) },
	{ "pattrBasic",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_OPTIONALLATEBINDSTRUCT(Character, pattrBasic) },
	{ "pPowerStatBonusData",			TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Character, pPowerStatBonusData, parse_PowerStatBonusData) },
	{ "pInnateAttribModData",			TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Character, pInnateAttribModData, parse_InnateAttribModData) },
	{ "modArray",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_EMBEDDEDSTRUCT(Character, modArray, parse_ModArray)},
	{ "ppModsNet",						TOK_STRUCT(Character, ppModsNet, parse_AttribModNet) },
	{ "pInnateAccrualSet",				TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Character, pInnateAccrualSet, parse_AttribAccrualSet) },
	{ "ppTraining",						TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_STRUCT(Character, ppTraining, parse_CharacterTraining) },
	{ "pCombatEventState",				TOK_SERVER_ONLY | TOK_OPTIONALSTRUCT(Character, pCombatEventState, parse_CombatEventState) },
	{ "piPowerModes",					TOK_INTARRAY(Character, piPowerModes),  NULL},
	{ "ppPowerModeHistory",				TOK_SERVER_ONLY | TOK_STRUCT(Character, ppPowerModeHistory, parse_PowerModes) },
	{ "ppCooldownTimers",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_STRUCT(Character, ppCooldownTimers, parse_CooldownTimer) },
	{ "ppSpeedCooldown",				TOK_SELF_ONLY | TOK_STRUCT(Character, ppSpeedCooldown, parse_CooldownRateModifier) },
	{ "ppCombatAdvantages",				TOK_STRUCT(Character, ppCombatAdvantages, parse_CombatAdvantageNode) },
	{ "pChargeData",					TOK_NO_NETSEND | TOK_OPTIONALSTRUCT(Character, pChargeData, parse_CharacterChargeData) },
	{ "pSubtarget",						TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Character, pSubtarget, parse_PowerSubtargetChoice) },
	{ "hPowerDefStanceDefault",			TOK_SELF_ONLY | TOK_REFERENCE(Character, hPowerDefStanceDefault, 0, "PowerDef") },
	{ "combatTrackerNetList",			TOK_EMBEDDEDSTRUCT(Character, combatTrackerNetList, parse_CombatTrackerNetList)},
	{ "ppSubtargets",					TOK_SERVER_ONLY | TOK_STRUCT(Character, ppSubtargets, parse_PowerSubtargetNet) },
	{ "erRingoutCredit",				TOK_SERVER_ONLY | TOK_AUTOINT(Character, erRingoutCredit, 0), NULL },
	{ "currentTargetRef",				TOK_AUTOINT(Character, currentTargetRef, 0), NULL },
	{ "erTargetDual",					TOK_AUTOINT(Character, erTargetDual, 0), NULL },
	{ "erTargetFocus",					TOK_AUTOINT(Character, erTargetFocus, 0), NULL },
	{ "currentTargetHandle",			TOK_REFERENCE(Character, currentTargetHandle, 0, "WorldInteractionNode") },
	{ "targetChangeID",					TOK_SELF_ONLY | TOK_AUTOINT(Character, targetChangeID, 0), NULL },
	{ "focusTargetChangeID",			TOK_AUTOINT(Character, focusTargetChangeID, 0), NULL },
	{ "perUntargetable",				TOK_SELF_ONLY | TOK_INTARRAY(Character, perUntargetable),  NULL},
	{ "perHidden",						TOK_SELF_ONLY | TOK_INTARRAY(Character, perHidden),  NULL},
	{ "ppAITargets",					TOK_STRUCT(Character, ppAITargets, parse_CharacterAITargetInfo) },
	{ "hHeldNode",						TOK_SELF_ONLY | TOK_REFERENCE(Character, hHeldNode, 0, "WorldInteractionNode") },
	{ "erHeld",							TOK_SELF_ONLY | TOK_AUTOINT(Character, erHeld, 0), NULL },
	{ "fHeldMass",						TOK_SELF_ONLY | TOK_F32(Character, fHeldMass, 0), NULL },
	{ "erHeldBy",						TOK_AUTOINT(Character, erHeldBy, 0), NULL },
	{ "ppchHeldFXNames",				TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRINGARRAY(Character, ppchHeldFXNames), NULL },
	{ "pfTimersAttribPool",				TOK_SERVER_ONLY | TOK_F32ARRAY(Character, pfTimersAttribPool), NULL },
	{ "pvpDuelState",					TOK_OPTIONALSTRUCT(Character, pvpDuelState, parse_PVPDuelState) },
	{ "pvpFlag",						TOK_OPTIONALSTRUCT(Character, pvpFlag, parse_PVPFlag) },
	{ "gangID",							TOK_AUTOINT(Character, gangID, 0), NULL },
	{ "pvpTeamDuelFlag",				TOK_OPTIONALSTRUCT(Character, pvpTeamDuelFlag, parse_PVPTeamFlag) },
	{ "pNearDeath",						TOK_OPTIONALSTRUCT(Character, pNearDeath, parse_NearDeath) },
	{ "primaryPetRef",					TOK_AUTOINT(Character, primaryPetRef, 0), NULL },
	{ "uiTimeCombatExit",				TOK_SELF_ONLY | TOK_AUTOINT(Character, uiTimeCombatExit, 0), NULL },
	{ "uiTimeCombatVisualsExit",		TOK_SELF_ONLY | TOK_AUTOINT(Character, uiTimeCombatVisualsExit, 0), NULL },
	{ "uiTimeBattleForm",				TOK_SELF_ONLY | TOK_AUTOINT(Character, uiTimeBattleForm, 0), NULL },
	{ "uiConfuseSeed",					TOK_SELF_ONLY | TOK_AUTOINT(Character, uiConfuseSeed, 0), NULL },
	{ "iFreeRespecAvailable",			TOK_SELF_ONLY | TOK_AUTOINT(Character, iFreeRespecAvailable, 0), NULL },
	{ "ppAutoExecItems",				TOK_SERVER_ONLY | TOK_STRUCT(Character, ppAutoExecItems, parse_Item) },
	{ "uiPowersCreatedEntityTime",		TOK_SERVER_ONLY | TOK_AUTOINT(Character, uiPowersCreatedEntityTime, 0), NULL },
	{ "bIsRooted",						TOK_BIT, 0, 8, NULL},
	{ "bIsHeld",						TOK_BIT, 0, 8, NULL},
	{ "bInvulnerable",					TOK_BIT, 0, 8, NULL},
	{ "bUnstoppable",					TOK_BIT, 0, 8, NULL},
	{ "bUnkillable",					TOK_BIT, 0, 8, NULL},
	{ "bDoNotDraw",						TOK_BIT, 0, 8, NULL},
	{ "bLevelAdjusting",				TOK_BIT, 0, 8, NULL},
	{ "bSafe",							TOK_BIT, 0, 8, NULL},
	{ "bBattleForm",					TOK_SELF_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bDisableFaceActivate",			TOK_BIT, 0, 8, NULL},
	{ "bDisableFaceSelected",			TOK_SELF_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bRequireValidTarget",			TOK_SELF_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bUseCameraTargeting",			TOK_SELF_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bDisablePowerQueuing",			TOK_SELF_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bShooterControls",				TOK_SELF_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bIsPrimaryPet",					TOK_BIT, 0, 8, NULL},
	{ "bModsOwnedByOwner",				TOK_BIT, 0, 8, NULL},
	{ "bBecomeCritter",					TOK_BIT, 0, 8, NULL},
	{ "bUseBecomeCritterTray",			TOK_BIT, 0, 8, NULL},
	{ "bHasAvailableResearch",			TOK_CLIENT_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bSpecialLargeMonster",			TOK_BIT, 0, 8, NULL},
	{ "ppActivationState",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_SERVER_ONLY | TOK_STRUCT(Character, ppActivationState, parse_PowerActivationState) },
	{ "puiPowerIDsSaved_Obsolete",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_INTARRAY(Character, puiPowerIDsSaved_Obsolete),  NULL},
	{ "eaSavedPowersIDs",				TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_INTARRAY(Character, puiPowerIDsSaved_Obsolete),  NULL},
	{ "puiPowerIDsSaved",				TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_INTARRAY(Character, puiPowerIDsSaved_Obsolete),  NULL},
	{ "uiPredictedDeathTime",			TOK_SERVER_ONLY | TOK_AUTOINT(Character, uiPredictedDeathTime, 0), NULL },
	{ "pcSwingingFX",					TOK_POOL_STRING | TOK_STRING(Character, pcSwingingFX, 0), NULL },
	{ "dirtyBit",						TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(Character, dirtyBit, 0), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_Character()
{
	int iSize = sizeof(Character);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_Character, iSize, "Character", NULL, "Character.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(Character)) + 7) / 4;
		NOCONST(Character) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bIsRooted = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[85]);
		pTemp->bIsRooted = 0;
		pTemp->bIsHeld = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[86]);
		pTemp->bIsHeld = 0;
		pTemp->bInvulnerable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[87]);
		pTemp->bInvulnerable = 0;
		pTemp->bUnstoppable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[88]);
		pTemp->bUnstoppable = 0;
		pTemp->bUnkillable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[89]);
		pTemp->bUnkillable = 0;
		pTemp->bDoNotDraw = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[90]);
		pTemp->bDoNotDraw = 0;
		pTemp->bLevelAdjusting = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[91]);
		pTemp->bLevelAdjusting = 0;
		pTemp->bSafe = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[92]);
		pTemp->bSafe = 0;
		pTemp->bBattleForm = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[93]);
		pTemp->bBattleForm = 0;
		pTemp->bDisableFaceActivate = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[94]);
		pTemp->bDisableFaceActivate = 0;
		pTemp->bDisableFaceSelected = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[95]);
		pTemp->bDisableFaceSelected = 0;
		pTemp->bRequireValidTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[96]);
		pTemp->bRequireValidTarget = 0;
		pTemp->bUseCameraTargeting = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[97]);
		pTemp->bUseCameraTargeting = 0;
		pTemp->bDisablePowerQueuing = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[98]);
		pTemp->bDisablePowerQueuing = 0;
		pTemp->bShooterControls = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[99]);
		pTemp->bShooterControls = 0;
		pTemp->bIsPrimaryPet = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[100]);
		pTemp->bIsPrimaryPet = 0;
		pTemp->bModsOwnedByOwner = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[101]);
		pTemp->bModsOwnedByOwner = 0;
		pTemp->bBecomeCritter = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[102]);
		pTemp->bBecomeCritter = 0;
		pTemp->bUseBecomeCritterTray = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[103]);
		pTemp->bUseBecomeCritterTray = 0;
		pTemp->bHasAvailableResearch = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[104]);
		pTemp->bHasAvailableResearch = 0;
		pTemp->bSpecialLargeMonster = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Character[105]);
		pTemp->bSpecialLargeMonster = 0;
	}
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_Character(void)
{
	DoAutoStructLateBind(parse_Character, 13, "CustomSpecies");
	DoAutoStructLateBind(parse_Character, 15, "Power");
	DoAutoStructLateBind(parse_Character, 16, "Power");
	DoAutoStructLateBind(parse_Character, 17, "Power");
	DoAutoStructLateBind(parse_Character, 18, "Power");
	DoAutoStructLateBind(parse_Character, 19, "Power");
	DoAutoStructLateBind(parse_Character, 20, "Power");
	DoAutoStructLateBind(parse_Character, 21, "CharacterPowerSlots");
	DoAutoStructLateBind(parse_Character, 38, "CharacterAttribs");
}
//autogeneratednocheckin
extern ParseTable parse_TempAttributes[];
#define TYPE_parse_TempAttributes TempAttributes
//Structparser.exe autogenerated ParseTable for struct CharacterPreSaveInfo
#define TYPE_parse_CharacterPreSaveInfo CharacterPreSaveInfo
ParseTable parse_CharacterPreSaveInfo[] =
{
	{ "CharacterPreSaveInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CharacterPreSaveInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "TempAttributes",			TOK_OPTIONALSTRUCT(CharacterPreSaveInfo, pTempAttributes, parse_TempAttributes) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CharacterPreSaveInfo()
{
	int iSize = sizeof(CharacterPreSaveInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CharacterPreSaveInfo, iSize, "CharacterPreSaveInfo", NULL, "Character.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerRechargeState
#define TYPE_parse_PowerRechargeState PowerRechargeState
ParseTable parse_PowerRechargeState[] =
{
	{ "PowerRechargeState", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerRechargeState), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "puiIDs",				TOK_INTARRAY(PowerRechargeState, puiIDs),  NULL},
	{ "pfTimes",			TOK_F32ARRAY(PowerRechargeState, pfTimes), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerRechargeState()
{
	int iSize = sizeof(PowerRechargeState);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerRechargeState, iSize, "PowerRechargeState", NULL, "Character.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PowerActivationState[];
#define TYPE_parse_PowerActivationState PowerActivationState
extern ParseTable parse_PowerRechargeState[];
#define TYPE_parse_PowerRechargeState PowerRechargeState
extern ParseTable parse_CooldownTimer[];
#define TYPE_parse_CooldownTimer CooldownTimer
//Structparser.exe autogenerated ParseTable for struct ClientCharacterInitData
#define TYPE_parse_ClientCharacterInitData ClientCharacterInitData
ParseTable parse_ClientCharacterInitData[] =
{
	{ "ClientCharacterInitData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ClientCharacterInitData), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "ActivationStateToggle",		TOK_STRUCT(ClientCharacterInitData, ppActivationStateToggle, parse_PowerActivationState) },
	{ "rechargeState",				TOK_EMBEDDEDSTRUCT(ClientCharacterInitData, rechargeState, parse_PowerRechargeState)},
	{ "CooldownTimers",				TOK_STRUCT(ClientCharacterInitData, ppCooldownTimers, parse_CooldownTimer) },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ClientCharacterInitData()
{
	int iSize = sizeof(ClientCharacterInitData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ClientCharacterInitData, iSize, "ClientCharacterInitData", NULL, "Character.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
