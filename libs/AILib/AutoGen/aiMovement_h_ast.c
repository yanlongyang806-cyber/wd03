#include "textparser.h"

//auto-generated staticdefine for enum AIMovementOrderType
//autogeneratednocheckin
StaticDefineInt AIMovementOrderTypeEnum[] =
{
	DEFINE_INT
	{ "NONE", AI_MOVEMENT_ORDER_NONE},
	{ "POS", AI_MOVEMENT_ORDER_POS},
	{ "ENT", AI_MOVEMENT_ORDER_ENT},
	DEFINE_END
};
void autoEnum_fixup_AIMovementOrderType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AIMovementOrderTypeEnum, "AIMovementOrderType");
}

//auto-generated staticdefine for enum AIMovementOrderEntDetail
//autogeneratednocheckin
StaticDefineInt AIMovementOrderEntDetailEnum[] =
{
	DEFINE_INT
	{ "UNSPECIFIED", AI_MOVEMENT_ORDER_ENT_UNSPECIFIED},
	{ "FOLLOW", AI_MOVEMENT_ORDER_ENT_FOLLOW},
	{ "FOLLOW_OFFSET", AI_MOVEMENT_ORDER_ENT_FOLLOW_OFFSET},
	{ "COMBAT", AI_MOVEMENT_ORDER_ENT_COMBAT},
	{ "PATROL", AI_MOVEMENT_ORDER_ENT_PATROL},
	{ "PATROL_OFFSET", AI_MOVEMENT_ORDER_ENT_PATROL_OFFSET},
	{ "GET_IN_RANGE", AI_MOVEMENT_ORDER_ENT_GET_IN_RANGE},
	{ "GET_IN_RANGE_DIST", AI_MOVEMENT_ORDER_ENT_GET_IN_RANGE_DIST},
	{ "COMBAT_MOVETO_OFFSET", AI_MOVEMENT_ORDER_ENT_COMBAT_MOVETO_OFFSET},
	DEFINE_END
};
void autoEnum_fixup_AIMovementOrderEntDetail(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AIMovementOrderEntDetailEnum, "AIMovementOrderEntDetail");
}

//auto-generated staticdefine for enum fsmLocalDataType
//autogeneratednocheckin
StaticDefineInt fsmLocalDataTypeEnum[] =
{
	DEFINE_INT
	{ "ADDCONFIGMOD", FSM_LDT_ADDCONFIGMOD},
	{ "ADDCONFIGMODSET", FSM_LDT_ADDCONFIGMODSET},
	{ "ANIMLIST", FSM_LDT_ANIMLIST},
	{ "FOLLOW", FSM_LDT_FOLLOW},
	{ "COMBAT", FSM_LDT_COMBAT},
	{ "AMBIENT", FSM_LDT_AMBIENT},
	{ "COMBATJOB", FSM_LDT_COMBATJOB},
	{ "GENERICSETDATA", FSM_LDT_GENERICSETDATA},
	{ "GENERICU64", FSM_LDT_GENERICU64},
	{ "GENERICU64EH", FSM_LDT_GENERICU64EH},
	{ "GENERICEARRAY", FSM_LDT_GENERICEARRAY},
	{ "GOTOSPAWNPOS", FSM_LDT_GOTOSPAWNPOS},
	{ "PATROL", FSM_LDT_PATROL},
	{ "RETREAT", FSM_LDT_RETREAT},
	{ "RUNINTODOOR", FSM_LDT_RUNINTODOOR},
	{ "RUNOUTOFDOOR", FSM_LDT_RUNOUTOFDOOR},
	{ "RUNTOPOINT", FSM_LDT_RUNTOPOINT},
	{ "SENDMESSAGE", FSM_LDT_SENDMESSAGE},
	{ "WANDER", FSM_LDT_WANDER},
	{ "GRIEVEDHEAL", FSM_LDT_GRIEVEDHEAL},
	{ "MMIND_PERSUE", FSM_LDT_MMIND_PERSUE},
	{ "DISORIENTED", FSM_LDT_DISORIENTED},
	DEFINE_END
};
void autoEnum_fixup_fsmLocalDataType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(fsmLocalDataTypeEnum, "fsmLocalDataType");
}

//auto-generated staticdefine for enum FSMLDAmbientState
//autogeneratednocheckin
StaticDefineInt FSMLDAmbientStateEnum[] =
{
	DEFINE_INT
	{ "idle", FSM_AMBIENT_IDLE},
	{ "chat", FSM_AMBIENT_CHAT},
	{ "wander", FSM_AMBIENT_WANDER},
	{ "job", FSM_AMBIENT_JOB},
	{ "spawn", FSM_AMBIENT_GOTOSPAWN},
	{ "END_OF_LIST", FSM_AMBIENT_END_OF_LIST},
	DEFINE_END
};
void autoEnum_fixup_FSMLDAmbientState(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(FSMLDAmbientStateEnum, "FSMLDAmbientState");
}

//auto-generated staticdefine for enum FSMLDAmbientWanderType
//autogeneratednocheckin
StaticDefineInt FSMLDAmbientWanderTypeEnum[] =
{
	DEFINE_INT
	{ "STANDARD", FSM_AMBIENTTYPE_STANDARD},
	{ "SPACE", FSM_AMBIENTTYPE_SPACE},
	{ "END_OF_LIST", FSM_AMBIENTTYPE_END_OF_LIST},
	DEFINE_END
};
void autoEnum_fixup_FSMLDAmbientWanderType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(FSMLDAmbientWanderTypeEnum, "FSMLDAmbientWanderType");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ExprLocalData
#define TYPE_parse_ExprLocalData ExprLocalData
ParseTable parse_ExprLocalData[] =
{
	{ "ExprLocalData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ExprLocalData), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "type",			TOK_OBJECTTYPE | TOK_AUTOINT(ExprLocalData, type, 0), fsmLocalDataTypeEnum },
	{ "key",			TOK_AUTOINT(ExprLocalData, key, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
//filled in by autogenerated fixup-time calls to AddEntryToPolyTable()
ParseTable polyTable_ExprLocalData[] = 
{
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 1 }
};
int autoStruct_fixup_ExprLocalData()
{
	int iSize = sizeof(ExprLocalData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ExprLocalData, iSize, "ExprLocalData", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable polyTable_ExprLocalData[];
//Structparser.exe autogenerated ParseTable for struct DestroyMyLocalData
#define TYPE_parse_DestroyMyLocalData DestroyMyLocalData
ParseTable parse_DestroyMyLocalData[] =
{
	{ "DestroyMyLocalData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DestroyMyLocalData), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "localdata",			TOK_OPTIONALPOLYMORPH(DestroyMyLocalData, localdata, polyTable_ExprLocalData) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DestroyMyLocalData()
{
	int iSize = sizeof(DestroyMyLocalData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DestroyMyLocalData, iSize, "DestroyMyLocalData", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDAddStructMod
#define TYPE_parse_FSMLDAddStructMod FSMLDAddStructMod
ParseTable parse_FSMLDAddStructMod[] =
{
	{ "FSMLDAddStructMod", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDAddStructMod), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "type",				TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDAddStructMod, baseData.type, FSM_LDT_ADDCONFIGMOD), fsmLocalDataTypeEnum },
	{ "key",				TOK_AUTOINT(FSMLDAddStructMod, baseData.key, 0), NULL },
	{ "id",					TOK_AUTOINT(FSMLDAddStructMod, id, 0), NULL },
	{ "dataIsSet",			TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDAddStructMod()
{
	int iSize = sizeof(FSMLDAddStructMod);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDAddStructMod, iSize, "FSMLDAddStructMod", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDAddStructMod", parse_FSMLDAddStructMod, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDAddStructMod) + 7) / 4;
		FSMLDAddStructMod *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->dataIsSet = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDAddStructMod[5]);
		pTemp->dataIsSet = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDAddStructModTagSet
#define TYPE_parse_FSMLDAddStructModTagSet FSMLDAddStructModTagSet
ParseTable parse_FSMLDAddStructModTagSet[] =
{
	{ "FSMLDAddStructModTagSet", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDAddStructModTagSet), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "type",						TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDAddStructModTagSet, baseData.type, FSM_LDT_ADDCONFIGMODSET), fsmLocalDataTypeEnum },
	{ "key",						TOK_AUTOINT(FSMLDAddStructModTagSet, baseData.key, 0), NULL },
	{ "ids",						TOK_INTARRAY(FSMLDAddStructModTagSet, ids),  NULL},
	{ "tagBit",						TOK_AUTOINT(FSMLDAddStructModTagSet, tagBit, 0), NULL },
	{ "dataIsSet",					TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDAddStructModTagSet()
{
	int iSize = sizeof(FSMLDAddStructModTagSet);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDAddStructModTagSet, iSize, "FSMLDAddStructModTagSet", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDAddStructModTagSet", parse_FSMLDAddStructModTagSet, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDAddStructModTagSet) + 7) / 4;
		FSMLDAddStructModTagSet *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->dataIsSet = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDAddStructModTagSet[6]);
		pTemp->dataIsSet = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDAnimList
#define TYPE_parse_FSMLDAnimList FSMLDAnimList
ParseTable parse_FSMLDAnimList[] =
{
	{ "FSMLDAnimList", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDAnimList), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "type",				TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDAnimList, baseData.type, FSM_LDT_ANIMLIST), fsmLocalDataTypeEnum },
	{ "key",				TOK_AUTOINT(FSMLDAnimList, baseData.key, 0), NULL },
	{ "CurrentAnimList",	TOK_POOL_STRING | TOK_STRING(FSMLDAnimList, pchCurrentAnimList, 0), NULL },
	{ "addedAnimList",		TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDAnimList()
{
	int iSize = sizeof(FSMLDAnimList);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDAnimList, iSize, "FSMLDAnimList", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDAnimList", parse_FSMLDAnimList, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDAnimList) + 7) / 4;
		FSMLDAnimList *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->addedAnimList = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDAnimList[5]);
		pTemp->addedAnimList = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDCombat
#define TYPE_parse_FSMLDCombat FSMLDCombat
ParseTable parse_FSMLDCombat[] =
{
	{ "FSMLDCombat", 						TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDCombat), 0, NULL, 0, NULL },
	{ "{",									TOK_START, 0 },
	{ "type",								TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDCombat, baseData.type, FSM_LDT_COMBAT), fsmLocalDataTypeEnum },
	{ "key",								TOK_AUTOINT(FSMLDCombat, baseData.key, 0), NULL },
	{ "combatMinimumThrottlePercentage",	TOK_F32(FSMLDCombat, combatMinimumThrottlePercentage, 0), NULL },
	{ "combatMinThrottleConfigModHandle",	TOK_AUTOINT(FSMLDCombat, combatMinThrottleConfigModHandle, 0), NULL },
	{ "continuousCombatMovementOffHandle",	TOK_AUTOINT(FSMLDCombat, continuousCombatMovementOffHandle, 0), NULL },
	{ "switchModsForLeashing",				TOK_BIT, 0, 8, NULL},
	{ "leashModeOn",						TOK_BIT, 0, 8, NULL},
	{ "setData",							TOK_BIT, 0, 8, NULL},
	{ "setCombatFSMData",					TOK_BIT, 0, 8, NULL},
	{ "}",									TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDCombat()
{
	int iSize = sizeof(FSMLDCombat);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDCombat, iSize, "FSMLDCombat", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDCombat", parse_FSMLDCombat, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDCombat) + 7) / 4;
		FSMLDCombat *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->switchModsForLeashing = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDCombat[7]);
		pTemp->switchModsForLeashing = 0;
		pTemp->leashModeOn = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDCombat[8]);
		pTemp->leashModeOn = 0;
		pTemp->setData = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDCombat[9]);
		pTemp->setData = 0;
		pTemp->setCombatFSMData = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDCombat[10]);
		pTemp->setCombatFSMData = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDCombatJob
#define TYPE_parse_FSMLDCombatJob FSMLDCombatJob
ParseTable parse_FSMLDCombatJob[] =
{
	{ "FSMLDCombatJob", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDCombatJob), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "type",					TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDCombatJob, baseData.type, FSM_LDT_COMBATJOB), fsmLocalDataTypeEnum },
	{ "key",					TOK_AUTOINT(FSMLDCombatJob, baseData.key, 0), NULL },
	{ "setCombatJobFSMData",	TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDCombatJob()
{
	int iSize = sizeof(FSMLDCombatJob);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDCombatJob, iSize, "FSMLDCombatJob", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDCombatJob", parse_FSMLDCombatJob, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDCombatJob) + 7) / 4;
		FSMLDCombatJob *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->setCombatJobFSMData = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDCombatJob[4]);
		pTemp->setCombatJobFSMData = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
extern ParseTable parse_FSMContext[];
#define TYPE_parse_FSMContext FSMContext
//Structparser.exe autogenerated ParseTable for struct FSMLDAmbient
#define TYPE_parse_FSMLDAmbient FSMLDAmbient
ParseTable parse_FSMLDAmbient[] =
{
	{ "FSMLDAmbient", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDAmbient), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "type",							TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDAmbient, baseData.type, FSM_LDT_AMBIENT), fsmLocalDataTypeEnum },
	{ "key",							TOK_AUTOINT(FSMLDAmbient, baseData.key, 0), NULL },
	{ "currentState",					TOK_AUTOINT(FSMLDAmbient, currentState, 0), FSMLDAmbientStateEnum },
	{ "lastTimeOffset",					TOK_AUTOINT(FSMLDAmbient, lastTimeOffset, 0), NULL },
	{ "ambientJobCooldown",				TOK_AUTOINT(FSMLDAmbient, ambientJobCooldown, 0), NULL },
	{ "stateDuration",					TOK_F32(FSMLDAmbient, stateDuration, 0), NULL },
	{ "wanderSpeed",					TOK_F32(FSMLDAmbient, wanderSpeed, 0), NULL },
	{ "wanderDuration",					TOK_F32(FSMLDAmbient, wanderDuration, 0), NULL },
	{ "wanderWeight",					TOK_F32(FSMLDAmbient, wanderWeight, 0), NULL },
	{ "wanderDistance",					TOK_F32(FSMLDAmbient, wanderDistance, 0), NULL },
	{ "wanderIdleTime",					TOK_F32(FSMLDAmbient, wanderIdleTime, 0), NULL },
	{ "wanderMaxPath",					TOK_AUTOINT(FSMLDAmbient, wanderMaxPath, 0), NULL },
	{ "chatDuration",					TOK_F32(FSMLDAmbient, chatDuration, 0), NULL },
	{ "chatWeight",						TOK_F32(FSMLDAmbient, chatWeight, 0), NULL },
	{ "chatMessageKey",					TOK_STRING(FSMLDAmbient, chatMessageKey, 0), NULL },
	{ "idleAnimation",					TOK_STRING(FSMLDAmbient, idleAnimation, 0), NULL },
	{ "chatAnimation",					TOK_STRING(FSMLDAmbient, chatAnimation, 0), NULL },
	{ "jobFsmContext",					TOK_OPTIONALSTRUCT(FSMLDAmbient, jobFsmContext, parse_FSMContext) },
	{ "jobDuration",					TOK_F32(FSMLDAmbient, jobDuration, 0), NULL },
	{ "jobWeight",						TOK_F32(FSMLDAmbient, jobWeight, 0), NULL },
	{ "TargetPos",						TOK_VEC3(FSMLDAmbient, vTargetPos), NULL },
	{ "idleDuration",					TOK_F32(FSMLDAmbient, idleDuration, 0), NULL },
	{ "idleWeight",						TOK_F32(FSMLDAmbient, idleWeight, 0), NULL },
	{ "speedConfigModHandle",			TOK_AUTOINT(FSMLDAmbient, speedConfigModHandle, 0), NULL },
	{ "waypointSplineConfigModHandle",	TOK_AUTOINT(FSMLDAmbient, waypointSplineConfigModHandle, 0), NULL },
	{ "groundRelative",					TOK_AUTOINT(FSMLDAmbient, groundRelative, 0), NULL },
	{ "airWander",						TOK_F32(FSMLDAmbient, airWander, 0), NULL },
	{ "distBeforeWaypointToSpline",		TOK_F32(FSMLDAmbient, distBeforeWaypointToSpline, 0), NULL },
	{ "JobAwarenessRadius",				TOK_F32(FSMLDAmbient, fJobAwarenessRadius, 0), NULL },
	{ "failedFindJobCount",				TOK_AUTOINT(FSMLDAmbient, failedFindJobCount, 0), NULL },
	{ "isActive",						TOK_BIT, 0, 8, NULL},
	{ "onEntry",						TOK_BIT, 0, 8, NULL},
	{ "isIdleActive",					TOK_BIT, 0, 8, NULL},
	{ "isChatActive",					TOK_BIT, 0, 8, NULL},
	{ "isWanderActive",					TOK_BIT, 0, 8, NULL},
	{ "isJobActive",					TOK_BIT, 0, 8, NULL},
	{ "addedAnimList",					TOK_BIT, 0, 8, NULL},
	{ "setData",						TOK_BIT, 0, 8, NULL},
	{ "isFlying",						TOK_BIT, 0, 8, NULL},
	{ "IsMovingToJobTarget",			TOK_BIT, 0, 8, NULL},
	{ "ReachedJobTarget",				TOK_BIT, 0, 8, NULL},
	{ "StateDoesNotCheckDuration",		TOK_BIT, 0, 8, NULL},
	{ "IgnoreFindJob",					TOK_BIT, 0, 8, NULL},
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDAmbient()
{
	int iSize = sizeof(FSMLDAmbient);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDAmbient, iSize, "FSMLDAmbient", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDAmbient", parse_FSMLDAmbient, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDAmbient) + 7) / 4;
		FSMLDAmbient *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->isActive = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDAmbient[32]);
		pTemp->isActive = 0;
		pTemp->onEntry = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDAmbient[33]);
		pTemp->onEntry = 0;
		pTemp->isIdleActive = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDAmbient[34]);
		pTemp->isIdleActive = 0;
		pTemp->isChatActive = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDAmbient[35]);
		pTemp->isChatActive = 0;
		pTemp->isWanderActive = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDAmbient[36]);
		pTemp->isWanderActive = 0;
		pTemp->isJobActive = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDAmbient[37]);
		pTemp->isJobActive = 0;
		pTemp->addedAnimList = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDAmbient[38]);
		pTemp->addedAnimList = 0;
		pTemp->setData = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDAmbient[39]);
		pTemp->setData = 0;
		pTemp->isFlying = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDAmbient[40]);
		pTemp->isFlying = 0;
		pTemp->bIsMovingToJobTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDAmbient[41]);
		pTemp->bIsMovingToJobTarget = 0;
		pTemp->bReachedJobTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDAmbient[42]);
		pTemp->bReachedJobTarget = 0;
		pTemp->bStateDoesNotCheckDuration = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDAmbient[43]);
		pTemp->bStateDoesNotCheckDuration = 0;
		pTemp->bIgnoreFindJob = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDAmbient[44]);
		pTemp->bIgnoreFindJob = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDGenericSetData
#define TYPE_parse_FSMLDGenericSetData FSMLDGenericSetData
ParseTable parse_FSMLDGenericSetData[] =
{
	{ "FSMLDGenericSetData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDGenericSetData), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "type",					TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDGenericSetData, baseData.type, FSM_LDT_GENERICSETDATA), fsmLocalDataTypeEnum },
	{ "key",					TOK_AUTOINT(FSMLDGenericSetData, baseData.key, 0), NULL },
	{ "setData",				TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDGenericSetData()
{
	int iSize = sizeof(FSMLDGenericSetData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDGenericSetData, iSize, "FSMLDGenericSetData", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDGenericSetData", parse_FSMLDGenericSetData, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDGenericSetData) + 7) / 4;
		FSMLDGenericSetData *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->setData = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDGenericSetData[4]);
		pTemp->setData = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDGenericU64
#define TYPE_parse_FSMLDGenericU64 FSMLDGenericU64
ParseTable parse_FSMLDGenericU64[] =
{
	{ "FSMLDGenericU64", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDGenericU64), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "type",				TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDGenericU64, baseData.type, FSM_LDT_GENERICU64), fsmLocalDataTypeEnum },
	{ "key",				TOK_AUTOINT(FSMLDGenericU64, baseData.key, 0), NULL },
	{ "myU64",				TOK_AUTOINT(FSMLDGenericU64, myU64, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDGenericU64()
{
	int iSize = sizeof(FSMLDGenericU64);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDGenericU64, iSize, "FSMLDGenericU64", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDGenericU64", parse_FSMLDGenericU64, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDGenericEArray
#define TYPE_parse_FSMLDGenericEArray FSMLDGenericEArray
ParseTable parse_FSMLDGenericEArray[] =
{
	{ "FSMLDGenericEArray", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDGenericEArray), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "type",				TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDGenericEArray, baseData.type, FSM_LDT_GENERICEARRAY), fsmLocalDataTypeEnum },
	{ "key",				TOK_AUTOINT(FSMLDGenericEArray, baseData.key, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDGenericEArray()
{
	int iSize = sizeof(FSMLDGenericEArray);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDGenericEArray, iSize, "FSMLDGenericEArray", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDGenericEArray", parse_FSMLDGenericEArray, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDGenericU64ExitHandlers
#define TYPE_parse_FSMLDGenericU64ExitHandlers FSMLDGenericU64ExitHandlers
ParseTable parse_FSMLDGenericU64ExitHandlers[] =
{
	{ "FSMLDGenericU64ExitHandlers", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDGenericU64ExitHandlers), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "type",							TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDGenericU64ExitHandlers, baseData.type, FSM_LDT_GENERICU64EH), fsmLocalDataTypeEnum },
	{ "key",							TOK_AUTOINT(FSMLDGenericU64ExitHandlers, baseData.key, 0), NULL },
	{ "myU64",							TOK_AUTOINT(FSMLDGenericU64ExitHandlers, myU64, 0), NULL },
	{ "addedExitHandlers",				TOK_BIT, 0, 8, NULL},
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDGenericU64ExitHandlers()
{
	int iSize = sizeof(FSMLDGenericU64ExitHandlers);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDGenericU64ExitHandlers, iSize, "FSMLDGenericU64ExitHandlers", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDGenericU64ExitHandlers", parse_FSMLDGenericU64ExitHandlers, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDGenericU64ExitHandlers) + 7) / 4;
		FSMLDGenericU64ExitHandlers *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->addedExitHandlers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDGenericU64ExitHandlers[5]);
		pTemp->addedExitHandlers = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDGoToSpawnPos
#define TYPE_parse_FSMLDGoToSpawnPos FSMLDGoToSpawnPos
ParseTable parse_FSMLDGoToSpawnPos[] =
{
	{ "FSMLDGoToSpawnPos", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDGoToSpawnPos), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "type",				TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDGoToSpawnPos, baseData.type, FSM_LDT_GOTOSPAWNPOS), fsmLocalDataTypeEnum },
	{ "key",				TOK_AUTOINT(FSMLDGoToSpawnPos, baseData.key, 0), NULL },
	{ "addedExitHandlers",	TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDGoToSpawnPos()
{
	int iSize = sizeof(FSMLDGoToSpawnPos);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDGoToSpawnPos, iSize, "FSMLDGoToSpawnPos", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDGoToSpawnPos", parse_FSMLDGoToSpawnPos, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDGoToSpawnPos) + 7) / 4;
		FSMLDGoToSpawnPos *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->addedExitHandlers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDGoToSpawnPos[4]);
		pTemp->addedExitHandlers = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDPatrol
#define TYPE_parse_FSMLDPatrol FSMLDPatrol
ParseTable parse_FSMLDPatrol[] =
{
	{ "FSMLDPatrol", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDPatrol), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "type",					TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDPatrol, baseData.type, FSM_LDT_PATROL), fsmLocalDataTypeEnum },
	{ "key",					TOK_AUTOINT(FSMLDPatrol, baseData.key, 0), NULL },
	{ "lastPointPassed",		TOK_AUTOINT(FSMLDPatrol, lastPointPassed, 0), NULL },
	{ "totalPoints",			TOK_AUTOINT(FSMLDPatrol, totalPoints, 0), NULL },
	{ "leaderRef",				TOK_AUTOINT(FSMLDPatrol, leaderRef, 0), NULL },
	{ "pingpongRev",			TOK_BIT, 0, 8, NULL},
	{ "amLeader",				TOK_BIT, 0, 8, NULL},
	{ "finishedOneRotation",	TOK_BIT, 0, 8, NULL},
	{ "dataSet",				TOK_BIT, 0, 8, NULL},
	{ "hadData",				TOK_BIT, 0, 8, NULL},
	{ "useOffset",				TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDPatrol()
{
	int iSize = sizeof(FSMLDPatrol);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDPatrol, iSize, "FSMLDPatrol", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDPatrol", parse_FSMLDPatrol, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDPatrol) + 7) / 4;
		FSMLDPatrol *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->pingpongRev = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDPatrol[7]);
		pTemp->pingpongRev = 0;
		pTemp->amLeader = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDPatrol[8]);
		pTemp->amLeader = 0;
		pTemp->finishedOneRotation = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDPatrol[9]);
		pTemp->finishedOneRotation = 0;
		pTemp->dataSet = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDPatrol[10]);
		pTemp->dataSet = 0;
		pTemp->hadData = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDPatrol[11]);
		pTemp->hadData = 0;
		pTemp->useOffset = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDPatrol[12]);
		pTemp->useOffset = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDFollow
#define TYPE_parse_FSMLDFollow FSMLDFollow
ParseTable parse_FSMLDFollow[] =
{
	{ "FSMLDFollow", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDFollow), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "type",				TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDFollow, baseData.type, FSM_LDT_FOLLOW), fsmLocalDataTypeEnum },
	{ "key",				TOK_AUTOINT(FSMLDFollow, baseData.key, 0), NULL },
	{ "addedExitHandlers",	TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDFollow()
{
	int iSize = sizeof(FSMLDFollow);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDFollow, iSize, "FSMLDFollow", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDFollow", parse_FSMLDFollow, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDFollow) + 7) / 4;
		FSMLDFollow *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->addedExitHandlers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDFollow[4]);
		pTemp->addedExitHandlers = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDRunIntoDoor
#define TYPE_parse_FSMLDRunIntoDoor FSMLDRunIntoDoor
ParseTable parse_FSMLDRunIntoDoor[] =
{
	{ "FSMLDRunIntoDoor", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDRunIntoDoor), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "type",						TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDRunIntoDoor, baseData.type, FSM_LDT_RUNINTODOOR), fsmLocalDataTypeEnum },
	{ "key",						TOK_AUTOINT(FSMLDRunIntoDoor, baseData.key, 0), NULL },
	{ "myDoorPos",					TOK_VEC3(FSMLDRunIntoDoor, myDoorPos), NULL },
	{ "addedExitHandlers",			TOK_BIT, 0, 8, NULL},
	{ "finishedRunningIntoDoor",	TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDRunIntoDoor()
{
	int iSize = sizeof(FSMLDRunIntoDoor);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDRunIntoDoor, iSize, "FSMLDRunIntoDoor", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDRunIntoDoor", parse_FSMLDRunIntoDoor, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDRunIntoDoor) + 7) / 4;
		FSMLDRunIntoDoor *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->addedExitHandlers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDRunIntoDoor[5]);
		pTemp->addedExitHandlers = 0;
		pTemp->finishedRunningIntoDoor = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDRunIntoDoor[6]);
		pTemp->finishedRunningIntoDoor = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDRunOutOfDoor
#define TYPE_parse_FSMLDRunOutOfDoor FSMLDRunOutOfDoor
ParseTable parse_FSMLDRunOutOfDoor[] =
{
	{ "FSMLDRunOutOfDoor", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDRunOutOfDoor), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "type",						TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDRunOutOfDoor, baseData.type, FSM_LDT_RUNOUTOFDOOR), fsmLocalDataTypeEnum },
	{ "key",						TOK_AUTOINT(FSMLDRunOutOfDoor, baseData.key, 0), NULL },
	{ "myDoorPos",					TOK_VEC3(FSMLDRunOutOfDoor, myDoorPos), NULL },
	{ "finishedRunningOutOfDoor",	TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDRunOutOfDoor()
{
	int iSize = sizeof(FSMLDRunOutOfDoor);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDRunOutOfDoor, iSize, "FSMLDRunOutOfDoor", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDRunOutOfDoor", parse_FSMLDRunOutOfDoor, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDRunOutOfDoor) + 7) / 4;
		FSMLDRunOutOfDoor *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->finishedRunningOutOfDoor = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDRunOutOfDoor[5]);
		pTemp->finishedRunningOutOfDoor = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDRunToPoint
#define TYPE_parse_FSMLDRunToPoint FSMLDRunToPoint
ParseTable parse_FSMLDRunToPoint[] =
{
	{ "FSMLDRunToPoint", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDRunToPoint), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "type",				TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDRunToPoint, baseData.type, FSM_LDT_RUNTOPOINT), fsmLocalDataTypeEnum },
	{ "key",				TOK_AUTOINT(FSMLDRunToPoint, baseData.key, 0), NULL },
	{ "addedExitHandlers",	TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDRunToPoint()
{
	int iSize = sizeof(FSMLDRunToPoint);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDRunToPoint, iSize, "FSMLDRunToPoint", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDRunToPoint", parse_FSMLDRunToPoint, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDRunToPoint) + 7) / 4;
		FSMLDRunToPoint *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->addedExitHandlers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDRunToPoint[4]);
		pTemp->addedExitHandlers = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDRetreat
#define TYPE_parse_FSMLDRetreat FSMLDRetreat
ParseTable parse_FSMLDRetreat[] =
{
	{ "FSMLDRetreat", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDRetreat), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "type",				TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDRetreat, baseData.type, FSM_LDT_RETREAT), fsmLocalDataTypeEnum },
	{ "key",				TOK_AUTOINT(FSMLDRetreat, baseData.key, 0), NULL },
	{ "addedExitHandlers",	TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDRetreat()
{
	int iSize = sizeof(FSMLDRetreat);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDRetreat, iSize, "FSMLDRetreat", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDRetreat", parse_FSMLDRetreat, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDRetreat) + 7) / 4;
		FSMLDRetreat *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->addedExitHandlers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDRetreat[4]);
		pTemp->addedExitHandlers = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDSendMessage
#define TYPE_parse_FSMLDSendMessage FSMLDSendMessage
ParseTable parse_FSMLDSendMessage[] =
{
	{ "FSMLDSendMessage", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDSendMessage), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "type",				TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDSendMessage, baseData.type, FSM_LDT_SENDMESSAGE), fsmLocalDataTypeEnum },
	{ "key",				TOK_AUTOINT(FSMLDSendMessage, baseData.key, 0), NULL },
	{ "handle",				TOK_AUTOINT(FSMLDSendMessage, handle, 0), NULL },
	{ "animOn",				TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDSendMessage()
{
	int iSize = sizeof(FSMLDSendMessage);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDSendMessage, iSize, "FSMLDSendMessage", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDSendMessage", parse_FSMLDSendMessage, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDSendMessage) + 7) / 4;
		FSMLDSendMessage *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->animOn = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDSendMessage[5]);
		pTemp->animOn = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDWander
#define TYPE_parse_FSMLDWander FSMLDWander
ParseTable parse_FSMLDWander[] =
{
	{ "FSMLDWander", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDWander), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "type",				TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDWander, baseData.type, FSM_LDT_WANDER), fsmLocalDataTypeEnum },
	{ "key",				TOK_AUTOINT(FSMLDWander, baseData.key, 0), NULL },
	{ "wanderHomePos",		TOK_VEC3(FSMLDWander, wanderHomePos), NULL },
	{ "wanderDistSQR",		TOK_F32(FSMLDWander, wanderDistSQR, 0), NULL },
	{ "wanderIdleTimeAvg",	TOK_F32(FSMLDWander, wanderIdleTimeAvg, 0), NULL },
	{ "lastPathFindTime",	TOK_AUTOINT(FSMLDWander, lastPathFindTime, 0), NULL },
	{ "wanderState",		TOK_AUTOINT(FSMLDWander, wanderState, 0), NULL },
	{ "wanderMaxPath",		TOK_AUTOINT(FSMLDWander, wanderMaxPath, 0), NULL },
	{ "addedExitHandlers",	TOK_BIT, 0, 8, NULL},
	{ "airWander",			TOK_BIT, 0, 8, NULL},
	{ "spawnRelative",		TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDWander()
{
	int iSize = sizeof(FSMLDWander);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDWander, iSize, "FSMLDWander", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDWander", parse_FSMLDWander, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDWander) + 7) / 4;
		FSMLDWander *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->addedExitHandlers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDWander[10]);
		pTemp->addedExitHandlers = 0;
		pTemp->airWander = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDWander[11]);
		pTemp->airWander = 0;
		pTemp->spawnRelative = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDWander[12]);
		pTemp->spawnRelative = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDGrievedHeal
#define TYPE_parse_FSMLDGrievedHeal FSMLDGrievedHeal
ParseTable parse_FSMLDGrievedHeal[] =
{
	{ "FSMLDGrievedHeal", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDGrievedHeal), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "type",				TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDGrievedHeal, baseData.type, FSM_LDT_GRIEVEDHEAL), fsmLocalDataTypeEnum },
	{ "key",				TOK_AUTOINT(FSMLDGrievedHeal, baseData.key, 0), NULL },
	{ "addedExitHandlers",	TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDGrievedHeal()
{
	int iSize = sizeof(FSMLDGrievedHeal);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDGrievedHeal, iSize, "FSMLDGrievedHeal", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDGrievedHeal", parse_FSMLDGrievedHeal, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDGrievedHeal) + 7) / 4;
		FSMLDGrievedHeal *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->addedExitHandlers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDGrievedHeal[4]);
		pTemp->addedExitHandlers = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDMastermindPursue
#define TYPE_parse_FSMLDMastermindPursue FSMLDMastermindPursue
ParseTable parse_FSMLDMastermindPursue[] =
{
	{ "FSMLDMastermindPursue", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDMastermindPursue), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "type",					TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDMastermindPursue, baseData.type, FSM_LDT_MMIND_PERSUE), fsmLocalDataTypeEnum },
	{ "key",					TOK_AUTOINT(FSMLDMastermindPursue, baseData.key, 0), NULL },
	{ "leaderRef",				TOK_AUTOINT(FSMLDMastermindPursue, leaderRef, 0), NULL },
	{ "dataSet",				TOK_BIT, 0, 8, NULL},
	{ "addedExitHandlers",		TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDMastermindPursue()
{
	int iSize = sizeof(FSMLDMastermindPursue);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDMastermindPursue, iSize, "FSMLDMastermindPursue", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDMastermindPursue", parse_FSMLDMastermindPursue, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDMastermindPursue) + 7) / 4;
		FSMLDMastermindPursue *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->dataSet = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDMastermindPursue[5]);
		pTemp->dataSet = 0;
		pTemp->addedExitHandlers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDMastermindPursue[6]);
		pTemp->addedExitHandlers = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExprLocalData[];
#define TYPE_parse_ExprLocalData ExprLocalData
//Structparser.exe autogenerated ParseTable for struct FSMLDDisoriented
#define TYPE_parse_FSMLDDisoriented FSMLDDisoriented
ParseTable parse_FSMLDDisoriented[] =
{
	{ "FSMLDDisoriented", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FSMLDDisoriented), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "type",				TOK_OBJECTTYPE | TOK_AUTOINT(FSMLDDisoriented, baseData.type, FSM_LDT_DISORIENTED), fsmLocalDataTypeEnum },
	{ "key",				TOK_AUTOINT(FSMLDDisoriented, baseData.key, 0), NULL },
	{ "DestinationPos",		TOK_VEC3(FSMLDDisoriented, vDestinationPos), NULL },
	{ "JagStartPos",		TOK_VEC3(FSMLDDisoriented, vJagStartPos), NULL },
	{ "addedExitHandlers",	TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
extern ParseTable polyTable_ExprLocalData[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_FSMLDDisoriented()
{
	int iSize = sizeof(FSMLDDisoriented);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FSMLDDisoriented, iSize, "FSMLDDisoriented", NULL, "aiMovement.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_ExprLocalData, "FSMLDDisoriented", parse_FSMLDDisoriented, iSize);
	{
		int iSizeInWords = (sizeof(FSMLDDisoriented) + 7) / 4;
		FSMLDDisoriented *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->addedExitHandlers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_FSMLDDisoriented[6]);
		pTemp->addedExitHandlers = 0;
	}
	return 0;
};
