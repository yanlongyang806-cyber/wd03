#include "textparser.h"

//auto-generated staticdefine for enum enumMapSearchAndPossibilitiesFlags
//autogeneratednocheckin
StaticDefineInt enumMapSearchAndPossibilitiesFlagsEnum[] =
{
	DEFINE_INT
	{ "MAPSEARCH_NOCANCELLING", MAPSEARCH_NOCANCELLING},
	DEFINE_END
};
void autoEnum_fixup_enumMapSearchAndPossibilitiesFlags(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(enumMapSearchAndPossibilitiesFlagsEnum, "enumMapSearchAndPossibilitiesFlags");
}

//auto-generated staticdefine for enum MapSearchType
//autogeneratednocheckin
StaticDefineInt MapSearchTypeEnum[] =
{
	DEFINE_INT
	{ "UNSPECIFIED", MAPSEARCHTYPE_UNSPECIFIED},
	{ "ALL_FOR_DEBUGGING", MAPSEARCHTYPE_ALL_FOR_DEBUGGING},
	{ "OWNED_MAP", MAPSEARCHTYPE_OWNED_MAP},
	{ "ONE_MAPNAME_ALL_CHOICES", MAPSEARCHTYPE_ONE_MAPNAME_ALL_CHOICES},
	{ "SPECIFIC_CONTAINER_AND_PARTITION_ID_ONLY", MAPSEARCHTYPE_SPECIFIC_CONTAINER_AND_PARTITION_ID_ONLY},
	{ "SPECIFIC_PUBLIC_INDEX_ONLY", MAPSEARCHTYPE_SPECIFIC_PUBLIC_INDEX_ONLY},
	{ "SPECIFIC_CONTAINER_AND_PARTITION_ID_OR_OTHER", MAPSEARCHTYPE_SPECIFIC_CONTAINER_AND_PARTITION_ID_OR_OTHER},
	{ "SPECIFIC_PUBLIC_INDEX_OR_OTHER", MAPSEARCHTYPE_SPECIFIC_PUBLIC_INDEX_OR_OTHER},
	{ "NEWPLAYER", MAPSEARCHTYPE_NEWPLAYER},
	{ "NEWPLAYER_SKIPTUTORIAL", MAPSEARCHTYPE_NEWPLAYER_SKIPTUTORIAL},
	{ "FALLBACK_MAP", MAPSEARCHTYPE_FALLBACK_MAP},
	{ "ALL_OWNED_MAPS", MAPSEARCHTYPE_ALL_OWNED_MAPS},
	DEFINE_END
};
void autoEnum_fixup_MapSearchType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(MapSearchTypeEnum, "MapSearchType");
}

//auto-generated staticdefine for enum enumMapSaturation
//autogeneratednocheckin
StaticDefineInt enumMapSaturationEnum[] =
{
	DEFINE_INT
	{ "NONE", MAP_SATURATION_NONE},
	{ "LIGHT", MAP_SATURATION_LIGHT},
	{ "MEDIUM", MAP_SATURATION_MEDIUM},
	{ "HIGH", MAP_SATURATION_HIGH},
	DEFINE_END
};
void autoEnum_fixup_enumMapSaturation(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(enumMapSaturationEnum, "enumMapSaturation");
}

//auto-generated staticdefine for enum MapChoiceType
//autogeneratednocheckin
StaticDefineInt MapChoiceTypeEnum[] =
{
	DEFINE_INT
	{ "UNSPECIFIED", MAPCHOICETYPE_UNSPECIFIED},
	{ "FORCE_NEW", MAPCHOICETYPE_FORCE_NEW},
	{ "NEW_OR_EXISTING_OWNED", MAPCHOICETYPE_NEW_OR_EXISTING_OWNED},
	{ "SPECIFIED_ONLY", MAPCHOICETYPE_SPECIFIED_ONLY},
	{ "SPECIFIED_OR_BEST_FIT", MAPCHOICETYPE_SPECIFIED_OR_BEST_FIT},
	{ "BEST_FIT", MAPCHOICETYPE_BEST_FIT},
	{ "NEW_PARTITION_ON_SPECIFIED_SERVER", MAPCHOICETYPE_NEW_PARTITION_ON_SPECIFIED_SERVER},
	DEFINE_END
};
void autoEnum_fixup_MapChoiceType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(MapChoiceTypeEnum, "MapChoiceType");
}

//auto-generated staticdefine for enum GameServerExeType
//autogeneratednocheckin
StaticDefineInt GameServerExeTypeEnum[] =
{
	DEFINE_INT
	{ "UNSPEC", GSTYPE_UNSPEC},
	{ "INVALID", GSTYPE_INVALID},
	{ "NORMAL", GSTYPE_NORMAL},
	{ "NOT_A_GS", GSTYPE_NOT_A_GS},
	{ "UGC_PLAY", GSTYPE_UGC_PLAY},
	{ "UGC_EDIT", GSTYPE_UGC_EDIT},
	{ "PREEXISTING", GSTYPE_PREEXISTING},
	{ "PRELOAD", GSTYPE_PRELOAD},
	DEFINE_END
};
void autoEnum_fixup_GameServerExeType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(GameServerExeTypeEnum, "GameServerExeType");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct MapDescription
#define TYPE_parse_MapDescription MapDescription
ParseTable parse_MapDescription[] =
{
	{ "MapDescription", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MapDescription), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "MapType",					TOK_AUTOINT(MapDescription, eMapType, 0), ZoneMapTypeEnum },
	{ "ownerType",					TOK_AUTOINT(MapDescription, ownerType, 0), GlobalTypeEnum },
	{ "SpawnPosSkipBeaconCheck",	TOK_AUTOINT(MapDescription, bSpawnPosSkipBeaconCheck, 0), NULL },
	{ "mapDescription",				TOK_POOL_STRING | TOK_STRING(MapDescription, mapDescription, 0), NULL },
	{ "mapDetail",					TOK_POOL_STRING | TOK_STRING(MapDescription, mapDetail, 0), NULL },
	{ "mapVariables",				TOK_POOL_STRING | TOK_STRING(MapDescription, mapVariables, 0), NULL },
	{ "mapInstanceIndex",			TOK_AUTOINT(MapDescription, mapInstanceIndex, 0), NULL },
	{ "ownerID",					TOK_AUTOINT(MapDescription, ownerID, 0), NULL },
	{ "spawnPos",					TOK_USEROPTIONBIT_1 | TOK_VEC3(MapDescription, spawnPos), NULL },
	{ "spawnPYR",					TOK_USEROPTIONBIT_1 | TOK_VEC3(MapDescription, spawnPYR), NULL },
	{ "spawnPoint",					TOK_USEROPTIONBIT_1 | TOK_POOL_STRING | TOK_STRING(MapDescription, spawnPoint, 0), NULL },
	{ "containerID",				TOK_AUTOINT(MapDescription, containerID, 0), NULL },
	{ "UGC",						TOK_AUTOINT(MapDescription, bUGC, 0), NULL },
	{ "UGCEdit",					TOK_AUTOINT(MapDescription, bUGCEdit, 0), NULL },
	{ "UGCProjectID",				TOK_AUTOINT(MapDescription, iUGCProjectID, 0), NULL },
	{ "VirtualShardID",				TOK_AUTOINT(MapDescription, iVirtualShardID, 0), NULL },
	{ "PartitionID",				TOK_AUTOINT(MapDescription, iPartitionID, 0), NULL },
	{ "uPartitionID",				TOK_REDUNDANTNAME | TOK_AUTOINT(MapDescription, iPartitionID, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MapDescription()
{
	int iSize = sizeof(MapDescription);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MapDescription, iSize, "MapDescription", NULL, "MapDescription.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct SavedMapDescription
#define TYPE_parse_SavedMapDescription SavedMapDescription
ParseTable parse_SavedMapDescription[] =
{
	{ "SavedMapDescription", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(SavedMapDescription), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "eMapType",					TOK_PERSIST | TOK_AUTOINT(SavedMapDescription, eMapType, 0), ZoneMapTypeEnum },
	{ "ownerType",					TOK_PERSIST | TOK_AUTOINT(SavedMapDescription, ownerType, 0), GlobalTypeEnum },
	{ "bSpawnPosSkipBeaconCheck",	TOK_PERSIST | TOK_AUTOINT(SavedMapDescription, bSpawnPosSkipBeaconCheck, 0), NULL },
	{ "mapDescription",				TOK_PERSIST | TOK_POOL_STRING | TOK_SUBSCRIBE | TOK_STRING(SavedMapDescription, mapDescription, 0), NULL },
	{ "mapDetail",					TOK_PERSIST | TOK_POOL_STRING | TOK_STRING(SavedMapDescription, mapDetail, 0), NULL },
	{ "mapVariables",				TOK_PERSIST | TOK_POOL_STRING | TOK_SUBSCRIBE | TOK_STRING(SavedMapDescription, mapVariables, 0), NULL },
	{ "mapInstanceIndex",			TOK_PERSIST | TOK_AUTOINT(SavedMapDescription, mapInstanceIndex, 0), NULL },
	{ "ownerID",					TOK_PERSIST | TOK_AUTOINT(SavedMapDescription, ownerID, 0), NULL },
	{ "spawnPos",					TOK_USEROPTIONBIT_1 | TOK_PERSIST | TOK_VEC3(SavedMapDescription, spawnPos), NULL },
	{ "spawnPYR",					TOK_USEROPTIONBIT_1 | TOK_PERSIST | TOK_VEC3(SavedMapDescription, spawnPYR), NULL },
	{ "spawnPoint",					TOK_USEROPTIONBIT_1 | TOK_PERSIST | TOK_POOL_STRING | TOK_STRING(SavedMapDescription, spawnPoint, 0), NULL },
	{ "containerID",				TOK_PERSIST | TOK_AUTOINT(SavedMapDescription, containerID, 0), NULL },
	{ "bUGC",						TOK_AUTOINT(SavedMapDescription, bUGC, 0), NULL },
	{ "bUGCEdit",					TOK_AUTOINT(SavedMapDescription, bUGCEdit, 0), NULL },
	{ "iUGCProjectID",				TOK_AUTOINT(SavedMapDescription, iUGCProjectID, 0), NULL },
	{ "iVirtualShardID",			TOK_AUTOINT(SavedMapDescription, iVirtualShardID, 0), NULL },
	{ "iPartitionID",				TOK_PERSIST | TOK_AUTOINT(SavedMapDescription, iPartitionID, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_SavedMapDescription()
{
	int iSize = sizeof(SavedMapDescription);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_SavedMapDescription, iSize, "SavedMapDescription", NULL, "MapDescription.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct obsolete_SavedMapDescription
#define TYPE_parse_obsolete_SavedMapDescription obsolete_SavedMapDescription
ParseTable parse_obsolete_SavedMapDescription[] =
{
	{ "obsolete_SavedMapDescription", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(obsolete_SavedMapDescription), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "eMapType",						TOK_PERSIST | TOK_AUTOINT(obsolete_SavedMapDescription, eMapType, 0), ZoneMapTypeEnum },
	{ "ownerType",						TOK_PERSIST | TOK_AUTOINT(obsolete_SavedMapDescription, ownerType, 0), GlobalTypeEnum },
	{ "mapDescription",					TOK_PERSIST | TOK_POOL_STRING | TOK_STRING(obsolete_SavedMapDescription, mapDescription, 0), NULL },
	{ "mapDetail",						TOK_PERSIST | TOK_POOL_STRING | TOK_STRING(obsolete_SavedMapDescription, mapDetail, 0), NULL },
	{ "mapVariables",					TOK_PERSIST | TOK_POOL_STRING | TOK_SUBSCRIBE | TOK_STRING(obsolete_SavedMapDescription, mapVariables, 0), NULL },
	{ "mapInstanceIndex",				TOK_PERSIST | TOK_AUTOINT(obsolete_SavedMapDescription, mapInstanceIndex, 0), NULL },
	{ "ownerID",						TOK_PERSIST | TOK_AUTOINT(obsolete_SavedMapDescription, ownerID, 0), NULL },
	{ "spawnPos",						TOK_USEROPTIONBIT_1 | TOK_PERSIST | TOK_VEC3(obsolete_SavedMapDescription, spawnPos), NULL },
	{ "spawnRot",						TOK_USEROPTIONBIT_1 | TOK_PERSIST | TOK_QUATPYR(obsolete_SavedMapDescription, spawnRot), NULL },
	{ "spawnPoint",						TOK_USEROPTIONBIT_1 | TOK_PERSIST | TOK_POOL_STRING | TOK_STRING(obsolete_SavedMapDescription, spawnPoint, 0), NULL },
	{ "containerID",					TOK_PERSIST | TOK_AUTOINT(obsolete_SavedMapDescription, containerID, 0), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_obsolete_SavedMapDescription()
{
	int iSize = sizeof(obsolete_SavedMapDescription);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_obsolete_SavedMapDescription, iSize, "obsolete_SavedMapDescription", NULL, "MapDescription.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DynamicPatchInfo
#define TYPE_parse_DynamicPatchInfo DynamicPatchInfo
ParseTable parse_DynamicPatchInfo[] =
{
	{ "DynamicPatchInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynamicPatchInfo), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Server",				TOK_STRING(DynamicPatchInfo, pServer, 0), NULL },
	{ "Port",				TOK_AUTOINT(DynamicPatchInfo, iPort, 0), NULL },
	{ "Prefix",				TOK_STRING(DynamicPatchInfo, pPrefix, 0), NULL },
	{ "ClientProject",		TOK_STRING(DynamicPatchInfo, pClientProject, 0), NULL },
	{ "ServerProject",		TOK_STRING(DynamicPatchInfo, pServerProject, 0), NULL },
	{ "UploadProject",		TOK_STRING(DynamicPatchInfo, pUploadProject, 0), NULL },
	{ "ResourceProject",	TOK_STRING(DynamicPatchInfo, pResourceProject, 0), NULL },
	{ "Branch",				TOK_AUTOINT(DynamicPatchInfo, iBranch, 0), NULL },
	{ "ViewName",			TOK_STRING(DynamicPatchInfo, pViewName, 0), NULL },
	{ "Timeout",			TOK_AUTOINT(DynamicPatchInfo, iTimeout, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DynamicPatchInfo()
{
	int iSize = sizeof(DynamicPatchInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynamicPatchInfo, iSize, "DynamicPatchInfo", NULL, "MapDescription.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct GameServerDescription_UgcStuff
#define TYPE_parse_GameServerDescription_UgcStuff GameServerDescription_UgcStuff
ParseTable parse_GameServerDescription_UgcStuff[] =
{
	{ "GameServerDescription_UgcStuff", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(GameServerDescription_UgcStuff), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "UgcUUID",						TOK_FIXEDSTR(GameServerDescription_UgcStuff, UgcUUID), NULL },
	{ "OwnerAccountID",					TOK_AUTOINT(GameServerDescription_UgcStuff, iOwnerAccountID, 0), NULL },
	{ "OwnerAccountName",				TOK_STRING(GameServerDescription_UgcStuff, pOwnerAccountName, 0), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_GameServerDescription_UgcStuff()
{
	int iSize = sizeof(GameServerDescription_UgcStuff);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_GameServerDescription_UgcStuff, iSize, "GameServerDescription_UgcStuff", NULL, "MapDescription.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_MapDescription[];
#define TYPE_parse_MapDescription MapDescription
extern ParseTable parse_GameServerDescription_UgcStuff[];
#define TYPE_parse_GameServerDescription_UgcStuff GameServerDescription_UgcStuff
extern ParseTable parse_DynamicPatchInfo[];
#define TYPE_parse_DynamicPatchInfo DynamicPatchInfo
//Structparser.exe autogenerated ParseTable for struct GameServerDescription
#define TYPE_parse_GameServerDescription GameServerDescription
ParseTable parse_GameServerDescription[] =
{
	{ "GameServerDescription", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(GameServerDescription), 0, NULL, 0, NULL },
	{ "{",										TOK_START, 0 },
	{ "DescriptionIsActive",					TOK_AUTOINT(GameServerDescription, bDescriptionIsActive, 0), NULL },
	{ "baseMapDescription",						TOK_EMBEDDEDSTRUCT(GameServerDescription, baseMapDescription, parse_MapDescription)},
	{ "MapPort",								TOK_AUTOINT(GameServerDescription, iMapPort, 0), NULL },
	{ "EditMode",								TOK_AUTOINT(GameServerDescription, bEditMode, 0), NULL },
	{ "AllowInstanceSwitchingBetweenOwnedMaps",	TOK_AUTOINT(GameServerDescription, bAllowInstanceSwitchingBetweenOwnedMaps, 0), NULL },
	{ "ExpectedMaxPlayers",						TOK_AUTOINT(GameServerDescription, iExpectedMaxPlayers, 0), NULL },
	{ "ugcStuff",								TOK_EMBEDDEDSTRUCT(GameServerDescription, ugcStuff, parse_GameServerDescription_UgcStuff)},
	{ "patchInfo",								TOK_OPTIONALSTRUCT(GameServerDescription, patchInfo, parse_DynamicPatchInfo) },
	{ "}",										TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_GameServerDescription()
{
	int iSize = sizeof(GameServerDescription);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_GameServerDescription, iSize, "GameServerDescription", NULL, "MapDescription.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_MapDescription[];
#define TYPE_parse_MapDescription MapDescription
extern ParseTable parse_AccountProxyKeyValueInfoList[];
#define TYPE_parse_AccountProxyKeyValueInfoList AccountProxyKeyValueInfoList
//Structparser.exe autogenerated ParseTable for struct MapSearchInfo
#define TYPE_parse_MapSearchInfo MapSearchInfo
ParseTable parse_MapSearchInfo[] =
{
	{ "MapSearchInfo", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MapSearchInfo), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "baseMapDescription",			TOK_EMBEDDEDSTRUCT(MapSearchInfo, baseMapDescription, parse_MapDescription)},
	{ "playerType",					TOK_AUTOINT(MapSearchInfo, playerType, 0), GlobalTypeEnum },
	{ "playerID",					TOK_AUTOINT(MapSearchInfo, playerID, 0), NULL },
	{ "GuildID",					TOK_AUTOINT(MapSearchInfo, iGuildID, 0), NULL },
	{ "teamID",						TOK_AUTOINT(MapSearchInfo, teamID, 0), NULL },
	{ "playerAccountID",			TOK_AUTOINT(MapSearchInfo, playerAccountID, 0), NULL },
	{ "developerAllStatic",			TOK_BIT, 0, 8, NULL},
	{ "debugPosLogin",				TOK_BIT, 0, 8, NULL},
	{ "newCharacter",				TOK_BIT, 0, 8, NULL},
	{ "ExpectedTrasferFromShardNS",	TOK_BIT, 0, 8, NULL},
	{ "requestFallback",			TOK_BIT, 0, 8, NULL},
	{ "overSoftCapOK",				TOK_BIT, 0, 8, NULL},
	{ "safeLogin",					TOK_BIT, 0, 8, NULL},
	{ "NoNewOwned",					TOK_BIT, 0, 8, NULL},
	{ "SkipTutorial",				TOK_BIT, 0, 8, NULL},
	{ "AllVirtualShards",			TOK_BIT, 0, 8, NULL},
	{ "ShowFullMapsAsDisabled",		TOK_BIT, 0, 8, NULL},
	{ "Flags",						TOK_AUTOINT(MapSearchInfo, eFlags, 0), enumMapSearchAndPossibilitiesFlagsEnum },
	{ "gameServerIDToExclude",		TOK_AUTOINT(MapSearchInfo, gameServerIDToExclude, 0), NULL },
	{ "AccountPermissions",			TOK_OPTIONALSTRUCT(MapSearchInfo, pAccountPermissions, parse_AccountProxyKeyValueInfoList) },
	{ "AccessLevel",				TOK_AUTOINT(MapSearchInfo, iAccessLevel, 0), NULL },
	{ "UGCProjectID",				TOK_AUTOINT(MapSearchInfo, iUGCProjectID, 0), NULL },
	{ "UGCNameSpace",				TOK_STRING(MapSearchInfo, pUGCNameSpace, 0), NULL },
	{ "SearchType",					TOK_AUTOINT(MapSearchInfo, eSearchType, 0), MapSearchTypeEnum },
	{ "AccountName",				TOK_STRING(MapSearchInfo, pAccountName, 0), NULL },
	{ "PlayerName",					TOK_STRING(MapSearchInfo, pPlayerName, 0), NULL },
	{ "Allegiance",					TOK_STRING(MapSearchInfo, pAllegiance, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_MapSearchInfo()
{
	int iSize = sizeof(MapSearchInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MapSearchInfo, iSize, "MapSearchInfo", NULL, "MapDescription.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(MapSearchInfo) + 7) / 4;
		MapSearchInfo *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->developerAllStatic = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MapSearchInfo[8]);
		pTemp->developerAllStatic = 0;
		pTemp->debugPosLogin = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MapSearchInfo[9]);
		pTemp->debugPosLogin = 0;
		pTemp->newCharacter = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MapSearchInfo[10]);
		pTemp->newCharacter = 0;
		pTemp->bExpectedTrasferFromShardNS = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MapSearchInfo[11]);
		pTemp->bExpectedTrasferFromShardNS = 0;
		pTemp->requestFallback = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MapSearchInfo[12]);
		pTemp->requestFallback = 0;
		pTemp->overSoftCapOK = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MapSearchInfo[13]);
		pTemp->overSoftCapOK = 0;
		pTemp->safeLogin = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MapSearchInfo[14]);
		pTemp->safeLogin = 0;
		pTemp->bNoNewOwned = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MapSearchInfo[15]);
		pTemp->bNoNewOwned = 0;
		pTemp->bSkipTutorial = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MapSearchInfo[16]);
		pTemp->bSkipTutorial = 0;
		pTemp->bAllVirtualShards = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MapSearchInfo[17]);
		pTemp->bAllVirtualShards = 0;
		pTemp->bShowFullMapsAsDisabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MapSearchInfo[18]);
		pTemp->bShowFullMapsAsDisabled = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DynamicPatchInfo[];
#define TYPE_parse_DynamicPatchInfo DynamicPatchInfo
//Structparser.exe autogenerated ParseTable for struct PossibleMapChoice
#define TYPE_parse_PossibleMapChoice PossibleMapChoice
ParseTable parse_PossibleMapChoice[] =
{
	{ "PossibleMapChoice", 								TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PossibleMapChoice), 0, NULL, 0, NULL },
	{ "{",												TOK_START, 0 },
	{ "ChoiceType",										TOK_AUTOINT(PossibleMapChoice, eChoiceType, 0), MapChoiceTypeEnum },
	{ "NumPlayers",										TOK_AUTOINT(PossibleMapChoice, iNumPlayers, 0), NULL },
	{ "saturation",										TOK_BIT, 0, 8, enumMapSaturationEnum},
	{ "LastMap",										TOK_BIT, 0, 8, NULL},
	{ "DebugLogin",										TOK_BIT, 0, 8, NULL},
	{ "NewMap",											TOK_BIT, 0, 8, NULL},
	{ "EditMap",										TOK_BIT, 0, 8, NULL},
	{ "MapIsLoading",									TOK_BIT, 0, 8, NULL},
	{ "NotALegalChoice",								TOK_BIT, 0, 8, NULL},
	{ "YourTeamLeaderIsThere",							TOK_USEROPTIONBIT_1 | TOK_BIT, 0, 8, NULL},
	{ "PossiblyNewStatic",								TOK_BIT, 0, 8, NULL},
	{ "NewCharacterSpawn",								TOK_BIT, 0, 8, NULL},
	{ "GoWhereATeammateRecentlyWentInsteadIfPossible",	TOK_BIT, 0, 8, NULL},
	{ "IsHardFull",										TOK_BIT, 0, 8, NULL},
	{ "IsSoftFull",										TOK_BIT, 0, 8, NULL},
	{ "IsCurrent",										TOK_BIT, 0, 8, NULL},
	{ "NumTeamMembersThere",							TOK_USEROPTIONBIT_1 | TOK_AUTOINT(PossibleMapChoice, iNumTeamMembersThere, 0), NULL },
	{ "NumGuildMembersThere",							TOK_USEROPTIONBIT_1 | TOK_AUTOINT(PossibleMapChoice, iNumGuildMembersThere, 0), NULL },
	{ "NumFriendsThere",								TOK_USEROPTIONBIT_1 | TOK_AUTOINT(PossibleMapChoice, iNumFriendsThere, 0), NULL },
	{ "baseMapDescription", 								TOK_IGNORE | TOK_FLATEMBED },
	{ "MapType",										TOK_AUTOINT(PossibleMapChoice, baseMapDescription.eMapType, 0), ZoneMapTypeEnum },
	{ "ownerType",										TOK_AUTOINT(PossibleMapChoice, baseMapDescription.ownerType, 0), GlobalTypeEnum },
	{ "SpawnPosSkipBeaconCheck",						TOK_AUTOINT(PossibleMapChoice, baseMapDescription.bSpawnPosSkipBeaconCheck, 0), NULL },
	{ "mapDescription",									TOK_POOL_STRING | TOK_STRING(PossibleMapChoice, baseMapDescription.mapDescription, 0), NULL },
	{ "mapDetail",										TOK_POOL_STRING | TOK_STRING(PossibleMapChoice, baseMapDescription.mapDetail, 0), NULL },
	{ "mapVariables",									TOK_POOL_STRING | TOK_STRING(PossibleMapChoice, baseMapDescription.mapVariables, 0), NULL },
	{ "mapInstanceIndex",								TOK_AUTOINT(PossibleMapChoice, baseMapDescription.mapInstanceIndex, 0), NULL },
	{ "ownerID",										TOK_AUTOINT(PossibleMapChoice, baseMapDescription.ownerID, 0), NULL },
	{ "spawnPos",										TOK_USEROPTIONBIT_1 | TOK_VEC3(PossibleMapChoice, baseMapDescription.spawnPos), NULL },
	{ "spawnPYR",										TOK_USEROPTIONBIT_1 | TOK_VEC3(PossibleMapChoice, baseMapDescription.spawnPYR), NULL },
	{ "spawnPoint",										TOK_USEROPTIONBIT_1 | TOK_POOL_STRING | TOK_STRING(PossibleMapChoice, baseMapDescription.spawnPoint, 0), NULL },
	{ "containerID",									TOK_AUTOINT(PossibleMapChoice, baseMapDescription.containerID, 0), NULL },
	{ "UGC",											TOK_AUTOINT(PossibleMapChoice, baseMapDescription.bUGC, 0), NULL },
	{ "UGCEdit",										TOK_AUTOINT(PossibleMapChoice, baseMapDescription.bUGCEdit, 0), NULL },
	{ "UGCProjectID",									TOK_AUTOINT(PossibleMapChoice, baseMapDescription.iUGCProjectID, 0), NULL },
	{ "VirtualShardID",									TOK_AUTOINT(PossibleMapChoice, baseMapDescription.iVirtualShardID, 0), NULL },
	{ "PartitionID",									TOK_AUTOINT(PossibleMapChoice, baseMapDescription.iPartitionID, 0), NULL },
	{ "uPartitionID",									TOK_REDUNDANTNAME | TOK_AUTOINT(PossibleMapChoice, baseMapDescription.iPartitionID, 0), NULL },
	{ "newMapReason",									TOK_FIXEDSTR(PossibleMapChoice, newMapReason), NULL },
	{ "notLegalChoiceReason",							TOK_FIXEDSTR(PossibleMapChoice, notLegalChoiceReason), NULL },
	{ "patchInfo",										TOK_OPTIONALSTRUCT(PossibleMapChoice, patchInfo, parse_DynamicPatchInfo) },
	{ "}",												TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PossibleMapChoice()
{
	int iSize = sizeof(PossibleMapChoice);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PossibleMapChoice, iSize, "PossibleMapChoice", NULL, "MapDescription.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PossibleMapChoice) + 7) / 4;
		PossibleMapChoice *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->saturation = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PossibleMapChoice[4]);
		pTemp->saturation = 0;
		pTemp->bLastMap = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PossibleMapChoice[5]);
		pTemp->bLastMap = 0;
		pTemp->bDebugLogin = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PossibleMapChoice[6]);
		pTemp->bDebugLogin = 0;
		pTemp->bNewMap = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PossibleMapChoice[7]);
		pTemp->bNewMap = 0;
		pTemp->bEditMap = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PossibleMapChoice[8]);
		pTemp->bEditMap = 0;
		pTemp->bMapIsLoading = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PossibleMapChoice[9]);
		pTemp->bMapIsLoading = 0;
		pTemp->bNotALegalChoice = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PossibleMapChoice[10]);
		pTemp->bNotALegalChoice = 0;
		pTemp->bYourTeamLeaderIsThere = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PossibleMapChoice[11]);
		pTemp->bYourTeamLeaderIsThere = 0;
		pTemp->bPossiblyNewStatic = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PossibleMapChoice[12]);
		pTemp->bPossiblyNewStatic = 0;
		pTemp->bNewCharacterSpawn = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PossibleMapChoice[13]);
		pTemp->bNewCharacterSpawn = 0;
		pTemp->bGoWhereATeammateRecentlyWentInsteadIfPossible = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PossibleMapChoice[14]);
		pTemp->bGoWhereATeammateRecentlyWentInsteadIfPossible = 0;
		pTemp->bIsHardFull = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PossibleMapChoice[15]);
		pTemp->bIsHardFull = 0;
		pTemp->bIsSoftFull = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PossibleMapChoice[16]);
		pTemp->bIsSoftFull = 0;
		pTemp->bIsCurrent = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PossibleMapChoice[17]);
		pTemp->bIsCurrent = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PossibleMapChoice[];
#define TYPE_parse_PossibleMapChoice PossibleMapChoice
//Structparser.exe autogenerated ParseTable for struct PossibleMapChoices
#define TYPE_parse_PossibleMapChoices PossibleMapChoices
ParseTable parse_PossibleMapChoices[] =
{
	{ "PossibleMapChoices", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PossibleMapChoices), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Flags",				TOK_AUTOINT(PossibleMapChoices, eFlags, 0), enumMapSearchAndPossibilitiesFlagsEnum },
	{ "Choices",			TOK_STRUCT(PossibleMapChoices, ppChoices, parse_PossibleMapChoice) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PossibleMapChoices()
{
	int iSize = sizeof(PossibleMapChoices);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PossibleMapChoices, iSize, "PossibleMapChoices", NULL, "MapDescription.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ReturnedGameServerAddress
#define TYPE_parse_ReturnedGameServerAddress ReturnedGameServerAddress
ParseTable parse_ReturnedGameServerAddress[] =
{
	{ "ReturnedGameServerAddress", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ReturnedGameServerAddress), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "ContainerID",				TOK_AUTOINT(ReturnedGameServerAddress, iContainerID, 0), NULL },
	{ "uPartitionID",				TOK_AUTOINT(ReturnedGameServerAddress, uPartitionID, 0), NULL },
	{ "InstanceIndex",				TOK_AUTOINT(ReturnedGameServerAddress, iInstanceIndex, 0), NULL },
	{ "IPs",						TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(ReturnedGameServerAddress, iIPs), NULL },
	{ "PortNum",					TOK_AUTOINT(ReturnedGameServerAddress, iPortNum, 0), NULL },
	{ "Cookie",						TOK_AUTOINT(ReturnedGameServerAddress, iCookie, 0), NULL },
	{ "errorString",				TOK_FIXEDSTR(ReturnedGameServerAddress, errorString), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ReturnedGameServerAddress()
{
	int iSize = sizeof(ReturnedGameServerAddress);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ReturnedGameServerAddress, iSize, "ReturnedGameServerAddress", NULL, "MapDescription.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct MapPartitionSummary
#define TYPE_parse_MapPartitionSummary MapPartitionSummary
ParseTable parse_MapPartitionSummary[] =
{
	{ "MapPartitionSummary", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MapPartitionSummary), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "uPartitionID",					TOK_AUTOINT(MapPartitionSummary, uPartitionID, 0), NULL },
	{ "MapVariables",					TOK_STRING(MapPartitionSummary, pMapVariables, 0), NULL },
	{ "VirtualShardID",					TOK_AUTOINT(MapPartitionSummary, iVirtualShardID, 0), NULL },
	{ "PublicIndex",					TOK_AUTOINT(MapPartitionSummary, iPublicIndex, 0), NULL },
	{ "OwnerType",						TOK_AUTOINT(MapPartitionSummary, eOwnerType, 0), GlobalTypeEnum },
	{ "OwnerID",						TOK_AUTOINT(MapPartitionSummary, iOwnerID, 0), NULL },
	{ "NumPlayers",						TOK_AUTOINT(MapPartitionSummary, iNumPlayers, 0), NULL },
	{ "NumPlayersRecentlyLoggingIn",	TOK_AUTOINT(MapPartitionSummary, iNumPlayersRecentlyLoggingIn, 0), NULL },
	{ "LastTimeSendPlayerThere",		TOK_AUTOINT(MapPartitionSummary, iLastTimeSendPlayerThere, 0), NULL , 0 , "HTML_SECS_AGO_SHORT = 1"},
	{ "AssignedOpenInstance",			TOK_BIT, 0, 8, NULL},
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_MapPartitionSummary()
{
	int iSize = sizeof(MapPartitionSummary);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MapPartitionSummary, iSize, "MapPartitionSummary", NULL, "MapDescription.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(MapPartitionSummary) + 7) / 4;
		MapPartitionSummary *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bAssignedOpenInstance = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MapPartitionSummary[11]);
		pTemp->bAssignedOpenInstance = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_MapPartitionSummary[];
#define TYPE_parse_MapPartitionSummary MapPartitionSummary
//Structparser.exe autogenerated ParseTable for struct GameServerExe_Description
#define TYPE_parse_GameServerExe_Description GameServerExe_Description
ParseTable parse_GameServerExe_Description[] =
{
	{ "GameServerExe_Description", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(GameServerExe_Description), 0, NULL, 0, "HTML_DEF_FIELDS_TO_SHOW = \"MapDescription, Type\""},
	{ "{",										TOK_START, 0 },
	{ "ServerType",								TOK_AUTOINT(GameServerExe_Description, eServerType, 0), GameServerExeTypeEnum },
	{ "MapType",								TOK_AUTOINT(GameServerExe_Description, eMapType, 0), ZoneMapTypeEnum },
	{ "MapDescription",							TOK_POOL_STRING | TOK_STRING(GameServerExe_Description, pMapDescription, 0), NULL },
	{ "ListeningPortNum",						TOK_AUTOINT(GameServerExe_Description, iListeningPortNum, 0), NULL },
	{ "UGCProjectID",							TOK_AUTOINT(GameServerExe_Description, iUGCProjectID, 0), NULL },
	{ "AllowInstanceSwitchingBetweenOwnedMaps",	TOK_AUTOINT(GameServerExe_Description, bAllowInstanceSwitchingBetweenOwnedMaps, 0), NULL },
	{ "Partitions",								TOK_STRUCT(GameServerExe_Description, ppPartitions, parse_MapPartitionSummary) },
	{ "}",										TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_GameServerExe_Description()
{
	int iSize = sizeof(GameServerExe_Description);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_GameServerExe_Description, iSize, "GameServerExe_Description", NULL, "MapDescription.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_GameServerExe_Description[];
#define TYPE_parse_GameServerExe_Description GameServerExe_Description
//Structparser.exe autogenerated ParseTable for struct GSDescription_And_ZoneMapInfo
#define TYPE_parse_GSDescription_And_ZoneMapInfo GSDescription_And_ZoneMapInfo
ParseTable parse_GSDescription_And_ZoneMapInfo[] =
{
	{ "GSDescription_And_ZoneMapInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(GSDescription_And_ZoneMapInfo), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "Description",					TOK_OPTIONALSTRUCT(GSDescription_And_ZoneMapInfo, pDescription, parse_GameServerExe_Description) },
	{ "ZoneMapInfo",					TOK_OPTIONALLATEBINDSTRUCT(GSDescription_And_ZoneMapInfo, pZoneMapInfo) },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_GSDescription_And_ZoneMapInfo()
{
	int iSize = sizeof(GSDescription_And_ZoneMapInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_GSDescription_And_ZoneMapInfo, iSize, "GSDescription_And_ZoneMapInfo", NULL, "MapDescription.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_GSDescription_And_ZoneMapInfo(void)
{
	DoAutoStructLateBind(parse_GSDescription_And_ZoneMapInfo, 3, "ZoneMapInfo");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct NewOrExistingGameServerAddressRequesterInfo
#define TYPE_parse_NewOrExistingGameServerAddressRequesterInfo NewOrExistingGameServerAddressRequesterInfo
ParseTable parse_NewOrExistingGameServerAddressRequesterInfo[] =
{
	{ "NewOrExistingGameServerAddressRequesterInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(NewOrExistingGameServerAddressRequesterInfo), 0, NULL, 0, NULL },
	{ "{",												TOK_START, 0 },
	{ "RequestingShardName",							TOK_STRING(NewOrExistingGameServerAddressRequesterInfo, pcRequestingShardName, 0), NULL },
	{ "RequestingServerType",							TOK_AUTOINT(NewOrExistingGameServerAddressRequesterInfo, eRequestingServerType, 0), GlobalTypeEnum },
	{ "RequestingServerID",								TOK_AUTOINT(NewOrExistingGameServerAddressRequesterInfo, iRequestingServerID, 0), NULL },
	{ "EntContainerID",									TOK_AUTOINT(NewOrExistingGameServerAddressRequesterInfo, iEntContainerID, 0), NULL },
	{ "RequestingTeamID",								TOK_AUTOINT(NewOrExistingGameServerAddressRequesterInfo, iRequestingTeamID, 0), NULL },
	{ "PlayerName",										TOK_STRING(NewOrExistingGameServerAddressRequesterInfo, pPlayerName, 0), NULL },
	{ "PlayerAccountID",								TOK_AUTOINT(NewOrExistingGameServerAddressRequesterInfo, iPlayerAccountID, 0), NULL },
	{ "PlayerAccountName",								TOK_STRING(NewOrExistingGameServerAddressRequesterInfo, pPlayerAccountName, 0), NULL },
	{ "PlayerLangID",									TOK_AUTOINT(NewOrExistingGameServerAddressRequesterInfo, iPlayerLangID, 0), NULL },
	{ "PlayerIdentificationCookie",						TOK_AUTOINT(NewOrExistingGameServerAddressRequesterInfo, iPlayerIdentificationCookie, 0), NULL },
	{ "}",												TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_NewOrExistingGameServerAddressRequesterInfo()
{
	int iSize = sizeof(NewOrExistingGameServerAddressRequesterInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_NewOrExistingGameServerAddressRequesterInfo, iSize, "NewOrExistingGameServerAddressRequesterInfo", NULL, "MapDescription.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct MapNameAndPopulation
#define TYPE_parse_MapNameAndPopulation MapNameAndPopulation
ParseTable parse_MapNameAndPopulation[] =
{
	{ "MapNameAndPopulation", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MapNameAndPopulation), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "mapName",				TOK_POOL_STRING | TOK_KEY | TOK_STRING(MapNameAndPopulation, mapName, 0), NULL },
	{ "uPlayerCount",			TOK_AUTOINT(MapNameAndPopulation, uPlayerCount, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MapNameAndPopulation()
{
	int iSize = sizeof(MapNameAndPopulation);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MapNameAndPopulation, iSize, "MapNameAndPopulation", NULL, "MapDescription.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_MapNameAndPopulation[];
#define TYPE_parse_MapNameAndPopulation MapNameAndPopulation
//Structparser.exe autogenerated ParseTable for struct MapNameAndPopulationList
#define TYPE_parse_MapNameAndPopulationList MapNameAndPopulationList
ParseTable parse_MapNameAndPopulationList[] =
{
	{ "MapNameAndPopulationList", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MapNameAndPopulationList), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "MapList",					TOK_STRUCT(MapNameAndPopulationList, eaMapList, parse_MapNameAndPopulation) },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MapNameAndPopulationList()
{
	int iSize = sizeof(MapNameAndPopulationList);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MapNameAndPopulationList, iSize, "MapNameAndPopulationList", NULL, "MapDescription.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
