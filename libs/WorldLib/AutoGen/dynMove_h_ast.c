#include "textparser.h"

//auto-generated staticdefine for enum eEaseType
//autogeneratednocheckin
StaticDefineInt eEaseTypeEnum[] =
{
	DEFINE_INT
	{ "Normal", eEaseType_None},
	{ "None", eEaseType_None},
	{ "Slow", eEaseType_Low},
	{ "Low", eEaseType_Low},
	{ "Slower", eEaseType_Medium},
	{ "Medium", eEaseType_Medium},
	{ "Slowest", eEaseType_High},
	{ "High", eEaseType_High},
	{ "Fast", eEaseType_LowInv},
	{ "Faster", eEaseType_MediumInv},
	{ "Fastest", eEaseType_HighInv},
	DEFINE_END
};
void autoEnum_fixup_eEaseType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(eEaseTypeEnum, "eEaseType");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DynAnimInterpolation
#define TYPE_parse_DynAnimInterpolation DynAnimInterpolation
ParseTable parse_DynAnimInterpolation[] =
{
	{ "DynAnimInterpolation", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynAnimInterpolation), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Interpolation",			TOK_F32(DynAnimInterpolation, fInterpolation, 0), NULL },
	{ "EaseIn",					TOK_AUTOINT(DynAnimInterpolation, easeIn, 0), eEaseTypeEnum },
	{ "EaseOut",				TOK_AUTOINT(DynAnimInterpolation, easeOut, 0), eEaseTypeEnum },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DynAnimInterpolation()
{
	int iSize = sizeof(DynAnimInterpolation);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynAnimInterpolation, iSize, "DynAnimInterpolation", NULL, "dynMove.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DynMoveFrameRange
#define TYPE_parse_DynMoveFrameRange DynMoveFrameRange
ParseTable parse_DynMoveFrameRange[] =
{
	{ "DynMoveFrameRange", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynMoveFrameRange), 0, NULL, 0, NULL },
	{ "First",				TOK_STRUCTPARAM | TOK_AUTOINT(DynMoveFrameRange, iFirst, 0), NULL },
	{ "Last",				TOK_STRUCTPARAM | TOK_AUTOINT(DynMoveFrameRange, iLast, 0), NULL },
	{ "\n",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DynMoveFrameRange()
{
	int iSize = sizeof(DynMoveFrameRange);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynMoveFrameRange, iSize, "DynMoveFrameRange", NULL, "dynMove.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DynMoveBoneOffset
#define TYPE_parse_DynMoveBoneOffset DynMoveBoneOffset
ParseTable parse_DynMoveBoneOffset[] =
{
	{ "DynMoveBoneOffset", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynMoveBoneOffset), 0, NULL, 0, NULL },
	{ "BoneName",			TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(DynMoveBoneOffset, pcBoneName, 0), NULL },
	{ "Offset",				TOK_STRUCTPARAM | TOK_VEC3(DynMoveBoneOffset, vOffset), NULL },
	{ "\n",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DynMoveBoneOffset()
{
	int iSize = sizeof(DynMoveBoneOffset);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynMoveBoneOffset, iSize, "DynMoveBoneOffset", NULL, "dynMove.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DynMoveBoneRotOffset
#define TYPE_parse_DynMoveBoneRotOffset DynMoveBoneRotOffset
ParseTable parse_DynMoveBoneRotOffset[] =
{
	{ "DynMoveBoneRotOffset", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynMoveBoneRotOffset), 0, NULL, 0, NULL },
	{ "BoneName",				TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(DynMoveBoneRotOffset, pcBoneName, 0), NULL },
	{ "rotOffset",				TOK_STRUCTPARAM | TOK_VEC3(DynMoveBoneRotOffset, rotOffset), NULL },
	{ "rotOffsetRuntime",		TOK_STRUCTPARAM | TOK_NO_TEXT_SAVE | TOK_QUATPYR(DynMoveBoneRotOffset, rotOffsetRuntime), NULL },
	{ "\n",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DynMoveBoneRotOffset()
{
	int iSize = sizeof(DynMoveBoneRotOffset);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynMoveBoneRotOffset, iSize, "DynMoveBoneRotOffset", NULL, "dynMove.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DynAnimFrameSnapshotBone
#define TYPE_parse_DynAnimFrameSnapshotBone DynAnimFrameSnapshotBone
ParseTable parse_DynAnimFrameSnapshotBone[] =
{
	{ "DynAnimFrameSnapshotBone", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynAnimFrameSnapshotBone), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Name",						TOK_POOL_STRING | TOK_KEY | TOK_STRING(DynAnimFrameSnapshotBone, pcName, 0), NULL },
	{ "qCompressedRot",				TOK_VEC3(DynAnimFrameSnapshotBone, qCompressedRot), NULL },
	{ "Pos",						TOK_VEC3(DynAnimFrameSnapshotBone, vPos), NULL },
	{ "Scale",						TOK_VEC3(DynAnimFrameSnapshotBone, vScale), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DynAnimFrameSnapshotBone()
{
	int iSize = sizeof(DynAnimFrameSnapshotBone);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynAnimFrameSnapshotBone, iSize, "DynAnimFrameSnapshotBone", NULL, "dynMove.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DynAnimFrameSnapshotBoneRotationOnly
#define TYPE_parse_DynAnimFrameSnapshotBoneRotationOnly DynAnimFrameSnapshotBoneRotationOnly
ParseTable parse_DynAnimFrameSnapshotBoneRotationOnly[] =
{
	{ "DynAnimFrameSnapshotBoneRotationOnly", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynAnimFrameSnapshotBoneRotationOnly), 0, NULL, 0, NULL },
	{ "{",										TOK_START, 0 },
	{ "Name",									TOK_POOL_STRING | TOK_KEY | TOK_STRING(DynAnimFrameSnapshotBoneRotationOnly, pcName, 0), NULL },
	{ "qCompressedRot",							TOK_VEC3(DynAnimFrameSnapshotBoneRotationOnly, qCompressedRot), NULL },
	{ "}",										TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DynAnimFrameSnapshotBoneRotationOnly()
{
	int iSize = sizeof(DynAnimFrameSnapshotBoneRotationOnly);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynAnimFrameSnapshotBoneRotationOnly, iSize, "DynAnimFrameSnapshotBoneRotationOnly", NULL, "dynMove.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DynAnimFrameSnapshotBone[];
#define TYPE_parse_DynAnimFrameSnapshotBone DynAnimFrameSnapshotBone
extern ParseTable parse_DynAnimFrameSnapshotBoneRotationOnly[];
#define TYPE_parse_DynAnimFrameSnapshotBoneRotationOnly DynAnimFrameSnapshotBoneRotationOnly
//Structparser.exe autogenerated ParseTable for struct DynAnimFrameSnapshot
#define TYPE_parse_DynAnimFrameSnapshot DynAnimFrameSnapshot
ParseTable parse_DynAnimFrameSnapshot[] =
{
	{ "DynAnimFrameSnapshot", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynAnimFrameSnapshot), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Bones",					TOK_STRUCT(DynAnimFrameSnapshot, eaBones, parse_DynAnimFrameSnapshotBone) },
	{ "BonesRotOnly",			TOK_STRUCT(DynAnimFrameSnapshot, eaBonesRotOnly, parse_DynAnimFrameSnapshotBoneRotationOnly) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DynAnimFrameSnapshot()
{
	int iSize = sizeof(DynAnimFrameSnapshot);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynAnimFrameSnapshot, iSize, "DynAnimFrameSnapshot", NULL, "dynMove.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DynMoveFxEvent
#define TYPE_parse_DynMoveFxEvent DynMoveFxEvent
ParseTable parse_DynMoveFxEvent[] =
{
	{ "DynMoveFxEvent", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynMoveFxEvent), 0, NULL, 0, NULL },
	{ "Fx",				TOK_POOL_STRING | TOK_REQUIRED | TOK_STRING(DynMoveFxEvent, pcFx, 0), NULL },
	{ "Frame",			TOK_AUTOINT(DynMoveFxEvent, uiFrame, 0), NULL },
	{ "uiFrameTrigger",	TOK_NO_TEXT_SAVE | TOK_AUTOINT(DynMoveFxEvent, uiFrameTrigger, 0), NULL },
	{ "Message",		TOK_AUTOINT(DynMoveFxEvent, bMessage, 0), NULL },
	{ "End",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DynMoveFxEvent()
{
	int iSize = sizeof(DynMoveFxEvent);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynMoveFxEvent, iSize, "DynMoveFxEvent", NULL, "dynMove.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DynMoveTag
#define TYPE_parse_DynMoveTag DynMoveTag
ParseTable parse_DynMoveTag[] =
{
	{ "DynMoveTag", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynMoveTag), 0, NULL, 0, NULL },
	{ "Tag",		TOK_POOL_STRING | TOK_STRING(DynMoveTag, pcTag, 0), NULL },
	{ "End",		TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DynMoveTag()
{
	int iSize = sizeof(DynMoveTag);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynMoveTag, iSize, "DynMoveTag", NULL, "dynMove.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DynMoveMatchBaseSkelAnim
#define TYPE_parse_DynMoveMatchBaseSkelAnim DynMoveMatchBaseSkelAnim
ParseTable parse_DynMoveMatchBaseSkelAnim[] =
{
	{ "DynMoveMatchBaseSkelAnim", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynMoveMatchBaseSkelAnim), 0, NULL, 0, NULL },
	{ "BoneName",					TOK_POOL_STRING | TOK_STRING(DynMoveMatchBaseSkelAnim, pcBoneName, 0), NULL },
	{ "BlendInTime",				TOK_F32(DynMoveMatchBaseSkelAnim, fBlendInTime, 0), NULL },
	{ "BlendOutTime",				TOK_F32(DynMoveMatchBaseSkelAnim, fBlendOutTime, 0), NULL },
	{ "PlayBlendOutDuringMove",		TOK_BOOLFLAG(DynMoveMatchBaseSkelAnim, bPlayBlendOutDuringMove, 0), NULL },
	{ "StartFullyBlended",			TOK_BOOLFLAG(DynMoveMatchBaseSkelAnim, bStartFullyBlended, 0), NULL },
	{ "End",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DynMoveMatchBaseSkelAnim()
{
	int iSize = sizeof(DynMoveMatchBaseSkelAnim);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynMoveMatchBaseSkelAnim, iSize, "DynMoveMatchBaseSkelAnim", NULL, "dynMove.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DynAnimFrameSnapshot[];
#define TYPE_parse_DynAnimFrameSnapshot DynAnimFrameSnapshot
extern ParseTable parse_DynMoveFrameRange[];
#define TYPE_parse_DynMoveFrameRange DynMoveFrameRange
extern ParseTable parse_DynMoveBoneOffset[];
#define TYPE_parse_DynMoveBoneOffset DynMoveBoneOffset
extern ParseTable parse_DynMoveBoneRotOffset[];
#define TYPE_parse_DynMoveBoneRotOffset DynMoveBoneRotOffset
//Structparser.exe autogenerated ParseTable for struct DynMoveAnimTrack
#define TYPE_parse_DynMoveAnimTrack DynMoveAnimTrack
ParseTable parse_DynMoveAnimTrack[] =
{
	{ "DynMoveAnimTrack", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynMoveAnimTrack), 0, NULL, 0, NULL },
	{ "First",						TOK_AUTOINT(DynMoveAnimTrack, uiFirst, 0), NULL },
	{ "Last",						TOK_AUTOINT(DynMoveAnimTrack, uiLast, 0), NULL },
	{ "uiFirstFrame",				TOK_NO_TEXT_SAVE | TOK_AUTOINT(DynMoveAnimTrack, uiFirstFrame, 0), NULL },
	{ "uiLastFrame",				TOK_NO_TEXT_SAVE | TOK_AUTOINT(DynMoveAnimTrack, uiLastFrame, 0), NULL },
	{ "StartOffsetFirst",			TOK_AUTOINT(DynMoveAnimTrack, uiStartOffsetFirst, 0), NULL },
	{ "StartOffsetLast",			TOK_AUTOINT(DynMoveAnimTrack, uiStartOffsetLast, 0), NULL },
	{ "uiStartOffsetFirstFrame",	TOK_NO_TEXT_SAVE | TOK_AUTOINT(DynMoveAnimTrack, uiStartOffsetFirstFrame, 0), NULL },
	{ "uiStartOffsetLastFrame",		TOK_NO_TEXT_SAVE | TOK_AUTOINT(DynMoveAnimTrack, uiStartOffsetLastFrame, 0), NULL },
	{ "Offset",						TOK_AUTOINT(DynMoveAnimTrack, uiFrameOffset, 0), NULL },
	{ "frameSnapshot",				TOK_NO_TEXT_SAVE | TOK_EMBEDDEDSTRUCT(DynMoveAnimTrack, frameSnapshot, parse_DynAnimFrameSnapshot)},
	{ "NonInterpFrames",			TOK_STRUCT(DynMoveAnimTrack, eaNoInterpFrameRange, parse_DynMoveFrameRange) },
	{ "BoneOffset",					TOK_STRUCT(DynMoveAnimTrack, eaBoneOffset, parse_DynMoveBoneOffset) },
	{ "BoneRotation",				TOK_STRUCT(DynMoveAnimTrack, eaBoneRotation, parse_DynMoveBoneRotOffset) },
	{ "NoInterp",					TOK_NO_TEXT_SAVE | TOK_AUTOINT(DynMoveAnimTrack, bNoInterp, 0), NULL },
	{ "AnimTrackName",				TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(DynMoveAnimTrack, pcAnimTrackName, 0), NULL },
	{ "Verified",					TOK_NO_TEXT_SAVE | TOK_AUTOINT(DynMoveAnimTrack, bVerified, 0), NULL },
	{ "End",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DynMoveAnimTrack()
{
	int iSize = sizeof(DynMoveAnimTrack);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynMoveAnimTrack, iSize, "DynMoveAnimTrack", NULL, "dynMove.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DynMoveAnimTrack[];
#define TYPE_parse_DynMoveAnimTrack DynMoveAnimTrack
extern ParseTable parse_DynMoveFxEvent[];
#define TYPE_parse_DynMoveFxEvent DynMoveFxEvent
extern ParseTable parse_DynMoveMatchBaseSkelAnim[];
#define TYPE_parse_DynMoveMatchBaseSkelAnim DynMoveMatchBaseSkelAnim
//Structparser.exe autogenerated ParseTable for struct DynMoveSeq
#define TYPE_parse_DynMoveSeq DynMoveSeq
ParseTable parse_DynMoveSeq[] =
{
	{ "DynMoveSeq", 						TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynMoveSeq), 0, NULL, 0, NULL },
	{ "DynMoveSeq",						TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(DynMoveSeq, pcDynMoveSeq, 0), NULL },
	{ "DynAnimTrack",					TOK_EMBEDDEDSTRUCT(DynMoveSeq, dynMoveAnimTrack, parse_DynMoveAnimTrack)},
	{ "DynFxEvent",						TOK_STRUCT(DynMoveSeq, eaDynMoveFxEvents, parse_DynMoveFxEvent) },
	{ "MatchBaseSkelAnim",				TOK_STRUCT(DynMoveSeq, eaMatchBaseSkelAnim, parse_DynMoveMatchBaseSkelAnim) },
	{ "RagdollFrame",					TOK_AUTOINT(DynMoveSeq, uiRagdollFrame, 0), NULL },
	{ "RagdollStartTime",				TOK_NO_TEXT_SAVE | TOK_F32(DynMoveSeq, fRagdollStartTime, 0), NULL },
	{ "RagdollAdditionalGravity",		TOK_F32(DynMoveSeq, fRagdollAdditionalGravity, 0), NULL },
	{ "DisableTorsoPointingTimeout",	TOK_F32(DynMoveSeq, fDisableTorsoPointingTimeout, 0), NULL },
	{ "Speed",							TOK_F32(DynMoveSeq, fSpeed, 1.0f), NULL },
	{ "SpeedLow",						TOK_REDUNDANTNAME | TOK_F32(DynMoveSeq, fSpeed, 1.0f), NULL },
	{ "SpeedHigh",						TOK_F32(DynMoveSeq, fSpeedHigh, 0), NULL },
	{ "IKTarget",						TOK_POOL_STRING | TOK_STRING(DynMoveSeq, pcIKTarget, 0), NULL },
	{ "IKTargetNodeLeft",				TOK_POOL_STRING | TOK_STRING(DynMoveSeq, pcIKTargetNodeLeft, 0), NULL },
	{ "IKTargetNodeRight",				TOK_POOL_STRING | TOK_STRING(DynMoveSeq, pcIKTargetNodeRight, 0), NULL },
	{ "BankMaxAngle",					TOK_F32(DynMoveSeq, fBankMaxAngle, 0), NULL },
	{ "BankScale",						TOK_F32(DynMoveSeq, fBankScale, 0), NULL },
	{ "Distance",						TOK_F32(DynMoveSeq, fDistance, 0), NULL },
	{ "MinRate",						TOK_F32(DynMoveSeq, fMinRate, 0), NULL },
	{ "MaxRate",						TOK_F32(DynMoveSeq, fMaxRate, 0), NULL },
	{ "BlendFrames",					TOK_F32(DynMoveSeq, fBlendFrames, 7.5f), NULL },
	{ "BlendRate",						TOK_NO_TEXT_SAVE | TOK_F32(DynMoveSeq, fBlendRate, 0), NULL },
	{ "Length",							TOK_NO_TEXT_SAVE | TOK_F32(DynMoveSeq, fLength, 0), NULL },
	{ "RandSpeed",						TOK_NO_TEXT_SAVE | TOK_AUTOINT(DynMoveSeq, bRandSpeed, 0), NULL },
	{ "Verified",						TOK_NO_TEXT_SAVE | TOK_AUTOINT(DynMoveSeq, bVerified, 0), NULL },
	{ "Ragdoll",						TOK_BOOLFLAG(DynMoveSeq, bRagdoll, 0), NULL },
	{ "IKBothHands",					TOK_BOOLFLAG(DynMoveSeq, bIKBothHands, 0), NULL },
	{ "RegisterWep",					TOK_BOOLFLAG(DynMoveSeq, bRegisterWep, 0), NULL },
	{ "IKMeleeMode",					TOK_BOOLFLAG(DynMoveSeq, bIKMeleeMode, 0), NULL },
	{ "EnableIKSliding",				TOK_BOOLFLAG(DynMoveSeq, bEnableIKSliding, 0), NULL },
	{ "DisableIKLeftWrist",				TOK_BOOLFLAG(DynMoveSeq, bDisableIKLeftWrist, 0), NULL },
	{ "DisableIKRightArm",				TOK_BOOLFLAG(DynMoveSeq, bDisableIKRightArm, 0), NULL },
	{ "PlayWhileStopped",				TOK_BOOLFLAG(DynMoveSeq, bShowWhileStopped, 0), NULL },
	{ "ShowWhileStopped",				TOK_REDUNDANTNAME | TOK_BOOLFLAG(DynMoveSeq, bShowWhileStopped, 0), NULL },
	{ "EnableTerrainTiltBlend",			TOK_BOOLFLAG(DynMoveSeq, bEnableTerrainTiltBlend, 0), NULL },
	{ "End",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DynMoveSeq()
{
	int iSize = sizeof(DynMoveSeq);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynMoveSeq, iSize, "DynMoveSeq", NULL, "dynMove.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_DynMoveSeq[9].param = GET_INTPTR_FROM_FLOAT((float)1.0f);
	parse_DynMoveSeq[10].param = GET_INTPTR_FROM_FLOAT((float)1.0f);
	parse_DynMoveSeq[20].param = GET_INTPTR_FROM_FLOAT((float)7.5f);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DynMoveTag[];
#define TYPE_parse_DynMoveTag DynMoveTag
extern ParseTable parse_DynMoveSeq[];
#define TYPE_parse_DynMoveSeq DynMoveSeq
//Structparser.exe autogenerated ParseTable for struct DynMove
#define TYPE_parse_DynMove DynMove
ParseTable parse_DynMove[] =
{
	{ "DynMove", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynMove), 0, NULL, 0, NULL },
	{ "Name",			TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_KEY | TOK_STRING(DynMove, pcName, 0), NULL },
	{ "Filename",		TOK_POOL_STRING | TOK_POOL_STRING | TOK_CURRENTFILE(DynMove, pcFilename), NULL},
	{ "Comments",		TOK_SERVER_ONLY | TOK_STRING(DynMove, pcComments, 0), NULL },
	{ "Scope",			TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_NO_TEXT_SAVE | TOK_STRING(DynMove, pcScope, 0), NULL },
	{ "UserFilename",	TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_NO_TEXT_SAVE | TOK_STRING(DynMove, pcUserFilename, 0), NULL },
	{ "UserScope",		TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_NO_TEXT_SAVE | TOK_STRING(DynMove, pcUserScope, 0), NULL },
	{ "DynMoveTag",		TOK_STRUCT(DynMove, eaDynMoveTags, parse_DynMoveTag) },
	{ "DynMoveSeq",		TOK_STRUCT(DynMove, eaDynMoveSeqs, parse_DynMoveSeq) },
	{ "Verified",		TOK_NO_TEXT_SAVE | TOK_AUTOINT(DynMove, bVerified, 0), NULL },
	{ "End",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DynMove()
{
	int iSize = sizeof(DynMove);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynMove, iSize, "DynMove", NULL, "dynMove.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
