#include "textparser.h"

//auto-generated staticdefine for enum eJointType
//autogeneratednocheckin
StaticDefineInt eJointTypeEnum[] =
{
	DEFINE_INT
	{ "None", eJointType_None},
	{ "D6", eJointType_D6},
	{ "Spherical", eJointType_Spherical},
	{ "Revolute", eJointType_Revolute},
	DEFINE_END
};
void autoEnum_fixup_eJointType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(eJointTypeEnum, "eJointType");
}

//auto-generated staticdefine for enum eJointAxis
//autogeneratednocheckin
StaticDefineInt eJointAxisEnum[] =
{
	DEFINE_INT
	{ "X", eJointAxis_X},
	{ "Y", eJointAxis_Y},
	{ "Z", eJointAxis_Z},
	DEFINE_END
};
void autoEnum_fixup_eJointAxis(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(eJointAxisEnum, "eJointAxis");
}

//auto-generated staticdefine for enum eRagdollShape
//autogeneratednocheckin
StaticDefineInt eRagdollShapeEnum[] =
{
	DEFINE_INT
	{ "Capsule", eRagdollShape_Capsule},
	{ "Box", eRagdollShape_Box},
	DEFINE_END
};
void autoEnum_fixup_eRagdollShape(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(eRagdollShapeEnum, "eRagdollShape");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DynJointLimit
#define TYPE_parse_DynJointLimit DynJointLimit
ParseTable parse_DynJointLimit[] =
{
	{ "DynJointLimit", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynJointLimit), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "value",			TOK_F32(DynJointLimit, value, 0), NULL },
	{ "hardness",		TOK_F32(DynJointLimit, hardness, 0), NULL },
	{ "restitution",	TOK_F32(DynJointLimit, restitution, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DynJointLimit()
{
	int iSize = sizeof(DynJointLimit);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynJointLimit, iSize, "DynJointLimit", NULL, "dynRagdollData.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DynJointSpring
#define TYPE_parse_DynJointSpring DynJointSpring
ParseTable parse_DynJointSpring[] =
{
	{ "DynJointSpring", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynJointSpring), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "spring",			TOK_F32(DynJointSpring, spring, 0), NULL },
	{ "damper",			TOK_F32(DynJointSpring, damper, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DynJointSpring()
{
	int iSize = sizeof(DynJointSpring);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynJointSpring, iSize, "DynJointSpring", NULL, "dynRagdollData.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DynJointSpring[];
#define TYPE_parse_DynJointSpring DynJointSpring
extern ParseTable parse_DynJointLimit[];
#define TYPE_parse_DynJointLimit DynJointLimit
extern ParseTable parse_DynJointLimit[];
#define TYPE_parse_DynJointLimit DynJointLimit
extern ParseTable parse_DynJointSpring[];
#define TYPE_parse_DynJointSpring DynJointSpring
extern ParseTable parse_DynJointLimit[];
#define TYPE_parse_DynJointLimit DynJointLimit
//Structparser.exe autogenerated ParseTable for struct DynJointTuning
#define TYPE_parse_DynJointTuning DynJointTuning
ParseTable parse_DynJointTuning[] =
{
	{ "DynJointTuning", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynJointTuning), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "jointType",			TOK_AUTOINT(DynJointTuning, jointType, 0), eJointTypeEnum },
	{ "axis",				TOK_AUTOINT(DynJointTuning, axis, 0), eJointAxisEnum },
	{ "spring",				TOK_EMBEDDEDSTRUCT(DynJointTuning, spring, parse_DynJointSpring)},
	{ "limitLow",			TOK_EMBEDDEDSTRUCT(DynJointTuning, limitLow, parse_DynJointLimit)},
	{ "limitHigh",			TOK_EMBEDDEDSTRUCT(DynJointTuning, limitHigh, parse_DynJointLimit)},
	{ "swingSpring",		TOK_EMBEDDEDSTRUCT(DynJointTuning, swingSpring, parse_DynJointSpring)},
	{ "swingLimit",			TOK_EMBEDDEDSTRUCT(DynJointTuning, swingLimit, parse_DynJointLimit)},
	{ "springEnabled",		TOK_BIT, 0, 8, NULL},
	{ "limitEnabled",		TOK_BIT, 0, 8, NULL},
	{ "swingSpringEnabled",	TOK_BIT, 0, 8, NULL},
	{ "swingLimitEnabled",	TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_DynJointTuning()
{
	int iSize = sizeof(DynJointTuning);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynJointTuning, iSize, "DynJointTuning", NULL, "dynRagdollData.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(DynJointTuning) + 7) / 4;
		DynJointTuning *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->springEnabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_DynJointTuning[9]);
		pTemp->springEnabled = 0;
		pTemp->limitEnabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_DynJointTuning[10]);
		pTemp->limitEnabled = 0;
		pTemp->swingSpringEnabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_DynJointTuning[11]);
		pTemp->swingSpringEnabled = 0;
		pTemp->swingLimitEnabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_DynJointTuning[12]);
		pTemp->swingLimitEnabled = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DynJointSpring[];
#define TYPE_parse_DynJointSpring DynJointSpring
extern ParseTable parse_DynJointLimit[];
#define TYPE_parse_DynJointLimit DynJointLimit
extern ParseTable parse_DynJointLimit[];
#define TYPE_parse_DynJointLimit DynJointLimit
extern ParseTable parse_DynJointSpring[];
#define TYPE_parse_DynJointSpring DynJointSpring
extern ParseTable parse_DynJointLimit[];
#define TYPE_parse_DynJointLimit DynJointLimit
//Structparser.exe autogenerated ParseTable for struct DynRagdollShape
#define TYPE_parse_DynRagdollShape DynRagdollShape
ParseTable parse_DynRagdollShape[] =
{
	{ "DynRagdollShape", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynRagdollShape), 0, NULL, 0, NULL },
	{ "Bone",				TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(DynRagdollShape, pcBone, 0), NULL },
	{ "Parent",				TOK_POOL_STRING | TOK_STRING(DynRagdollShape, pcParentBone, 0), NULL },
	{ "JointTarget",		TOK_POOL_STRING | TOK_STRING(DynRagdollShape, pcJointTargetBone, 0), NULL },
	{ "Shape",				TOK_AUTOINT(DynRagdollShape, eShape, 0), eRagdollShapeEnum },
	{ "Offset",				TOK_VEC3(DynRagdollShape, vOffset), NULL },
	{ "Rotation",			TOK_QUATPYR(DynRagdollShape, qRotation), NULL },
	{ "Min",				TOK_VEC3(DynRagdollShape, vMin), NULL },
	{ "Max",				TOK_VEC3(DynRagdollShape, vMax), NULL },
	{ "HeightMin",			TOK_F32(DynRagdollShape, fHeightMin, 0), NULL },
	{ "HeightMax",			TOK_F32(DynRagdollShape, fHeightMax, 0), NULL },
	{ "Radius",				TOK_F32(DynRagdollShape, fRadius, 0), NULL },
	{ "Density",			TOK_F32(DynRagdollShape, fDensity, 0), NULL },
	{ "UseCustomJointAxis",	TOK_BOOLFLAG(DynRagdollShape, bUseCustomJointAxis, 0), NULL },
	{ "tuning", 				TOK_IGNORE | TOK_FLATEMBED },
	{ "jointType",			TOK_AUTOINT(DynRagdollShape, tuning.jointType, 0), eJointTypeEnum },
	{ "axis",				TOK_AUTOINT(DynRagdollShape, tuning.axis, 0), eJointAxisEnum },
	{ "spring",				TOK_EMBEDDEDSTRUCT(DynRagdollShape, tuning.spring, parse_DynJointSpring)},
	{ "limitLow",			TOK_EMBEDDEDSTRUCT(DynRagdollShape, tuning.limitLow, parse_DynJointLimit)},
	{ "limitHigh",			TOK_EMBEDDEDSTRUCT(DynRagdollShape, tuning.limitHigh, parse_DynJointLimit)},
	{ "swingSpring",		TOK_EMBEDDEDSTRUCT(DynRagdollShape, tuning.swingSpring, parse_DynJointSpring)},
	{ "swingLimit",			TOK_EMBEDDEDSTRUCT(DynRagdollShape, tuning.swingLimit, parse_DynJointLimit)},
	{ "springEnabled",		TOK_BIT, 0, 8, NULL},
	{ "limitEnabled",		TOK_BIT, 0, 8, NULL},
	{ "swingSpringEnabled",	TOK_BIT, 0, 8, NULL},
	{ "swingLimitEnabled",	TOK_BIT, 0, 8, NULL},
	{ "End",				TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_DynRagdollShape()
{
	int iSize = sizeof(DynRagdollShape);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynRagdollShape, iSize, "DynRagdollShape", NULL, "dynRagdollData.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(DynRagdollShape) + 7) / 4;
		DynRagdollShape *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->tuning.springEnabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_DynRagdollShape[22]);
		pTemp->tuning.springEnabled = 0;
		pTemp->tuning.limitEnabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_DynRagdollShape[23]);
		pTemp->tuning.limitEnabled = 0;
		pTemp->tuning.swingSpringEnabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_DynRagdollShape[24]);
		pTemp->tuning.swingSpringEnabled = 0;
		pTemp->tuning.swingLimitEnabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_DynRagdollShape[25]);
		pTemp->tuning.swingLimitEnabled = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DynRagdollShape[];
#define TYPE_parse_DynRagdollShape DynRagdollShape
//Structparser.exe autogenerated ParseTable for struct DynRagdollData
#define TYPE_parse_DynRagdollData DynRagdollData
ParseTable parse_DynRagdollData[] =
{
	{ "DynRagdollData", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DynRagdollData), 0, NULL, 0, NULL },
	{ "Name",				TOK_POOL_STRING | TOK_KEY | TOK_STRING(DynRagdollData, pcName, 0), NULL },
	{ "FileName",			TOK_POOL_STRING | TOK_CURRENTFILE(DynRagdollData, pcFileName), NULL},
	{ "PhysicalProperties",	TOK_STRING(DynRagdollData, pcPhysicalProperties, 0), NULL },
	{ "Bone",				TOK_STRUCT(DynRagdollData, eaShapes, parse_DynRagdollShape) },
	{ "PoseAnimTrack",		TOK_POOL_STRING | TOK_STRING(DynRagdollData, pcPoseAnimTrack, 0), NULL },
	{ "PoseFrames",			TOK_F32ARRAY(DynRagdollData, eaPoseFrames), NULL },
	{ "End",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DynRagdollData()
{
	int iSize = sizeof(DynRagdollData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DynRagdollData, iSize, "DynRagdollData", NULL, "dynRagdollData.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
