#include "textparser.h"
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ShadowRules
#define TYPE_parse_ShadowRules ShadowRules
ParseTable parse_ShadowRules[] =
{
	{ "ShadowRules", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ShadowRules), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "time",					TOK_F32(ShadowRules, time, 0), NULL },
	{ "camerafalloffdist",		TOK_F32(ShadowRules, camera_falloff_dist, 0), NULL },
	{ "camerascalefalloff",		TOK_AUTOINT(ShadowRules, camera_scale_falloff, 0), NULL },
	{ "threesplitdistances",	TOK_FIXED_ARRAY | TOK_F32_X, offsetof(ShadowRules, three_split_distances),  3, NULL },
	{ "foursplitdistances",		TOK_FIXED_ARRAY | TOK_F32_X, offsetof(ShadowRules, four_split_distances),  4, NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ShadowRules()
{
	int iSize = sizeof(ShadowRules);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ShadowRules, iSize, "ShadowRules", NULL, "wlLight.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CamLightRules
#define TYPE_parse_CamLightRules CamLightRules
ParseTable parse_CamLightRules[] =
{
	{ "CamLightRules", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CamLightRules), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "enabled",		TOK_AUTOINT(CamLightRules, enabled, 0), NULL },
	{ "keyOverride",	TOK_AUTOINT(CamLightRules, keyOverride, 0), NULL },
	{ "offset",			TOK_FIXED_ARRAY | TOK_F32_X, offsetof(CamLightRules, offset),  3, NULL },
	{ "AmbientHSV",		TOK_VEC3(CamLightRules, ambientHsv), NULL  ,  TOK_FORMAT_HSV},
	{ "DiffuseHSV",		TOK_VEC3(CamLightRules, diffuseHsv), NULL  ,  TOK_FORMAT_HSV},
	{ "SpecularHSV",	TOK_VEC3(CamLightRules, specularHsv), NULL  ,  TOK_FORMAT_HSV},
	{ "innerRadius",	TOK_F32(CamLightRules, innerRadius, 0), NULL },
	{ "outerRadius",	TOK_F32(CamLightRules, outerRadius, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CamLightRules()
{
	int iSize = sizeof(CamLightRules);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CamLightRules, iSize, "CamLightRules", NULL, "wlLight.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct LightCloudLayer
#define TYPE_parse_LightCloudLayer LightCloudLayer
ParseTable parse_LightCloudLayer[] =
{
	{ "LightCloudLayer", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(LightCloudLayer), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "scroll_rate",		TOK_VEC2(LightCloudLayer, scroll_rate), NULL },
	{ "scale",				TOK_F32(LightCloudLayer, scale, 0), NULL },
	{ "multiplier",			TOK_F32(LightCloudLayer, multiplier, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_LightCloudLayer()
{
	int iSize = sizeof(LightCloudLayer);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_LightCloudLayer, iSize, "LightCloudLayer", NULL, "wlLight.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_LightCloudLayer[];
#define TYPE_parse_LightCloudLayer LightCloudLayer
//Structparser.exe autogenerated ParseTable for struct LightData
#define TYPE_parse_LightData LightData
ParseTable parse_LightData[] =
{
	{ "LightData", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(LightData), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "light_type",				TOK_AUTOINT(LightData, light_type, 0), LightTypeEnum },
	{ "light_affect_type",		TOK_AUTOINT(LightData, light_affect_type, 0), LightAffectTypeEnum },
	{ "rot_world_mat",			TOK_MAT4PYR_ROT(LightData, world_mat), NULL },
	{ "pos_world_mat",			TOK_MAT4PYR_POS(LightData, world_mat), NULL },
	{ "ambient_hsv",			TOK_VEC3(LightData, ambient_hsv), NULL  ,  TOK_FORMAT_HSV},
	{ "diffuse_hsv",			TOK_VEC3(LightData, diffuse_hsv), NULL  ,  TOK_FORMAT_HSV},
	{ "specular_hsv",			TOK_VEC3(LightData, specular_hsv), NULL  ,  TOK_FORMAT_HSV},
	{ "secondary_diffuse_hsv",	TOK_VEC3(LightData, secondary_diffuse_hsv), NULL  ,  TOK_FORMAT_HSV},
	{ "inner_radius",			TOK_F32(LightData, inner_radius, 0), NULL },
	{ "outer_radius",			TOK_F32(LightData, outer_radius, 0), NULL },
	{ "inner_cone_angle",		TOK_F32(LightData, inner_cone_angle, 0), NULL },
	{ "outer_cone_angle",		TOK_F32(LightData, outer_cone_angle, 0), NULL },
	{ "inner_cone_angle2",		TOK_F32(LightData, inner_cone_angle2, 0), NULL },
	{ "outer_cone_angle2",		TOK_F32(LightData, outer_cone_angle2, 0), NULL },
	{ "min_shadow_val",			TOK_F32(LightData, min_shadow_val, 0), NULL },
	{ "shadow_near_plane",		TOK_F32(LightData, shadow_near_plane, 0), NULL },
	{ "shadow_fade_val",		TOK_F32(LightData, shadow_fade_val, 0), NULL },
	{ "shadow_fade_time",		TOK_F32(LightData, shadow_fade_time, 0), NULL },
	{ "shadow_fade_dark_time",	TOK_F32(LightData, shadow_fade_dark_time, 0), NULL },
	{ "shadow_pulse_amount",	TOK_F32(LightData, shadow_pulse_amount, 0), NULL },
	{ "shadow_pulse_rate",		TOK_F32(LightData, shadow_pulse_rate, 0), NULL },
	{ "texture_name",			TOK_STRING(LightData, texture_name, 0), NULL },
	{ "cloud_texture_name",		TOK_POOL_STRING | TOK_STRING(LightData, cloud_texture_name, 0), NULL },
	{ "cloud_layer_0",			TOK_EMBEDDEDSTRUCT(LightData, cloud_layers[0], parse_LightCloudLayer)},
	{ "cloud_layer_1",			TOK_EMBEDDEDSTRUCT(LightData, cloud_layers[1], parse_LightCloudLayer)},
	{ "cast_shadows",			TOK_AUTOINT(LightData, cast_shadows, 0), NULL },
	{ "dynamic",				TOK_AUTOINT(LightData, dynamic, 0), NULL },
	{ "is_sun",					TOK_AUTOINT(LightData, is_sun, 0), NULL },
	{ "key_light",				TOK_AUTOINT(LightData, key_light, 0), NULL },
	{ "infinite_shadows",		TOK_AUTOINT(LightData, infinite_shadows, 0), NULL },
	{ "visual_lod_scale",		TOK_F32(LightData, visual_lod_scale, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_LightData()
{
	int iSize = sizeof(LightData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_LightData, iSize, "LightData", NULL, "wlLight.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
