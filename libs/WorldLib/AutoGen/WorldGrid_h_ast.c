#include "textparser.h"

//auto-generated staticdefine for enum WorldEncounterObjectInteractType
//autogeneratednocheckin
StaticDefineInt WorldEncounterObjectInteractTypeEnum[] =
{
	DEFINE_INT
	{ "UNKNOWN", WL_ENC_UNKNOWN},
	{ "DOOR", WL_ENC_DOOR},
	{ "CLICKIE", WL_ENC_CLICKIE},
	{ "DESTRUCTIBLE", WL_ENC_DESTRUCTIBLE},
	{ "CONTACT", WL_ENC_CONTACT},
	{ "STARTSPAWN", WL_ENC_STARTSPAWN},
	{ "DIALOGTREE", WL_ENC_DIALOGTREE},
	{ "REWARD_BOX", WL_ENC_REWARD_BOX},
	DEFINE_END
};
void autoEnum_fixup_WorldEncounterObjectInteractType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(WorldEncounterObjectInteractTypeEnum, "WorldEncounterObjectInteractType");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct WorldFile
#define TYPE_parse_WorldFile WorldFile
ParseTable parse_WorldFile[] =
{
	{ "WorldFile", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldFile), 0, NULL, 0, NULL },
	{ "FN",			TOK_POOL_STRING | TOK_CURRENTFILE(WorldFile, fullname), NULL},
	{ "\n",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldFile()
{
	int iSize = sizeof(WorldFile);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldFile, iSize, "WorldFile", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ZoneMapTimeBlock
#define TYPE_parse_ZoneMapTimeBlock ZoneMapTimeBlock
ParseTable parse_ZoneMapTimeBlock[] =
{
	{ "ZoneMapTimeBlock", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ZoneMapTimeBlock), 0, NULL, 0, NULL },
	{ "Time",				TOK_F32(ZoneMapTimeBlock, time, 0), NULL },
	{ "Duration",			TOK_F32(ZoneMapTimeBlock, duration, 0), NULL },
	{ "Tag",				TOK_POOL_STRING | TOK_STRING(ZoneMapTimeBlock, tag, 0), NULL },
	{ "EndTimeBlock",		TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ZoneMapTimeBlock()
{
	int iSize = sizeof(ZoneMapTimeBlock);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ZoneMapTimeBlock, iSize, "ZoneMapTimeBlock", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct WorldCivilianGenerator
#define TYPE_parse_WorldCivilianGenerator WorldCivilianGenerator
ParseTable parse_WorldCivilianGenerator[] =
{
	{ "WorldCivilianGenerator", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldCivilianGenerator), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "position",				TOK_VEC3(WorldCivilianGenerator, position), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldCivilianGenerator()
{
	int iSize = sizeof(WorldCivilianGenerator);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldCivilianGenerator, iSize, "WorldCivilianGenerator", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct WorldForbiddenPosition
#define TYPE_parse_WorldForbiddenPosition WorldForbiddenPosition
ParseTable parse_WorldForbiddenPosition[] =
{
	{ "WorldForbiddenPosition", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldForbiddenPosition), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "position",				TOK_VEC3(WorldForbiddenPosition, position), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldForbiddenPosition()
{
	int iSize = sizeof(WorldForbiddenPosition);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldForbiddenPosition, iSize, "WorldForbiddenPosition", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldPathEdge[];
#define TYPE_parse_WorldPathEdge WorldPathEdge
//Structparser.exe autogenerated ParseTable for struct WorldPathNode
#define TYPE_parse_WorldPathNode WorldPathNode
ParseTable parse_WorldPathNode[] =
{
	{ "WorldPathNode", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldPathNode), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "position",		TOK_VEC3(WorldPathNode, position), NULL },
	{ "uID",			TOK_AUTOINT(WorldPathNode, uID, 0), NULL },
	{ "properties", 		TOK_IGNORE | TOK_FLATEMBED },
	{ "UGC",			TOK_AUTOINT(WorldPathNode, properties.bUGCNode, 0), NULL },
	{ "Connection",		TOK_STRUCT(WorldPathNode, properties.eaConnections, parse_WorldPathEdge) },
	{ "Connections",	TOK_REDUNDANTNAME | TOK_STRUCT(WorldPathNode, properties.eaConnections, parse_WorldPathEdge) },
	{ "CanBeObstructed",TOK_AUTOINT(WorldPathNode, properties.bCanBeObstructed, 0), NULL },
	{ "IsSecret",		TOK_AUTOINT(WorldPathNode, properties.bIsSecret, 0), NULL },
	{ "TeleportID",		TOK_AUTOINT(WorldPathNode, properties.iTeleportID, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldPathNode()
{
	int iSize = sizeof(WorldPathNode);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldPathNode, iSize, "WorldPathNode", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct WorldPathEdge
#define TYPE_parse_WorldPathEdge WorldPathEdge
ParseTable parse_WorldPathEdge[] =
{
	{ "WorldPathEdge", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldPathEdge), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "uOther",			TOK_AUTOINT(WorldPathEdge, uOther, 0), NULL },
	{ "UGCGenerated",	TOK_AUTOINT(WorldPathEdge, bUGCGenerated, 0), NULL },
	{ "v3Other",		TOK_NO_TEXT_SAVE | TOK_VEC3(WorldPathEdge, v3Other), NULL },
	{ "Cost",			TOK_NO_TEXT_SAVE | TOK_F32(WorldPathEdge, fCost, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldPathEdge()
{
	int iSize = sizeof(WorldPathEdge);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldPathEdge, iSize, "WorldPathEdge", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PhotoOptions
#define TYPE_parse_PhotoOptions PhotoOptions
ParseTable parse_PhotoOptions[] =
{
	{ "PhotoOptions", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PhotoOptions), 0, NULL, 0, NULL },
	{ "far_plane_offset",	TOK_F32(PhotoOptions, far_plane_offset, 0), NULL },
	{ "near_plane_offset",	TOK_F32(PhotoOptions, near_plane_offset, 0), NULL },
	{ "End",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PhotoOptions()
{
	int iSize = sizeof(PhotoOptions);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PhotoOptions, iSize, "PhotoOptions", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct TempPuppetChoice
#define TYPE_parse_TempPuppetChoice TempPuppetChoice
ParseTable parse_TempPuppetChoice[] =
{
	{ "TempPuppetChoice", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(TempPuppetChoice), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "hPetDef",			TOK_STRUCTPARAM | TOK_REFERENCE(TempPuppetChoice, hPetDef, 0, "PetDef") },
	{ "EvalExpression",		TOK_OPTIONALLATEBINDSTRUCT(TempPuppetChoice, pEvalExpression) },
	{ "Weight",				TOK_F32(TempPuppetChoice, fWeight, 1.0f), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_TempPuppetChoice()
{
	int iSize = sizeof(TempPuppetChoice);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_TempPuppetChoice, iSize, "TempPuppetChoice", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_TempPuppetChoice[4].param = GET_INTPTR_FROM_FLOAT((float)1.0f);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_TempPuppetChoice(void)
{
	DoAutoStructLateBind(parse_TempPuppetChoice, 3, "Expression");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct RegionRulesOverride
#define TYPE_parse_RegionRulesOverride RegionRulesOverride
ParseTable parse_RegionRulesOverride[] =
{
	{ "RegionRulesOverride", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(RegionRulesOverride), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "AllowedPetsPerPlayer",	TOK_AUTOINT(RegionRulesOverride, iAllowedPetsPerPlayer, -1), NULL },
	{ "UnteamedPetsPerPlayer",	TOK_AUTOINT(RegionRulesOverride, iUnteamedPetsPerPlayer, -1), NULL },
	{ "TempPuppet",				TOK_LATEBINDSTRUCT(RegionRulesOverride, ppTempPuppets) },
	{ "VehicleRules",			TOK_AUTOINT(RegionRulesOverride, eVehicleRules, kVehicleRules_Inherit), VehicleRulesEnum },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_RegionRulesOverride()
{
	int iSize = sizeof(RegionRulesOverride);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_RegionRulesOverride, iSize, "RegionRulesOverride", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_RegionRulesOverride(void)
{
	DoAutoStructLateBind(parse_RegionRulesOverride, 4, "TempPuppetChoice");
}
//autogeneratednocheckin
extern ParseTable parse_WorldRegion[];
#define TYPE_parse_WorldRegion WorldRegion
extern ParseTable parse_GenesisZoneMapData[];
#define TYPE_parse_GenesisZoneMapData GenesisZoneMapData
extern ParseTable parse_GenesisZoneMapInfo[];
#define TYPE_parse_GenesisZoneMapInfo GenesisZoneMapInfo
extern ParseTable parse_WorldVariableDef[];
#define TYPE_parse_WorldVariableDef WorldVariableDef
extern ParseTable parse_Expression[];
#define TYPE_parse_Expression Expression
extern ParseTable parse_Expression[];
#define TYPE_parse_Expression Expression
//Structparser.exe autogenerated ParseTable for struct ZoneMapInfoRequest
#define TYPE_parse_ZoneMapInfoRequest ZoneMapInfoRequest
ParseTable parse_ZoneMapInfoRequest[] =
{
	{ "ZoneMapInfoRequest", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ZoneMapInfoRequest), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "DisplayNameMsgKey",		TOK_STRING(ZoneMapInfoRequest, pchDisplayNameMsgKey, 0), NULL },
	{ "MapType",				TOK_AUTOINT(ZoneMapInfoRequest, eMapType, 0), ZoneMapTypeEnum },
	{ "Regions",				TOK_STRUCT(ZoneMapInfoRequest, eaRegions, parse_WorldRegion) },
	{ "GenesisData",			TOK_OPTIONALSTRUCT(ZoneMapInfoRequest, pGenesisData, parse_GenesisZoneMapData) },
	{ "GenesisInfo",			TOK_OPTIONALSTRUCT(ZoneMapInfoRequest, pGenesisInfo, parse_GenesisZoneMapInfo) },
	{ "VarDefs",				TOK_STRUCT(ZoneMapInfoRequest, eaVarDefs, parse_WorldVariableDef) },
	{ "RequiresExpr",			TOK_OPTIONALSTRUCT(ZoneMapInfoRequest, pRequiresExpr, parse_Expression) },
	{ "PermissionExpr",			TOK_OPTIONALSTRUCT(ZoneMapInfoRequest, pPermissionExpr, parse_Expression) },
	{ "ConfirmPurchasesOnExit",	TOK_AUTOINT(ZoneMapInfoRequest, bConfirmPurchasesOnExit, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ZoneMapInfoRequest()
{
	int iSize = sizeof(ZoneMapInfoRequest);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ZoneMapInfoRequest, iSize, "ZoneMapInfoRequest", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ZoneMapEncounterObjectUGCInfo
#define TYPE_parse_ZoneMapEncounterObjectUGCInfo ZoneMapEncounterObjectUGCInfo
ParseTable parse_ZoneMapEncounterObjectUGCInfo[] =
{
	{ "ZoneMapEncounterObjectUGCInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ZoneMapEncounterObjectUGCInfo), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "LogicalName",					TOK_STRUCTPARAM | TOK_STRING(ZoneMapEncounterObjectUGCInfo, logicalName, 0), NULL },
	{ "DisplayName",					TOK_REFERENCE(ZoneMapEncounterObjectUGCInfo, displayName, 0, "Message") },
	{ "DisplayDetails",					TOK_REFERENCE(ZoneMapEncounterObjectUGCInfo, displayDetails, 0, "Message") },
	{ "InteractType",					TOK_AUTOINT(ZoneMapEncounterObjectUGCInfo, interactType, 0), WorldEncounterObjectInteractTypeEnum },
	{ "UGCContactName",					TOK_POOL_STRING | TOK_STRING(ZoneMapEncounterObjectUGCInfo, ugcContactName, 0), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ZoneMapEncounterObjectUGCInfo()
{
	int iSize = sizeof(ZoneMapEncounterObjectUGCInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ZoneMapEncounterObjectUGCInfo, iSize, "ZoneMapEncounterObjectUGCInfo", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldUGCFactionRestrictionProperties[];
#define TYPE_parse_WorldUGCFactionRestrictionProperties WorldUGCFactionRestrictionProperties
extern ParseTable parse_ZoneMapEncounterObjectUGCInfo[];
#define TYPE_parse_ZoneMapEncounterObjectUGCInfo ZoneMapEncounterObjectUGCInfo
//Structparser.exe autogenerated ParseTable for struct ZoneMapEncounterObjectUGCGroup
#define TYPE_parse_ZoneMapEncounterObjectUGCGroup ZoneMapEncounterObjectUGCGroup
ParseTable parse_ZoneMapEncounterObjectUGCGroup[] =
{
	{ "ZoneMapEncounterObjectUGCGroup", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ZoneMapEncounterObjectUGCGroup), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "restrictions", 					TOK_IGNORE | TOK_FLATEMBED },
	{ "MinLevel",						TOK_AUTOINT(ZoneMapEncounterObjectUGCGroup, restrictions.iMinLevel, 0), NULL },
	{ "MaxLevel",						TOK_AUTOINT(ZoneMapEncounterObjectUGCGroup, restrictions.iMaxLevel, 0), NULL },
	{ "Faction",						TOK_STRUCT(ZoneMapEncounterObjectUGCGroup, restrictions.eaFactions, parse_WorldUGCFactionRestrictionProperties) },
	{ "RestrictAllegiance",				TOK_REDUNDANTNAME | TOK_STRUCT(ZoneMapEncounterObjectUGCGroup, restrictions.eaFactions, parse_WorldUGCFactionRestrictionProperties) },
	{ "UGCObject",						TOK_STRUCT(ZoneMapEncounterObjectUGCGroup, objects, parse_ZoneMapEncounterObjectUGCInfo) },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ZoneMapEncounterObjectUGCGroup()
{
	int iSize = sizeof(ZoneMapEncounterObjectUGCGroup);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ZoneMapEncounterObjectUGCGroup, iSize, "ZoneMapEncounterObjectUGCGroup", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldUGCFactionRestrictionProperties[];
#define TYPE_parse_WorldUGCFactionRestrictionProperties WorldUGCFactionRestrictionProperties
extern ParseTable parse_ZoneMapEncounterObjectUGCInfo[];
#define TYPE_parse_ZoneMapEncounterObjectUGCInfo ZoneMapEncounterObjectUGCInfo
extern ParseTable parse_ZoneMapEncounterObjectUGCGroup[];
#define TYPE_parse_ZoneMapEncounterObjectUGCGroup ZoneMapEncounterObjectUGCGroup
//Structparser.exe autogenerated ParseTable for struct ZoneMapEncounterUGCInfo
#define TYPE_parse_ZoneMapEncounterUGCInfo ZoneMapEncounterUGCInfo
ParseTable parse_ZoneMapEncounterUGCInfo[] =
{
	{ "ZoneMapEncounterUGCInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ZoneMapEncounterUGCInfo), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "MapName",					TOK_POOL_STRING | TOK_KEY | TOK_STRING(ZoneMapEncounterUGCInfo, map_name, 0), NULL },
	{ "filename",					TOK_POOL_STRING | TOK_CURRENTFILE(ZoneMapEncounterUGCInfo, filename), NULL},
	{ "DeprecatedMapNewMapName",	TOK_STRING(ZoneMapEncounterUGCInfo, deprecated_map_new_map_name, 0), NULL },
	{ "VolumeLogicalName",			TOK_STRINGARRAY(ZoneMapEncounterUGCInfo, volume_logical_name), NULL },
	{ "default_group", 				TOK_IGNORE | TOK_FLATEMBED },
	{ "restrictions", 				TOK_IGNORE | TOK_FLATEMBED },
	{ "MinLevel",					TOK_AUTOINT(ZoneMapEncounterUGCInfo, default_group.restrictions.iMinLevel, 0), NULL },
	{ "MaxLevel",					TOK_AUTOINT(ZoneMapEncounterUGCInfo, default_group.restrictions.iMaxLevel, 0), NULL },
	{ "Faction",					TOK_STRUCT(ZoneMapEncounterUGCInfo, default_group.restrictions.eaFactions, parse_WorldUGCFactionRestrictionProperties) },
	{ "RestrictAllegiance",			TOK_REDUNDANTNAME | TOK_STRUCT(ZoneMapEncounterUGCInfo, default_group.restrictions.eaFactions, parse_WorldUGCFactionRestrictionProperties) },
	{ "UGCObject",					TOK_STRUCT(ZoneMapEncounterUGCInfo, default_group.objects, parse_ZoneMapEncounterObjectUGCInfo) },
	{ "Group",						TOK_STRUCT(ZoneMapEncounterUGCInfo, groups, parse_ZoneMapEncounterObjectUGCGroup) },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ZoneMapEncounterUGCInfo()
{
	int iSize = sizeof(ZoneMapEncounterUGCInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ZoneMapEncounterUGCInfo, iSize, "ZoneMapEncounterUGCInfo", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldPowerVolumeProperties[];
#define TYPE_parse_WorldPowerVolumeProperties WorldPowerVolumeProperties
//Structparser.exe autogenerated ParseTable for struct ZoneMapEncounterVolumeInfo
#define TYPE_parse_ZoneMapEncounterVolumeInfo ZoneMapEncounterVolumeInfo
ParseTable parse_ZoneMapEncounterVolumeInfo[] =
{
	{ "ZoneMapEncounterVolumeInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ZoneMapEncounterVolumeInfo), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Shape",						TOK_AUTOINT(ZoneMapEncounterVolumeInfo, shape, 0), WorldVolumeShapeEnum },
	{ "BoxMin",						TOK_VEC3(ZoneMapEncounterVolumeInfo, boxMin), NULL },
	{ "BoxMax",						TOK_VEC3(ZoneMapEncounterVolumeInfo, boxMax), NULL },
	{ "SphereRadius",				TOK_F32(ZoneMapEncounterVolumeInfo, sphereRadius, 0), NULL },
	{ "PowerProperties",			TOK_OPTIONALSTRUCT(ZoneMapEncounterVolumeInfo, power_properties, parse_WorldPowerVolumeProperties) },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ZoneMapEncounterVolumeInfo()
{
	int iSize = sizeof(ZoneMapEncounterVolumeInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ZoneMapEncounterVolumeInfo, iSize, "ZoneMapEncounterVolumeInfo", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldUGCFactionRestrictionProperties[];
#define TYPE_parse_WorldUGCFactionRestrictionProperties WorldUGCFactionRestrictionProperties
extern ParseTable parse_ZoneMapEncounterVolumeInfo[];
#define TYPE_parse_ZoneMapEncounterVolumeInfo ZoneMapEncounterVolumeInfo
//Structparser.exe autogenerated ParseTable for struct ZoneMapEncounterObjectInfo
#define TYPE_parse_ZoneMapEncounterObjectInfo ZoneMapEncounterObjectInfo
ParseTable parse_ZoneMapEncounterObjectInfo[] =
{
	{ "ZoneMapEncounterObjectInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ZoneMapEncounterObjectInfo), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "LogicalName",				TOK_STRUCTPARAM | TOK_STRING(ZoneMapEncounterObjectInfo, logicalName, 0), NULL },
	{ "RegionName",					TOK_POOL_STRING | TOK_STRING(ZoneMapEncounterObjectInfo, regionName, 0), NULL },
	{ "Pos",						TOK_VEC3(ZoneMapEncounterObjectInfo, pos), NULL },
	{ "Orientation",				TOK_QUATPYR(ZoneMapEncounterObjectInfo, qOrientation), NULL },
	{ "Type",						TOK_AUTOINT(ZoneMapEncounterObjectInfo, type, 0), WorldEncounterObjectTypeEnum },
	{ "InteractType",				TOK_AUTOINT(ZoneMapEncounterObjectInfo, interactType, 0), WorldEncounterObjectInteractTypeEnum },
	{ "restrictions", 				TOK_IGNORE | TOK_FLATEMBED },
	{ "MinLevel",					TOK_AUTOINT(ZoneMapEncounterObjectInfo, restrictions.iMinLevel, 0), NULL },
	{ "MaxLevel",					TOK_AUTOINT(ZoneMapEncounterObjectInfo, restrictions.iMaxLevel, 0), NULL },
	{ "Faction",					TOK_STRUCT(ZoneMapEncounterObjectInfo, restrictions.eaFactions, parse_WorldUGCFactionRestrictionProperties) },
	{ "RestrictAllegiance",			TOK_REDUNDANTNAME | TOK_STRUCT(ZoneMapEncounterObjectInfo, restrictions.eaFactions, parse_WorldUGCFactionRestrictionProperties) },
	{ "DisplayName",				TOK_REFERENCE(ZoneMapEncounterObjectInfo, displayName, 0, "Message") },
	{ "DisplayDetails",				TOK_REFERENCE(ZoneMapEncounterObjectInfo, displayDetails, 0, "Message") },
	{ "UGCContactName",				TOK_POOL_STRING | TOK_STRING(ZoneMapEncounterObjectInfo, ugcContactName, 0), NULL },
	{ "UGCContactCostume",			TOK_REFERENCE(ZoneMapEncounterObjectInfo, ugcContactCostume, 0, "PlayerCostume") },
	{ "Volume",						TOK_OPTIONALSTRUCT(ZoneMapEncounterObjectInfo, volume, parse_ZoneMapEncounterVolumeInfo) },
	{ "UGCDisplayName",				TOK_STRING(ZoneMapEncounterObjectInfo, ugcDisplayName, 0), NULL },
	{ "UGCDisplayDetails",			TOK_STRING(ZoneMapEncounterObjectInfo, ugcDisplayDetails, 0), NULL },
	{ "UGCIsInvalidSelection",		TOK_AUTOINT(ZoneMapEncounterObjectInfo, ugcIsInvalidSelection, 0), NULL },
	{ "UGCComponentID",				TOK_AUTOINT(ZoneMapEncounterObjectInfo, ugcComponentID, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ZoneMapEncounterObjectInfo()
{
	int iSize = sizeof(ZoneMapEncounterObjectInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ZoneMapEncounterObjectInfo, iSize, "ZoneMapEncounterObjectInfo", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ZoneMapEncounterRoomInfo
#define TYPE_parse_ZoneMapEncounterRoomInfo ZoneMapEncounterRoomInfo
ParseTable parse_ZoneMapEncounterRoomInfo[] =
{
	{ "ZoneMapEncounterRoomInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ZoneMapEncounterRoomInfo), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "min",						TOK_VEC3(ZoneMapEncounterRoomInfo, min), NULL },
	{ "max",						TOK_VEC3(ZoneMapEncounterRoomInfo, max), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ZoneMapEncounterRoomInfo()
{
	int iSize = sizeof(ZoneMapEncounterRoomInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ZoneMapEncounterRoomInfo, iSize, "ZoneMapEncounterRoomInfo", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ZoneMapEncounterRoomInfo[];
#define TYPE_parse_ZoneMapEncounterRoomInfo ZoneMapEncounterRoomInfo
//Structparser.exe autogenerated ParseTable for struct ZoneMapEncounterRegionInfo
#define TYPE_parse_ZoneMapEncounterRegionInfo ZoneMapEncounterRegionInfo
ParseTable parse_ZoneMapEncounterRegionInfo[] =
{
	{ "ZoneMapEncounterRegionInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ZoneMapEncounterRegionInfo), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "regionName",					TOK_POOL_STRING | TOK_STRING(ZoneMapEncounterRegionInfo, regionName, 0), NULL },
	{ "min",						TOK_VEC3(ZoneMapEncounterRegionInfo, min), NULL },
	{ "max",						TOK_VEC3(ZoneMapEncounterRegionInfo, max), NULL },
	{ "rooms",						TOK_STRUCT(ZoneMapEncounterRegionInfo, rooms, parse_ZoneMapEncounterRoomInfo) },
	{ "GroundFocusHeight",			TOK_F32(ZoneMapEncounterRegionInfo, fGroundFocusHeight, 0), NULL },
	{ "type",						TOK_AUTOINT(ZoneMapEncounterRegionInfo, type, 0), WorldRegionTypeEnum },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ZoneMapEncounterRegionInfo()
{
	int iSize = sizeof(ZoneMapEncounterRegionInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ZoneMapEncounterRegionInfo, iSize, "ZoneMapEncounterRegionInfo", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_FileEntry[];
#define TYPE_parse_FileEntry FileEntry
extern ParseTable parse_ZoneMapEncounterObjectInfo[];
#define TYPE_parse_ZoneMapEncounterObjectInfo ZoneMapEncounterObjectInfo
extern ParseTable parse_ZoneMapEncounterRegionInfo[];
#define TYPE_parse_ZoneMapEncounterRegionInfo ZoneMapEncounterRegionInfo
extern ParseTable parse_ZoneMapEncounterRoomInfo[];
#define TYPE_parse_ZoneMapEncounterRoomInfo ZoneMapEncounterRoomInfo
extern ParseTable parse_SecondaryZoneMap[];
#define TYPE_parse_SecondaryZoneMap SecondaryZoneMap
//Structparser.exe autogenerated ParseTable for struct ZoneMapEncounterInfo
#define TYPE_parse_ZoneMapEncounterInfo ZoneMapEncounterInfo
ParseTable parse_ZoneMapEncounterInfo[] =
{
	{ "ZoneMapEncounterInfo", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ZoneMapEncounterInfo), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "MapName",					TOK_POOL_STRING | TOK_KEY | TOK_STRING(ZoneMapEncounterInfo, map_name, 0), NULL },
	{ "filename",					TOK_POOL_STRING | TOK_CURRENTFILE(ZoneMapEncounterInfo, filename), NULL},
	{ "deps",						TOK_STRUCT(ZoneMapEncounterInfo, deps, parse_FileEntry) },
	{ "Version",					TOK_AUTOINT(ZoneMapEncounterInfo, version, 0), NULL },
	{ "DeprecatedMapNewMapName",	TOK_STRING(ZoneMapEncounterInfo, deprecated_map_new_map_name, 0), NULL },
	{ "Object",						TOK_STRUCT(ZoneMapEncounterInfo, objects, parse_ZoneMapEncounterObjectInfo) },
	{ "Region",						TOK_STRUCT(ZoneMapEncounterInfo, regions, parse_ZoneMapEncounterRegionInfo) },
	{ "PlayableVolume",				TOK_STRUCT(ZoneMapEncounterInfo, playable_volumes, parse_ZoneMapEncounterRoomInfo) },
	{ "VolumeLogicalName",			TOK_STRINGARRAY(ZoneMapEncounterInfo, volume_logical_name), NULL },
	{ "SecondaryMap",				TOK_STRUCT(ZoneMapEncounterInfo, secondary_maps, parse_SecondaryZoneMap) },
	{ "v2",							TOK_IGNORE, 0 },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
TextParserResult fixupZoneMapEncounterInfo(ZoneMapEncounterInfo *pStruct, enumTextParserFixupType eFixupType, void *pExtraData);
int autoStruct_fixup_ZoneMapEncounterInfo()
{
	int iSize = sizeof(ZoneMapEncounterInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ZoneMapEncounterInfo, iSize, "ZoneMapEncounterInfo", fixupZoneMapEncounterInfo, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ZoneMapMetadataPathEdge
#define TYPE_parse_ZoneMapMetadataPathEdge ZoneMapMetadataPathEdge
ParseTable parse_ZoneMapMetadataPathEdge[] =
{
	{ "ZoneMapMetadataPathEdge", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ZoneMapMetadataPathEdge), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "uOther",						TOK_AUTOINT(ZoneMapMetadataPathEdge, uOther, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ZoneMapMetadataPathEdge()
{
	int iSize = sizeof(ZoneMapMetadataPathEdge);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ZoneMapMetadataPathEdge, iSize, "ZoneMapMetadataPathEdge", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ZoneMapMetadataPathEdge[];
#define TYPE_parse_ZoneMapMetadataPathEdge ZoneMapMetadataPathEdge
//Structparser.exe autogenerated ParseTable for struct ZoneMapMetadataPathNode
#define TYPE_parse_ZoneMapMetadataPathNode ZoneMapMetadataPathNode
ParseTable parse_ZoneMapMetadataPathNode[] =
{
	{ "ZoneMapMetadataPathNode", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ZoneMapMetadataPathNode), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "DefUID",						TOK_AUTOINT(ZoneMapMetadataPathNode, defUID, 0), NULL },
	{ "Pos",						TOK_VEC3(ZoneMapMetadataPathNode, pos), NULL },
	{ "Connection",					TOK_STRUCT(ZoneMapMetadataPathNode, eaConnections, parse_ZoneMapMetadataPathEdge) },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ZoneMapMetadataPathNode()
{
	int iSize = sizeof(ZoneMapMetadataPathNode);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ZoneMapMetadataPathNode, iSize, "ZoneMapMetadataPathNode", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_FileEntry[];
#define TYPE_parse_FileEntry FileEntry
extern ParseTable parse_RoomPartitionParsed[];
#define TYPE_parse_RoomPartitionParsed RoomPartitionParsed
extern ParseTable parse_ZoneMapMetadataPathNode[];
#define TYPE_parse_ZoneMapMetadataPathNode ZoneMapMetadataPathNode
//Structparser.exe autogenerated ParseTable for struct ZoneMapExternalMapSnap
#define TYPE_parse_ZoneMapExternalMapSnap ZoneMapExternalMapSnap
ParseTable parse_ZoneMapExternalMapSnap[] =
{
	{ "ZoneMapExternalMapSnap", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ZoneMapExternalMapSnap), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "MapName",				TOK_POOL_STRING | TOK_KEY | TOK_STRING(ZoneMapExternalMapSnap, map_name, 0), NULL },
	{ "filename",				TOK_POOL_STRING | TOK_CURRENTFILE(ZoneMapExternalMapSnap, filename), NULL},
	{ "deps",					TOK_STRUCT(ZoneMapExternalMapSnap, deps, parse_FileEntry) },
	{ "Version",				TOK_AUTOINT(ZoneMapExternalMapSnap, version, 0), NULL },
	{ "MapRoom",				TOK_STRUCT(ZoneMapExternalMapSnap, mapRooms, parse_RoomPartitionParsed) },
	{ "PathNode",				TOK_NO_NETSEND | TOK_STRUCT(ZoneMapExternalMapSnap, eaPathNodes, parse_ZoneMapMetadataPathNode) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
TextParserResult fixupZoneMapExternalMapSnap(ZoneMapExternalMapSnap *pStruct, enumTextParserFixupType eFixupType, void *pExtraData);
int autoStruct_fixup_ZoneMapExternalMapSnap()
{
	int iSize = sizeof(ZoneMapExternalMapSnap);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ZoneMapExternalMapSnap, iSize, "ZoneMapExternalMapSnap", fixupZoneMapExternalMapSnap, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct LayerBounds
#define TYPE_parse_LayerBounds LayerBounds
ParseTable parse_LayerBounds[] =
{
	{ "LayerBounds", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(LayerBounds), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "local_min",			TOK_VEC3(LayerBounds, local_min), NULL },
	{ "local_max",			TOK_VEC3(LayerBounds, local_max), NULL },
	{ "visible_geo_min",	TOK_VEC3(LayerBounds, visible_geo_min), NULL },
	{ "visible_geo_max",	TOK_VEC3(LayerBounds, visible_geo_max), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_LayerBounds()
{
	int iSize = sizeof(LayerBounds);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_LayerBounds, iSize, "LayerBounds", NULL, "WorldGrid.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
