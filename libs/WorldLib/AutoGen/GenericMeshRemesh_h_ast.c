#include "textparser.h"

//auto-generated staticdefine for enum ClusterTargetLOD
//autogeneratednocheckin
StaticDefineInt ClusterTargetLODEnum[] =
{
	DEFINE_INT
	{ "0", ClusterTargetLOD0},
	{ "1", ClusterTargetLOD1},
	{ "2", ClusterTargetLOD2},
	{ "3", ClusterTargetLOD3},
	{ "4", ClusterTargetLOD4},
	{ "5", ClusterTargetLOD5},
	{ "6", ClusterTargetLOD6},
	{ "7", ClusterTargetLOD7},
	{ "8", ClusterTargetLOD8},
	DEFINE_END
};
void autoEnum_fixup_ClusterTargetLOD(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ClusterTargetLODEnum, "ClusterTargetLOD");
}

//auto-generated staticdefine for enum ClusterMinLevel
//autogeneratednocheckin
StaticDefineInt ClusterMinLevelEnum[] =
{
	DEFINE_INT
	{ "256ft", ClusterMinLevel256ft},
	{ "512ft", ClusterMinLevel512ft},
	{ "1024ft", ClusterMinLevel1024ft},
	{ "2048ft", ClusterMinLevel2048ft},
	{ "4096ft", ClusterMinLevel4096ft},
	DEFINE_END
};
void autoEnum_fixup_ClusterMinLevel(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ClusterMinLevelEnum, "ClusterMinLevel");
}

//auto-generated staticdefine for enum ClusterMaxLODLevel
//autogeneratednocheckin
StaticDefineInt ClusterMaxLODLevelEnum[] =
{
	DEFINE_INT
	{ "Default", ClusterMaxLODLevel_Default},
	{ "1", ClusterMaxLODLevel_1},
	{ "2", ClusterMaxLODLevel_2},
	{ "3", ClusterMaxLODLevel_3},
	{ "4", ClusterMaxLODLevel_4},
	{ "5", ClusterMaxLODLevel_5},
	{ "6", ClusterMaxLODLevel_6},
	{ "7", ClusterMaxLODLevel_7},
	{ "8", ClusterMaxLODLevel_8},
	DEFINE_END
};
void autoEnum_fixup_ClusterMaxLODLevel(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ClusterMaxLODLevelEnum, "ClusterMaxLODLevel");
}

//auto-generated staticdefine for enum ClusterTextureResolution
//autogeneratednocheckin
StaticDefineInt ClusterTextureResolutionEnum[] =
{
	DEFINE_INT
	{ "Default", ClusterTextureResolutionDefault},
	{ "64", ClusterTextureResolution64},
	{ "128", ClusterTextureResolution128},
	{ "256", ClusterTextureResolution256},
	{ "512", ClusterTextureResolution512},
	{ "1024", ClusterTextureResolution1024},
	{ "2048", ClusterTextureResolution2048},
	{ "4096", ClusterTextureResolution4096},
	DEFINE_END
};
void autoEnum_fixup_ClusterTextureResolution(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ClusterTextureResolutionEnum, "ClusterTextureResolution");
}

//auto-generated staticdefine for enum ClusterGeometryResolution
//autogeneratednocheckin
StaticDefineInt ClusterGeometryResolutionEnum[] =
{
	DEFINE_INT
	{ "Default", ClusterGeometryResolutionDefault},
	{ "64", ClusterGeometryResolution64},
	{ "128", ClusterGeometryResolution128},
	{ "256", ClusterGeometryResolution256},
	{ "512", ClusterGeometryResolution512},
	{ "1024", ClusterGeometryResolution1024},
	DEFINE_END
};
void autoEnum_fixup_ClusterGeometryResolution(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ClusterGeometryResolutionEnum, "ClusterGeometryResolution");
}

//auto-generated staticdefine for enum ClusterTextureSupersample
//autogeneratednocheckin
StaticDefineInt ClusterTextureSupersampleEnum[] =
{
	DEFINE_INT
	{ "Default", ClusterTextureSupersampleDefault},
	{ "1", ClusterTextureSupersample1},
	{ "4x", ClusterTextureSupersample4x},
	{ "16x", ClusterTextureSupersample16x},
	DEFINE_END
};
void autoEnum_fixup_ClusterTextureSupersample(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ClusterTextureSupersampleEnum, "ClusterTextureSupersample");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct WorldClusterGeoStats
#define TYPE_parse_WorldClusterGeoStats WorldClusterGeoStats
ParseTable parse_WorldClusterGeoStats[] =
{
	{ "WorldClusterGeoStats", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldClusterGeoStats), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "numMaterials",			TOK_AUTOINT(WorldClusterGeoStats, numMaterials, 0), NULL },
	{ "numTextures",			TOK_AUTOINT(WorldClusterGeoStats, numTextures, 0), NULL },
	{ "numVertices",			TOK_AUTOINT(WorldClusterGeoStats, numVertices, 0), NULL },
	{ "numTriangles",			TOK_AUTOINT(WorldClusterGeoStats, numTriangles, 0), NULL },
	{ "numMeshes",				TOK_AUTOINT(WorldClusterGeoStats, numMeshes, 0), NULL },
	{ "numMeshBytes",			TOK_AUTOINT(WorldClusterGeoStats, numMeshBytes, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldClusterGeoStats()
{
	int iSize = sizeof(WorldClusterGeoStats);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldClusterGeoStats, iSize, "WorldClusterGeoStats", NULL, "GenericMeshRemesh.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_TaskProfile[];
#define TYPE_parse_TaskProfile TaskProfile
extern ParseTable parse_WorldClusterGeoStats[];
#define TYPE_parse_WorldClusterGeoStats WorldClusterGeoStats
extern ParseTable parse_WorldClusterGeoStats[];
#define TYPE_parse_WorldClusterGeoStats WorldClusterGeoStats
//Structparser.exe autogenerated ParseTable for struct WorldClusterStats
#define TYPE_parse_WorldClusterStats WorldClusterStats
ParseTable parse_WorldClusterStats[] =
{
	{ "WorldClusterStats", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldClusterStats), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "clusteringTotals",		TOK_AUTOINT(WorldClusterStats, clusteringTotals, 0), TaskProfileEnum },
	{ "netSend",				TOK_AUTOINT(WorldClusterStats, netSend, 0), TaskProfileEnum },
	{ "netRecv",				TOK_AUTOINT(WorldClusterStats, netRecv, 0), TaskProfileEnum },
	{ "wtexDecompress",			TOK_AUTOINT(WorldClusterStats, wtexDecompress, 0), TaskProfileEnum },
	{ "modelExport",			TOK_AUTOINT(WorldClusterStats, modelExport, 0), TaskProfileEnum },
	{ "pngExport",				TOK_AUTOINT(WorldClusterStats, pngExport, 0), TaskProfileEnum },
	{ "convertGeo",				TOK_AUTOINT(WorldClusterStats, convertGeo, 0), TaskProfileEnum },
	{ "remeshGeo",				TOK_AUTOINT(WorldClusterStats, remeshGeo, 0), TaskProfileEnum },
	{ "CastTextures",			TOK_STRUCT(WorldClusterStats, eaCastTextures, parse_TaskProfile) },
	{ "wtexCompress",			TOK_AUTOINT(WorldClusterStats, wtexCompress, 0), TaskProfileEnum },
	{ "cacheGeo",				TOK_AUTOINT(WorldClusterStats, cacheGeo, 0), TaskProfileEnum },
	{ "cacheTex",				TOK_AUTOINT(WorldClusterStats, cacheTex, 0), TaskProfileEnum },
	{ "msetBinGeneration",		TOK_AUTOINT(WorldClusterStats, msetBinGeneration, 0), TaskProfileEnum },
	{ "wtexBinGeneration",		TOK_AUTOINT(WorldClusterStats, wtexBinGeneration, 0), TaskProfileEnum },
	{ "clientClusterBinSize",	TOK_AUTOINT(WorldClusterStats, clientClusterBinSize, 0), TaskProfileEnum },
	{ "inputGeo",				TOK_EMBEDDEDSTRUCT(WorldClusterStats, inputGeo, parse_WorldClusterGeoStats)},
	{ "outputGeo",				TOK_EMBEDDEDSTRUCT(WorldClusterStats, outputGeo, parse_WorldClusterGeoStats)},
	{ "numBuilds",				TOK_AUTOINT(WorldClusterStats, numBuilds, 0), NULL },
	{ "numReuse",				TOK_AUTOINT(WorldClusterStats, numReuse, 0), NULL },
	{ "numCrashes",				TOK_AUTOINT(WorldClusterStats, numCrashes, 0), NULL },
	{ "numDisconnects",			TOK_AUTOINT(WorldClusterStats, numDisconnects, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
TextParserResult fixupWorldClusterStats(WorldClusterStats *pStruct, enumTextParserFixupType eFixupType, void *pExtraData);
int autoStruct_fixup_WorldClusterStats()
{
	int iSize = sizeof(WorldClusterStats);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldClusterStats, iSize, "WorldClusterStats", fixupWorldClusterStats, "GenericMeshRemesh.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ModelClusterTextures
#define TYPE_parse_ModelClusterTextures ModelClusterTextures
ParseTable parse_ModelClusterTextures[] =
{
	{ "ModelClusterTextures", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ModelClusterTextures), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "gmesh_texture_file_d",	TOK_FIXEDSTR(ModelClusterTextures, gmesh_texture_file_d), NULL },
	{ "gmesh_texture_file_n",	TOK_FIXEDSTR(ModelClusterTextures, gmesh_texture_file_n), NULL },
	{ "gmesh_texture_file_s",	TOK_FIXEDSTR(ModelClusterTextures, gmesh_texture_file_s), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ModelClusterTextures()
{
	int iSize = sizeof(ModelClusterTextures);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ModelClusterTextures, iSize, "ModelClusterTextures", NULL, "GenericMeshRemesh.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct NamedTimestamp
#define TYPE_parse_NamedTimestamp NamedTimestamp
ParseTable parse_NamedTimestamp[] =
{
	{ "NamedTimestamp", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(NamedTimestamp), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "name",			TOK_POOL_STRING | TOK_STRING(NamedTimestamp, name, 0), NULL },
	{ "timestamp",		TOK_AUTOINT(NamedTimestamp, timestamp, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_NamedTimestamp()
{
	int iSize = sizeof(NamedTimestamp);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_NamedTimestamp, iSize, "NamedTimestamp", NULL, "GenericMeshRemesh.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct RemeshAssetSwap
#define TYPE_parse_RemeshAssetSwap RemeshAssetSwap
ParseTable parse_RemeshAssetSwap[] =
{
	{ "RemeshAssetSwap", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(RemeshAssetSwap), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "orig_name",			TOK_POOL_STRING | TOK_STRING(RemeshAssetSwap, orig_name, 0), NULL },
	{ "replace_name",		TOK_POOL_STRING | TOK_STRING(RemeshAssetSwap, replace_name, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_RemeshAssetSwap()
{
	int iSize = sizeof(RemeshAssetSwap);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_RemeshAssetSwap, iSize, "RemeshAssetSwap", NULL, "GenericMeshRemesh.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ModelClusterVolume
#define TYPE_parse_ModelClusterVolume ModelClusterVolume
ParseTable parse_ModelClusterVolume[] =
{
	{ "ModelClusterVolume", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ModelClusterVolume), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "volume_min",				TOK_VEC3(ModelClusterVolume, volume_min), NULL },
	{ "volume_max",				TOK_VEC3(ModelClusterVolume, volume_max), NULL },
	{ "lod_max",				TOK_AUTOINT(ModelClusterVolume, lod_max, 0), NULL },
	{ "lod_min",				TOK_AUTOINT(ModelClusterVolume, lod_min, 0), NULL },
	{ "target_lod_level",		TOK_AUTOINT(ModelClusterVolume, target_lod_level, 0), NULL },
	{ "texture_height",			TOK_AUTOINT(ModelClusterVolume, texture_height, 0), NULL },
	{ "texture_width",			TOK_AUTOINT(ModelClusterVolume, texture_width, 0), NULL },
	{ "texture_super_sample",	TOK_AUTOINT(ModelClusterVolume, texture_super_sample, 0), NULL },
	{ "geo_resolution",			TOK_AUTOINT(ModelClusterVolume, geo_resolution, 0), NULL },
	{ "include_specular",		TOK_AUTOINT(ModelClusterVolume, include_specular, 0), NULL },
	{ "include_normal",			TOK_AUTOINT(ModelClusterVolume, include_normal, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
TextParserResult fixupModelClusterVolume(ModelClusterVolume *pStruct, enumTextParserFixupType eFixupType, void *pExtraData);
int autoStruct_fixup_ModelClusterVolume()
{
	int iSize = sizeof(ModelClusterVolume);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ModelClusterVolume, iSize, "ModelClusterVolume", fixupModelClusterVolume, "GenericMeshRemesh.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ModelClusterTextures[];
#define TYPE_parse_ModelClusterTextures ModelClusterTextures
extern ParseTable parse_NamedTimestamp[];
#define TYPE_parse_NamedTimestamp NamedTimestamp
extern ParseTable parse_NamedTimestamp[];
#define TYPE_parse_NamedTimestamp NamedTimestamp
extern ParseTable parse_RemeshAssetSwap[];
#define TYPE_parse_RemeshAssetSwap RemeshAssetSwap
extern ParseTable parse_RemeshAssetSwap[];
#define TYPE_parse_RemeshAssetSwap RemeshAssetSwap
//Structparser.exe autogenerated ParseTable for struct ModelClusterObject
#define TYPE_parse_ModelClusterObject ModelClusterObject
ParseTable parse_ModelClusterObject[] =
{
	{ "ModelClusterObject", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ModelClusterObject), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "model_filename",			TOK_POOL_STRING | TOK_STRING(ModelClusterObject, model_filename, 0), NULL },
	{ "mesh_filename",			TOK_POOL_STRING | TOK_STRING(ModelClusterObject, mesh_filename, 0), NULL },
	{ "model_timestamp",		TOK_AUTOINT(ModelClusterObject, model_timestamp, 0), NULL },
	{ "gmesh_texture_files",	TOK_STRUCT(ModelClusterObject, gmesh_texture_files, parse_ModelClusterTextures) },
	{ "model_matrix",			TOK_FIXED_ARRAY | TOK_F32_X, offsetof(ModelClusterObject, model_matrix),  16, NULL , 0 , "HIGH_PREC_FLOAT = 1"},
	{ "radius",					TOK_F32(ModelClusterObject, radius, 0), NULL , 0 , "HIGH_PREC_FLOAT = 1"},
	{ "position",				TOK_VEC3(ModelClusterObject, position), NULL , 0 , "HIGH_PREC_FLOAT = 1"},
	{ "tex_stamps",				TOK_STRUCT(ModelClusterObject, tex_stamps, parse_NamedTimestamp) },
	{ "mat_stamps",				TOK_STRUCT(ModelClusterObject, mat_stamps, parse_NamedTimestamp) },
	{ "tex_swaps",				TOK_STRUCT(ModelClusterObject, tex_swaps, parse_RemeshAssetSwap) },
	{ "mat_swaps",				TOK_STRUCT(ModelClusterObject, mat_swaps, parse_RemeshAssetSwap) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
TextParserResult fixupModelClusterObject(ModelClusterObject *pStruct, enumTextParserFixupType eFixupType, void *pExtraData);
int autoStruct_fixup_ModelClusterObject()
{
	int iSize = sizeof(ModelClusterObject);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ModelClusterObject, iSize, "ModelClusterObject", fixupModelClusterObject, "GenericMeshRemesh.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ModelClusterObject[];
#define TYPE_parse_ModelClusterObject ModelClusterObject
extern ParseTable parse_ModelClusterVolume[];
#define TYPE_parse_ModelClusterVolume ModelClusterVolume
//Structparser.exe autogenerated ParseTable for struct ModelClusterSource
#define TYPE_parse_ModelClusterSource ModelClusterSource
ParseTable parse_ModelClusterSource[] =
{
	{ "ModelClusterSource", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ModelClusterSource), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "cluster_tool_version",		TOK_AUTOINT(ModelClusterSource, cluster_tool_version, 0), NULL },
	{ "cluster_models",				TOK_STRUCT(ModelClusterSource, cluster_models, parse_ModelClusterObject) },
	{ "cluster_volumes_condensed",	TOK_OPTIONALSTRUCT(ModelClusterSource, cluster_volumes_condensed, parse_ModelClusterVolume) },
	{ "texture_super_sample",		TOK_IGNORE, 0 },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
TextParserResult fixupModelClusterSource(ModelClusterSource *pStruct, enumTextParserFixupType eFixupType, void *pExtraData);
int autoStruct_fixup_ModelClusterSource()
{
	int iSize = sizeof(ModelClusterSource);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ModelClusterSource, iSize, "ModelClusterSource", fixupModelClusterSource, "GenericMeshRemesh.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_RemeshAssetSwap[];
#define TYPE_parse_RemeshAssetSwap RemeshAssetSwap
//Structparser.exe autogenerated ParseTable for struct RemeshMaterial
#define TYPE_parse_RemeshMaterial RemeshMaterial
ParseTable parse_RemeshMaterial[] =
{
	{ "RemeshMaterial", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(RemeshMaterial), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "simplygon_material",	TOK_POOL_STRING | TOK_STRING(RemeshMaterial, simplygon_material, 0), NULL },
	{ "tex_swaps",			TOK_STRUCT(RemeshMaterial, tex_swaps, parse_RemeshAssetSwap) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_RemeshMaterial()
{
	int iSize = sizeof(RemeshMaterial);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_RemeshMaterial, iSize, "RemeshMaterial", NULL, "GenericMeshRemesh.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
