#ifndef _WORLDGRID_H_
#define _WORLDGRID_H_
GCC_SYSTEM

#include "file.h"
#include "Message.h"
#include "GlobalEnums.h"
#include "WorldLibEnums.h"
#include "wlEncounter.h"
#include "wlUGC.h"
#include "wlVolumes.h"
#include "../StaticWorld/ZoneMap.h"
#include "../StaticWorld/ZoneMapLayer.h"
#include "../StaticWorld/group.h"
#include "../StaticWorld/groupjournal.h"
#include "../StaticWorld/grouptrack.h"
#include "../StaticWorld/grouputil.h"
#include "../StaticWorld/groupProperties.h"
#include "../StaticWorld/WorldGridLoad.h"
#include "../StaticWorld/WorldGridSave.h"
#include "../StaticWorld/WorldGridSend.h"
#include "../StaticWorld/WorldGridRecv.h"
#include "../StaticWorld/WorldCellEntry.h"
#include "ObjectLibrary.h"

typedef struct GroupDef GroupDef;
typedef struct GroupTracker GroupTracker;
typedef struct ZoneMap ZoneMap;
typedef struct ZoneMapInfo ZoneMapInfo;
typedef struct ZoneMapLayer ZoneMapLayer;
typedef struct WorldColl WorldColl;
typedef struct WorldGraphicsData WorldGraphicsData;
typedef struct WorldRegion WorldRegion;
typedef struct WorldRegionGraphicsData WorldRegionGraphicsData;
typedef struct SkyInfoGroup SkyInfoGroup;
typedef struct RoomConnGraph RoomConnGraph;
typedef struct GPolySet GPolySet;
typedef struct CivilianGenerator CivilianGenerator;
typedef struct BlockRange BlockRange;
typedef struct StashTableImp* StashTable;
typedef struct ResourceInfo ResourceInfo;
typedef struct DynFxRegion DynFxRegion;
typedef struct PetDef PetDef;
typedef struct TempPuppetChoice TempPuppetChoice;
typedef struct UIWidget UIWidget;
typedef struct WorldRegionRules WorldRegionRules;
typedef struct ShadowRules ShadowRules;
typedef struct CamLightRules CamLightRules;
typedef struct WorldRegionWindRules WorldRegionWindRules;
typedef struct WorldRegionLODSettings WorldRegionLODSettings;
typedef struct RoomPartitionParsed RoomPartitionParsed;
typedef struct MapSnapRegionData MapSnapRegionData;
typedef struct SecondaryZoneMap SecondaryZoneMap;
typedef U32 dtFxManager;

AUTO_STRUCT;
typedef struct WorldFile
{
	const char		*fullname;  AST( NAME(FN) CURRENTFILE ) // Must be first for ParserReloadFile
	AST_STOP
	U32				mod_time;
	__time32_t		timestamp; // timestamp of the file when loaded
	U32				checked_out : 1;
	U32				unsaved : 1;
	U32				client_owned : 1;
	U32				failed_check_out : 1;
} WorldFile;


// world grid & terrain block size
#define GRID_BLOCK_SIZE		256.f
#define MAX_TERRAIN_LODS		8 // Deprecated
#define MIN_TERRAIN_EDIT_LOD	2 // Deprecated
#define GRID_LOD(x)			(((U32)GRID_BLOCK_SIZE >> (x)) + 1)	// Deprecated

// world cell block size
//#define CELL_BLOCK_SIZE		16.f
#define CELL_BLOCK_SIZE		256.f

#define UPDATE_GROUP_PROPERTIES (-1)
#define UPDATE_REMOVED_CHILD (-2)

// this mimicks g_dynNodeMaxDistOriginSqr, but is used to bounds check groupdefs instead of dynnodes,
// and should be a square bound instead of a radius.  It gets set on zone map load to MAX_PLAYABLE_COORDINATE
// or space bounds distance.
extern F32 g_worldBoundsMaxDist;

AUTO_STRUCT AST_STARTTOK("") AST_ENDTOK("EndTimeBlock");
typedef struct ZoneMapTimeBlock
{
	F32 time;						AST( NAME("Time") )
	F32 duration;					AST( NAME("Duration") )
	const char *tag;				AST( NAME("Tag") POOL_STRING )
} ZoneMapTimeBlock;

AUTO_STRUCT;
typedef struct WorldCivilianGenerator
{
	Vec3 position;
	CivilianGenerator *civ_gen;  NO_AST
} WorldCivilianGenerator;

AUTO_STRUCT;
typedef struct WorldForbiddenPosition
{
	Vec3 position;
} WorldForbiddenPosition;

AUTO_STRUCT;
typedef struct WorldPathNode
{
	Vec3 position;
	int uID;
	WorldPathNodeProperties properties;  AST(EMBEDDED_FLAT)
} WorldPathNode;

AUTO_STRUCT;
typedef struct WorldPathEdge
{
	int uOther;

	// Set if this edge was generated by UGC.  This allows the edge to
	// be removed during binning.
	bool bUGCGenerated;

	// The following fields calculated on map load.
	Vec3 v3Other;					AST( NO_TEXT_SAVE )
	F32 fCost;						AST( NO_TEXT_SAVE )
} WorldPathEdge;
extern ParseTable parse_WorldPathEdge[];
#define TYPE_parse_WorldPathEdge WorldPathEdge

AUTO_STRUCT AST_STARTTOK("") AST_ENDTOK(End);
typedef struct PhotoOptions
{
	F32 far_plane_offset;
	F32 near_plane_offset;
} PhotoOptions;

AUTO_STRUCT;
typedef struct TempPuppetChoice {
	REF_TO(PetDef) hPetDef;			AST(REFDICT(PetDef) STRUCTPARAM)
	Expression *pEvalExpression;	AST(LATEBIND)
	F32 fWeight;					AST(DEFAULT(1.0f))
}TempPuppetChoice;

AUTO_STRUCT;
typedef struct RegionRulesOverride{
	S32 iAllowedPetsPerPlayer;				AST(NAME(AllowedPetsPerPlayer) DEFAULT(-1))
	S32 iUnteamedPetsPerPlayer;				AST(NAME(UnteamedPetsPerPlayer) DEFAULT(-1))

	TempPuppetChoice **ppTempPuppets;		AST(NAME(TempPuppet) LATEBIND)

	U32 eVehicleRules;						AST(NAME(VehicleRules) DEFAULT(kVehicleRules_Inherit) SUBTABLE(VehicleRulesEnum))
}RegionRulesOverride;

//If you change this structure, make sure to also modify the following functions:
//aslMapManagerRequestZoneMapInfoByPublicName and zmapInfoGetFromRequest
AUTO_STRUCT;
typedef struct ZoneMapInfoRequest
{
	char* pchDisplayNameMsgKey;
	ZoneMapType	eMapType;
	WorldRegion** eaRegions;
	GenesisZoneMapData* pGenesisData;
	GenesisZoneMapInfo* pGenesisInfo;
	WorldVariableDef** eaVarDefs;
	Expression* pRequiresExpr;
	Expression* pPermissionExpr;
	bool bConfirmPurchasesOnExit;
} ZoneMapInfoRequest;

C_DECLARATIONS_BEGIN

void worldLoadZoneMaps(void);

bool worldIsSameMap(SA_PARAM_OP_STR const char *map_name_1, SA_PARAM_OP_STR const char *map_name_2); // either one may be a filename or public name

U32 worldGetZoneMapCount();
void worldGetZoneMapIterator(RefDictIterator *iter);
ZoneMapInfo *worldGetNextZoneMap(RefDictIterator *iter);
SA_RET_OP_VALID ZoneMapInfo *worldGetZoneMapByPublicNameSimple(SA_PARAM_OP_STR const char *public_name); // simple version does not support filenames or matching public name within namespaces
SA_RET_OP_VALID ZoneMapInfo *worldGetZoneMapByPublicName(SA_PARAM_OP_STR const char *public_name); // may be filename or public name
SA_RET_OP_STR const char *worldGetZoneMapFilenameByPublicName(SA_PARAM_OP_STR const char *public_name); // may be filename or public name
void worldGetZoneMapsThatStartWith(SA_PARAM_OP_STR const char *public_name, ZoneMapInfo ***zmaps_out);
void worldGetZoneMapsInNamespace(const char *name_space, ZoneMapInfo ***zminfos_out);
bool worldIsZoneMapInNamespace(ZoneMapInfo *zmap);

bool worldLoadZoneMapByName(SA_PARAM_NN_STR const char *map_name); // may be filename or public name
bool worldLoadZoneMapEx(ZoneMapInfo *zminfo, bool force_create_bins, bool load_from_source, bool clear_manifest_cache_after_loading);
#define worldLoadZoneMap(zminfo, force_create_bins, load_from_source) worldLoadZoneMapEx(zminfo, force_create_bins, load_from_source, true)
bool worldGetMapClustered(ZoneMap *zMap);

bool worldZoneMapStartPatching(ZoneMapInfo *zminfo);
bool worldZoneMapStartPatchingByName(SA_PARAM_NN_STR const char *map_name); // may be filename or public name
bool worldZoneMapPatching(bool bCheckCallbacks);

typedef void (*ZoneMapLoadedCallback)(void *userData);
// This will allow for asynchronous patching of the map data (file is still actually loaded in the main thread)
bool worldLoadZoneMapAsync(ZoneMapInfo *zminfo, ZoneMapLoadedCallback callback, void *userData);
bool worldLoadZoneMapByNameAsync(SA_PARAM_NN_STR const char *map_name, ZoneMapLoadedCallback callback, void *userData); // may be filename or public name
void worldLoadZoneMapAsyncCancel();

// Slow, will stall, should only be used for things like builders binning maps
bool worldLoadZoneMapSyncWithPatching(ZoneMapInfo *zminfo, bool force_create_bins, bool load_from_source, bool clear_manifest_cache_after_loading);
bool worldLoadZoneMapByNameSyncWithPatching(SA_PARAM_NN_STR const char *map_name);

void worldResetWorldGrid(void);
void worldResetDefPools(bool destroy_memory_pools);
void worldLoadEmptyMap(void);
void worldReloadMap(void);

WorldGraphicsData *worldGetWorldGraphicsData(void);

int worldGetLoadedZoneMapCount(void);
SA_RET_OP_VALID ZoneMap *worldGetLoadedZoneMapByIndex(int index);
SA_RET_OP_VALID ZoneMap *worldGetLoadedZoneMapByName(SA_PARAM_NN_STR const char *zmap_name); // filename or public name

void worldSetActiveMap(SA_PARAM_OP_VALID ZoneMap *zmap);
void worldSetActiveMapByName(SA_PARAM_OP_STR const char *zmap_name); // filename or public name

ZoneMap *worldGetActiveMap(void); // you probably don't need to call this, passing NULL to any zmap function defaults to the active map
ZoneMap *worldGetPrimaryMap(void);

void worldCreatePartition(int iPartitionIdx, bool bCreateScenes);
void worldDestroyPartition(int iPartitionIdx);
WorldColl* worldGetActiveColl(int iPartitionIdx);
S32 worldGetPartitionIdxByColl(WorldColl *wc);
WorldColl* worldGetAnyActiveColl(void);
int worldGetAnyCollPartitionIdx(void);
bool worldIsValidPartitionIdx(int iPartitionIdx);
void worldCreateAllCollScenes(void);

int worldRebuiltBins(void);

int worldIncrementDefAccessTime(void);
int worldIsLoading(void);
U32 worldGetModTime(void);
void worldGridOncePerFrame(void);
int worldGetResetCount(bool include_reloads);
void worldSetModTime(U32 iTime);
U32 worldIncModTime(void);

//OK to use during ASYNC loading, don't use this unless you really know what you're doing
void worldSetModTime_AsyncOK(U32 iTime);

SA_ORET_NN_VALID WorldRegion *worldGetTempWorldRegionByName(SA_PARAM_OP_STR const char *name);
void worldGridClearTempTrackers(void);
SA_ORET_NN_VALID WorldRegion *worldGetWorldRegionByPos(SA_PRE_NN_RELEMS(3) const Vec3 cam_pos);
bool worldHasWorldRegions(void);
SA_ORET_OP_VALID WorldRegion *worldGetEditorWorldRegion(void);
WorldRegion **worldGetAllWorldRegions(void);
SA_ORET_OP_VALID WorldRegionGraphicsData *worldRegionGetGraphicsData(SA_PARAM_OP_VALID WorldRegion *region);
int worldRegionGetVisibleBounds(SA_PARAM_NN_VALID const WorldRegion *region, SA_PRE_NN_ELEMS(3) SA_POST_OP_VALID Vec3 world_min, SA_PRE_NN_ELEMS(3) SA_POST_OP_VALID Vec3 world_max);
int worldRegionGetBounds(SA_PARAM_NN_VALID const WorldRegion *region, SA_PRE_NN_ELEMS(3) SA_POST_OP_VALID Vec3 world_min, SA_PRE_NN_ELEMS(3) SA_POST_OP_VALID Vec3 world_max);
SA_ORET_NN_VALID const WorldRegionRules *worldRegionGetRulesByType(WorldRegionType region_type);
SA_ORET_NN_VALID const WorldRegionRules *worldRegionGetRules(SA_PARAM_OP_VALID const WorldRegion *region);
SA_ORET_NN_VALID const CamLightRules *worldRegionRulesGetCamLightRules(SA_PARAM_NN_VALID const WorldRegionRules *region_rules);
SA_ORET_NN_VALID const ShadowRules *worldRegionRulesGetShadowRules(SA_PARAM_NN_VALID const WorldRegionRules *region_rules);
SA_ORET_NN_VALID const WorldRegionWindRules *worldRegionRulesGetWindRules(SA_PARAM_NN_VALID const WorldRegionRules *region_rules);
SA_ORET_NN_VALID const WorldRegionLODSettings *worldRegionRulesGetLODSettings(SA_PARAM_NN_VALID const WorldRegionRules *region_rules);
const char *worldRegionGetRegionName(SA_PARAM_NN_VALID const WorldRegion *region);
F32 worldRegionGetEffectiveScale(SA_PARAM_OP_VALID const WorldRegion *region);
F32 worldRegionGetLodScale(SA_PARAM_OP_VALID const WorldRegion *region);
bool worldRegionGetNoSkySun(SA_PARAM_OP_VALID const WorldRegion *region);
WorldRegionType worldRegionGetType(SA_PARAM_OP_VALID const WorldRegion *region);
void worldRegionSetType(SA_PARAM_NN_VALID WorldRegion *region, WorldRegionType type);
bool worldRegionGetIndoorLighting(SA_PARAM_NN_VALID WorldRegion *region);
void worldRegionSetIndoorLighting(SA_PARAM_NN_VALID WorldRegion *region, bool bIndoorLightingMode);
bool worldRegionGetWorldGeoClustering(WorldRegion *region);
void worldRegionSetWorldGeoClustering(WorldRegion *region, bool bWorldGeoClustering);
RegionRulesOverride *worldRegionGetOverrides(SA_PARAM_NN_VALID WorldRegion *region);
SA_ORET_OP_VALID ZoneMap *worldRegionGetZoneMap(SA_PARAM_NN_VALID WorldRegion *region);
SA_ORET_OP_VALID SkyInfoGroup *worldRegionGetSkyGroup(SA_PARAM_NN_VALID WorldRegion *region);
void worldRegionSetSkyGroup(SA_PARAM_NN_VALID WorldRegion *region, SkyInfoGroup *sky_group);
SA_ORET_OP_STR const char *worldRegionGetOverrideCubeMap(SA_PARAM_NN_VALID WorldRegion *region);
void worldRegionSetOverrideCubeMap(SA_PARAM_NN_VALID WorldRegion *region, SA_PARAM_OP_STR const char *override_cubemap, bool increment_mod_time);
S32 worldRegionGetAllowedPetsPerPlayer(SA_PARAM_NN_VALID WorldRegion *region);
S32 worldRegionGetUnteamedPetsPerPlayer(SA_PARAM_NN_VALID WorldRegion *region);
S32 worldRegionGetVehicleRules(SA_PARAM_NN_VALID WorldRegion *region);
void worldRegionSetAllowedPetsPerPlayer(SA_PARAM_NN_VALID WorldRegion *region, S32 iAllowedPetsPerPlayer);
void worldRegionSetUnteamedPetsPerPlayer(SA_PARAM_NN_VALID WorldRegion *region, S32 iUnteamedPetsPerPlayer);
bool worldRegionIsEditorRegion(SA_PARAM_NN_VALID const WorldRegion *region);
bool worldRegionIsTemporary(SA_PARAM_NN_VALID const WorldRegion *region);
void worldCloseAllRegionsExcept(SA_PARAM_OP_VALID const WorldRegion *region);
void worldCloseAllOldRegions(U32 timestamp);
void worldRegionGetAssociatedRegionList(WorldRegion ***regions, F32 **camera_positions, int **hidden_object_ids);
const char* worldRegionSwapFX(SA_PARAM_NN_VALID const WorldRegion *region, SA_PARAM_NN_STR const char* pcFxName);
SA_ORET_OP_VALID DynFxRegion *worldRegionGetFXRegion(SA_PARAM_OP_VALID WorldRegion *region);
dtFxManager worldRegionGetGlobalFXManager(SA_PARAM_OP_VALID WorldRegion *region);
SA_ORET_NN_VALID MapSnapRegionData * worldRegionGetMapSnapData(SA_PARAM_NN_VALID WorldRegion *region);
WorldPathNode** worldRegionGetPathNodes(WorldRegion *region);

int worldGridOpenAllCellsForCameraPos(int iPartitionIdx, SA_PARAM_NN_VALID WorldRegion *region, const F32 *camera_positions, int camera_position_count, 
									   const BlockRange **terrain_editor_blocks, bool load_all, bool new_partition,
									   bool draw_high_detail, bool draw_high_fill_detail, U32 timestamp, F32 cell_scale);

int worldFindServerFileIndex(SA_PARAM_NN_STR const char *fullname);

int worldGenerateDefNameUID(SA_PARAM_NN_STR const char *name_str, SA_PARAM_OP_VALID GroupDef *def, bool is_objlib, bool is_core);

U32 worldCountGroupDefs(SA_PARAM_NN_VALID GroupDef *def);

void worldClearWorldLocks(U32 UID);

// GroupDef
void groupDefRename(SA_PARAM_NN_VALID GroupDef *def, SA_PARAM_NN_STR const char *new_def_name);
void groupDefClear(SA_PARAM_OP_VALID GroupDef *def);
void groupDefFree(SA_PRE_OP_VALID SA_POST_P_FREE GroupDef *def);
const char *groupDefGetFilename(SA_PARAM_NN_VALID GroupDef *def);

U32 groupGenerateGroupChildUID(SA_PARAM_NN_VALID GroupDef *parent, GroupChild **def_children, int idx_in_parent);
void groupDefSetChildCount(SA_PARAM_NN_VALID GroupDef *parent, GroupChild ***def_children, int new_child_count);
SA_ORET_NN_VALID GroupChild *groupChildInitialize(SA_PARAM_NN_VALID GroupDef *parent, int child_idx, SA_PARAM_OP_VALID GroupDef *child, SA_PRE_OP_RBYTES(sizeof(Mat4)) const Mat4 mat, F32 scale, U32 seed, U32 uid_in_parent);

// WorldFile
void worldFileSetSaved(SA_PARAM_NN_VALID WorldFile *file);
bool worldFileBlock(SA_PARAM_NN_VALID WorldFile *file);
bool worldFileUnblock(SA_PARAM_NN_VALID WorldFile *file);
bool worldFileCheckout(SA_PARAM_NN_VALID WorldFile *file);
bool worldFileUndoCheckout(SA_PARAM_NN_VALID WorldFile *file);
bool worldFileCheckoutList(WorldFile **files);
bool worldFileDeleteList(WorldFile **files);
const char *worldFileGetLockee(SA_PARAM_NN_VALID WorldFile *file);
bool worldFileCanSave(SA_PARAM_NN_VALID WorldFile *file, SA_PARAM_OP_STR const char *filename_override, bool do_timestamp_check);
void worldFileModify(SA_PARAM_NN_VALID WorldFile *file, bool increment_mod_time, bool do_checkout);
bool worldFileLoad(SA_PARAM_NN_VALID WorldFile *file, SA_PARAM_NN_VALID ParseTable *table, SA_PARAM_NN_VALID void *data, SA_PARAM_OP_STR const char *parent_filename, bool exists_error, bool persist);
bool worldFileSaveAs(SA_PARAM_NN_VALID WorldFile *file, SA_PARAM_NN_VALID ParseTable *table, SA_PARAM_NN_VALID void *data, SA_PARAM_OP_VALID const char *filename, bool force);
bool worldFileSave(SA_PARAM_NN_VALID WorldFile *file, SA_PARAM_NN_VALID ParseTable *table, SA_PARAM_NN_VALID void *data);


void worldCellCloseAll(void);
void worldCellGetDrawableEntries(SA_PARAM_OP_VALID WorldCell *cell, SA_PARAM_NN_VALID WorldDrawableEntry ***drawable_entries);
SA_ORET_OP_VALID WorldCell *worldCellGetParent(SA_PARAM_OP_VALID WorldCell *cell);
void worldUpdateBounds(bool recalc_all, bool close_trackers);

// Directory helpers
void worldGetClientBaseDir(const char *zmapFilename, char *base_dir, size_t base_dir_size);
void worldGetServerBaseDir(const char *zmapFilename, char *base_dir, size_t base_dir_size);
void worldGetTempBaseDir(const char *zmapFilename, char *base_dir, size_t base_dir_size);

typedef struct TempGroupParams
{
	bool editor_only;
	bool in_headshot;
	bool unlit;
	bool dont_cast_shadows;
	bool no_culling : 1;
	bool disable_vertex_lighting : 1;
	unsigned no_sound : 1;
	int wireframe;
    int seed;
	F32 alpha;
	F32 *tint_color0;
	F32 *tint_color1;
	const char *override_region_name; // will create a temporary region if a region with this name is not found
	GroupSplineParams *spline_params;
	GroupChildParameter **params;
} TempGroupParams;

GroupTracker *worldAddTempGroup(SA_PARAM_NN_VALID GroupDef *def, SA_PRE_OP_RBYTES(sizeof(Mat4)) const Mat4 world_mat, SA_PARAM_OP_VALID TempGroupParams *tgparams, bool in_world);

SA_ORET_OP_VALID SkyInfoGroup *worldRegionGetSkyOverride(SA_PARAM_OP_VALID WorldRegion *region, SA_PRE_NN_FREE SA_POST_NN_VALID F32 *fade_percent, SA_PRE_NN_FREE SA_POST_NN_VALID F32 *fade_rate);
SA_ORET_OP_VALID RoomConnGraph *worldRegionGetRoomConnGraph(SA_PARAM_OP_VALID WorldRegion *region);
SA_ORET_OP_VALID WorldCivilianGenerator** worldRegionGetCivilianGenerators(SA_PARAM_OP_VALID WorldRegion *region);
SA_ORET_OP_VALID WorldForbiddenPosition** worldRegionGetForbiddenPositions(SA_PARAM_OP_VALID WorldRegion *region);

void worldControllerScriptWaitForMapLoad();

extern WLUsageFlags model_override_use_flags;

ExprContext **worldGetTempChoiceContext(void);


//////////////////////////////////////////////////////////////////////////
// Logical Named map data
//
// Location, type, etc. info about named things, and regions
AUTO_ENUM;
typedef enum WorldEncounterObjectInteractType
{
	WL_ENC_UNKNOWN,
	WL_ENC_DOOR,
	WL_ENC_CLICKIE,
	WL_ENC_DESTRUCTIBLE,
	WL_ENC_CONTACT,
	WL_ENC_STARTSPAWN,
	WL_ENC_DIALOGTREE,
	WL_ENC_REWARD_BOX,

	WL_ENC_UGC_OPEN_DOOR,							EIGNORE // UGC Only
} WorldEncounterObjectInteractType;
extern StaticDefineInt WorldEncounterObjectInteractTypeEnum[];

AUTO_STRUCT;
typedef struct ZoneMapEncounterObjectUGCInfo
{
	char* logicalName;								AST( NAME(LogicalName) STRUCTPARAM )
	REF_TO(Message) displayName;					AST( NAME(DisplayName) )
	REF_TO(Message) displayDetails;					AST( NAME(DisplayDetails) )
	WorldEncounterObjectInteractType interactType;	AST( NAME(InteractType) )
	const char *ugcContactName;						AST( POOL_STRING NAME(UGCContactName) )
} ZoneMapEncounterObjectUGCInfo;
extern ParseTable parse_ZoneMapEncounterObjectUGCInfo[];
#define TYPE_parse_ZoneMapEncounterObjectUGCInfo ZoneMapEncounterObjectUGCInfo

AUTO_STRUCT;
typedef struct ZoneMapEncounterObjectUGCGroup
{
	WorldUGCRestrictionProperties restrictions;		AST( EMBEDDED_FLAT )
	
	ZoneMapEncounterObjectUGCInfo** objects;		AST( NAME(UGCObject) )
} ZoneMapEncounterObjectUGCGroup;
extern ParseTable parse_ZoneMapEncounterObjectUGCGroup[];
#define TYPE_parse_ZoneMapEncounterObjectUGCGroup ZoneMapEncounterObjectUGCGroup

AUTO_STRUCT;
typedef struct ZoneMapEncounterUGCInfo
{
	const char* map_name;							AST( NAME(MapName) KEY POOL_STRING )
	const char* filename;							AST( CURRENTFILE )
	
	// If set, then all the other fields should not be set.
	const char* deprecated_map_new_map_name;		AST( NAME(DeprecatedMapNewMapName) )
	
	const char** volume_logical_name;				AST( NAME(VolumeLogicalName) )

	ZoneMapEncounterObjectUGCGroup default_group;	AST( EMBEDDED_FLAT )
	ZoneMapEncounterObjectUGCGroup** groups;		AST( NAME(Group) )
} ZoneMapEncounterUGCInfo;
extern ParseTable parse_ZoneMapEncounterUGCInfo[];
#define TYPE_parse_ZoneMapEncounterUGCInfo ZoneMapEncounterUGCInfo

AUTO_STRUCT;
typedef struct ZoneMapEncounterVolumeInfo
{
	WorldVolumeShape shape;							AST( NAME(Shape) SUBTABLE(WorldVolumeShapeEnum) )
	Vec3 boxMin;									AST( NAME(BoxMin) )
	Vec3 boxMax;									AST( NAME(BoxMax) )
	float sphereRadius;								AST( NAME(SphereRadius) )
	WorldPowerVolumeProperties* power_properties;	AST( NAME(PowerProperties) )
} ZoneMapEncounterVolumeInfo;

AUTO_STRUCT;
typedef struct ZoneMapEncounterObjectInfo
{
	char* logicalName;								AST( NAME(LogicalName) STRUCTPARAM )
	const char* regionName;							AST( POOL_STRING NAME(RegionName))
	Vec3 pos;										AST( NAME(Pos) )
	Quat qOrientation;								AST( NAME(Orientation) )
	// type info
	WorldEncounterObjectType type;					AST( NAME(Type) )
	WorldEncounterObjectInteractType interactType;	AST( NAME(InteractType) )

	// All Cryptic Map objects get these filled out (if applicable)
	WorldUGCRestrictionProperties restrictions;		AST( EMBEDDED_FLAT )
	REF_TO(Message) displayName;					AST( NAME(DisplayName) )
	REF_TO(Message) displayDetails;					AST( NAME(DisplayDetails) )
	const char *ugcContactName;						AST( POOL_STRING NAME(UGCContactName) )
	REF_TO(PlayerCostume) ugcContactCostume;		AST( NAME(UGCContactCostume) )
	ZoneMapEncounterVolumeInfo* volume;				AST( NAME(Volume) )

	// Only UGC Components get these filled out
	char *ugcDisplayName;							AST( NAME(UGCDisplayName) )
	char *ugcDisplayDetails;						AST( NAME(UGCDisplayDetails) )
	bool ugcIsInvalidSelection;						AST( NAME(UGCIsInvalidSelection) )
	int ugcComponentID;								AST( NAME(UGCComponentID)) //=component uid if made in ugc, =0 otherwise. 


} ZoneMapEncounterObjectInfo;
extern ParseTable parse_ZoneMapEncounterObjectInfo[];
#define TYPE_parse_ZoneMapEncounterObjectInfo ZoneMapEncounterObjectInfo

AUTO_STRUCT;
typedef struct ZoneMapEncounterRoomInfo
{
	Vec3 min;
	Vec3 max;
} ZoneMapEncounterRoomInfo;
extern ParseTable parse_ZoneMapEncounterRoomInfo[];
#define TYPE_parse_ZoneMapEncounterRoomInfo ZoneMapEncounterRoomInfo

AUTO_STRUCT;
typedef struct ZoneMapEncounterRegionInfo
{
	const char* regionName;								AST( POOL_STRING )
	Vec3 min;
	Vec3 max;
	ZoneMapEncounterRoomInfo **rooms;
	F32 fGroundFocusHeight;					//used to find mapsnap skew offsets
	WorldRegionType			type;
} ZoneMapEncounterRegionInfo;
extern ParseTable parse_ZoneMapEncounterRegionInfo[];
#define TYPE_parse_ZoneMapEncounterRegionInfo ZoneMapEncounterRegionInfo

/// Really, this should be called "ZoneMapMetadataServer".
///
/// Metadata about all the different interactable object positions and
/// other interesting data tha normaly is only known when on that map
/// and only the server.
AUTO_STRUCT AST_FIXUPFUNC( fixupZoneMapEncounterInfo ) AST_IGNORE( v2 );
typedef struct ZoneMapEncounterInfo
{
	const char* map_name;							AST( NAME(MapName) KEY POOL_STRING )
	const char* filename;							AST( CURRENTFILE )
	FileEntry** deps;								AST( NAME(deps) STRUCT(parse_FileEntry) )		
	int version;									AST( NAME(Version) )

	// If set, then all the other fields should not be set.
	const char* deprecated_map_new_map_name;		AST( NAME(DeprecatedMapNewMapName) )

	ZoneMapEncounterObjectInfo** objects;			AST( NAME(Object) )
	ZoneMapEncounterRegionInfo** regions;			AST( NAME(Region) )
	ZoneMapEncounterRoomInfo** playable_volumes;	AST( NAME(PlayableVolume))
	char** volume_logical_name;						AST( NAME(VolumeLogicalName) )
	SecondaryZoneMap **secondary_maps;				AST( NAME(SecondaryMap) )

	const char *ugc_display_name;					NO_AST
	UIWidget *ugc_picker_widget;					NO_AST
	F32 ugc_map_scale;								NO_AST
} ZoneMapEncounterInfo;
extern ParseTable parse_ZoneMapEncounterInfo[];
#define TYPE_parse_ZoneMapEncounterInfo ZoneMapEncounterInfo

AUTO_STRUCT;
typedef struct ZoneMapMetadataPathEdge
{
	int uOther;
} ZoneMapMetadataPathEdge;
extern ParseTable parse_ZoneMapMetadataPathEdge[];
#define TYPE_parse_ZoneMapMetadataPathEdge ZoneMapMetadataPathEdge

/// Metadata about a path node.
AUTO_STRUCT;
typedef struct ZoneMapMetadataPathNode
{
	int defUID;										AST( NAME(DefUID) )
	Vec3 pos;										AST( NAME(Pos) )
	ZoneMapMetadataPathEdge** eaConnections;		AST( NAME(Connection) )
} ZoneMapMetadataPathNode;
extern ParseTable parse_ZoneMapMetadataPathNode[];
#define TYPE_parse_ZoneMapMetadataPathNode ZoneMapMetadataPathNode

/// Really, this should be called "ZoneMapMetadataClient".
///
/// Metadata about the map snap and path nodes that normally only is
/// known when on that map and only the client.
AUTO_STRUCT AST_FIXUPFUNC( fixupZoneMapExternalMapSnap );
typedef struct ZoneMapExternalMapSnap
{
	const char* map_name;							AST( NAME(MapName) KEY POOL_STRING )
	const char* filename;							AST( CURRENTFILE )
	FileEntry** deps;								AST( NAME(deps) )
	int version;									AST( NAME(Version) )

	// for minimap display	
	RoomPartitionParsed** mapRooms;					AST( NAME(MapRoom) )

	// GoldenPath data
	ZoneMapMetadataPathNode** eaPathNodes;			AST( NAME(PathNode) NO_NETSEND )
} ZoneMapExternalMapSnap;
extern ParseTable parse_ZoneMapExternalMapSnap[];
#define TYPE_parse_ZoneMapExternalMapSnap ZoneMapExternalMapSnap

AUTO_STRUCT;
typedef struct LayerBounds
{
	Vec3 local_min;
	Vec3 local_max;
	Vec3 visible_geo_min;
	Vec3 visible_geo_max;
} LayerBounds;

ZoneMapEncounterObjectInfo* zeniObjectFind( const char* mapName, const char* objectName );
bool zeniObjIsUGCPickable( ZoneMapEncounterObjectInfo* zeniObj );

// Returns true if the object is something that can be picked by UGC.
bool zeniObjIsUGC( ZoneMapEncounterObjectInfo* zeniObj );

// Returns true if the object can be picked by UGC or is needed by the
// UGC system (like kill volumes)
bool zeniObjIsUGCData( ZoneMapEncounterObjectInfo* zeniObj );

//function is actually in WorldGridLoad.c
//if we are doing makebinsAndExit in multiplexed slave mode
bool WorldGrid_DoingMultiplexedMakeBinsAsSlave(void);

C_DECLARATIONS_END

#endif //_WORLDGRID_H_

