#include "textparser.h"

//auto-generated staticdefine for enum BeaconMapWarning
//autogeneratednocheckin
StaticDefineInt BeaconMapWarningEnum[] =
{
	DEFINE_INT
	{ "BCN_MAPWARN_NO_SPAWNS", BCN_MAPWARN_NO_SPAWNS},
	DEFINE_END
};
void autoEnum_fixup_BeaconMapWarning(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(BeaconMapWarningEnum, "BeaconMapWarning");
}

//auto-generated staticdefine for enum BeaconMapFailureReason
//autogeneratednocheckin
StaticDefineInt BeaconMapFailureReasonEnum[] =
{
	DEFINE_INT
	{ "FILE_DNE", BCN_MAPFAIL_FILE_DNE},
	{ "CHECKOUT", BCN_MAPFAIL_CHECKOUT},
	{ "NO_BEACONS", BCN_MAPFAIL_NO_BEACONS},
	DEFINE_END
};
void autoEnum_fixup_BeaconMapFailureReason(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(BeaconMapFailureReasonEnum, "BeaconMapFailureReason");
}

//auto-generated staticdefine for enum BeaconProcessPhase
//autogeneratednocheckin
StaticDefineInt BeaconProcessPhaseEnum[] =
{
	DEFINE_INT
	{ "RECV_LOAD_MAP", BPP_RECV_LOAD_MAP},
	{ "GENERATE", BPP_GENERATE},
	{ "CONNECT", BPP_CONNECT},
	{ "COUNT", BPP_COUNT},
	DEFINE_END
};
void autoEnum_fixup_BeaconProcessPhase(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(BeaconProcessPhaseEnum, "BeaconProcessPhase");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct SimpleWaypoint
#define TYPE_parse_SimpleWaypoint SimpleWaypoint
ParseTable parse_SimpleWaypoint[] =
{
	{ "SimpleWaypoint", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(SimpleWaypoint), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "pos",			TOK_VEC3(SimpleWaypoint, pos), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_SimpleWaypoint()
{
	int iSize = sizeof(SimpleWaypoint);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_SimpleWaypoint, iSize, "SimpleWaypoint", NULL, "beaconFile.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_SimpleWaypoint[];
#define TYPE_parse_SimpleWaypoint SimpleWaypoint
//Structparser.exe autogenerated ParseTable for struct SimplePath
#define TYPE_parse_SimplePath SimplePath
ParseTable parse_SimplePath[] =
{
	{ "SimplePath", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(SimplePath), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "waypoints",	TOK_STRUCT(SimplePath, waypoints, parse_SimpleWaypoint) },
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_SimplePath()
{
	int iSize = sizeof(SimplePath);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_SimplePath, iSize, "SimplePath", NULL, "beaconFile.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_SimplePath[];
#define TYPE_parse_SimplePath SimplePath
//Structparser.exe autogenerated ParseTable for struct BeaconMapMetaData
#define TYPE_parse_BeaconMapMetaData BeaconMapMetaData
ParseTable parse_BeaconMapMetaData[] =
{
	{ "BeaconMapMetaData", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(BeaconMapMetaData), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "mapWarning",				TOK_AUTOINT(BeaconMapMetaData, mapWarning, 0), BeaconMapWarningEnum },
	{ "failureReason",			TOK_AUTOINT(BeaconMapMetaData, failureReason, 0), BeaconMapFailureReasonEnum },
	{ "metaDataVersion",		TOK_AUTOINT(BeaconMapMetaData, metaDataVersion, 0), NULL },
	{ "dataProcessVersion",		TOK_AUTOINT(BeaconMapMetaData, dataProcessVersion, 0), NULL },
	{ "patchViewTime",			TOK_AUTOINT(BeaconMapMetaData, patchViewTime, 0), NULL },
	{ "fullCRC",				TOK_AUTOINT(BeaconMapMetaData, fullCRC, 0), NULL },
	{ "geoCRC",					TOK_AUTOINT(BeaconMapMetaData, geoCRC, 0), NULL },
	{ "geoRoundCRC",			TOK_AUTOINT(BeaconMapMetaData, geoRoundCRC, 0), NULL },
	{ "encCRC",					TOK_AUTOINT(BeaconMapMetaData, encCRC, 0), NULL },
	{ "cfgCRC",					TOK_AUTOINT(BeaconMapMetaData, cfgCRC, 0), NULL },
	{ "minXYZ",					TOK_VEC3(BeaconMapMetaData, minXYZ), NULL },
	{ "maxXYZ",					TOK_VEC3(BeaconMapMetaData, maxXYZ), NULL },
	{ "beaconCount",			TOK_AUTOINT(BeaconMapMetaData, beaconCount, 0), NULL },
	{ "beaconRaisedCount",		TOK_AUTOINT(BeaconMapMetaData, beaconRaisedCount, 0), NULL },
	{ "beaconGroundCount",		TOK_AUTOINT(BeaconMapMetaData, beaconGroundCount, 0), NULL },
	{ "beaconClientSeconds",	TOK_FIXED_ARRAY | TOK_F32_X, offsetof(BeaconMapMetaData, beaconClientSeconds),  BPP_COUNT, NULL },
	{ "invalidPaths",			TOK_STRUCT(BeaconMapMetaData, invalidPaths, parse_SimplePath) },
	{ "zippedSize",				TOK_AUTOINT(BeaconMapMetaData, zippedSize, 0), NULL },
	{ "unzippedSize",			TOK_AUTOINT(BeaconMapMetaData, unzippedSize, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_BeaconMapMetaData()
{
	int iSize = sizeof(BeaconMapMetaData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_BeaconMapMetaData, iSize, "BeaconMapMetaData", NULL, "beaconFile.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
