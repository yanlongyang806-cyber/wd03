#include "textparser.h"

//auto-generated staticdefine for enum ShaderInputDefaultType
//autogeneratednocheckin
StaticDefineInt ShaderInputDefaultTypeEnum[] =
{
	DEFINE_INT
	{ "None", SIDT_NODEFAULT},
	{ "Value", SIDT_VALUE},
	{ "Color0", SIDT_COLOR},
	{ "TexCoord0", SIDT_TEXCOORD0},
	{ "TexCoord1", SIDT_TEXCOORD1},
	DEFINE_END
};
void autoEnum_fixup_ShaderInputDefaultType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ShaderInputDefaultTypeEnum, "ShaderInputDefaultType");
}

//auto-generated staticdefine for enum ShaderOperationType
//autogeneratednocheckin
StaticDefineInt ShaderOperationTypeEnum[] =
{
	DEFINE_INT
	{ "Custom", SOT_CUSTOM},
	{ "Texture", SOT_TEXTURE},
	{ "Simple", SOT_SIMPLE},
	{ "Advanced", SOT_ADVANCED},
	{ "Sink", SOT_SINK},
	{ "END", SOT_END},
	DEFINE_END
};
void autoEnum_fixup_ShaderOperationType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ShaderOperationTypeEnum, "ShaderOperationType");
}

//auto-generated staticdefine for enum SwizzleParams
//autogeneratednocheckin
StaticDefineInt SwizzleParamsEnum[] =
{
	DEFINE_INT
	{ "X", SWIZZLE_X},
	{ "Y", SWIZZLE_Y},
	{ "Z", SWIZZLE_Z},
	{ "W", SWIZZLE_W},
	DEFINE_END
};
void autoEnum_fixup_SwizzleParams(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(SwizzleParamsEnum, "SwizzleParams");
}

//auto-generated staticdefine for enum ShaderGraphFlags
//autogeneratednocheckin
StaticDefineInt ShaderGraphFlagsEnum[] =
{
	DEFINE_INT
	{ "HAS_BUMP", SGRAPH_DEPRECATED},
	{ "HANDLES_COLOR_TINT", SGRAPH_HANDLES_COLOR_TINT},
	{ "NoAlphaCutout", SGRAPH_NO_ALPHACUTOUT},
	{ "NoHDR", SGRAPH_NO_HDR},
	{ "DoNotParseMe", SGRAPH_NO_CACHING},
	{ "AlphaPassOnly", SGRAPH_ALPHA_PASS_ONLY},
	{ "NO_NORMALMAP", SGRAPH_NO_NORMALMAP},
	{ "UseAmbientCube", SGRAPH_USE_AMBIENT_CUBE},
	{ "NoTintForHDR", SGRAPH_NO_TINT_FOR_HDR},
	{ "AllowAlphaRef", SGRAPH_ALLOW_ALPHA_REF},
	{ "AllowRefMIPBias", SGRAPH_ALLOW_REF_MIP_BIASE},
	{ "AlphaToCoverage", SGRAPH_ALPHA_TO_COVERAGE},
	{ "BacklightInShadow", SGRAPH_BACKLIGHT_IN_SHADOW},
	{ "UnlitInShadow", SGRAPH_UNLIT_IN_SHADOW},
	{ "ExcludeFromCluster", SGRAPH_EXCLUDE_FROM_CLUSTER},
	{ "HasDiffuseWarp", SGRAPH_DIFFUSEWARP},
	{ "AnisotropicSpec", SGRAPH_ANISOTROPIC_SPEC},
	DEFINE_END
};
void autoEnum_fixup_ShaderGraphFlags(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ShaderGraphFlagsEnum, "ShaderGraphFlags");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ShaderInputDefault
#define TYPE_parse_ShaderInputDefault ShaderInputDefault
ParseTable parse_ShaderInputDefault[] =
{
	{ "ShaderInputDefault", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ShaderInputDefault), 0, NULL, 0, NULL },
	{ "Type",				TOK_AUTOINT(ShaderInputDefault, default_type, SIDT_NODEFAULT), ShaderInputDefaultTypeEnum },
	{ "Floats",				TOK_F32ARRAY(ShaderInputDefault, default_floats), NULL },
	{ "Strings",			TOK_STRINGARRAY(ShaderInputDefault, default_strings), NULL },
	{ "EndDefault",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ShaderInputDefault()
{
	int iSize = sizeof(ShaderInputDefault);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ShaderInputDefault, iSize, "ShaderInputDefault", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ShaderInputDefault[];
#define TYPE_parse_ShaderInputDefault ShaderInputDefault
//Structparser.exe autogenerated ParseTable for struct ShaderInput
#define TYPE_parse_ShaderInput ShaderInput
ParseTable parse_ShaderInput[] =
{
	{ "ShaderInput", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ShaderInput), 0, NULL, 0, NULL },
	{ "Name",				TOK_POOL_STRING | TOK_STRING(ShaderInput, input_name, 0), NULL },
	{ "Description",		TOK_STRING(ShaderInput, input_description, 0), NULL },
	{ "Type",				TOK_AUTOINT(ShaderInput, data_type, SDT_DEFAULT), ShaderDataTypeEnum },
	{ "Float",				TOK_AUTOINT(ShaderInput, num_floats, 0), NULL },
	{ "FloatRange",			TOK_VEC2(ShaderInput, float_range), NULL },
	{ "Texture",			TOK_AUTOINT(ShaderInput, num_texnames, 0), NULL },
	{ "Hidden",				TOK_AUTOINT(ShaderInput, input_hidden, 0), NULL },
	{ "NoAutoConnect",		TOK_AUTOINT(ShaderInput, input_no_auto_connect, 0), NULL },
	{ "NotForAssembler",	TOK_AUTOINT(ShaderInput, input_not_for_assembler, 0), NULL },
	{ "NoManualConnect",	TOK_AUTOINT(ShaderInput, input_no_manual_connect, 0), NULL },
	{ "Default",			TOK_EMBEDDEDSTRUCT(ShaderInput, input_default, parse_ShaderInputDefault)},
	{ "EndInput",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ShaderInput()
{
	int iSize = sizeof(ShaderInput);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ShaderInput, iSize, "ShaderInput", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ShaderOutput
#define TYPE_parse_ShaderOutput ShaderOutput
ParseTable parse_ShaderOutput[] =
{
	{ "ShaderOutput", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ShaderOutput), 0, NULL, 0, NULL },
	{ "Name",			TOK_POOL_STRING | TOK_STRING(ShaderOutput, output_name, 0), NULL },
	{ "Description",	TOK_STRING(ShaderOutput, output_description, 0), NULL },
	{ "Float",			TOK_AUTOINT(ShaderOutput, num_floats, 0), NULL },
	{ "Type",			TOK_AUTOINT(ShaderOutput, data_type, SDT_DEFAULT), ShaderDataTypeEnum },
	{ "AlphaModeAnd",	TOK_AUTOINT(ShaderOutput, output_alpha_mode_and, 0), NULL },
	{ "AlphaFrom",		TOK_POOL_STRING | TOK_STRINGARRAY(ShaderOutput, output_alpha_from), NULL },
	{ "AutoConnect",	TOK_POOL_STRING | TOK_STRING(ShaderOutput, output_auto_connect, 0), NULL },
	{ "EndOutput",		TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ShaderOutput()
{
	int iSize = sizeof(ShaderOutput);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ShaderOutput, iSize, "ShaderOutput", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ShaderInput[];
#define TYPE_parse_ShaderInput ShaderInput
extern ParseTable parse_ShaderOutput[];
#define TYPE_parse_ShaderOutput ShaderOutput
//Structparser.exe autogenerated ParseTable for struct ShaderOperationDef
#define TYPE_parse_ShaderOperationDef ShaderOperationDef
ParseTable parse_ShaderOperationDef[] =
{
	{ "ShaderOperationDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ShaderOperationDef), 0, NULL, 0, NULL },
	{ "Name",				TOK_POOL_STRING | TOK_KEY | TOK_STRING(ShaderOperationDef, op_type_name, 0), NULL },
	{ "Category",			TOK_STRING(ShaderOperationDef, op_category, 0), NULL },
	{ "Description",		TOK_STRING(ShaderOperationDef, op_description, 0), NULL },
	{ "ParentName",			TOK_POOL_STRING | TOK_STRING(ShaderOperationDef, op_parent_type_name, 0), NULL },
	{ "OptionName",			TOK_STRING(ShaderOperationDef, op_option_name, 0), NULL },
	{ "DefaultOptionName",	TOK_STRING(ShaderOperationDef, op_default_option_name, 0), NULL },
	{ "Type",				TOK_AUTOINT(ShaderOperationDef, op_type, 0), ShaderOperationTypeEnum },
	{ "Input",				TOK_STRUCT(ShaderOperationDef, op_inputs, parse_ShaderInput) },
	{ "Input:",				TOK_REDUNDANTNAME | TOK_STRUCT(ShaderOperationDef, op_inputs, parse_ShaderInputOneLine) },
	{ "Output",				TOK_STRUCT(ShaderOperationDef, op_outputs, parse_ShaderOutput) },
	{ "Output:",			TOK_REDUNDANTNAME | TOK_STRUCT(ShaderOperationDef, op_outputs, parse_ShaderOutputOneLine) },
	{ "FN",					TOK_POOL_STRING | TOK_CURRENTFILE(ShaderOperationDef, filename), NULL},
	{ "MinShader",			TOK_F32(ShaderOperationDef, min_shader_level, 0), NULL },
	{ "OperationDef",		TOK_IGNORE, 0 },
	{ "EndOperationDef",	TOK_END, 0 },
	{ "", 0, 0 }
};
TextParserResult fixupShaderOperationDef(ShaderOperationDef *pStruct, enumTextParserFixupType eFixupType, void *pExtraData);
int autoStruct_fixup_ShaderOperationDef()
{
	int iSize = sizeof(ShaderOperationDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ShaderOperationDef, iSize, "ShaderOperationDef", fixupShaderOperationDef, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ShaderInputEdge
#define TYPE_parse_ShaderInputEdge ShaderInputEdge
ParseTable parse_ShaderInputEdge[] =
{
	{ "ShaderInputEdge", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ShaderInputEdge), 0, NULL, 0, NULL },
	{ "InputName",			TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(ShaderInputEdge, input_name, 0), NULL },
	{ "SourceName",			TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(ShaderInputEdge, input_source_name, 0), NULL },
	{ "SourceOutputName",	TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(ShaderInputEdge, input_source_output_name, 0), NULL },
	{ "SwizzleX",			TOK_STRUCTPARAM | TOK_AUTOINT(ShaderInputEdge, input_swizzle[0], 0), SwizzleParamsEnum },
	{ "SwizzleY",			TOK_STRUCTPARAM | TOK_AUTOINT(ShaderInputEdge, input_swizzle[1], 0), SwizzleParamsEnum },
	{ "SwizzleZ",			TOK_STRUCTPARAM | TOK_AUTOINT(ShaderInputEdge, input_swizzle[2], 0), SwizzleParamsEnum },
	{ "SwizzleW",			TOK_STRUCTPARAM | TOK_AUTOINT(ShaderInputEdge, input_swizzle[3], 0), SwizzleParamsEnum },
	{ "\n",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ShaderInputEdge()
{
	int iSize = sizeof(ShaderInputEdge);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ShaderInputEdge, iSize, "ShaderInputEdge", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ShaderFixedInput
#define TYPE_parse_ShaderFixedInput ShaderFixedInput
ParseTable parse_ShaderFixedInput[] =
{
	{ "ShaderFixedInput", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ShaderFixedInput), 0, NULL, 0, NULL },
	{ "InputName",			TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(ShaderFixedInput, input_name, 0), NULL },
	{ "FValue",				TOK_F32ARRAY(ShaderFixedInput, fvalues), NULL },
	{ "EndFixedInput",		TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ShaderFixedInput()
{
	int iSize = sizeof(ShaderFixedInput);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ShaderFixedInput, iSize, "ShaderFixedInput", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ShaderRuntimeInput
#define TYPE_parse_ShaderRuntimeInput ShaderRuntimeInput
ParseTable parse_ShaderRuntimeInput[] =
{
	{ "ShaderRuntimeInput", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ShaderRuntimeInput), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "input_name",				TOK_POOL_STRING | TOK_STRING(ShaderRuntimeInput, input_name, 0), NULL },
	{ "input_register",			TOK_AUTOINT(ShaderRuntimeInput, input_register, 0), NULL },
	{ "input_swizzle_start",	TOK_AUTOINT(ShaderRuntimeInput, input_swizzle_start, 0), NULL },
	{ "input_swizzle_count",	TOK_AUTOINT(ShaderRuntimeInput, input_swizzle_count, 0), NULL },
	{ "input_instance_param",	TOK_AUTOINT(ShaderRuntimeInput, input_instance_param, 0), NULL },
	{ "input_index",			TOK_AUTOINT(ShaderRuntimeInput, input_index, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ShaderRuntimeInput()
{
	int iSize = sizeof(ShaderRuntimeInput);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ShaderRuntimeInput, iSize, "ShaderRuntimeInput", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ShaderInputEdge[];
#define TYPE_parse_ShaderInputEdge ShaderInputEdge
extern ParseTable parse_ShaderFixedInput[];
#define TYPE_parse_ShaderFixedInput ShaderFixedInput
//Structparser.exe autogenerated ParseTable for struct ShaderOperation
#define TYPE_parse_ShaderOperation ShaderOperation
ParseTable parse_ShaderOperation[] =
{
	{ "ShaderOperation", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ShaderOperation), 0, NULL, 0, NULL },
	{ "Name",				TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(ShaderOperation, op_name, 0), NULL },
	{ "Group",				TOK_POOL_STRING | TOK_STRING(ShaderOperation, group_name, 0), NULL },
	{ "Notes",				TOK_STRING(ShaderOperation, notes, 0), NULL },
	{ "OperationType",		TOK_NON_NULL_REF | TOK_REQUIRED | TOK_REFERENCE(ShaderOperation, h_op_definition, 0, "OperationDef") },
	{ "Input",				TOK_STRUCT(ShaderOperation, inputs, parse_ShaderInputEdge) },
	{ "FixedInput",			TOK_STRUCT(ShaderOperation, fixed_inputs, parse_ShaderFixedInput) },
	{ "Position",			TOK_VEC2(ShaderOperation, op_pos), NULL },
	{ "Collapsed",			TOK_AUTOINT(ShaderOperation, op_collapsed, 0), NULL },
	{ "InstanceParam",		TOK_AUTOINT(ShaderOperation, instance_param, 0), NULL },
	{ "EndOperation",		TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ShaderOperation()
{
	int iSize = sizeof(ShaderOperation);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ShaderOperation, iSize, "ShaderOperation", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ShaderOperation[];
#define TYPE_parse_ShaderOperation ShaderOperation
//Structparser.exe autogenerated ParseTable for struct ShaderGraph
#define TYPE_parse_ShaderGraph ShaderGraph
ParseTable parse_ShaderGraph[] =
{
	{ "ShaderGraph", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ShaderGraph), 0, NULL, 0, NULL },
	{ "FN",					TOK_POOL_STRING | TOK_CURRENTFILE(ShaderGraph, filename), NULL},
	{ "timestamp",			TOK_NO_TEXT_SAVE | TOK_TIMESTAMP(ShaderGraph, timestamp), NULL },
	{ "Operation",			TOK_STRUCT(ShaderGraph, operations, parse_ShaderOperation) },
	{ "Flags",				TOK_AUTOINT(ShaderGraph, graph_flags, 0), ShaderGraphFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "Features",			TOK_AUTOINT(ShaderGraph, graph_features, 0), ShaderGraphFeaturesEnum  ,  TOK_FORMAT_FLAGS},
	{ "FeaturesOverriden",	TOK_AUTOINT(ShaderGraph, graph_features_overriden, 0), ShaderGraphFeaturesEnum  ,  TOK_FORMAT_FLAGS},
	{ "Reflection",			TOK_AUTOINT(ShaderGraph, graph_reflection_type, 0), ShaderGraphReflectionTypeEnum },
	{ "Defines",			TOK_POOL_STRING | TOK_STRINGARRAY(ShaderGraph, defines), NULL },
	{ "ExcludeClustering",	TOK_AUTOINT(ShaderGraph, exclude_clustering, 0), NULL },
	{ "GraphQuality",		TOK_AUTOINT(ShaderGraph, graph_quality, 0), ShaderGraphQualityEnum },
	{ "EndShaderGraph",		TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ShaderGraph()
{
	int iSize = sizeof(ShaderGraph);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ShaderGraph, iSize, "ShaderGraph", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ShaderGuide
#define TYPE_parse_ShaderGuide ShaderGuide
ParseTable parse_ShaderGuide[] =
{
	{ "ShaderGuide", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ShaderGuide), 0, NULL, 0, NULL },
	{ "TL",				TOK_VEC2(ShaderGuide, top_left), NULL },
	{ "BR",				TOK_VEC2(ShaderGuide, bottom_right), NULL },
	{ "EndGuide",		TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ShaderGuide()
{
	int iSize = sizeof(ShaderGuide);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ShaderGuide, iSize, "ShaderGuide", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ShaderTemplateLink
#define TYPE_parse_ShaderTemplateLink ShaderTemplateLink
ParseTable parse_ShaderTemplateLink[] =
{
	{ "ShaderTemplateLink", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ShaderTemplateLink), 0, NULL, 0, NULL },
	{ "SourceLOD",				TOK_AUTOINT(ShaderTemplateLink, source_lod, 0), NULL },
	{ "SourceOp",				TOK_POOL_STRING | TOK_STRING(ShaderTemplateLink, source_op_name, 0), NULL },
	{ "DestLOD",				TOK_AUTOINT(ShaderTemplateLink, dest_lod, 0), NULL },
	{ "DestOp",					TOK_POOL_STRING | TOK_STRING(ShaderTemplateLink, dest_op_name, 0), NULL },
	{ "EndShaderTemplateLink",	TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ShaderTemplateLink()
{
	int iSize = sizeof(ShaderTemplateLink);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ShaderTemplateLink, iSize, "ShaderTemplateLink", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ShaderGraph[];
#define TYPE_parse_ShaderGraph ShaderGraph
extern ParseTable parse_ShaderGuide[];
#define TYPE_parse_ShaderGuide ShaderGuide
extern ParseTable parse_ShaderTemplateLink[];
#define TYPE_parse_ShaderTemplateLink ShaderTemplateLink
//Structparser.exe autogenerated ParseTable for struct ShaderTemplate
#define TYPE_parse_ShaderTemplate ShaderTemplate
ParseTable parse_ShaderTemplate[] =
{
	{ "ShaderTemplate", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ShaderTemplate), 0, NULL, 0, NULL },
	{ "Name",					TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(ShaderTemplate, template_name, 0), NULL },
	{ "FN",						TOK_POOL_STRING | TOK_CURRENTFILE(ShaderTemplate, filename), NULL},
	{ "ShaderGraph",			TOK_EMBEDDEDSTRUCT(ShaderTemplate, graph_parser, parse_ShaderGraph)},
	{ "Guide",					TOK_STRUCT(ShaderTemplate, guides, parse_ShaderGuide) },
	{ "ShaderTemplateLink",		TOK_STRUCT(ShaderTemplate, template_links, parse_ShaderTemplateLink) },
	{ "IsAutosave",				TOK_AUTOINT(ShaderTemplate, is_autosave, 0), NULL },
	{ "score",					TOK_AUTOINT(ShaderTemplate, score,  -1 ), NULL },
	{ "ShaderTemplateLOD",		TOK_IGNORE, 0 },
	{ "EndShaderTemplateLOD",	TOK_IGNORE, 0 },
	{ "FarDist",				TOK_IGNORE, 0 },
	{ "FarFade",				TOK_IGNORE, 0 },
	{ "EndShaderTemplate",		TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ShaderTemplate()
{
	int iSize = sizeof(ShaderTemplate);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ShaderTemplate, iSize, "ShaderTemplate", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ShaderOperationSpecificValue
#define TYPE_parse_ShaderOperationSpecificValue ShaderOperationSpecificValue
ParseTable parse_ShaderOperationSpecificValue[] =
{
	{ "ShaderOperationSpecificValue", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ShaderOperationSpecificValue), 0, NULL, 0, NULL },
	{ "InputName",						TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(ShaderOperationSpecificValue, input_name, 0), NULL },
	{ "FValue",							TOK_F32ARRAY(ShaderOperationSpecificValue, fvalues), NULL },
	{ "SValue",							TOK_POOL_STRING | TOK_STRINGARRAY(ShaderOperationSpecificValue, svalues), NULL },
	{ "EndSpecificValue",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ShaderOperationSpecificValue()
{
	int iSize = sizeof(ShaderOperationSpecificValue);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ShaderOperationSpecificValue, iSize, "ShaderOperationSpecificValue", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ShaderOperationSpecificValue[];
#define TYPE_parse_ShaderOperationSpecificValue ShaderOperationSpecificValue
//Structparser.exe autogenerated ParseTable for struct ShaderOperationValues
#define TYPE_parse_ShaderOperationValues ShaderOperationValues
ParseTable parse_ShaderOperationValues[] =
{
	{ "ShaderOperationValues", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ShaderOperationValues), 0, NULL, 0, NULL },
	{ "OpName",					TOK_POOL_STRING | TOK_STRING(ShaderOperationValues, op_name, 0), NULL },
	{ "SpecificValue",			TOK_STRUCT(ShaderOperationValues, values, parse_ShaderOperationSpecificValue) },
	{ "EndOperationValue",		TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ShaderOperationValues()
{
	int iSize = sizeof(ShaderOperationValues);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ShaderOperationValues, iSize, "ShaderOperationValues", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ShaderInputMapping
#define TYPE_parse_ShaderInputMapping ShaderInputMapping
ParseTable parse_ShaderInputMapping[] =
{
	{ "ShaderInputMapping", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ShaderInputMapping), 0, NULL, 0, NULL },
	{ "OpName",				TOK_POOL_STRING | TOK_STRING(ShaderInputMapping, op_name, 0), NULL },
	{ "MappedOpName",		TOK_POOL_STRING | TOK_STRING(ShaderInputMapping, mapped_op_name, 0), NULL },
	{ "EndInputMapping",	TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ShaderInputMapping()
{
	int iSize = sizeof(ShaderInputMapping);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ShaderInputMapping, iSize, "ShaderInputMapping", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ShaderInputMapping[];
#define TYPE_parse_ShaderInputMapping ShaderInputMapping
extern ParseTable parse_ShaderOperationValues[];
#define TYPE_parse_ShaderOperationValues ShaderOperationValues
//Structparser.exe autogenerated ParseTable for struct MaterialFallback
#define TYPE_parse_MaterialFallback MaterialFallback
ParseTable parse_MaterialFallback[] =
{
	{ "MaterialFallback", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MaterialFallback), 0, NULL, 0, NULL },
	{ "Template",			TOK_POOL_STRING | TOK_STRING(MaterialFallback, shader_template_name, 0), NULL },
	{ "InputMapping",		TOK_STRUCT(MaterialFallback, input_mappings, parse_ShaderInputMapping) },
	{ "OperationValue",		TOK_STRUCT(MaterialFallback, shader_values, parse_ShaderOperationValues) },
	{ "EndFallback",		TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MaterialFallback()
{
	int iSize = sizeof(MaterialFallback);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MaterialFallback, iSize, "MaterialFallback", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ShaderInputMapping[];
#define TYPE_parse_ShaderInputMapping ShaderInputMapping
extern ParseTable parse_ShaderOperationValues[];
#define TYPE_parse_ShaderOperationValues ShaderOperationValues
extern ParseTable parse_MaterialFallback[];
#define TYPE_parse_MaterialFallback MaterialFallback
//Structparser.exe autogenerated ParseTable for struct MaterialGraphicPropertiesLoadTime
#define TYPE_parse_MaterialGraphicPropertiesLoadTime MaterialGraphicPropertiesLoadTime
ParseTable parse_MaterialGraphicPropertiesLoadTime[] =
{
	{ "MaterialGraphicPropertiesLoadTime", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MaterialGraphicPropertiesLoadTime), 0, NULL, 0, NULL },
	{ "default_fallback", 					TOK_IGNORE | TOK_FLATEMBED },
	{ "Template",							TOK_POOL_STRING | TOK_STRING(MaterialGraphicPropertiesLoadTime, default_fallback.shader_template_name, 0), NULL },
	{ "InputMapping",						TOK_STRUCT(MaterialGraphicPropertiesLoadTime, default_fallback.input_mappings, parse_ShaderInputMapping) },
	{ "OperationValue",						TOK_STRUCT(MaterialGraphicPropertiesLoadTime, default_fallback.shader_values, parse_ShaderOperationValues) },
	{ "Fallback",							TOK_STRUCT(MaterialGraphicPropertiesLoadTime, fallbacks, parse_MaterialFallback) },
	{ "FallbacksOverriden",					TOK_AUTOINT(MaterialGraphicPropertiesLoadTime, fallbacks_overriden, 0), NULL },
	{ "GfxFlags",							TOK_MINBITS(5) | TOK_AUTOINT(MaterialGraphicPropertiesLoadTime, flags, 0), RdrMaterialFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "UnlitContribution",					TOK_FLOAT_ROUNDING(FLOAT_HUNDREDTHS) | TOK_F32(MaterialGraphicPropertiesLoadTime, unlit_contribution, 0), NULL },
	{ "DiffuseContribution",				TOK_FLOAT_ROUNDING(FLOAT_HUNDREDTHS) | TOK_F32(MaterialGraphicPropertiesLoadTime, diffuse_contribution, 0), NULL },
	{ "SpecularContribution",				TOK_FLOAT_ROUNDING(FLOAT_HUNDREDTHS) | TOK_F32(MaterialGraphicPropertiesLoadTime, specular_contribution, 0), NULL },
	{ "MaxReflectResolution",				TOK_BIT, 0, 8, NULL},
	{ "}",									TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_MaterialGraphicPropertiesLoadTime()
{
	int iSize = sizeof(MaterialGraphicPropertiesLoadTime);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MaterialGraphicPropertiesLoadTime, iSize, "MaterialGraphicPropertiesLoadTime", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(MaterialGraphicPropertiesLoadTime) + 7) / 4;
		MaterialGraphicPropertiesLoadTime *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->max_reflect_resolution = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MaterialGraphicPropertiesLoadTime[11]);
		pTemp->max_reflect_resolution = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct MaterialWorldPropertiesLoadTime
#define TYPE_parse_MaterialWorldPropertiesLoadTime MaterialWorldPropertiesLoadTime
ParseTable parse_MaterialWorldPropertiesLoadTime[] =
{
	{ "MaterialWorldPropertiesLoadTime", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MaterialWorldPropertiesLoadTime), 0, NULL, 0, NULL },
	{ "PhysicalProperties",					TOK_REFERENCE(MaterialWorldPropertiesLoadTime, physical_properties, 0, "PhysicalProperties") },
	{ "SoundProfile",						TOK_REDUNDANTNAME | TOK_REFERENCE(MaterialWorldPropertiesLoadTime, physical_properties, 0, "PhysicalProperties") },
	{ "WorldFlags",							TOK_IGNORE, 0 },
	{ "}",									TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MaterialWorldPropertiesLoadTime()
{
	int iSize = sizeof(MaterialWorldPropertiesLoadTime);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MaterialWorldPropertiesLoadTime, iSize, "MaterialWorldPropertiesLoadTime", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct MaterialNamedConstant
#define TYPE_parse_MaterialNamedConstant MaterialNamedConstant
ParseTable parse_MaterialNamedConstant[] =
{
	{ "MaterialNamedConstant", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MaterialNamedConstant), 0, NULL, 0, NULL },
	{ "name",					TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(MaterialNamedConstant, name, 0), NULL },
	{ "value",					TOK_STRUCTPARAM | TOK_VEC4(MaterialNamedConstant, value), NULL },
	{ "\n",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MaterialNamedConstant()
{
	int iSize = sizeof(MaterialNamedConstant);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MaterialNamedConstant, iSize, "MaterialNamedConstant", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct MaterialNamedTexture
#define TYPE_parse_MaterialNamedTexture MaterialNamedTexture
ParseTable parse_MaterialNamedTexture[] =
{
	{ "MaterialNamedTexture", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MaterialNamedTexture), 0, NULL, 0, NULL },
	{ "op",						TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(MaterialNamedTexture, op, 0), NULL },
	{ "input",					TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(MaterialNamedTexture, input, 0), NULL },
	{ "texture_name",			TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(MaterialNamedTexture, texture_name, 0), NULL },
	{ "\n",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MaterialNamedTexture()
{
	int iSize = sizeof(MaterialNamedTexture);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MaterialNamedTexture, iSize, "MaterialNamedTexture", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct MaterialNamedDynamicConstant
#define TYPE_parse_MaterialNamedDynamicConstant MaterialNamedDynamicConstant
ParseTable parse_MaterialNamedDynamicConstant[] =
{
	{ "MaterialNamedDynamicConstant", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MaterialNamedDynamicConstant), 0, NULL, 0, NULL },
	{ "name",							TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(MaterialNamedDynamicConstant, name, 0), NULL },
	{ "data_type",						TOK_STRUCTPARAM | TOK_AUTOINT(MaterialNamedDynamicConstant, data_type, 0), ShaderDataTypeEnum },
	{ "value",							TOK_STRUCTPARAM | TOK_VEC4(MaterialNamedDynamicConstant, value), NULL },
	{ "\n",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MaterialNamedDynamicConstant()
{
	int iSize = sizeof(MaterialNamedDynamicConstant);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MaterialNamedDynamicConstant, iSize, "MaterialNamedDynamicConstant", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ShaderInputMapping[];
#define TYPE_parse_ShaderInputMapping ShaderInputMapping
extern ParseTable parse_ShaderOperationValues[];
#define TYPE_parse_ShaderOperationValues ShaderOperationValues
extern ParseTable parse_MaterialFallback[];
#define TYPE_parse_MaterialFallback MaterialFallback
//Structparser.exe autogenerated ParseTable for struct MaterialData
#define TYPE_parse_MaterialData MaterialData
ParseTable parse_MaterialData[] =
{
	{ "MaterialData", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MaterialData), 0, NULL, 0, NULL },
	{ "FN",						TOK_POOL_STRING | TOK_CURRENTFILE(MaterialData, filename), NULL},
	{ "N",						TOK_POOL_STRING | TOK_STRING(MaterialData, material_name, 0), NULL },
	{ "graphic_props", 			TOK_IGNORE | TOK_FLATEMBED },
	{ "default_fallback", 		TOK_IGNORE | TOK_FLATEMBED },
	{ "Template",				TOK_POOL_STRING | TOK_STRING(MaterialData, graphic_props.default_fallback.shader_template_name, 0), NULL },
	{ "InputMapping",			TOK_STRUCT(MaterialData, graphic_props.default_fallback.input_mappings, parse_ShaderInputMapping) },
	{ "OperationValue",			TOK_STRUCT(MaterialData, graphic_props.default_fallback.shader_values, parse_ShaderOperationValues) },
	{ "Fallback",				TOK_STRUCT(MaterialData, graphic_props.fallbacks, parse_MaterialFallback) },
	{ "FallbacksOverriden",		TOK_AUTOINT(MaterialData, graphic_props.fallbacks_overriden, 0), NULL },
	{ "GfxFlags",				TOK_MINBITS(5) | TOK_AUTOINT(MaterialData, graphic_props.flags, 0), RdrMaterialFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "UnlitContribution",		TOK_FLOAT_ROUNDING(FLOAT_HUNDREDTHS) | TOK_F32(MaterialData, graphic_props.unlit_contribution, 0), NULL },
	{ "DiffuseContribution",	TOK_FLOAT_ROUNDING(FLOAT_HUNDREDTHS) | TOK_F32(MaterialData, graphic_props.diffuse_contribution, 0), NULL },
	{ "SpecularContribution",	TOK_FLOAT_ROUNDING(FLOAT_HUNDREDTHS) | TOK_F32(MaterialData, graphic_props.specular_contribution, 0), NULL },
	{ "MaxReflectResolution",	TOK_BIT, 0, 8, NULL},
	{ "world_props", 			TOK_IGNORE | TOK_FLATEMBED },
	{ "PhysicalProperties",		TOK_REFERENCE(MaterialData, world_props.physical_properties, 0, "PhysicalProperties") },
	{ "SoundProfile",			TOK_REDUNDANTNAME | TOK_REFERENCE(MaterialData, world_props.physical_properties, 0, "PhysicalProperties") },
	{ "IsAutosave",				TOK_AUTOINT(MaterialData, is_autosave, 0), NULL },
	{ "OldName",				TOK_IGNORE | TOK_STRUCTPARAM, 0 },
	{ "has_validation_error",	TOK_IGNORE, 0 },
	{ "bad_material_is_mine",	TOK_IGNORE, 0 },
	{ "disallowed_features",	TOK_IGNORE, 0 },
	{ "EndMaterial",			TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
TextParserResult fixupMaterialData(MaterialData *pStruct, enumTextParserFixupType eFixupType, void *pExtraData);
int autoStruct_fixup_MaterialData()
{
	int iSize = sizeof(MaterialData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MaterialData, iSize, "MaterialData", fixupMaterialData, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(MaterialData) + 7) / 4;
		MaterialData *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->graphic_props.max_reflect_resolution = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MaterialData[14]);
		pTemp->graphic_props.max_reflect_resolution = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct MaterialDataInfoSerialize
#define TYPE_parse_MaterialDataInfoSerialize MaterialDataInfoSerialize
ParseTable parse_MaterialDataInfoSerialize[] =
{
	{ "MaterialDataInfoSerialize", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MaterialDataInfoSerialize), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "material_name",				TOK_POOL_STRING | TOK_STRING(MaterialDataInfoSerialize, material_name, 0), NULL },
	{ "data_offset",				TOK_AUTOINT(MaterialDataInfoSerialize, data_offset, 0), NULL },
	{ "filename",					TOK_POOL_STRING | TOK_STRING(MaterialDataInfoSerialize, filename, 0), NULL },
	{ "texture_deps",				TOK_POOL_STRING | TOK_STRINGARRAY(MaterialDataInfoSerialize, texture_deps), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MaterialDataInfoSerialize()
{
	int iSize = sizeof(MaterialDataInfoSerialize);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MaterialDataInfoSerialize, iSize, "MaterialDataInfoSerialize", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ShaderTemplate[];
#define TYPE_parse_ShaderTemplate ShaderTemplate
extern ParseTable parse_MaterialData[];
#define TYPE_parse_MaterialData MaterialData
extern ParseTable parse_SerializablePackedStructStream[];
#define TYPE_parse_SerializablePackedStructStream SerializablePackedStructStream
extern ParseTable parse_MaterialDataInfoSerialize[];
#define TYPE_parse_MaterialDataInfoSerialize MaterialDataInfoSerialize
//Structparser.exe autogenerated ParseTable for struct MaterialLoadInfo
#define TYPE_parse_MaterialLoadInfo MaterialLoadInfo
ParseTable parse_MaterialLoadInfo[] =
{
	{ "MaterialLoadInfo", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MaterialLoadInfo), 0, NULL, 0, NULL },
	{ "ShaderTemplate",			TOK_STRUCT(MaterialLoadInfo, templates, parse_ShaderTemplate) },
	{ "stTemplates",			TOK_STASHTABLE(MaterialLoadInfo, stTemplates), NULL},
	{ "stTemplateOverrides",	TOK_STASHTABLE(MaterialLoadInfo, stTemplateOverrides), NULL},
	{ "Material",				TOK_STRUCT(MaterialLoadInfo, material_datas, parse_MaterialData) },
	{ "packed_data_serialize",	TOK_NO_TEXT_SAVE | TOK_OPTIONALSTRUCT(MaterialLoadInfo, packed_data_serialize, parse_SerializablePackedStructStream) },
	{ "data_infos_serialize",	TOK_NO_TEXT_SAVE | TOK_STRUCT(MaterialLoadInfo, data_infos_serialize, parse_MaterialDataInfoSerialize) },
	{ "", 0, 0 }
};
TextParserResult fixupMaterialLoadInfo(MaterialLoadInfo *pStruct, enumTextParserFixupType eFixupType, void *pExtraData);
int autoStruct_fixup_MaterialLoadInfo()
{
	int iSize = sizeof(MaterialLoadInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MaterialLoadInfo, iSize, "MaterialLoadInfo", fixupMaterialLoadInfo, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct MaterialConstantMappingFake
#define TYPE_parse_MaterialConstantMappingFake MaterialConstantMappingFake
ParseTable parse_MaterialConstantMappingFake[] =
{
	{ "MaterialConstantMappingFake", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MaterialConstantMappingFake), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "data_type",						TOK_AUTOINT(MaterialConstantMappingFake, data_type, 0), NULL },
	{ "constant_index",					TOK_AUTOINT(MaterialConstantMappingFake, constant_index, 0), NULL },
	{ "constant_subindex",				TOK_AUTOINT(MaterialConstantMappingFake, constant_subindex, 0), NULL },
	{ "values",							TOK_FIXED_ARRAY | TOK_F32_X, offsetof(MaterialConstantMappingFake, values),  MAX_MATERIAL_CONSTANT_MAPPING_VALUES, NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MaterialConstantMappingFake()
{
	int iSize = sizeof(MaterialConstantMappingFake);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MaterialConstantMappingFake, iSize, "MaterialConstantMappingFake", NULL, "Materials.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
