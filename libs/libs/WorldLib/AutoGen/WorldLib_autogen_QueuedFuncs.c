//For more info on queued commands, look here: http://crypticwiki:8081/display/Core/AUTO_COMMAND_QUEUED
//This file is autogenerated. autogeneratednocheckin
#include "commandqueue.h"

void dpoAddAngVelocity(DynPhysicsObject* dpo,Vec3 vel);
extern CommandQueue *dpoCommandQueue;
void dpoAddAngVelocity_QUEUEDWRAPPER(CommandQueue *pQueue)
{
	DynPhysicsObject* dpo;
	Vec3 vel;
	bool bRead_vel = false;

	CommandQueue_EnterCriticalSection(pQueue);

	CommandQueue_Read(pQueue, &dpo, sizeof(void*));
	if (CommandQueue_ReadByte(pQueue))
	{
		bRead_vel=true;
		CommandQueue_Read(pQueue, vel, sizeof(Vec3));
	}

	dpoAddAngVelocity(dpo, bRead_vel ? vel : NULL);

	CommandQueue_LeaveCriticalSection(pQueue);
}
typedef struct DynPhysicsObject DynPhysicsObject;

void QueuedCommand_dpoAddAngVelocity(DynPhysicsObject* dpo,Vec3 vel)
{
	void *pFunc = dpoAddAngVelocity_QUEUEDWRAPPER;
	CommandQueue_EnterCriticalSection(dpoCommandQueue);
	CommandQueue_Write(dpoCommandQueue, &pFunc, sizeof(void*));
	CommandQueue_Write(dpoCommandQueue, &dpo, sizeof(void*));
	if (vel)
	{
		CommandQueue_WriteByte(dpoCommandQueue, 1);
		CommandQueue_Write(dpoCommandQueue, vel, sizeof(Vec3));
	}
	else
	{
		CommandQueue_WriteByte(dpoCommandQueue, 0);
	}

	CommandQueue_LeaveCriticalSection(dpoCommandQueue);
}
void dpoAddForce(DynPhysicsObject* dpo,Vec3 force,U32 isAcceleration,U32 shouldWakeup);
extern CommandQueue *dpoCommandQueue;
void dpoAddForce_QUEUEDWRAPPER(CommandQueue *pQueue)
{
	DynPhysicsObject* dpo;
	Vec3 force;
	bool bRead_force = false;
	U32 isAcceleration;
	U32 shouldWakeup;

	CommandQueue_EnterCriticalSection(pQueue);

	CommandQueue_Read(pQueue, &dpo, sizeof(void*));
	if (CommandQueue_ReadByte(pQueue))
	{
		bRead_force=true;
		CommandQueue_Read(pQueue, force, sizeof(Vec3));
	}
	CommandQueue_Read(pQueue, &isAcceleration, sizeof(U32));
	CommandQueue_Read(pQueue, &shouldWakeup, sizeof(U32));

	dpoAddForce(dpo, bRead_force ? force : NULL, isAcceleration, shouldWakeup);

	CommandQueue_LeaveCriticalSection(pQueue);
}
typedef struct DynPhysicsObject DynPhysicsObject;

void QueuedCommand_dpoAddForce(DynPhysicsObject* dpo,Vec3 force,U32 isAcceleration,U32 shouldWakeup)
{
	void *pFunc = dpoAddForce_QUEUEDWRAPPER;
	CommandQueue_EnterCriticalSection(dpoCommandQueue);
	CommandQueue_Write(dpoCommandQueue, &pFunc, sizeof(void*));
	CommandQueue_Write(dpoCommandQueue, &dpo, sizeof(void*));
	if (force)
	{
		CommandQueue_WriteByte(dpoCommandQueue, 1);
		CommandQueue_Write(dpoCommandQueue, force, sizeof(Vec3));
	}
	else
	{
		CommandQueue_WriteByte(dpoCommandQueue, 0);
	}
	CommandQueue_Write(dpoCommandQueue, &isAcceleration, sizeof(U32));
	CommandQueue_Write(dpoCommandQueue, &shouldWakeup, sizeof(U32));

	CommandQueue_LeaveCriticalSection(dpoCommandQueue);
}
void dpoAddVelocity(DynPhysicsObject* dpo,Vec3 vel);
extern CommandQueue *dpoCommandQueue;
void dpoAddVelocity_QUEUEDWRAPPER(CommandQueue *pQueue)
{
	DynPhysicsObject* dpo;
	Vec3 vel;
	bool bRead_vel = false;

	CommandQueue_EnterCriticalSection(pQueue);

	CommandQueue_Read(pQueue, &dpo, sizeof(void*));
	if (CommandQueue_ReadByte(pQueue))
	{
		bRead_vel=true;
		CommandQueue_Read(pQueue, vel, sizeof(Vec3));
	}

	dpoAddVelocity(dpo, bRead_vel ? vel : NULL);

	CommandQueue_LeaveCriticalSection(pQueue);
}
typedef struct DynPhysicsObject DynPhysicsObject;

void QueuedCommand_dpoAddVelocity(DynPhysicsObject* dpo,Vec3 vel)
{
	void *pFunc = dpoAddVelocity_QUEUEDWRAPPER;
	CommandQueue_EnterCriticalSection(dpoCommandQueue);
	CommandQueue_Write(dpoCommandQueue, &pFunc, sizeof(void*));
	CommandQueue_Write(dpoCommandQueue, &dpo, sizeof(void*));
	if (vel)
	{
		CommandQueue_WriteByte(dpoCommandQueue, 1);
		CommandQueue_Write(dpoCommandQueue, vel, sizeof(Vec3));
	}
	else
	{
		CommandQueue_WriteByte(dpoCommandQueue, 0);
	}

	CommandQueue_LeaveCriticalSection(dpoCommandQueue);
}
void dpoDestroy(DynPhysicsObject* dpo);
extern CommandQueue *dpoCommandQueue;
void dpoDestroy_QUEUEDWRAPPER(CommandQueue *pQueue)
{
	DynPhysicsObject* dpo;

	CommandQueue_EnterCriticalSection(pQueue);

	CommandQueue_Read(pQueue, &dpo, sizeof(void*));

	dpoDestroy(dpo);

	CommandQueue_LeaveCriticalSection(pQueue);
}
typedef struct DynPhysicsObject DynPhysicsObject;

void QueuedCommand_dpoDestroy(DynPhysicsObject* dpo)
{
	void *pFunc = dpoDestroy_QUEUEDWRAPPER;
	CommandQueue_EnterCriticalSection(dpoCommandQueue);
	CommandQueue_Write(dpoCommandQueue, &pFunc, sizeof(void*));
	CommandQueue_Write(dpoCommandQueue, &dpo, sizeof(void*));

	CommandQueue_LeaveCriticalSection(dpoCommandQueue);
}
void dpoMovePosition(DynPhysicsObject* dpo,Vec3 pos);
extern CommandQueue *dpoCommandQueue;
void dpoMovePosition_QUEUEDWRAPPER(CommandQueue *pQueue)
{
	DynPhysicsObject* dpo;
	Vec3 pos;
	bool bRead_pos = false;

	CommandQueue_EnterCriticalSection(pQueue);

	CommandQueue_Read(pQueue, &dpo, sizeof(void*));
	if (CommandQueue_ReadByte(pQueue))
	{
		bRead_pos=true;
		CommandQueue_Read(pQueue, pos, sizeof(Vec3));
	}

	dpoMovePosition(dpo, bRead_pos ? pos : NULL);

	CommandQueue_LeaveCriticalSection(pQueue);
}
typedef struct DynPhysicsObject DynPhysicsObject;

void QueuedCommand_dpoMovePosition(DynPhysicsObject* dpo,Vec3 pos)
{
	void *pFunc = dpoMovePosition_QUEUEDWRAPPER;
	CommandQueue_EnterCriticalSection(dpoCommandQueue);
	CommandQueue_Write(dpoCommandQueue, &pFunc, sizeof(void*));
	CommandQueue_Write(dpoCommandQueue, &dpo, sizeof(void*));
	if (pos)
	{
		CommandQueue_WriteByte(dpoCommandQueue, 1);
		CommandQueue_Write(dpoCommandQueue, pos, sizeof(Vec3));
	}
	else
	{
		CommandQueue_WriteByte(dpoCommandQueue, 0);
	}

	CommandQueue_LeaveCriticalSection(dpoCommandQueue);
}
void dpoMovePositionRotation(DynPhysicsObject* dpo,Vec3 pos,Quat rot);
extern CommandQueue *dpoCommandQueue;
void dpoMovePositionRotation_QUEUEDWRAPPER(CommandQueue *pQueue)
{
	DynPhysicsObject* dpo;
	Vec3 pos;
	bool bRead_pos = false;
	Quat rot;
	bool bRead_rot = false;

	CommandQueue_EnterCriticalSection(pQueue);

	CommandQueue_Read(pQueue, &dpo, sizeof(void*));
	if (CommandQueue_ReadByte(pQueue))
	{
		bRead_pos=true;
		CommandQueue_Read(pQueue, pos, sizeof(Vec3));
	}
	if (CommandQueue_ReadByte(pQueue))
	{
		bRead_rot=true;
		CommandQueue_Read(pQueue, rot, sizeof(Quat));
	}

	dpoMovePositionRotation(dpo, bRead_pos ? pos : NULL, bRead_rot ? rot : NULL);

	CommandQueue_LeaveCriticalSection(pQueue);
}
typedef struct DynPhysicsObject DynPhysicsObject;

void QueuedCommand_dpoMovePositionRotation(DynPhysicsObject* dpo,Vec3 pos,Quat rot)
{
	void *pFunc = dpoMovePositionRotation_QUEUEDWRAPPER;
	CommandQueue_EnterCriticalSection(dpoCommandQueue);
	CommandQueue_Write(dpoCommandQueue, &pFunc, sizeof(void*));
	CommandQueue_Write(dpoCommandQueue, &dpo, sizeof(void*));
	if (pos)
	{
		CommandQueue_WriteByte(dpoCommandQueue, 1);
		CommandQueue_Write(dpoCommandQueue, pos, sizeof(Vec3));
	}
	else
	{
		CommandQueue_WriteByte(dpoCommandQueue, 0);
	}
	if (rot)
	{
		CommandQueue_WriteByte(dpoCommandQueue, 1);
		CommandQueue_Write(dpoCommandQueue, rot, sizeof(Quat));
	}
	else
	{
		CommandQueue_WriteByte(dpoCommandQueue, 0);
	}

	CommandQueue_LeaveCriticalSection(dpoCommandQueue);
}
void dpoSetAngVelocity(DynPhysicsObject* dpo,Vec3 vel);
extern CommandQueue *dpoCommandQueue;
void dpoSetAngVelocity_QUEUEDWRAPPER(CommandQueue *pQueue)
{
	DynPhysicsObject* dpo;
	Vec3 vel;
	bool bRead_vel = false;

	CommandQueue_EnterCriticalSection(pQueue);

	CommandQueue_Read(pQueue, &dpo, sizeof(void*));
	if (CommandQueue_ReadByte(pQueue))
	{
		bRead_vel=true;
		CommandQueue_Read(pQueue, vel, sizeof(Vec3));
	}

	dpoSetAngVelocity(dpo, bRead_vel ? vel : NULL);

	CommandQueue_LeaveCriticalSection(pQueue);
}
typedef struct DynPhysicsObject DynPhysicsObject;

void QueuedCommand_dpoSetAngVelocity(DynPhysicsObject* dpo,Vec3 vel)
{
	void *pFunc = dpoSetAngVelocity_QUEUEDWRAPPER;
	CommandQueue_EnterCriticalSection(dpoCommandQueue);
	CommandQueue_Write(dpoCommandQueue, &pFunc, sizeof(void*));
	CommandQueue_Write(dpoCommandQueue, &dpo, sizeof(void*));
	if (vel)
	{
		CommandQueue_WriteByte(dpoCommandQueue, 1);
		CommandQueue_Write(dpoCommandQueue, vel, sizeof(Vec3));
	}
	else
	{
		CommandQueue_WriteByte(dpoCommandQueue, 0);
	}

	CommandQueue_LeaveCriticalSection(dpoCommandQueue);
}
void dpoSetCollidable(DynPhysicsObject* dpo,bool collidable);
extern CommandQueue *dpoCommandQueue;
void dpoSetCollidable_QUEUEDWRAPPER(CommandQueue *pQueue)
{
	DynPhysicsObject* dpo;
	bool collidable;

	CommandQueue_EnterCriticalSection(pQueue);

	CommandQueue_Read(pQueue, &dpo, sizeof(void*));
	CommandQueue_Read(pQueue, &collidable, sizeof(bool));

	dpoSetCollidable(dpo, collidable);

	CommandQueue_LeaveCriticalSection(pQueue);
}
typedef struct DynPhysicsObject DynPhysicsObject;

void QueuedCommand_dpoSetCollidable(DynPhysicsObject* dpo,bool collidable)
{
	void *pFunc = dpoSetCollidable_QUEUEDWRAPPER;
	CommandQueue_EnterCriticalSection(dpoCommandQueue);
	CommandQueue_Write(dpoCommandQueue, &pFunc, sizeof(void*));
	CommandQueue_Write(dpoCommandQueue, &dpo, sizeof(void*));
	CommandQueue_Write(dpoCommandQueue, &collidable, sizeof(bool));

	CommandQueue_LeaveCriticalSection(dpoCommandQueue);
}
void dpoSetMat(DynPhysicsObject* dpo,Mat4 mat);
extern CommandQueue *dpoCommandQueue;
void dpoSetMat_QUEUEDWRAPPER(CommandQueue *pQueue)
{
	DynPhysicsObject* dpo;
	Mat4 mat;
	bool bRead_mat = false;

	CommandQueue_EnterCriticalSection(pQueue);

	CommandQueue_Read(pQueue, &dpo, sizeof(void*));
	if (CommandQueue_ReadByte(pQueue))
	{
		bRead_mat=true;
		CommandQueue_Read(pQueue, mat, sizeof(Mat4));
	}

	dpoSetMat(dpo, bRead_mat ? mat : NULL);

	CommandQueue_LeaveCriticalSection(pQueue);
}
typedef struct DynPhysicsObject DynPhysicsObject;

void QueuedCommand_dpoSetMat(DynPhysicsObject* dpo,Mat4 mat)
{
	void *pFunc = dpoSetMat_QUEUEDWRAPPER;
	CommandQueue_EnterCriticalSection(dpoCommandQueue);
	CommandQueue_Write(dpoCommandQueue, &pFunc, sizeof(void*));
	CommandQueue_Write(dpoCommandQueue, &dpo, sizeof(void*));
	if (mat)
	{
		CommandQueue_WriteByte(dpoCommandQueue, 1);
		CommandQueue_Write(dpoCommandQueue, mat, sizeof(Mat4));
	}
	else
	{
		CommandQueue_WriteByte(dpoCommandQueue, 0);
	}

	CommandQueue_LeaveCriticalSection(dpoCommandQueue);
}
void dpoSetVelocity(DynPhysicsObject* dpo,Vec3 vel);
extern CommandQueue *dpoCommandQueue;
void dpoSetVelocity_QUEUEDWRAPPER(CommandQueue *pQueue)
{
	DynPhysicsObject* dpo;
	Vec3 vel;
	bool bRead_vel = false;

	CommandQueue_EnterCriticalSection(pQueue);

	CommandQueue_Read(pQueue, &dpo, sizeof(void*));
	if (CommandQueue_ReadByte(pQueue))
	{
		bRead_vel=true;
		CommandQueue_Read(pQueue, vel, sizeof(Vec3));
	}

	dpoSetVelocity(dpo, bRead_vel ? vel : NULL);

	CommandQueue_LeaveCriticalSection(pQueue);
}
typedef struct DynPhysicsObject DynPhysicsObject;

void QueuedCommand_dpoSetVelocity(DynPhysicsObject* dpo,Vec3 vel)
{
	void *pFunc = dpoSetVelocity_QUEUEDWRAPPER;
	CommandQueue_EnterCriticalSection(dpoCommandQueue);
	CommandQueue_Write(dpoCommandQueue, &pFunc, sizeof(void*));
	CommandQueue_Write(dpoCommandQueue, &dpo, sizeof(void*));
	if (vel)
	{
		CommandQueue_WriteByte(dpoCommandQueue, 1);
		CommandQueue_Write(dpoCommandQueue, vel, sizeof(Vec3));
	}
	else
	{
		CommandQueue_WriteByte(dpoCommandQueue, 0);
	}

	CommandQueue_LeaveCriticalSection(dpoCommandQueue);
}
void dpoWakeUp(DynPhysicsObject* dpo);
extern CommandQueue *dpoCommandQueue;
void dpoWakeUp_QUEUEDWRAPPER(CommandQueue *pQueue)
{
	DynPhysicsObject* dpo;

	CommandQueue_EnterCriticalSection(pQueue);

	CommandQueue_Read(pQueue, &dpo, sizeof(void*));

	dpoWakeUp(dpo);

	CommandQueue_LeaveCriticalSection(pQueue);
}
typedef struct DynPhysicsObject DynPhysicsObject;

void QueuedCommand_dpoWakeUp(DynPhysicsObject* dpo)
{
	void *pFunc = dpoWakeUp_QUEUEDWRAPPER;
	CommandQueue_EnterCriticalSection(dpoCommandQueue);
	CommandQueue_Write(dpoCommandQueue, &pFunc, sizeof(void*));
	CommandQueue_Write(dpoCommandQueue, &dpo, sizeof(void*));

	CommandQueue_LeaveCriticalSection(dpoCommandQueue);
}
