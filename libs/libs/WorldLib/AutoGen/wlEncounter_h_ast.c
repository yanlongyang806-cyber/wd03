#include "textparser.h"

//auto-generated staticdefine for enum WorldEncounterObjectType
//autogeneratednocheckin
StaticDefineInt WorldEncounterObjectTypeEnum[] =
{
	DEFINE_INT
	{ "ENCOUNTER", WL_ENC_ENCOUNTER},
	{ "ENCOUNTER_HACK", WL_ENC_ENCOUNTER_HACK},
	{ "INTERACTABLE", WL_ENC_INTERACTABLE},
	{ "SPAWN_POINT", WL_ENC_SPAWN_POINT},
	{ "PATROL_ROUTE", WL_ENC_PATROL_ROUTE},
	{ "NAMED_POINT", WL_ENC_NAMED_POINT},
	{ "NAMED_VOLUME", WL_ENC_NAMED_VOLUME},
	{ "LOGICAL_GROUP", WL_ENC_LOGICAL_GROUP},
	{ "TRIGGER_CONDITION", WL_ENC_TRIGGER_CONDITION},
	{ "LAYER_FSM", WL_ENC_LAYER_FSM},
	DEFINE_END
};
void autoEnum_fixup_WorldEncounterObjectType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(WorldEncounterObjectTypeEnum, "WorldEncounterObjectType");
}
//autogeneratednocheckin
extern ParseTable parse_WorldScope[];
#define TYPE_parse_WorldScope WorldScope
//Structparser.exe autogenerated ParseTable for struct WorldScopeNamePair
#define TYPE_parse_WorldScopeNamePair WorldScopeNamePair
ParseTable parse_WorldScopeNamePair[] =
{
	{ "WorldScopeNamePair", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldScopeNamePair), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "scope",				TOK_UNOWNED | TOK_OPTIONALSTRUCT(WorldScopeNamePair, scope, parse_WorldScope) },
	{ "name",				TOK_POOL_STRING | TOK_STRING(WorldScopeNamePair, name, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldScopeNamePair()
{
	int iSize = sizeof(WorldScopeNamePair);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldScopeNamePair, iSize, "WorldScopeNamePair", NULL, "wlEncounter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldScopeNamePair[];
#define TYPE_parse_WorldScopeNamePair WorldScopeNamePair
//Structparser.exe autogenerated ParseTable for struct WorldEncounterObject
#define TYPE_parse_WorldEncounterObject WorldEncounterObject
ParseTable parse_WorldEncounterObject[] =
{
	{ "WorldEncounterObject", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldEncounterObject), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "type",					TOK_AUTOINT(WorldEncounterObject, type, 0), WorldEncounterObjectTypeEnum },
	{ "unique_id",				TOK_AUTOINT(WorldEncounterObject, unique_id, 0), NULL },
	{ "layer_idx",				TOK_AUTOINT(WorldEncounterObject, layer_idx, 0), NULL },
	{ "parent_node_id",			TOK_AUTOINT(WorldEncounterObject, parent_node_id, 0), NULL },
	{ "parent_node_child_idx",	TOK_AUTOINT(WorldEncounterObject, parent_node_child_idx, 0), NULL },
	{ "scope_names",			TOK_NO_WRITE | TOK_STRUCT(WorldEncounterObject, scope_names, parse_WorldScopeNamePair) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldEncounterObject()
{
	int iSize = sizeof(WorldEncounterObject);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldEncounterObject, iSize, "WorldEncounterObject", NULL, "wlEncounter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldEncounterObject[];
#define TYPE_parse_WorldEncounterObject WorldEncounterObject
extern ParseTable parse_WorldEncounterProperties[];
#define TYPE_parse_WorldEncounterProperties WorldEncounterProperties
//Structparser.exe autogenerated ParseTable for struct WorldEncounter
#define TYPE_parse_WorldEncounter WorldEncounter
ParseTable parse_WorldEncounter[] =
{
	{ "WorldEncounter", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldEncounter), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "common_data",	TOK_EMBEDDEDSTRUCT(WorldEncounter, common_data, parse_WorldEncounterObject)},
	{ "properties",		TOK_OPTIONALSTRUCT(WorldEncounter, properties, parse_WorldEncounterProperties) },
	{ "encounter_pos",	TOK_VEC3(WorldEncounter, encounter_pos), NULL },
	{ "encounter_rot",	TOK_QUATPYR(WorldEncounter, encounter_rot), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldEncounter()
{
	int iSize = sizeof(WorldEncounter);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldEncounter, iSize, "WorldEncounter", NULL, "wlEncounter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldEncounterObject[];
#define TYPE_parse_WorldEncounterObject WorldEncounterObject
extern ParseTable parse_WorldEncounterHackProperties[];
#define TYPE_parse_WorldEncounterHackProperties WorldEncounterHackProperties
//Structparser.exe autogenerated ParseTable for struct WorldEncounterHack
#define TYPE_parse_WorldEncounterHack WorldEncounterHack
ParseTable parse_WorldEncounterHack[] =
{
	{ "WorldEncounterHack", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldEncounterHack), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "common_data",		TOK_EMBEDDEDSTRUCT(WorldEncounterHack, common_data, parse_WorldEncounterObject)},
	{ "properties",			TOK_OPTIONALSTRUCT(WorldEncounterHack, properties, parse_WorldEncounterHackProperties) },
	{ "encounter_pos",		TOK_VEC3(WorldEncounterHack, encounter_pos), NULL },
	{ "encounter_rot",		TOK_QUATPYR(WorldEncounterHack, encounter_rot), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldEncounterHack()
{
	int iSize = sizeof(WorldEncounterHack);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldEncounterHack, iSize, "WorldEncounterHack", NULL, "wlEncounter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldEncounterObject[];
#define TYPE_parse_WorldEncounterObject WorldEncounterObject
//Structparser.exe autogenerated ParseTable for struct WorldNamedInteractable
#define TYPE_parse_WorldNamedInteractable WorldNamedInteractable
ParseTable parse_WorldNamedInteractable[] =
{
	{ "WorldNamedInteractable", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldNamedInteractable), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "common_data",			TOK_EMBEDDEDSTRUCT(WorldNamedInteractable, common_data, parse_WorldEncounterObject)},
	{ "entry_id",				TOK_AUTOINT(WorldNamedInteractable, entry_id, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldNamedInteractable()
{
	int iSize = sizeof(WorldNamedInteractable);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldNamedInteractable, iSize, "WorldNamedInteractable", NULL, "wlEncounter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldEncounterObject[];
#define TYPE_parse_WorldEncounterObject WorldEncounterObject
extern ParseTable parse_WorldSpawnProperties[];
#define TYPE_parse_WorldSpawnProperties WorldSpawnProperties
//Structparser.exe autogenerated ParseTable for struct WorldSpawnPoint
#define TYPE_parse_WorldSpawnPoint WorldSpawnPoint
ParseTable parse_WorldSpawnPoint[] =
{
	{ "WorldSpawnPoint", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldSpawnPoint), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "common_data",		TOK_EMBEDDEDSTRUCT(WorldSpawnPoint, common_data, parse_WorldEncounterObject)},
	{ "properties",			TOK_OPTIONALSTRUCT(WorldSpawnPoint, properties, parse_WorldSpawnProperties) },
	{ "spawn_pos",			TOK_VEC3(WorldSpawnPoint, spawn_pos), NULL },
	{ "spawn_rot",			TOK_QUATPYR(WorldSpawnPoint, spawn_rot), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldSpawnPoint()
{
	int iSize = sizeof(WorldSpawnPoint);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldSpawnPoint, iSize, "WorldSpawnPoint", NULL, "wlEncounter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldEncounterObject[];
#define TYPE_parse_WorldEncounterObject WorldEncounterObject
extern ParseTable parse_WorldPatrolProperties[];
#define TYPE_parse_WorldPatrolProperties WorldPatrolProperties
//Structparser.exe autogenerated ParseTable for struct WorldPatrolRoute
#define TYPE_parse_WorldPatrolRoute WorldPatrolRoute
ParseTable parse_WorldPatrolRoute[] =
{
	{ "WorldPatrolRoute", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldPatrolRoute), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "common_data",		TOK_EMBEDDEDSTRUCT(WorldPatrolRoute, common_data, parse_WorldEncounterObject)},
	{ "properties",			TOK_OPTIONALSTRUCT(WorldPatrolRoute, properties, parse_WorldPatrolProperties) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldPatrolRoute()
{
	int iSize = sizeof(WorldPatrolRoute);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldPatrolRoute, iSize, "WorldPatrolRoute", NULL, "wlEncounter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldEncounterObject[];
#define TYPE_parse_WorldEncounterObject WorldEncounterObject
extern ParseTable parse_WorldTriggerConditionProperties[];
#define TYPE_parse_WorldTriggerConditionProperties WorldTriggerConditionProperties
//Structparser.exe autogenerated ParseTable for struct WorldTriggerCondition
#define TYPE_parse_WorldTriggerCondition WorldTriggerCondition
ParseTable parse_WorldTriggerCondition[] =
{
	{ "WorldTriggerCondition", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldTriggerCondition), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "common_data",			TOK_EMBEDDEDSTRUCT(WorldTriggerCondition, common_data, parse_WorldEncounterObject)},
	{ "properties",				TOK_OPTIONALSTRUCT(WorldTriggerCondition, properties, parse_WorldTriggerConditionProperties) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldTriggerCondition()
{
	int iSize = sizeof(WorldTriggerCondition);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldTriggerCondition, iSize, "WorldTriggerCondition", NULL, "wlEncounter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldEncounterObject[];
#define TYPE_parse_WorldEncounterObject WorldEncounterObject
extern ParseTable parse_WorldLayerFSMProperties[];
#define TYPE_parse_WorldLayerFSMProperties WorldLayerFSMProperties
//Structparser.exe autogenerated ParseTable for struct WorldLayerFSM
#define TYPE_parse_WorldLayerFSM WorldLayerFSM
ParseTable parse_WorldLayerFSM[] =
{
	{ "WorldLayerFSM", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldLayerFSM), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "common_data",	TOK_EMBEDDEDSTRUCT(WorldLayerFSM, common_data, parse_WorldEncounterObject)},
	{ "properties",		TOK_OPTIONALSTRUCT(WorldLayerFSM, properties, parse_WorldLayerFSMProperties) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldLayerFSM()
{
	int iSize = sizeof(WorldLayerFSM);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldLayerFSM, iSize, "WorldLayerFSM", NULL, "wlEncounter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldEncounterObject[];
#define TYPE_parse_WorldEncounterObject WorldEncounterObject
//Structparser.exe autogenerated ParseTable for struct WorldNamedPoint
#define TYPE_parse_WorldNamedPoint WorldNamedPoint
ParseTable parse_WorldNamedPoint[] =
{
	{ "WorldNamedPoint", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldNamedPoint), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "common_data",		TOK_EMBEDDEDSTRUCT(WorldNamedPoint, common_data, parse_WorldEncounterObject)},
	{ "point_pos",			TOK_VEC3(WorldNamedPoint, point_pos), NULL },
	{ "point_rot",			TOK_QUATPYR(WorldNamedPoint, point_rot), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldNamedPoint()
{
	int iSize = sizeof(WorldNamedPoint);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldNamedPoint, iSize, "WorldNamedPoint", NULL, "wlEncounter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldEncounterObject[];
#define TYPE_parse_WorldEncounterObject WorldEncounterObject
//Structparser.exe autogenerated ParseTable for struct WorldNamedVolume
#define TYPE_parse_WorldNamedVolume WorldNamedVolume
ParseTable parse_WorldNamedVolume[] =
{
	{ "WorldNamedVolume", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldNamedVolume), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "common_data",		TOK_EMBEDDEDSTRUCT(WorldNamedVolume, common_data, parse_WorldEncounterObject)},
	{ "entry_id",			TOK_AUTOINT(WorldNamedVolume, entry_id, 0), NULL },
	{ "def_name",			TOK_IGNORE, 0 },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldNamedVolume()
{
	int iSize = sizeof(WorldNamedVolume);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldNamedVolume, iSize, "WorldNamedVolume", NULL, "wlEncounter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldEncounterObject[];
#define TYPE_parse_WorldEncounterObject WorldEncounterObject
extern ParseTable parse_LogicalGroupProperties[];
#define TYPE_parse_LogicalGroupProperties LogicalGroupProperties
//Structparser.exe autogenerated ParseTable for struct WorldLogicalGroup
#define TYPE_parse_WorldLogicalGroup WorldLogicalGroup
ParseTable parse_WorldLogicalGroup[] =
{
	{ "WorldLogicalGroup", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldLogicalGroup), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "common_data",		TOK_EMBEDDEDSTRUCT(WorldLogicalGroup, common_data, parse_WorldEncounterObject)},
	{ "properties",			TOK_OPTIONALSTRUCT(WorldLogicalGroup, properties, parse_LogicalGroupProperties) },
	{ "object_ids",			TOK_INTARRAY(WorldLogicalGroup, object_ids),  NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldLogicalGroup()
{
	int iSize = sizeof(WorldLogicalGroup);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldLogicalGroup, iSize, "WorldLogicalGroup", NULL, "wlEncounter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct WorldScopeNameId
#define TYPE_parse_WorldScopeNameId WorldScopeNameId
ParseTable parse_WorldScopeNameId[] =
{
	{ "WorldScopeNameId", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldScopeNameId), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "name",				TOK_STRING(WorldScopeNameId, name, 0), NULL },
	{ "unique_id",			TOK_AUTOINT(WorldScopeNameId, unique_id, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldScopeNameId()
{
	int iSize = sizeof(WorldScopeNameId);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldScopeNameId, iSize, "WorldScopeNameId", NULL, "wlEncounter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct WorldLogicalGroupLoc
#define TYPE_parse_WorldLogicalGroupLoc WorldLogicalGroupLoc
ParseTable parse_WorldLogicalGroupLoc[] =
{
	{ "WorldLogicalGroupLoc", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldLogicalGroupLoc), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "index",					TOK_AUTOINT(WorldLogicalGroupLoc, index, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldLogicalGroupLoc()
{
	int iSize = sizeof(WorldLogicalGroupLoc);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldLogicalGroupLoc, iSize, "WorldLogicalGroupLoc", NULL, "wlEncounter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldScopeNameId[];
#define TYPE_parse_WorldScopeNameId WorldScopeNameId
extern ParseTable parse_WorldScope[];
#define TYPE_parse_WorldScope WorldScope
//Structparser.exe autogenerated ParseTable for struct WorldScope
#define TYPE_parse_WorldScope WorldScope
ParseTable parse_WorldScope[] =
{
	{ "WorldScope", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldScope), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "layer_idx",		TOK_AUTOINT(WorldScope, layer_idx, 0), NULL },
	{ "name_id_pairs",	TOK_STRUCT(WorldScope, name_id_pairs, parse_WorldScopeNameId) },
	{ "sub_scopes",		TOK_STRUCT(WorldScope, sub_scopes, parse_WorldScope) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldScope()
{
	int iSize = sizeof(WorldScope);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldScope, iSize, "WorldScope", NULL, "wlEncounter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldScope[];
#define TYPE_parse_WorldScope WorldScope
extern ParseTable parse_WorldEncounterHack[];
#define TYPE_parse_WorldEncounterHack WorldEncounterHack
extern ParseTable parse_WorldEncounter[];
#define TYPE_parse_WorldEncounter WorldEncounter
extern ParseTable parse_WorldNamedInteractable[];
#define TYPE_parse_WorldNamedInteractable WorldNamedInteractable
extern ParseTable parse_WorldSpawnPoint[];
#define TYPE_parse_WorldSpawnPoint WorldSpawnPoint
extern ParseTable parse_WorldPatrolRoute[];
#define TYPE_parse_WorldPatrolRoute WorldPatrolRoute
extern ParseTable parse_WorldNamedPoint[];
#define TYPE_parse_WorldNamedPoint WorldNamedPoint
extern ParseTable parse_WorldNamedVolume[];
#define TYPE_parse_WorldNamedVolume WorldNamedVolume
extern ParseTable parse_WorldTriggerCondition[];
#define TYPE_parse_WorldTriggerCondition WorldTriggerCondition
extern ParseTable parse_WorldLayerFSM[];
#define TYPE_parse_WorldLayerFSM WorldLayerFSM
extern ParseTable parse_WorldLogicalGroup[];
#define TYPE_parse_WorldLogicalGroup WorldLogicalGroup
//Structparser.exe autogenerated ParseTable for struct WorldZoneMapScope
#define TYPE_parse_WorldZoneMapScope WorldZoneMapScope
ParseTable parse_WorldZoneMapScope[] =
{
	{ "WorldZoneMapScope", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WorldZoneMapScope), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "scope",				TOK_EMBEDDEDSTRUCT(WorldZoneMapScope, scope, parse_WorldScope)},
	{ "encounter_hacks",	TOK_STRUCT(WorldZoneMapScope, encounter_hacks, parse_WorldEncounterHack) },
	{ "encounters",			TOK_STRUCT(WorldZoneMapScope, encounters, parse_WorldEncounter) },
	{ "interactables",		TOK_STRUCT(WorldZoneMapScope, interactables, parse_WorldNamedInteractable) },
	{ "spawn_points",		TOK_STRUCT(WorldZoneMapScope, spawn_points, parse_WorldSpawnPoint) },
	{ "patrol_routes",		TOK_STRUCT(WorldZoneMapScope, patrol_routes, parse_WorldPatrolRoute) },
	{ "named_points",		TOK_STRUCT(WorldZoneMapScope, named_points, parse_WorldNamedPoint) },
	{ "named_volumes",		TOK_STRUCT(WorldZoneMapScope, named_volumes, parse_WorldNamedVolume) },
	{ "trigger_conditions",	TOK_STRUCT(WorldZoneMapScope, trigger_conditions, parse_WorldTriggerCondition) },
	{ "layer_fsms",			TOK_STRUCT(WorldZoneMapScope, layer_fsms, parse_WorldLayerFSM) },
	{ "groups",				TOK_STRUCT(WorldZoneMapScope, groups, parse_WorldLogicalGroup) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WorldZoneMapScope()
{
	int iSize = sizeof(WorldZoneMapScope);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WorldZoneMapScope, iSize, "WorldZoneMapScope", NULL, "wlEncounter.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
