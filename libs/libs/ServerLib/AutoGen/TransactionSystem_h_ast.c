#include "textparser.h"

//auto-generated staticdefine for enum enumTransactionType
//autogeneratednocheckin
StaticDefineInt enumTransactionTypeEnum[] =
{
	DEFINE_INT
	{ "NONE", TRANS_TYPE_NONE},
	{ "SIMULTANEOUS", TRANS_TYPE_SIMULTANEOUS},
	{ "SIMULTANEOUS_ATOMIC", TRANS_TYPE_SIMULTANEOUS_ATOMIC},
	{ "SEQUENTIAL", TRANS_TYPE_SEQUENTIAL},
	{ "SEQUENTIAL_STOPONFAIL", TRANS_TYPE_SEQUENTIAL_STOPONFAIL},
	{ "SEQUENTIAL_ATOMIC", TRANS_TYPE_SEQUENTIAL_ATOMIC},
	{ "CORRUPT", TRANS_TYPE_CORRUPT},
	{ "COUNT", TRANS_TYPE_COUNT},
	DEFINE_END
};
void autoEnum_fixup_enumTransactionType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(enumTransactionTypeEnum, "enumTransactionType");
}

//auto-generated staticdefine for enum enumTransServerConnectResult
//autogeneratednocheckin
StaticDefineInt enumTransServerConnectResultEnum[] =
{
	DEFINE_INT
	{ "NONE", TRANS_SERVER_CONNECT_RESULT_NONE},
	{ "SUCCESS", TRANS_SERVER_CONNECT_RESULT_SUCCESS},
	{ "FAILURE_OBJECTDBALREADYCONNECTED", TRANS_SERVER_CONNECT_RESULT_FAILURE_OBJECTDBALREADYCONNECTED},
	{ "FAILURE_SERVERIDNOTUNIQUE", TRANS_SERVER_CONNECT_RESULT_FAILURE_SERVERIDNOTUNIQUE},
	{ "FAILURE_ANTIZOMBIFICATIONCOOKIE_MISMATCH", TRANS_SERVER_CONNECT_RESULT_FAILURE_ANTIZOMBIFICATIONCOOKIE_MISMATCH},
	{ "FAILURE_TOOMANYMULTIPLEXERS", TRANS_SERVER_CONNECT_RESULT_FAILURE_TOOMANYMULTIPLEXERS},
	{ "FAILURE_MULTIPLEXIDINUSE", TRANS_SERVER_CONNECT_RESULT_FAILURE_MULTIPLEXIDINUSE},
	{ "HANDSHAKE_FAILED", TRANS_SERVER_CONNECT_RESULT_HANDSHAKE_FAILED},
	{ "TOO_MANY_CONNECTIONS", TRANS_SERVER_CONNECT_RESULT_TOO_MANY_CONNECTIONS},
	{ "FAILURE_VERSION_MISMATCH", TRANS_SERVER_CONNECT_RESULT_FAILURE_VERSION_MISMATCH},
	DEFINE_END
};
void autoEnum_fixup_enumTransServerConnectResult(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(enumTransServerConnectResultEnum, "enumTransServerConnectResult");
}
//autogeneratednocheckin
extern ParseTable parse_ContainerRef[];
#define TYPE_parse_ContainerRef ContainerRef
//Structparser.exe autogenerated ParseTable for struct BaseTransaction
#define TYPE_parse_BaseTransaction BaseTransaction
ParseTable parse_BaseTransaction[] =
{
	{ "BaseTransaction", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(BaseTransaction), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "recipient",						TOK_EMBEDDEDSTRUCT(BaseTransaction, recipient, parse_ContainerRef)},
	{ "Data",							TOK_STRING(BaseTransaction, pData, 0), NULL },
	{ "RequestedTransVariableNames",	TOK_STRING(BaseTransaction, pRequestedTransVariableNames, 0), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_BaseTransaction()
{
	int iSize = sizeof(BaseTransaction);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_BaseTransaction, iSize, "BaseTransaction", NULL, "TransactionSystem.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_BaseTransaction[];
#define TYPE_parse_BaseTransaction BaseTransaction
//Structparser.exe autogenerated ParseTable for struct TransactionRequest
#define TYPE_parse_TransactionRequest TransactionRequest
ParseTable parse_TransactionRequest[] =
{
	{ "TransactionRequest", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(TransactionRequest), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "BaseTransactions",	TOK_STRUCT(TransactionRequest, ppBaseTransactions, parse_BaseTransaction) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_TransactionRequest()
{
	int iSize = sizeof(TransactionRequest);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_TransactionRequest, iSize, "TransactionRequest", NULL, "TransactionSystem.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
