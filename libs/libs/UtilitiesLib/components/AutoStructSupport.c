#include "textparser.h"
#include "error.h"

ParseTable parse_NullStruct[] =
{
	{ "{",				TOK_START, 0 },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};



//the struct must always have an entire word padding it out at the end to ensure we catch any
//weird padding cases
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn)
{
	int iWord;
	U32 *pWords = (U32*)pStruct;

	for (iWord = 0; iWord < iAllocedSizeInWords - 1; iWord++)
	{
		if (pWords[iWord])
		{
            int iBit;
            U32 uBitMask = 1;

            for (iBit = 0; iBit < 32; iBit++, uBitMask<<=1)
			{
				if (pWords[iWord] & uBitMask)
				{
					int iCount = 0;

                    assert(TOK_GET_TYPE(pTPIColumn->type) == TOK_BIT);
					assert(pWords[iWord + 1] == 0);

                    while ((pWords[iWord] & uBitMask) && uBitMask)
					{
						iCount++;
                        uBitMask<<=1;
					}

					pTPIColumn->storeoffset = iWord * 4;
					pTPIColumn->param = (iCount << 16) + iBit;
					return;
				}
			}
		}
	}

	assertmsg(0, "Couldn't find bitfield");
}


/*
void FixupPolyTable(ParseTable *pPolyTable, char *pNameToFind, int iStructSize)
{
	int i;
	FORALL_PARSETABLE(pPolyTable, i)
	{
		if (pPolyTable[i].name && strcmp(pNameToFind, pPolyTable[i].name) == 0)
		{
			pPolyTable[i].param = iStructSize;
			return;
		}
	}

	assertmsg(0, "Couldn't fixup poly table");
}
*/

void AddEntryToPolyTable(ParseTable *pPolyTable, char *pName, ParseTable *pTable, int iSize)
{
	int i;
	int iCurCount = 0;

	FORALL_PARSETABLE(pPolyTable, i)
	{
		iCurCount++;
	}

	//the last row in an autogenerated polytable has 1 instead of 0 in its storeoffset... if we hit that, then
	//we are out of space
	assertmsgf(!pPolyTable[iCurCount].storeoffset, "Ran out of space while trying to insert type %s into its parent's polytable... add extra space by increasing the value in AST(POLYPARENTTYPE(x))", pName);

	pPolyTable[iCurCount].name = pName;
	pPolyTable[iCurCount].type = TOK_STRUCT_X;
	pPolyTable[iCurCount].subtable = pTable;
	pPolyTable[iCurCount].param = iSize;
}





void DoAutoStructLateBind(ParseTable *pTPI, int iColumnNum, char *pOtherTPIName)
{

	intptr_t iSize;
	ParseTable *parseTable;

	if (parseTable = ParserGetTableFromStructName(pOtherTPIName))
	{	
		int i;

		if (!(iSize = ParserGetTableSize(parseTable)))
		{
			assert(0);
		}

		FORALL_PARSETABLE(parseTable, i)
		{
			if (TOK_GET_TYPE(parseTable[i].type) == TOK_IGNORE) continue;

			if (parseTable[i].type & TOK_OBJECTTYPE)
			{
				ErrorOrAlertDeferred(false, "BAD_LATEBIND", "Parse table %s trying to latebind %s as a child. But %s is a polymorphic struct. This will not work",
					ParserGetTableName(pTPI), pOtherTPIName, pOtherTPIName);
			}

		}

		pTPI[iColumnNum].subtable = parseTable;
		assertmsgf(pTPI[iColumnNum].param == 0 || pTPI[iColumnNum].param == iSize, "Size inconsistency in LateBind fixup");
		pTPI[iColumnNum].param = iSize;
		return;
	}
	else
	{
		pTPI[iColumnNum].subtable = parse_NullStruct;
		pTPI[iColumnNum].param = 0;
		// didn't load right
		return;
	}
	
}


//this is really for LATELINK, but this seems like a reasonable place to put it
void SetLateLinkArgString(char **ppVar, char *pArgString, char *pFuncName)
{
	if (*ppVar == NULL)
	{
		*ppVar = pArgString;
		return;
	}
	else
	{
		assertmsgf(strcmp(*ppVar, pArgString) == 0, "Argument mismatch for LATELINK func %s", pFuncName);
	}
}

