#include "cmdparse.h"
#include "ResourceManager.h"
#include "Message.h"
#include "file.h"
#include "UtilitiesLibEnums.h"
#include "StringCache.h"
#include "strings_opt.h"
#include "AppLocale_h_ast.h"
#include "CommandTranslation.h"
#include "CommandTranslation_h_ast.c"
#include "TimedCallback.h"

AUTO_RUN_ANON(memBudgetAddMapping(__FILE__, BUDGET_GameSystems););

// Dump command messages into Commands_{Prefix}_User.ms and Commands_{Prefix}_CSR.ms.
AUTO_COMMAND ACMD_CATEGORY(Debug);
void CmdParseDumpMessages(const char *pchPrefix, CommandNameList *pExcept, CommandNameList *pAdded, const char *pchRoot)
{
#ifndef MESSAGE_IS_TINY
	char achUserFile[MAX_PATH];
	char achCsrFile[MAX_PATH];
	char achUserSuffix[MAX_PATH];
	char achCsrSuffix[MAX_PATH];
	FILE *pUserFile;
	FILE *pCsrFile;
	Message message = {0};
	char achName[1024];
	char achDescription[1024];
	char achScope[1024];
	char *pch = NULL;

	sprintf(achUserSuffix, "%s/Commands_%s_User.ms", pchRoot, pchPrefix);
	sprintf(achCsrSuffix, "%s/Commands_%s_CSR.ms", pchRoot, pchPrefix);
	fileLocateWrite(achUserSuffix, achUserFile);
	fileLocateWrite(achCsrSuffix, achCsrFile);
	makeDirectoriesForFile(achUserFile);
	makeDirectoriesForFile(achCsrFile);

	fileForceRemove(achUserFile);
	fileForceRemove(achCsrFile);
	pUserFile = fopen(achUserFile, "wb");
	pCsrFile = fopen(achCsrFile, "wb");

	if (pUserFile)
		fprintf(pUserFile, "### This file is automatically generated and should not be modified by hand.\r\n\r\n");
	if (pCsrFile)
		fprintf(pCsrFile, "### This file is automatically generated and should not be modified by hand.\r\n\r\n");

	FOR_EACH_IN_STASHTABLE(gGlobalCmdList.sCmdsByName, Cmd, pCommand)
	{
		FILE *pFile = NULL;

		if (pCommand->flags & CMDF_HIDEPRINT)
			continue;
		if (pCommand->access_level == 0)
			pFile = pUserFile;
		else if (pCommand->access_level < ACCESS_DEBUG)
			pFile = pCsrFile;

		if (!pFile)
			continue;

		if (pExcept && eaFindString(&pExcept->eaNames, pCommand->name) >= 0)
			continue;

		estrClear(&pch);
		sprintf(achDescription, "Description for command %s", pCommand->name);
		sprintf(achName, "Command_Help_%s", pCommand->name);
		sprintf(achScope, "CommandHelp/%s", pCommand->origin ? pCommand->origin : "Unknown");
		message.pcDescription = achDescription;
		message.pcMessageKey = achName;
		message.pcDefaultString = (char *)pCommand->comment;
		message.pcScope = achScope;
		ParserWriteText(&pch, parse_Message, &message, 0, 0, 0);
		fprintf(pFile, "Message %s", pch);

		estrClear(&pch);
		sprintf(achDescription, "Translated name for command %s", pCommand->name);
		sprintf(achName, "Command_Name_%s", pCommand->name);
		sprintf(achScope, "CommandName/%s", pCommand->origin ? pCommand->origin : "Unknown");
		message.pcDescription = achDescription;
		message.pcMessageKey = achName;
		message.pcDefaultString = (char *)pCommand->name;
		message.pcScope = achScope;
		ParserWriteText(&pch, parse_Message, &message, 0, 0, 0);
		fprintf(pFile, "Message %s", pch);
		if (pAdded)
			eaPush(&pAdded->eaNames, pCommand->name);
	}
	FOR_EACH_END;

	fclose(pUserFile);
	fclose(pCsrFile);
	estrDestroy(&pch);
#endif // MESSAGE_IS_TINY
}

const char *CmdTranslatedName(const char *pchName, Language eLanguage)
{
	char achName[1024];
	sprintf(achName, "Command_Name_%s", pchName);
	return langTranslateMessageKeyDefault(eLanguage, achName, pchName);
}

const char *CmdTranslatedHelp(Cmd *pCommand, Language eLanguage)
{
	char achName[1024];
	sprintf(achName, "Command_Help_%s", pCommand->name);
	return langTranslateMessageKeyDefault(eLanguage, achName, pCommand->comment);
}

static CmdList **s_eaTranslated;
static bool s_abNeedsReload[LANGUAGE_MAX];

static void CommandTranslationReload(TimedCallback *pCB, F32 fTime, UserData pLanguage)
{
	Language eLanguage = PTR_TO_S32(pLanguage);
	S32 i;
	loadstart_printf("Regenerating command lists for language %s... ", StaticDefineIntRevLookup(LanguageEnum, eLanguage));
	for (i = 0; i < eaSize(&s_eaTranslated); i++)
	{
		stashTableDestroy(s_eaTranslated[i]->sCmdsByName_Translated[eLanguage]);
		s_eaTranslated[i]->sCmdsByName_Translated[eLanguage] = NULL;
		CmdListGenerateMapForLanguage(s_eaTranslated[i], eLanguage);
	}
	s_abNeedsReload[eLanguage] = false;
	loadend_printf("Done.");
}

// When a message is changed, we need to regenerate all the command strings.
void CommandTranslationDictEventCallback(enumResourceEventType eType, const char *pDictName, const char *pResourceName, void *pResource, void *pUserData)
{
	if ((eType == RESEVENT_RESOURCE_ADDED || eType == RESEVENT_RESOURCE_REMOVED || eType == RESEVENT_RESOURCE_MODIFIED)
		&& strStartsWith(pResourceName, "Command_"))
	{
		Language eLanguage = PTR_TO_S32(pUserData);
		if (!s_abNeedsReload[eLanguage])
		{
			TimedCallback_Run(CommandTranslationReload, pUserData, 0); 
			s_abNeedsReload[eLanguage] = true;
		}
	}
}

void CmdListGenerateMapForLanguage(CmdList *pList, Language eLanguage)
{
	S32 iTotal = 0;

	if (!devassertmsg(eLanguage >= 0 && eLanguage < ARRAY_SIZE_CHECKED(pList->sCmdsByName_Translated),
		"Trying to generate command mappings for an invalid language ID"))
		return;
	// If the command list is already generated we don't need to do it again.
	// If the command list is internal, we shouldn't translate it.
	if (pList->sCmdsByName_Translated[eLanguage] || pList->bInternalList)
		return;

	eaPushUnique(&s_eaTranslated, pList);

	loadstart_printf("Processing translated commands for %s... ", StaticDefineIntRevLookup(LanguageEnum, eLanguage));
	pList->sCmdsByName_Translated[eLanguage] = stashTableCreateWithStringKeys(8, StashDefault);
	FOR_EACH_IN_STASHTABLE(pList->sCmdsByName, Cmd, pCommand);
	{
		char achTranslationKey[1024];
		const char *pchTranslation;
		Message *pMessage; 

		sprintf(achTranslationKey, "Command_Name_%s", pCommand->name);
		pMessage = RefSystem_ReferentFromString("Message", achTranslationKey);
		pchTranslation = pMessage ? langTranslateMessage(eLanguage, pMessage) : NULL;
		// If there's a translation, and it's not blank, and it's different from the command's base name, and it's different from the English string
		if (pchTranslation && *pchTranslation && stricmp(pchTranslation, pCommand->name) && stricmp(pchTranslation, pMessage->pcDefaultString))
		{
			const char *pchCmdName = allocAddString(stripUnderscores(pchTranslation));
			Cmd *pExisting;
			if (stashFindPointer(pList->sCmdsByName, pchCmdName, &pExisting))
			{
				ErrorFilenamef(
					msgGetFilename(pMessage),
					"Command translation key:\"%s\" value:\"%s\" could not be added for language %s. It is already the English command name \"%s\".",
					pMessage->pcMessageKey, TranslateMessagePtr(pMessage), StaticDefineIntRevLookup(LanguageEnum, eLanguage), pExisting->name);
			}
			else if (!stashAddPointer(pList->sCmdsByName_Translated[eLanguage], pchCmdName, pCommand, false))
			{
				stashFindPointer(pList->sCmdsByName_Translated[eLanguage], pchCmdName, &pExisting);
				ErrorFilenamef(
					msgGetFilename(pMessage),
					"Command translation key:\"%s\" value:\"%s\" could not be added for language %s. It is the same as the translation for %s.",
					pMessage->pcMessageKey, TranslateMessagePtr(pMessage), StaticDefineIntRevLookup(LanguageEnum, eLanguage), pExisting ? pExisting->name : NULL);
			}
			else
				iTotal++;
		}
	}
	FOR_EACH_END;

	loadend_printf("%d translated commands.", iTotal);
}
