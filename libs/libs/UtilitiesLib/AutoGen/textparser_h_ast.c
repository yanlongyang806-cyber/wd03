#include "textparser.h"

//auto-generated staticdefine for enum StructTokenType
//autogeneratednocheckin
StaticDefineInt StructTokenTypeEnum[] =
{
	DEFINE_INT
	{ "TOK_IGNORE", TOK_IGNORE},
	{ "TOK_START", TOK_START},
	{ "TOK_END", TOK_END},
	{ "TOK_U8_X", TOK_U8_X},
	{ "TOK_INT16_X", TOK_INT16_X},
	{ "TOK_INT_X", TOK_INT_X},
	{ "TOK_INT64_X", TOK_INT64_X},
	{ "TOK_F32_X", TOK_F32_X},
	{ "TOK_STRING_X", TOK_STRING_X},
	{ "TOK_CURRENTFILE_X", TOK_CURRENTFILE_X},
	{ "TOK_TIMESTAMP_X", TOK_TIMESTAMP_X},
	{ "TOK_LINENUM_X", TOK_LINENUM_X},
	{ "TOK_BOOL_X", TOK_BOOL_X},
	{ "TOK_UNUSED1_X", TOK_UNUSED1_X},
	{ "TOK_BOOLFLAG_X", TOK_BOOLFLAG_X},
	{ "TOK_QUATPYR_X", TOK_QUATPYR_X},
	{ "TOK_MATPYR_X", TOK_MATPYR_X},
	{ "TOK_FILENAME_X", TOK_FILENAME_X},
	{ "TOK_REFERENCE_X", TOK_REFERENCE_X},
	{ "TOK_FUNCTIONCALL_X", TOK_FUNCTIONCALL_X},
	{ "TOK_STRUCT_X", TOK_STRUCT_X},
	{ "TOK_POLYMORPH_X", TOK_POLYMORPH_X},
	{ "TOK_STASHTABLE_X", TOK_STASHTABLE_X},
	{ "TOK_BIT", TOK_BIT},
	{ "TOK_MULTIVAL_X", TOK_MULTIVAL_X},
	{ "TOK_COMMAND", TOK_COMMAND},
	{ "NUM_TOK_TYPE_TOKENS", NUM_TOK_TYPE_TOKENS},
	DEFINE_END
};
void autoEnum_fixup_StructTokenType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(StructTokenTypeEnum, "StructTokenType");
}

//auto-generated staticdefine for enum StructDiffOperator
//autogeneratednocheckin
StaticDefineInt StructDiffOperatorEnum[] =
{
	DEFINE_INT
	{ "DESTROY", STRUCTDIFF_DESTROY},
	{ "INVALID", STRUCTDIFF_INVALID},
	{ "SET", STRUCTDIFF_SET},
	{ "CREATE", STRUCTDIFF_CREATE},
	DEFINE_END
};
void autoEnum_fixup_StructDiffOperator(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(StructDiffOperatorEnum, "StructDiffOperator");
}

//auto-generated staticdefine for enum enumParserLoadFlags
//autogeneratednocheckin
StaticDefineInt enumParserLoadFlagsEnum[] =
{
	DEFINE_INT
	{ "INCLUDEHIDDEN", PARSER_INCLUDEHIDDEN},
	{ "FORCEREBUILD", PARSER_FORCEREBUILD},
	{ "INTERNALLOAD", PARSER_INTERNALLOAD},
	{ "DONTFREE", PARSER_DONTFREE},
	{ "OPTIONALFLAG", PARSER_OPTIONALFLAG},
	{ "SERVERSIDE", PARSER_SERVERSIDE},
	{ "CLIENTSIDE", PARSER_CLIENTSIDE},
	{ "BINS_ARE_SHARED", PARSER_BINS_ARE_SHARED},
	{ "NOERRORFSONPARSE", PARSER_NOERRORFSONPARSE},
	{ "PARSECURRENTFILE", PARSER_PARSECURRENTFILE},
	{ "DONTSETEDITMODE", PARSER_DONTSETEDITMODE},
	{ "USE_CRCS", PARSER_USE_CRCS},
	{ "IGNORE_ALL_UNKNOWN", PARSER_IGNORE_ALL_UNKNOWN},
	{ "NOINCLUDES", PARSER_NOINCLUDES},
	{ "NOERROR_ONIGNORE", PARSER_NOERROR_ONIGNORE},
	{ "DONTREBUILD", PARSER_DONTREBUILD},
	{ "HUGEBUFFERFORBINARYFILE", PARSER_HUGEBUFFERFORBINARYFILE},
	{ "DEVMODE", PARSER_DEVMODE},
	{ "IGNORE_EXTENSIONS", PARSER_IGNORE_EXTENSIONS},
	{ "NO_RELOAD", PARSER_NO_RELOAD},
	{ "ALLOW_BINS_WITH_ERRORS_AND_RELOADING", PARSER_ALLOW_BINS_WITH_ERRORS_AND_RELOADING},
	{ "ONLY_LOAD_BIN_FILE_IF_IT_HAD_NO_ERRORS", PARSER_ONLY_LOAD_BIN_FILE_IF_IT_HAD_NO_ERRORS},
	{ "LASTPLUSONE", PARSER_LASTPLUSONE},
	DEFINE_END
};
void autoEnum_fixup_enumParserLoadFlags(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(enumParserLoadFlagsEnum, "enumParserLoadFlags");
}
//autogeneratednocheckin
extern ParseTable parse_ObjectPath[];
#define TYPE_parse_ObjectPath ObjectPath
//Structparser.exe autogenerated ParseTable for struct StructDiffOp
#define TYPE_parse_StructDiffOp StructDiffOp
ParseTable parse_StructDiffOp[] =
{
	{ "StructDiffOp", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(StructDiffOp), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Field",			TOK_OPTIONALSTRUCT(StructDiffOp, pField, parse_ObjectPath) },
	{ "op",				TOK_AUTOINT(StructDiffOp, op, 0), StructDiffOperatorEnum },
	{ "Operand",		TOK_AUTOINT(StructDiffOp, pOperand, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_StructDiffOp()
{
	int iSize = sizeof(StructDiffOp);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_StructDiffOp, iSize, "StructDiffOp", NULL, "textparser.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_StructDiffOp[];
#define TYPE_parse_StructDiffOp StructDiffOp
//Structparser.exe autogenerated ParseTable for struct StructDiff
#define TYPE_parse_StructDiff StructDiff
ParseTable parse_StructDiff[] =
{
	{ "StructDiff", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(StructDiff), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "Ops",		TOK_STRUCT(StructDiff, ppOps, parse_StructDiffOp) },
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_StructDiff()
{
	int iSize = sizeof(StructDiff);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_StructDiff, iSize, "StructDiff", NULL, "textparser.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct WriteHTMLContextInternalState
#define TYPE_parse_WriteHTMLContextInternalState WriteHTMLContextInternalState
ParseTable parse_WriteHTMLContextInternalState[] =
{
	{ "WriteHTMLContextInternalState", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WriteHTMLContextInternalState), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "Depth",							TOK_AUTOINT(WriteHTMLContextInternalState, iDepth, 0), NULL },
	{ "GeneratingTableStack",			TOK_INTARRAY(WriteHTMLContextInternalState, iGeneratingTableStack),  NULL},
	{ "XPathSegments",					TOK_STRINGARRAY(WriteHTMLContextInternalState, ppXPathSegments), NULL },
	{ "OverrideLink",					TOK_ESTRING | TOK_STRING(WriteHTMLContextInternalState, pOverrideLink, 0), NULL },
	{ "XpathDepthOfOverrideLink",		TOK_AUTOINT(WriteHTMLContextInternalState, iXpathDepthOfOverrideLink, 0), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_WriteHTMLContextInternalState()
{
	int iSize = sizeof(WriteHTMLContextInternalState);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WriteHTMLContextInternalState, iSize, "WriteHTMLContextInternalState", NULL, "textparser.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WriteHTMLContextInternalState[];
#define TYPE_parse_WriteHTMLContextInternalState WriteHTMLContextInternalState
extern ParseTable parse_UrlArgumentList[];
#define TYPE_parse_UrlArgumentList UrlArgumentList
//Structparser.exe autogenerated ParseTable for struct WriteHTMLContext
#define TYPE_parse_WriteHTMLContext WriteHTMLContext
ParseTable parse_WriteHTMLContext[] =
{
	{ "WriteHTMLContext", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(WriteHTMLContext), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "internalState",				TOK_EMBEDDEDSTRUCT(WriteHTMLContext, internalState, parse_WriteHTMLContextInternalState)},
	{ "UrlArgs",					TOK_OPTIONALSTRUCT(WriteHTMLContext, pUrlArgs, parse_UrlArgumentList) },
	{ "MaxDepth",					TOK_AUTOINT(WriteHTMLContext, iMaxDepth, 0), NULL },
	{ "ArrayContext",				TOK_BIT, 0, 8, NULL},
	{ "NeedToDoAccessLevelChecks",	TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_WriteHTMLContext()
{
	int iSize = sizeof(WriteHTMLContext);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_WriteHTMLContext, iSize, "WriteHTMLContext", NULL, "textparser.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(WriteHTMLContext) + 7) / 4;
		WriteHTMLContext *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bArrayContext = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_WriteHTMLContext[5]);
		pTemp->bArrayContext = 0;
		pTemp->bNeedToDoAccessLevelChecks = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_WriteHTMLContext[6]);
		pTemp->bNeedToDoAccessLevelChecks = 0;
	}
	return 0;
};
