#include "textparser.h"
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct RateLimitCost
#define TYPE_parse_RateLimitCost RateLimitCost
ParseTable parse_RateLimitCost[] =
{
	{ "RateLimitCost", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(RateLimitCost), 0, NULL, 0, NULL },
	{ "szActivityType",	TOK_STRUCTPARAM | TOK_STRING(RateLimitCost, szActivityType, 0), NULL },
	{ "Cost",			TOK_STRUCTPARAM | TOK_AUTOINT(RateLimitCost, iCost, 0), NULL },
	{ "\n",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_RateLimitCost()
{
	int iSize = sizeof(RateLimitCost);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_RateLimitCost, iSize, "RateLimitCost", NULL, "RateLimit.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_RateLimitCost[];
#define TYPE_parse_RateLimitCost RateLimitCost
//Structparser.exe autogenerated ParseTable for struct RateLimitTier
#define TYPE_parse_RateLimitTier RateLimitTier
ParseTable parse_RateLimitTier[] =
{
	{ "RateLimitTier", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(RateLimitTier), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "AlertTokenThreshold",		TOK_AUTOINT(RateLimitTier, uAlertTokenThreshold, 0), NULL },
	{ "BlockTokenThreshold",		TOK_AUTOINT(RateLimitTier, uBlockTokenThreshold, 0), NULL },
	{ "MaximumTokens",				TOK_AUTOINT(RateLimitTier, uMaximumTokens, 0), NULL },
	{ "TokenExpirationInterval",	TOK_AUTOINT(RateLimitTier, uTokenExpirationInterval, 1), NULL },
	{ "SecondsPerToken",			TOK_REDUNDANTNAME | TOK_AUTOINT(RateLimitTier, uTokenExpirationInterval, 1), NULL },
	{ "TokensExpiredPerInterval",	TOK_AUTOINT(RateLimitTier, uTokensExpiredPerInterval, 1), NULL },
	{ "TokensPerSecond",			TOK_REDUNDANTNAME | TOK_AUTOINT(RateLimitTier, uTokensExpiredPerInterval, 1), NULL },
	{ "MaximumNumberOfBuckets",		TOK_AUTOINT(RateLimitTier, uMaximumNumberOfBuckets, 0), NULL },
	{ "AlertLevel",					TOK_AUTOINT(RateLimitTier, eAlertLevel, ALERTLEVEL_CRITICAL), enumAlertLevelEnum },
	{ "TokenCost",					TOK_STRUCT(RateLimitTier, eaTokenCosts, parse_RateLimitCost) },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_RateLimitTier()
{
	int iSize = sizeof(RateLimitTier);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_RateLimitTier, iSize, "RateLimitTier", NULL, "RateLimit.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_RateLimitTier[];
#define TYPE_parse_RateLimitTier RateLimitTier
//Structparser.exe autogenerated ParseTable for struct RateLimitConfig
#define TYPE_parse_RateLimitConfig RateLimitConfig
ParseTable parse_RateLimitConfig[] =
{
	{ "RateLimitConfig", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(RateLimitConfig), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Enabled",			TOK_AUTOINT(RateLimitConfig, bEnabled, true), NULL },
	{ "Tier",				TOK_STRUCT(RateLimitConfig, eaTiers, parse_RateLimitTier) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_RateLimitConfig()
{
	int iSize = sizeof(RateLimitConfig);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_RateLimitConfig, iSize, "RateLimitConfig", NULL, "RateLimit.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
