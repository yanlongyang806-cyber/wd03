/***************************************************************************



*/

#ifndef LOGGING_H_
#define LOGGING_H_
GCC_SYSTEM

#include "GlobalTypeEnum.h"
#include "loggingEnums.h"

typedef U32 ContainerID;
typedef struct MessageStruct MessageStruct;

#define DEFAULT_LOG_ROTATION 10080 // How often to rotate logs in minutes
#define HEAVY_LOG_ROTATION 60 // Once log is large, how often to rotate
#define HEAVY_LOG_THRESHOLD 10000000 // Size in bytes where a log is considered "large" and we should increase rotation

STATIC_ASSERT_MESSAGE(LOG_LAST - 1 == LOG_PVP, "Whenever you add a new logging type, you will hit this assert. That's OK, just change this assert and then increment the literal int in the assert in the next line. ");
STATIC_ASSERT_MESSAGE(LOG_LAST - 1 == 164, "If you see this assert, and it's the only one you see, it's because you tried to add a logging type to the middle of the list, or perhaps remove one. That is BAD BAD BAD BAD. Do not do it. Add all new types to the END of the list, and instead of removing unneeded ones, rename them into obsolescence.");

// Use this to send a transient message to a given object. Callbacks define what actually happens
void objPrintf(GlobalType type, ContainerID id, FORMAT_STR char const *fmt, ...);
#define objPrintf(type, id, fmt, ...) objPrintf(type, id, FORMAT_STRING_CHECKED(fmt), __VA_ARGS__)
void objvPrintf(GlobalType type, ContainerID id, FORMAT_STR char const *fmt, va_list ap);

typedef void (*objPrintCB)(GlobalType type, ContainerID id, const char *str);
void setObjPrintCB(objPrintCB cb);

// Sends a transient, but important, message to the specified container
void objBroadcastMessage(GlobalType type, ContainerID id, const char *pTitle, const char *pMessage);
typedef void (*objBroadcastMessageCB)(GlobalType type, ContainerID id, const char *title, const char *str);
void setObjBroadcastMessageCB(objBroadcastMessageCB cb);

void objBroadcastMessageEx(GlobalType type, ContainerID id, const char *pTitle, MessageStruct *pFmt);
typedef void (*objBroadcastMessageExCB)(GlobalType type, ContainerID id, const char *title, MessageStruct *pFmt);
void setObjBroadcastMessageExCB(objBroadcastMessageExCB cb);

// Name-value pairs created by logPair()
typedef struct LogClosure {
	const char *name;
	char *value;
} LogClosure;

// Create one name-value pair to log.
LogClosure *logPair_dbg(const char *name, FORMAT_STR const char *format, ...);
//#define logPair(name, format, ...) logPair_dbg(name, FORMAT_STRING_CHECKED(format), __VA_ARGS__)  // MSVC doesn't like this.
#define logPair logPair_dbg

// Append pairs generated by logPair() to an EString.
void logAppendPairs(char **estrPairs, ...);
void logvAppendPairs(char **estrPairs, va_list args);

// Expand a sequence like (A)(B)(C) into logPair(A), logPair(B), logPair(C)
#define LOG_PAIR_EXPAND(...) LOG_CAT(LOG_START_EATING __VA_ARGS__, LOG_STOP_EATING)
#define LOG_CAT(LHS, RHS) LOG_CAT_EVAL(LHS, RHS)
#define LOG_CAT_EVAL(LHS, RHS) LHS ## RHS
#define LOG_START_EATING LOG_EATER1
#define LOG_EATER1(...) logPair(__VA_ARGS__) LOG_EATER2
#define LOG_EATER2(...) , logPair(__VA_ARGS__) LOG_EATER3
#define LOG_EATER3(...) , logPair(__VA_ARGS__) LOG_EATER4
#define LOG_EATER4(...) , logPair(__VA_ARGS__) LOG_EATER5
#define LOG_EATER5(...) , logPair(__VA_ARGS__) LOG_EATER6
#define LOG_EATER6(...) , logPair(__VA_ARGS__) LOG_EATER7
#define LOG_EATER7(...) , logPair(__VA_ARGS__) LOG_EATER8
#define LOG_EATER8(...) , logPair(__VA_ARGS__) LOG_EATER9
#define LOG_EATER9(...) , logPair(__VA_ARGS__) LOG_EATER10
#define LOG_EATER10(...) , logPair(__VA_ARGS__) LOG_EATER11
#define LOG_EATER11(...) , logPair(__VA_ARGS__) LOG_EATER12
#define LOG_EATER12(...) , logPair(__VA_ARGS__) LOG_EATER13
#define LOG_EATER13(...) , logPair(__VA_ARGS__) LOG_EATER14
#define LOG_EATER14(...) , logPair(__VA_ARGS__) LOG_EATER15
#define LOG_EATER15(...) , logPair(__VA_ARGS__) LOG_EATER16
#define LOG_EATER16(...) , logPair(__VA_ARGS__) LOG_EATER17
#define LOG_EATER17(...) , logPair(__VA_ARGS__) LOG_EATER18
#define LOG_EATER18(...) , logPair(__VA_ARGS__) LOG_EATER19
#define LOG_EATER19(...) , logPair(__VA_ARGS__) LOG_EATER20
#define LOG_EATER20(...) , logPair(__VA_ARGS__) LOG_EATER21
#define LOG_EATER21(...) , logPair(__VA_ARGS__) LOG_EATER22
#define LOG_EATER22(...) , logPair(__VA_ARGS__) LOG_EATER23
#define LOG_EATER23(...) , logPair(__VA_ARGS__) LOG_EATER24
#define LOG_EATER24(...) , logPair(__VA_ARGS__) LOG_EATER25
#define LOG_EATER25(...) , logPair(__VA_ARGS__) ERROR_TOO_MANY_PAIRS
#define LOG_EATER1LOG_STOP_EATING
#define LOG_EATER2LOG_STOP_EATING
#define LOG_EATER3LOG_STOP_EATING
#define LOG_EATER4LOG_STOP_EATING
#define LOG_EATER5LOG_STOP_EATING
#define LOG_EATER6LOG_STOP_EATING
#define LOG_EATER7LOG_STOP_EATING
#define LOG_EATER8LOG_STOP_EATING
#define LOG_EATER9LOG_STOP_EATING
#define LOG_EATER10LOG_STOP_EATING
#define LOG_EATER11LOG_STOP_EATING
#define LOG_EATER12LOG_STOP_EATING
#define LOG_EATER13LOG_STOP_EATING
#define LOG_EATER14LOG_STOP_EATING
#define LOG_EATER15LOG_STOP_EATING
#define LOG_EATER16LOG_STOP_EATING
#define LOG_EATER17LOG_STOP_EATING
#define LOG_EATER18LOG_STOP_EATING
#define LOG_EATER19LOG_STOP_EATING
#define LOG_EATER20LOG_STOP_EATING
#define LOG_EATER21LOG_STOP_EATING
#define LOG_EATER22LOG_STOP_EATING
#define LOG_EATER23LOG_STOP_EATING
#define LOG_EATER24LOG_STOP_EATING
#define LOG_EATER25LOG_STOP_EATING

// Use instead of objLog if the server is the object.
int servLog_vprintf(enumLogCategory eCategory, const char *action, FORMAT_STR char const *oldFmt, va_list ap);
int servLog(enumLogCategory eCategory, const char *action, FORMAT_STR char const *fmt, ...);
#define servLog(eCategory, action, fmt, ...) servLog(eCategory, action, FORMAT_STRING_CHECKED(fmt), __VA_ARGS__)
int servLogWithStruct(enumLogCategory eCategory, const char *action, void *pStruct, ParseTable *pTPI);
int servLogWithPairs(enumLogCategory eCategory, const char *action, ...);
int servLogPairs(enumLogCategory eCategory, const char *action, ...);
#define SERVLOG_PAIRS(eCategory, action, ...) servLogPairs(eCategory, action, LOG_PAIR_EXPAND(__VA_ARGS__), NULL)


int file_servLogWithStruct(const char *fname, const char *action, void *pStruct, ParseTable *pTPI);


// Use these for recording logs about general objects. You can pass null for name and location
// Use entLog for entities
int objLog_vprintf(enumLogCategory eCategory, GlobalType type, ContainerID id, ContainerID owner_id, const char *objName, Vec3 *pLocation, const char *objOwner, const char *action, const char *pProjSpecificObjInfoString, FORMAT_STR char const *oldFmt, va_list ap);
int objLog(enumLogCategory eCategory, GlobalType type, ContainerID id, ContainerID owner_id, const char *objName, Vec3 *pLocation, const char *objOwner, const char *action, const char *pProjSpecificObjInfoString, FORMAT_STR char const *fmt, ...);

// Who so Pulleth Out This Comment of this Code and Macro, is Rightwise King Born of all Hax0rdom
// The following macro should be uncommented to allow FORMAT_STRING_CHECKED() to work as it does for servLog().  However, uncommenting
// it causes IntelliSense to crash Visual Studio 2005.  It seems to have something to do with the large number of parameters to the macro
// and the presence of the __VA_ARGS__ token.    This is probably the same crash as this:
//        http://connect.microsoft.com/VisualStudio/feedback/details/245794
// It may be possible to make this work by messing with it somehow; if you decide to try to fix it, make sure you reproduce the original
// crash (which should occur within 30 seconds or so of uncommenting it), as it will not occur if IntelliSense is disabled or otherwise
// non-functioning.
//#define objLog(eCategory, type, id, owner_id, name, pLocation, owner, action, pProjSpecificObjInfoString, fmt, ...) \
//	objLog(eCategory, type, id, owner_id, name, pLocation, owner, action, pProjSpecificObjInfoString, FORMAT_STRING_CHECKED(fmt), __VA_ARGS__)

int objLogWithStruct(enumLogCategory eCategory, GlobalType type, ContainerID id, ContainerID owner_id, const char *objName, Vec3 *pLocation, const char *objOwner, const char *action, const char *pProjSpecificObjInfoString, void *pStruct, ParseTable *pTPI);
int objLogPairs(enumLogCategory eCategory, GlobalType type, ContainerID id, ContainerID owner_id, const char *objName, Vec3 *pLocation, const char *objOwner, const char *action, const char *pProjSpecificObjInfoString, ...);
#define OBJLOG_PAIRS(eCategory, type, id, owner_id, objName, pLocation, objOwner, action, pProjSpecificObjInfoString, ...) \
	objLogPairs(eCategory, type, id, owner_id, objName, pLocation, objOwner, action, pProjSpecificObjInfoString, LOG_PAIR_EXPAND(__VA_ARGS__), NULL)

// Use this to report general status information, gets sent to logserver
int log_vprintf(enumLogCategory eCategory, FORMAT_STR char const *fmt, va_list ap);
int log_printf(enumLogCategory eCategory, FORMAT_STR char const *fmt, ...);
#define log_printf(eCategory, fmt, ...) log_printf(eCategory, FORMAT_STRING_CHECKED(fmt), __VA_ARGS__)

// Use this for local log printing, goes directly to a file
int filelog_vprintf(const char *fname, FORMAT_STR char const *fmt, va_list ap);
int filelog_vprintf_echo(bool bEcho, const char *fname,char const *fmt, va_list ap);
int filelog_printf(const char *fname, FORMAT_STR char const *fmt, ...);
#define filelog_printf(fname, fmt, ...) filelog_printf(fname, FORMAT_STRING_CHECKED(fmt), __VA_ARGS__)
int filelog_printf_zipped(const char *fname,FORMAT_STR char const *fmt, ...);

// Sets up a function to handle formatting log_vprintf calls
typedef int (*LogFormatCB)(char **estrOut, enumLogCategory eCategory,char const *fmt, va_list ap);
LogFormatCB logSetFormatCallback(LogFormatCB log_vprintf_fptr);

// Sets up a function to deal with the actual message sending/saving for log_vprintf
typedef int (*LogWriteCB)(enumLogCategory eCategory, const char *msg);
LogWriteCB logSetWriteCallback(LogWriteCB log_vprintf_fptr);

// Set directory that logs end up in
void logSetDir(const char *dir);
char *logGetDir(void);

// Disable all logging
void logDisableLogging(int disable);

// Turn on high-performance single server mode
// DO NOT turn this on for game servers, or anything else with multiple instances per machine
void logEnableHighPerformance(void);

// Say if we should auto-rotate log files
void logAutoRotateLogFiles(int enable);

//if true, then we will be doing our logging with logDirectWriteWithTime, and want to use the time
//of the individual logs to manage file rotating
void logSetUseLogTimeForFileRotation(bool bSet);

// Sets options for a specific log file
int logSetFileOptions_Filename(char *fname, bool bManualRotation, U32 rotateMinutes, bool bZipFile, bool bFlushOnWrite);

// Writes a single string to the local log file, without any formatting
int logDirectWriteWithTime(const char *pFileName, const char *msg_str, int flags, U32 iTime);

#define logDirectWrite(pFileName, msg_str) logDirectWriteWithTime(pFileName, msg_str, 0, 0)

// Closes all open logs
int logCloseAllLogs(void);

// Flush a single log
int logFlushFile(const char *pFileName);
int logFlushAndRenameFile(const char *pFileName, const char *pNewFileName);
int logFlushFile_ByCategory(enumLogCategory eCategory);

// Waits for pending log operations to complete, and closes all logs
void logWaitForQueueToEmpty(void);

// Internal logging system functions
void logSetMsgQueueSize(int max_bytes);

// Sets alert threshold for the log size alerts.
// Does nothing if the max log size has already been set by the command-line argument
void logSetMaxLogSize(int size);

// Sets alert threshold for the log size alerts.
void logSetMaxLogSizeOverride(int size);

int logToFileName(char *fname_ptr,char *msg,int compress); // Internal function, but used by gimme

void logGetFilename(char *filename, char *buffer, size_t buffer_size);

//generic flushing, sends all packets on servers
LATELINK;
void logFlush(void);

// Generate a canonical debug string for an object
void objSetDebugName(char *pchName, U32 uiLen, GlobalType type, ContainerID id, ContainerID owner_id, const char *objName, const char *objOwner);


//add a CB which is called on each log, but which does not stop the log from going to the normal place
//
//if bUseRawMessage is true, then the initially-passed-in log message will be used, otherwise the formatted
//one with dates and stuff will be used
//
//specify LOG_LAST as eCategory to fork all logs
typedef void LogForkingCB(char *pMsg);

//simple forking callback which printfs
void PrintfLogCB(char *pMsg);

void logAddForkingCB(LogForkingCB *pCB, enumLogCategory eCategory, bool bUseRawMessage);

U64 logGetNumBytesInMessageQueue(void);

enumLogCategory FindLogCategoryByFilename(const char *pFileName);

LATELINK;
const char *GetExtraInfoForLogPrintf(void);

AUTO_STRUCT;
typedef struct FrameCountsHistReported
{
	F32 fps;
	F32 rendererPerf;
	U32 ping;
	U32 ip;
} FrameCountsHistReported;
extern ParseTable parse_FrameCountsHistReported[];
#define TYPE_parse_FrameCountsHistReported FrameCountsHistReported

void GenerateLog(int n);

bool loggingActive(void);

extern bool gbZipAllLogs;

//returns a string that describes what's going on for logging, intended for the 
//servermonitor
LATELINK;
char *GetLoggingStatusString(void);
char *DEFAULT_LATELINK_GetLoggingStatusString(void);

//the logging system optionally writes a file into this directory every time it completes and properly closes a log file
extern char *gpDirectoryForLogCompletionFiles;

//returns the size, in bytes, of the background thread message queue
int logGetQueueSize(void);

//returns the number of times the foreground (or other logging) thread has had to sleep a MS while waiting for
//the background thread
U32 logGetNumStalls(void);

LATELINK;
void LoggingResizeHappened(int iBlockSize, int iOldSize, int iNewSize, int iMaxSize);
#endif
