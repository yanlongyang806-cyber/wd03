//For more info on remote commands, look here: http://crypticwiki:8081/display/Core/AUTO_COMMAND_REMOTE+and+AUTO_COMMAND_REMOTE_SLOW
//This file is autogenerated. autogeneratednocheckin
#include "RemoteAutoCommandSupport.h"
#include "TextParser.h"
#include "ObjTransactions.h"
#include "LocalTransactionManager.h"
#include "StructNet.h"
#include "netpacketutil.h"
#include "StringUtil.h"
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function AttemptToBootPlayerWithBooter_Outer, source file: I:\Night\Night\src\libs\ServerLib\PlayerBooter.c
typedef struct PlayerBooterResult PlayerBooterResult;
extern ParseTable parse_PlayerBooterResult[];
#define TYPE_parse_PlayerBooterResult PlayerBooterResult
void RemoteCommand_AttemptToBootPlayerWithBooter_Outer( TransactionReturnVal *pReturnValStruct, GlobalType gServerType, ContainerID gServerID, ContainerID iPlayerToBootID, const char* pReason)
{
	char *_SP_pCommandString = NULL;
	BaseTransaction baseTransaction;
	BaseTransaction **ppBaseTransactions = NULL;
	estrStackCreateSize(&_SP_pCommandString, 4096);
	estrConcatf(&_SP_pCommandString, "slowremotecommand AttemptToBootPlayerWithBooter_Outer ");
	estrConcatf(&_SP_pCommandString, PRINTF_CODE_FOR_INT(iPlayerToBootID), iPlayerToBootID);
	estrAppend2(&_SP_pCommandString, " \"");
	if (pReason) estrAppendEscaped(&_SP_pCommandString, pReason);
	estrAppend2(&_SP_pCommandString, "\" ");
	baseTransaction.pData = _SP_pCommandString;
	baseTransaction.recipient.containerID = gServerID;
	baseTransaction.recipient.containerType = gServerType;
	baseTransaction.pRequestedTransVariableNames = NULL;
	eaPush(&ppBaseTransactions, &baseTransaction);
	if (pReturnValStruct)
	{
		RequestNewTransaction( objLocalManager(), "AttemptToBootPlayerWithBooter_Outer", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, pReturnValStruct, 0 );
	}
	else
	{
		RequestNewTransaction( objLocalManager(), "AttemptToBootPlayerWithBooter_Outer", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, NULL, 0 );
	}
	eaDestroy(&ppBaseTransactions);
	estrDestroy(&_SP_pCommandString);
}

//Autogenerated function return function AttemptToBootPlayerWithBooter_Outer, source file: I:\Night\Night\src\libs\ServerLib\PlayerBooter.c
//externs and typedefs for return struct from AttemptToBootPlayerWithBooter_Outer:
typedef struct PlayerBooterResult PlayerBooterResult;
extern ParseTable parse_PlayerBooterResult[];
#define TYPE_parse_PlayerBooterResult PlayerBooterResult
enumTransactionOutcome RemoteCommandCheck_AttemptToBootPlayerWithBooter_Outer(TransactionReturnVal *pTransReturnStruct, PlayerBooterResult** pRetVal)
{
	switch (pTransReturnStruct->eOutcome)
	{
	case TRANSACTION_OUTCOME_FAILURE:
		return TRANSACTION_OUTCOME_FAILURE;
	case TRANSACTION_OUTCOME_SUCCESS:
		if (!pTransReturnStruct->pBaseReturnVals[0].returnString || pTransReturnStruct->pBaseReturnVals[0].returnString[0] == 0)
		{
			*pRetVal = NULL;
		}
		else
		{
			char *pTempString;
			*pRetVal = StructCreateVoid(parse_PlayerBooterResult);
			pTempString = pTransReturnStruct->pBaseReturnVals[0].returnString;
			ParserReadTextEscaped(&pTempString, parse_PlayerBooterResult, *pRetVal, 0);
		}
		return TRANSACTION_OUTCOME_SUCCESS;
	}
	return TRANSACTION_OUTCOME_NONE;
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function BeginSendingKeepAliveToController, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_BeginSendingKeepAliveToController( GlobalType gServerType, ContainerID gServerID, int iSeconds)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "BeginSendingKeepAliveToController"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "BeginSendingKeepAliveToController", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iSeconds);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function BeginSendingKeepAliveToController, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_BeginSendingKeepAliveToController(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, int iSeconds)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d BeginSendingKeepAliveToController ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iSeconds), iSeconds);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function CallLocalCommandRemotely, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_CallLocalCommandRemotely( GlobalType gServerType, ContainerID gServerID, const char* pLocalCommandString)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "CallLocalCommandRemotely"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "CallLocalCommandRemotely", NULL, NULL, NULL);
	pktSendString(_pPacket_StructParser__INTERNAL, pLocalCommandString);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function CallLocalCommandRemotely, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_CallLocalCommandRemotely(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, const char* pLocalCommandString)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d CallLocalCommandRemotely ", (int) gServerType, gServerID);
	estrAppend2(_SP_pCommandString, " \"");
	if (pLocalCommandString) estrAppendEscaped(_SP_pCommandString, pLocalCommandString);
	estrAppend2(_SP_pCommandString, "\" ");
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function CallLocalCommandRemotelyAndReturnVerboseHtmlString, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
typedef enum CommandServingFlags CommandServingFlags;
void RemoteCommand_CallLocalCommandRemotelyAndReturnVerboseHtmlString( GlobalType gServerType, ContainerID gServerID, int iClientID, int iCommandRequestID, U32 iMCPID, CommandServingFlags eFlags, const char* pCommand, int iAccessLevel, const char* pAuthNameAndIP)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "CallLocalCommandRemotelyAndReturnVerboseHtmlString"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "CallLocalCommandRemotelyAndReturnVerboseHtmlString", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iClientID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iCommandRequestID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iMCPID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, eFlags);
	pktSendString(_pPacket_StructParser__INTERNAL, pCommand);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iAccessLevel);
	pktSendString(_pPacket_StructParser__INTERNAL, pAuthNameAndIP);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function CallLocalCommandRemotelyAndReturnVerboseHtmlString, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_CallLocalCommandRemotelyAndReturnVerboseHtmlString(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, int iClientID, int iCommandRequestID, U32 iMCPID, CommandServingFlags eFlags, const char* pCommand, int iAccessLevel, const char* pAuthNameAndIP)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d CallLocalCommandRemotelyAndReturnVerboseHtmlString ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iClientID), iClientID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iCommandRequestID), iCommandRequestID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iMCPID), iMCPID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(eFlags), eFlags);
	estrAppend2(_SP_pCommandString, " \"");
	if (pCommand) estrAppendEscaped(_SP_pCommandString, pCommand);
	estrAppend2(_SP_pCommandString, "\" ");
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iAccessLevel), iAccessLevel);
	estrAppend2(_SP_pCommandString, " \"");
	if (pAuthNameAndIP) estrAppendEscaped(_SP_pCommandString, pAuthNameAndIP);
	estrAppend2(_SP_pCommandString, "\" ");
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function CallRemoteVerifyNoReturnLogging, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_CallRemoteVerifyNoReturnLogging( GlobalType gServerType, ContainerID gServerID, const char* pAutoTransFuncName, GlobalType eCallingType)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "CallRemoteVerifyNoReturnLogging"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "CallRemoteVerifyNoReturnLogging", NULL, NULL, NULL);
	pktSendString(_pPacket_StructParser__INTERNAL, pAutoTransFuncName);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, eCallingType);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function CallRemoteVerifyNoReturnLogging, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_CallRemoteVerifyNoReturnLogging(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, const char* pAutoTransFuncName, GlobalType eCallingType)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d CallRemoteVerifyNoReturnLogging ", (int) gServerType, gServerID);
	estrAppend2(_SP_pCommandString, " \"");
	if (pAutoTransFuncName) estrAppendEscaped(_SP_pCommandString, pAutoTransFuncName);
	estrAppend2(_SP_pCommandString, "\" ");
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(eCallingType), eCallingType);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function ContainerGetOwner, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
typedef struct ContainerRef ContainerRef;
extern ParseTable parse_ContainerRef[];
#define TYPE_parse_ContainerRef ContainerRef
void RemoteCommand_ContainerGetOwner( TransactionReturnVal *pReturnValStruct, GlobalType gServerType, ContainerID gServerID)
{
	char *_SP_pCommandString = NULL;
	BaseTransaction baseTransaction;
	BaseTransaction **ppBaseTransactions = NULL;
	estrStackCreateSize(&_SP_pCommandString, 4096);
	estrConcatf(&_SP_pCommandString, "remotecommand ContainerGetOwner ");
	baseTransaction.pData = _SP_pCommandString;
	baseTransaction.recipient.containerID = gServerID;
	baseTransaction.recipient.containerType = gServerType;
	baseTransaction.pRequestedTransVariableNames = NULL;
	eaPush(&ppBaseTransactions, &baseTransaction);
	if (pReturnValStruct)
	{
		RequestNewTransaction( objLocalManager(), "ContainerGetOwner", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, pReturnValStruct, 0 );
	}
	else
	{
		RequestNewTransaction( objLocalManager(), "ContainerGetOwner", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, NULL, 0 );
	}
	eaDestroy(&ppBaseTransactions);
	estrDestroy(&_SP_pCommandString);
}

//Autogenerated function return function ContainerGetOwner, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
//externs and typedefs for return struct from ContainerGetOwner:
typedef struct ContainerRef ContainerRef;
extern ParseTable parse_ContainerRef[];
#define TYPE_parse_ContainerRef ContainerRef
enumTransactionOutcome RemoteCommandCheck_ContainerGetOwner(TransactionReturnVal *pTransReturnStruct, ContainerRef** pRetVal)
{
	switch (pTransReturnStruct->eOutcome)
	{
	case TRANSACTION_OUTCOME_FAILURE:
		return TRANSACTION_OUTCOME_FAILURE;
	case TRANSACTION_OUTCOME_SUCCESS:
		if (!pTransReturnStruct->pBaseReturnVals[0].returnString || pTransReturnStruct->pBaseReturnVals[0].returnString[0] == 0)
		{
			*pRetVal = NULL;
		}
		else
		{
			char *pTempString;
			*pRetVal = StructCreateVoid(parse_ContainerRef);
			pTempString = pTransReturnStruct->pBaseReturnVals[0].returnString;
			ParserReadTextEscaped(&pTempString, parse_ContainerRef, *pRetVal, 0);
		}
		return TRANSACTION_OUTCOME_SUCCESS;
	}
	return TRANSACTION_OUTCOME_NONE;
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function ControllerScript_Failed_RC, source file: I:\Night\Night\src\libs\ServerLib\RemoteCommandGroup.c
void RemoteCommand_ControllerScript_Failed_RC( TransactionReturnVal *pReturnValStruct, GlobalType gServerType, ContainerID gServerID, const char* pStr)
{
	char *_SP_pCommandString = NULL;
	BaseTransaction baseTransaction;
	BaseTransaction **ppBaseTransactions = NULL;
	estrStackCreateSize(&_SP_pCommandString, 4096);
	estrConcatf(&_SP_pCommandString, "remotecommand ControllerScript_Failed_RC ");
	estrAppend2(&_SP_pCommandString, " \"");
	if (pStr) estrAppendEscaped(&_SP_pCommandString, pStr);
	estrAppend2(&_SP_pCommandString, "\" ");
	baseTransaction.pData = _SP_pCommandString;
	baseTransaction.recipient.containerID = gServerID;
	baseTransaction.recipient.containerType = gServerType;
	baseTransaction.pRequestedTransVariableNames = NULL;
	eaPush(&ppBaseTransactions, &baseTransaction);
	if (pReturnValStruct)
	{
		RequestNewTransaction( objLocalManager(), "ControllerScript_Failed_RC", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, pReturnValStruct, 0 );
	}
	else
	{
		RequestNewTransaction( objLocalManager(), "ControllerScript_Failed_RC", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, NULL, 0 );
	}
	eaDestroy(&ppBaseTransactions);
	estrDestroy(&_SP_pCommandString);
}

//Autogenerated function return function ControllerScript_Failed_RC, source file: I:\Night\Night\src\libs\ServerLib\RemoteCommandGroup.c
enumTransactionOutcome RemoteCommandCheck_ControllerScript_Failed_RC(TransactionReturnVal *pTransReturnStruct, int* pRetVal)
{
	switch (pTransReturnStruct->eOutcome)
	{
	case TRANSACTION_OUTCOME_FAILURE:
		return TRANSACTION_OUTCOME_FAILURE;
	case TRANSACTION_OUTCOME_SUCCESS:
		StringToInt_Multisize_AssumeGoodInput(pTransReturnStruct->pBaseReturnVals[0].returnString, pRetVal);
		return TRANSACTION_OUTCOME_SUCCESS;
	}
	return TRANSACTION_OUTCOME_NONE;
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function ControllerScript_Succeeded_RC, source file: I:\Night\Night\src\libs\ServerLib\RemoteCommandGroup.c
void RemoteCommand_ControllerScript_Succeeded_RC( TransactionReturnVal *pReturnValStruct, GlobalType gServerType, ContainerID gServerID)
{
	char *_SP_pCommandString = NULL;
	BaseTransaction baseTransaction;
	BaseTransaction **ppBaseTransactions = NULL;
	estrStackCreateSize(&_SP_pCommandString, 4096);
	estrConcatf(&_SP_pCommandString, "remotecommand ControllerScript_Succeeded_RC ");
	baseTransaction.pData = _SP_pCommandString;
	baseTransaction.recipient.containerID = gServerID;
	baseTransaction.recipient.containerType = gServerType;
	baseTransaction.pRequestedTransVariableNames = NULL;
	eaPush(&ppBaseTransactions, &baseTransaction);
	if (pReturnValStruct)
	{
		RequestNewTransaction( objLocalManager(), "ControllerScript_Succeeded_RC", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, pReturnValStruct, 0 );
	}
	else
	{
		RequestNewTransaction( objLocalManager(), "ControllerScript_Succeeded_RC", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, NULL, 0 );
	}
	eaDestroy(&ppBaseTransactions);
	estrDestroy(&_SP_pCommandString);
}

//Autogenerated function return function ControllerScript_Succeeded_RC, source file: I:\Night\Night\src\libs\ServerLib\RemoteCommandGroup.c
enumTransactionOutcome RemoteCommandCheck_ControllerScript_Succeeded_RC(TransactionReturnVal *pTransReturnStruct, int* pRetVal)
{
	switch (pTransReturnStruct->eOutcome)
	{
	case TRANSACTION_OUTCOME_FAILURE:
		return TRANSACTION_OUTCOME_FAILURE;
	case TRANSACTION_OUTCOME_SUCCESS:
		StringToInt_Multisize_AssumeGoodInput(pTransReturnStruct->pBaseReturnVals[0].returnString, pRetVal);
		return TRANSACTION_OUTCOME_SUCCESS;
	}
	return TRANSACTION_OUTCOME_NONE;
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function DebugCheckContainer_DoYouOwnContainer, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_DebugCheckContainer_DoYouOwnContainer( GlobalType gServerType, ContainerID gServerID, GlobalType eRequesterType, ContainerID iRequesterID, GlobalType eType, ContainerID iID, int iRequestID, bool bIsForTransServer)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "DebugCheckContainer_DoYouOwnContainer"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "DebugCheckContainer_DoYouOwnContainer", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, eRequesterType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iRequesterID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, eType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iRequestID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, bIsForTransServer);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function DebugCheckContainer_DoYouOwnContainer, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_DebugCheckContainer_DoYouOwnContainer(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, GlobalType eRequesterType, ContainerID iRequesterID, GlobalType eType, ContainerID iID, int iRequestID, bool bIsForTransServer)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d DebugCheckContainer_DoYouOwnContainer ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(eRequesterType), eRequesterType);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iRequesterID), iRequesterID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(eType), eType);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iID), iID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iRequestID), iRequestID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(bIsForTransServer), bIsForTransServer);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function DoYouOwnContainerReturn, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_DoYouOwnContainerReturn( GlobalType gServerType, ContainerID gServerID, int iRequestID, bool bIsTrans, bool bIOwn)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "DoYouOwnContainerReturn"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "DoYouOwnContainerReturn", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iRequestID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, bIsTrans);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, bIOwn);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function DoYouOwnContainerReturn, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_DoYouOwnContainerReturn(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, int iRequestID, bool bIsTrans, bool bIOwn)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d DoYouOwnContainerReturn ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iRequestID), iRequestID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(bIsTrans), bIsTrans);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(bIOwn), bIOwn);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function FileServingRequestForServerMonitoring, source file: I:\Night\Night\src\libs\ServerLib\HttpXpathRemoteCommands.c
typedef enum enumFileServingCommand enumFileServingCommand;
void RemoteCommand_FileServingRequestForServerMonitoring( GlobalType gServerType, ContainerID gServerID, const char* pFileName, int iControllerReqID, enumFileServingCommand eCommand, S64 iBytesRequested)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "FileServingRequestForServerMonitoring"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "FileServingRequestForServerMonitoring", NULL, NULL, NULL);
	pktSendString(_pPacket_StructParser__INTERNAL, pFileName);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iControllerReqID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, eCommand);
	pktSendBits64(_pPacket_StructParser__INTERNAL, 64, iBytesRequested);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function FileServingRequestForServerMonitoring, source file: I:\Night\Night\src\libs\ServerLib\HttpXpathRemoteCommands.c
void QueueRemoteCommand_FileServingRequestForServerMonitoring(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, const char* pFileName, int iControllerReqID, enumFileServingCommand eCommand, S64 iBytesRequested)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d FileServingRequestForServerMonitoring ", (int) gServerType, gServerID);
	estrAppend2(_SP_pCommandString, " \"");
	if (pFileName) estrAppendEscaped(_SP_pCommandString, pFileName);
	estrAppend2(_SP_pCommandString, "\" ");
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iControllerReqID), iControllerReqID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(eCommand), eCommand);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iBytesRequested), iBytesRequested);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function GatewayIsLocked, source file: I:\Night\Night\src\libs\ServerLib\GatewayUtil.c
void RemoteCommand_GatewayIsLocked( GlobalType gServerType, ContainerID gServerID, bool bLocked)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "GatewayIsLocked"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "GatewayIsLocked", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, bLocked);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function GatewayIsLocked, source file: I:\Night\Night\src\libs\ServerLib\GatewayUtil.c
void QueueRemoteCommand_GatewayIsLocked(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, bool bLocked)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d GatewayIsLocked ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(bLocked), bLocked);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function GenerateLotsOfTestTransactions, source file: I:\Night\Night\src\libs\ServerLib\ServerLibCmdParse.c
void RemoteCommand_GenerateLotsOfTestTransactions( GlobalType gServerType, ContainerID gServerID, const char* pToWhoType, U32 ToWhoID, int iNum)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "GenerateLotsOfTestTransactions"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "GenerateLotsOfTestTransactions", NULL, NULL, NULL);
	pktSendString(_pPacket_StructParser__INTERNAL, pToWhoType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, ToWhoID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iNum);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function GenerateLotsOfTestTransactions, source file: I:\Night\Night\src\libs\ServerLib\ServerLibCmdParse.c
void QueueRemoteCommand_GenerateLotsOfTestTransactions(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, const char* pToWhoType, U32 ToWhoID, int iNum)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d GenerateLotsOfTestTransactions ", (int) gServerType, gServerID);
	estrAppend2(_SP_pCommandString, " \"");
	if (pToWhoType) estrAppendEscaped(_SP_pCommandString, pToWhoType);
	estrAppend2(_SP_pCommandString, "\" ");
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(ToWhoID), ToWhoID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iNum), iNum);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function GetHeadShot_Return, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
typedef struct TextParserBinaryBlock TextParserBinaryBlock;
extern ParseTable parse_TextParserBinaryBlock[];
#define TYPE_parse_TextParserBinaryBlock TextParserBinaryBlock
void RemoteCommand_GetHeadShot_Return( GlobalType gServerType, ContainerID gServerID, const TextParserBinaryBlock* pData, const char* pMessage, U32 iUserData)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "GetHeadShot_Return"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "GetHeadShot_Return", NULL, NULL, NULL);
	if (pData)
	{
		pktSendBits(_pPacket_StructParser__INTERNAL, 1, 1);
		ParserSendStruct(parse_TextParserBinaryBlock, _pPacket_StructParser__INTERNAL, pData);
	}
	else
	{
		pktSendBits(_pPacket_StructParser__INTERNAL, 1, 0);
	}
	pktSendString(_pPacket_StructParser__INTERNAL, pMessage);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iUserData);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function GetHeadShot_Return, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_GetHeadShot_Return(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, const TextParserBinaryBlock* pData, const char* pMessage, U32 iUserData)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d GetHeadShot_Return ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, " ");
	if (pData)
		ParserWriteTextEscaped(_SP_pCommandString, parse_TextParserBinaryBlock, pData, 0, 0, 0);
	else
		estrConcatf(_SP_pCommandString, "<& __NULL__ &>");
	estrAppend2(_SP_pCommandString, " \"");
	if (pMessage) estrAppendEscaped(_SP_pCommandString, pMessage);
	estrAppend2(_SP_pCommandString, "\" ");
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iUserData), iUserData);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function GetJpegForServerMonitoring, source file: I:\Night\Night\src\libs\ServerLib\HttpXpathRemoteCommands.c
typedef struct UrlArgumentList UrlArgumentList;
extern ParseTable parse_UrlArgumentList[];
#define TYPE_parse_UrlArgumentList UrlArgumentList
void RemoteCommand_GetJpegForServerMonitoring( GlobalType gServerType, ContainerID gServerID, int iRequestID, const UrlArgumentList* pArgList, ContainerID iMCPID, const char* pJpegName)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "GetJpegForServerMonitoring"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "GetJpegForServerMonitoring", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iRequestID);
	if (pArgList)
	{
		pktSendBits(_pPacket_StructParser__INTERNAL, 1, 1);
		ParserSendStruct(parse_UrlArgumentList, _pPacket_StructParser__INTERNAL, pArgList);
	}
	else
	{
		pktSendBits(_pPacket_StructParser__INTERNAL, 1, 0);
	}
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iMCPID);
	pktSendString(_pPacket_StructParser__INTERNAL, pJpegName);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function GetJpegForServerMonitoring, source file: I:\Night\Night\src\libs\ServerLib\HttpXpathRemoteCommands.c
void QueueRemoteCommand_GetJpegForServerMonitoring(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, int iRequestID, const UrlArgumentList* pArgList, ContainerID iMCPID, const char* pJpegName)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d GetJpegForServerMonitoring ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iRequestID), iRequestID);
	estrConcatf(_SP_pCommandString, " ");
	if (pArgList)
		ParserWriteTextEscaped(_SP_pCommandString, parse_UrlArgumentList, pArgList, 0, 0, 0);
	else
		estrConcatf(_SP_pCommandString, "<& __NULL__ &>");
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iMCPID), iMCPID);
	estrAppend2(_SP_pCommandString, " \"");
	if (pJpegName) estrAppendEscaped(_SP_pCommandString, pJpegName);
	estrAppend2(_SP_pCommandString, "\" ");
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function GoAheadAndDie, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_GoAheadAndDie( GlobalType gServerType, ContainerID gServerID)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "GoAheadAndDie"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "GoAheadAndDie", NULL, NULL, NULL);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function GoAheadAndDie, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_GoAheadAndDie(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d GoAheadAndDie ", (int) gServerType, gServerID);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function HandleNonExistentContainerNotification, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_HandleNonExistentContainerNotification( GlobalType gServerType, ContainerID gServerID, GlobalType conType, ContainerID conID)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "HandleNonExistentContainerNotification"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "HandleNonExistentContainerNotification", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conID);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated wrapper for function HandleNonExistentContainerNotification, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_MultipleRecipients_HandleNonExistentContainerNotification(ContainerRef ***pppRecipients, GlobalType conType, ContainerID conID)
{
	Packet *_pPacket_StructParser__INTERNAL; 
	static PacketTracker *__pTracker;
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommandMultiple", 0, "HandleNonExistentContainerNotification"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer_MultipleRecipients(pManager, __pTracker, pppRecipients, TRANSPACKETCMD_REMOTECOMMAND, "HandleNonExistentContainerNotification");
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conID);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function HandleNonExistentContainerNotification, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_HandleNonExistentContainerNotification(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, GlobalType conType, ContainerID conID)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d HandleNonExistentContainerNotification ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(conType), conType);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(conID), conID);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function HandleRemoveSubscribedContainer, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_HandleRemoveSubscribedContainer( GlobalType gServerType, ContainerID gServerID, GlobalType conType, ContainerID conID)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "HandleRemoveSubscribedContainer"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "HandleRemoveSubscribedContainer", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conID);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated wrapper for function HandleRemoveSubscribedContainer, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_MultipleRecipients_HandleRemoveSubscribedContainer(ContainerRef ***pppRecipients, GlobalType conType, ContainerID conID)
{
	Packet *_pPacket_StructParser__INTERNAL; 
	static PacketTracker *__pTracker;
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommandMultiple", 0, "HandleRemoveSubscribedContainer"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer_MultipleRecipients(pManager, __pTracker, pppRecipients, TRANSPACKETCMD_REMOTECOMMAND, "HandleRemoveSubscribedContainer");
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conID);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function HandleRemoveSubscribedContainer, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_HandleRemoveSubscribedContainer(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, GlobalType conType, ContainerID conID)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d HandleRemoveSubscribedContainer ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(conType), conType);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(conID), conID);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function HandleSubscribedContainerCopyChange, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_HandleSubscribedContainerCopyChange( GlobalType gServerType, ContainerID gServerID, GlobalType conType, ContainerID conID, const char* diffString)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "HandleSubscribedContainerCopyChange"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "HandleSubscribedContainerCopyChange", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conID);
	pktSendString(_pPacket_StructParser__INTERNAL, diffString);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated wrapper for function HandleSubscribedContainerCopyChange, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_MultipleRecipients_HandleSubscribedContainerCopyChange(ContainerRef ***pppRecipients, GlobalType conType, ContainerID conID, const char* diffString)
{
	Packet *_pPacket_StructParser__INTERNAL; 
	static PacketTracker *__pTracker;
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommandMultiple", 0, "HandleSubscribedContainerCopyChange"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer_MultipleRecipients(pManager, __pTracker, pppRecipients, TRANSPACKETCMD_REMOTECOMMAND, "HandleSubscribedContainerCopyChange");
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conID);
	pktSendString(_pPacket_StructParser__INTERNAL, diffString);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function HandleSubscribedContainerCopyChange, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_HandleSubscribedContainerCopyChange(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, GlobalType conType, ContainerID conID, const char* diffString)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d HandleSubscribedContainerCopyChange ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(conType), conType);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(conID), conID);
	estrAppend2(_SP_pCommandString, " \"");
	if (diffString) estrAppendEscaped(_SP_pCommandString, diffString);
	estrAppend2(_SP_pCommandString, "\" ");
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function HandleSubscribedContainerCopyDestroy, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_HandleSubscribedContainerCopyDestroy( GlobalType gServerType, ContainerID gServerID, GlobalType conType, ContainerID conID)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "HandleSubscribedContainerCopyDestroy"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "HandleSubscribedContainerCopyDestroy", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conID);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated wrapper for function HandleSubscribedContainerCopyDestroy, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_MultipleRecipients_HandleSubscribedContainerCopyDestroy(ContainerRef ***pppRecipients, GlobalType conType, ContainerID conID)
{
	Packet *_pPacket_StructParser__INTERNAL; 
	static PacketTracker *__pTracker;
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommandMultiple", 0, "HandleSubscribedContainerCopyDestroy"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer_MultipleRecipients(pManager, __pTracker, pppRecipients, TRANSPACKETCMD_REMOTECOMMAND, "HandleSubscribedContainerCopyDestroy");
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conID);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function HandleSubscribedContainerCopyDestroy, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_HandleSubscribedContainerCopyDestroy(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, GlobalType conType, ContainerID conID)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d HandleSubscribedContainerCopyDestroy ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(conType), conType);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(conID), conID);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function HandleSubscribedContainerCopyOwnerChange, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_HandleSubscribedContainerCopyOwnerChange( GlobalType gServerType, ContainerID gServerID, GlobalType conType, ContainerID conID, GlobalType ownerType, ContainerID ownerID)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "HandleSubscribedContainerCopyOwnerChange"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "HandleSubscribedContainerCopyOwnerChange", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, ownerType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, ownerID);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated wrapper for function HandleSubscribedContainerCopyOwnerChange, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_MultipleRecipients_HandleSubscribedContainerCopyOwnerChange(ContainerRef ***pppRecipients, GlobalType conType, ContainerID conID, GlobalType ownerType, ContainerID ownerID)
{
	Packet *_pPacket_StructParser__INTERNAL; 
	static PacketTracker *__pTracker;
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommandMultiple", 0, "HandleSubscribedContainerCopyOwnerChange"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer_MultipleRecipients(pManager, __pTracker, pppRecipients, TRANSPACKETCMD_REMOTECOMMAND, "HandleSubscribedContainerCopyOwnerChange");
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, ownerType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, ownerID);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function HandleSubscribedContainerCopyOwnerChange, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_HandleSubscribedContainerCopyOwnerChange(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, GlobalType conType, ContainerID conID, GlobalType ownerType, ContainerID ownerID)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d HandleSubscribedContainerCopyOwnerChange ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(conType), conType);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(conID), conID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(ownerType), ownerType);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(ownerID), ownerID);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function HereIsShardClusterOverview, source file: I:\Night\Night\src\libs\ServerLib\ShardCluster.c
typedef struct Cluster_Overview Cluster_Overview;
extern ParseTable parse_Cluster_Overview[];
#define TYPE_parse_Cluster_Overview Cluster_Overview
void RemoteCommand_HereIsShardClusterOverview( GlobalType gServerType, ContainerID gServerID, const Cluster_Overview* ppOverview)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "HereIsShardClusterOverview"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "HereIsShardClusterOverview", NULL, NULL, NULL);
	if (ppOverview)
	{
		pktSendBits(_pPacket_StructParser__INTERNAL, 1, 1);
		ParserSendStruct(parse_Cluster_Overview, _pPacket_StructParser__INTERNAL, ppOverview);
	}
	else
	{
		pktSendBits(_pPacket_StructParser__INTERNAL, 1, 0);
	}
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function HereIsShardClusterOverview, source file: I:\Night\Night\src\libs\ServerLib\ShardCluster.c
void QueueRemoteCommand_HereIsShardClusterOverview(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, const Cluster_Overview* ppOverview)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d HereIsShardClusterOverview ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, " ");
	if (ppOverview)
		ParserWriteTextEscaped(_SP_pCommandString, parse_Cluster_Overview, ppOverview, 0, 0, 0);
	else
		estrConcatf(_SP_pCommandString, "<& __NULL__ &>");
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function HereIsTextureFromTextureServer, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
typedef struct TextParserBinaryBlock TextParserBinaryBlock;
extern ParseTable parse_TextParserBinaryBlock[];
#define TYPE_parse_TextParserBinaryBlock TextParserBinaryBlock
void RemoteCommand_HereIsTextureFromTextureServer( GlobalType gServerType, ContainerID gServerID, int iRequestID, const TextParserBinaryBlock* pTexture, const char* pErrorString)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "HereIsTextureFromTextureServer"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "HereIsTextureFromTextureServer", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iRequestID);
	if (pTexture)
	{
		pktSendBits(_pPacket_StructParser__INTERNAL, 1, 1);
		ParserSendStruct(parse_TextParserBinaryBlock, _pPacket_StructParser__INTERNAL, pTexture);
	}
	else
	{
		pktSendBits(_pPacket_StructParser__INTERNAL, 1, 0);
	}
	pktSendString(_pPacket_StructParser__INTERNAL, pErrorString);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function HereIsTextureFromTextureServer, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_HereIsTextureFromTextureServer(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, int iRequestID, const TextParserBinaryBlock* pTexture, const char* pErrorString)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d HereIsTextureFromTextureServer ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iRequestID), iRequestID);
	estrConcatf(_SP_pCommandString, " ");
	if (pTexture)
		ParserWriteTextEscaped(_SP_pCommandString, parse_TextParserBinaryBlock, pTexture, 0, 0, 0);
	else
		estrConcatf(_SP_pCommandString, "<& __NULL__ &>");
	estrAppend2(_SP_pCommandString, " \"");
	if (pErrorString) estrAppendEscaped(_SP_pCommandString, pErrorString);
	estrAppend2(_SP_pCommandString, "\" ");
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function LotsOfTestTransactionsTest1, source file: I:\Night\Night\src\libs\ServerLib\ServerLibCmdParse.c
void RemoteCommand_LotsOfTestTransactionsTest1( TransactionReturnVal *pReturnValStruct, GlobalType gServerType, ContainerID gServerID, U32 eWhoSent, U32 iID)
{
	char *_SP_pCommandString = NULL;
	BaseTransaction baseTransaction;
	BaseTransaction **ppBaseTransactions = NULL;
	estrStackCreateSize(&_SP_pCommandString, 4096);
	estrConcatf(&_SP_pCommandString, "remotecommand LotsOfTestTransactionsTest1 ");
	estrConcatf(&_SP_pCommandString, PRINTF_CODE_FOR_INT(eWhoSent), eWhoSent);
	estrConcatf(&_SP_pCommandString, PRINTF_CODE_FOR_INT(iID), iID);
	baseTransaction.pData = _SP_pCommandString;
	baseTransaction.recipient.containerID = gServerID;
	baseTransaction.recipient.containerType = gServerType;
	baseTransaction.pRequestedTransVariableNames = NULL;
	eaPush(&ppBaseTransactions, &baseTransaction);
	if (pReturnValStruct)
	{
		RequestNewTransaction( objLocalManager(), "LotsOfTestTransactionsTest1", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, pReturnValStruct, 0 );
	}
	else
	{
		RequestNewTransaction( objLocalManager(), "LotsOfTestTransactionsTest1", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, NULL, 0 );
	}
	eaDestroy(&ppBaseTransactions);
	estrDestroy(&_SP_pCommandString);
}

//Autogenerated function return function LotsOfTestTransactionsTest1, source file: I:\Night\Night\src\libs\ServerLib\ServerLibCmdParse.c
enumTransactionOutcome RemoteCommandCheck_LotsOfTestTransactionsTest1(TransactionReturnVal *pTransReturnStruct, char** pRetVal)
{
	switch (pTransReturnStruct->eOutcome)
	{
	case TRANSACTION_OUTCOME_FAILURE:
		return TRANSACTION_OUTCOME_FAILURE;
	case TRANSACTION_OUTCOME_SUCCESS:
		estrCopy2(pRetVal, pTransReturnStruct->pBaseReturnVals[0].returnString);
		return TRANSACTION_OUTCOME_SUCCESS;
	}
	return TRANSACTION_OUTCOME_NONE;
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function LotsOfTestTransactionsTest2, source file: I:\Night\Night\src\libs\ServerLib\ServerLibCmdParse.c
void RemoteCommand_LotsOfTestTransactionsTest2( TransactionReturnVal *pReturnValStruct, GlobalType gServerType, ContainerID gServerID, U32 eWhoSent, U32 iID)
{
	char *_SP_pCommandString = NULL;
	BaseTransaction baseTransaction;
	BaseTransaction **ppBaseTransactions = NULL;
	estrStackCreateSize(&_SP_pCommandString, 4096);
	estrConcatf(&_SP_pCommandString, "remotecommand LotsOfTestTransactionsTest2 ");
	estrConcatf(&_SP_pCommandString, PRINTF_CODE_FOR_INT(eWhoSent), eWhoSent);
	estrConcatf(&_SP_pCommandString, PRINTF_CODE_FOR_INT(iID), iID);
	baseTransaction.pData = _SP_pCommandString;
	baseTransaction.recipient.containerID = gServerID;
	baseTransaction.recipient.containerType = gServerType;
	baseTransaction.pRequestedTransVariableNames = NULL;
	eaPush(&ppBaseTransactions, &baseTransaction);
	if (pReturnValStruct)
	{
		RequestNewTransaction( objLocalManager(), "LotsOfTestTransactionsTest2", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, pReturnValStruct, 0 );
	}
	else
	{
		RequestNewTransaction( objLocalManager(), "LotsOfTestTransactionsTest2", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, NULL, 0 );
	}
	eaDestroy(&ppBaseTransactions);
	estrDestroy(&_SP_pCommandString);
}

//Autogenerated function return function LotsOfTestTransactionsTest2, source file: I:\Night\Night\src\libs\ServerLib\ServerLibCmdParse.c
enumTransactionOutcome RemoteCommandCheck_LotsOfTestTransactionsTest2(TransactionReturnVal *pTransReturnStruct, char** pRetVal)
{
	switch (pTransReturnStruct->eOutcome)
	{
	case TRANSACTION_OUTCOME_FAILURE:
		return TRANSACTION_OUTCOME_FAILURE;
	case TRANSACTION_OUTCOME_SUCCESS:
		estrCopy2(pRetVal, pTransReturnStruct->pBaseReturnVals[0].returnString);
		return TRANSACTION_OUTCOME_SUCCESS;
	}
	return TRANSACTION_OUTCOME_NONE;
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function PrintWithReturn, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_PrintWithReturn( TransactionReturnVal *pReturnValStruct, GlobalType gServerType, ContainerID gServerID, const ACMD_SENTENCE pStr)
{
	char *_SP_pCommandString = NULL;
	BaseTransaction baseTransaction;
	BaseTransaction **ppBaseTransactions = NULL;
	estrStackCreateSize(&_SP_pCommandString, 4096);
	estrConcatf(&_SP_pCommandString, "remotecommand PrintWithReturn ");
	estrAppend2(&_SP_pCommandString, " \"");
	if (pStr) estrAppendEscaped(&_SP_pCommandString, pStr);
	estrAppend2(&_SP_pCommandString, "\" ");
	baseTransaction.pData = _SP_pCommandString;
	baseTransaction.recipient.containerID = gServerID;
	baseTransaction.recipient.containerType = gServerType;
	baseTransaction.pRequestedTransVariableNames = NULL;
	eaPush(&ppBaseTransactions, &baseTransaction);
	if (pReturnValStruct)
	{
		RequestNewTransaction( objLocalManager(), "PrintWithReturn", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, pReturnValStruct, 0 );
	}
	else
	{
		RequestNewTransaction( objLocalManager(), "PrintWithReturn", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, NULL, 0 );
	}
	eaDestroy(&ppBaseTransactions);
	estrDestroy(&_SP_pCommandString);
}

//Autogenerated function return function PrintWithReturn, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
enumTransactionOutcome RemoteCommandCheck_PrintWithReturn(TransactionReturnVal *pTransReturnStruct, int* pRetVal)
{
	switch (pTransReturnStruct->eOutcome)
	{
	case TRANSACTION_OUTCOME_FAILURE:
		return TRANSACTION_OUTCOME_FAILURE;
	case TRANSACTION_OUTCOME_SUCCESS:
		StringToInt_Multisize_AssumeGoodInput(pTransReturnStruct->pBaseReturnVals[0].returnString, pRetVal);
		return TRANSACTION_OUTCOME_SUCCESS;
	}
	return TRANSACTION_OUTCOME_NONE;
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function RemoteObjBroadcastMessage, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_RemoteObjBroadcastMessage( GlobalType gServerType, ContainerID gServerID, const char* pTitle, const char* pString)
{
	char *_SP_pCommandString = NULL;
	BaseTransaction baseTransaction;
	BaseTransaction **ppBaseTransactions = NULL;
	estrStackCreateSize(&_SP_pCommandString, 4096);
	estrConcatf(&_SP_pCommandString, "remotecommand RemoteObjBroadcastMessage ");
	estrAppend2(&_SP_pCommandString, " \"");
	if (pTitle) estrAppendEscaped(&_SP_pCommandString, pTitle);
	estrAppend2(&_SP_pCommandString, "\" ");
	estrAppend2(&_SP_pCommandString, " \"");
	if (pString) estrAppendEscaped(&_SP_pCommandString, pString);
	estrAppend2(&_SP_pCommandString, "\" ");
	baseTransaction.pData = _SP_pCommandString;
	baseTransaction.recipient.containerID = gServerID;
	baseTransaction.recipient.containerType = gServerType;
	baseTransaction.pRequestedTransVariableNames = NULL;
	eaPush(&ppBaseTransactions, &baseTransaction);
	RequestNewTransaction( objLocalManager(), "RemoteObjBroadcastMessage", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, NULL, 0 );
	eaDestroy(&ppBaseTransactions);
	estrDestroy(&_SP_pCommandString);
}

//Autogenerated queued wrapper for function RemoteObjBroadcastMessage, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_RemoteObjBroadcastMessage(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, const char* pTitle, const char* pString)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d RemoteObjBroadcastMessage ", (int) gServerType, gServerID);
	estrAppend2(_SP_pCommandString, " \"");
	if (pTitle) estrAppendEscaped(_SP_pCommandString, pTitle);
	estrAppend2(_SP_pCommandString, "\" ");
	estrAppend2(_SP_pCommandString, " \"");
	if (pString) estrAppendEscaped(_SP_pCommandString, pString);
	estrAppend2(_SP_pCommandString, "\" ");
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function RemoteObjBroadcastMessageEx, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
typedef struct MessageStruct MessageStruct;
extern ParseTable parse_MessageStruct[];
#define TYPE_parse_MessageStruct MessageStruct
void RemoteCommand_RemoteObjBroadcastMessageEx( GlobalType gServerType, ContainerID gServerID, const char* pTitle, const MessageStruct* pFmt)
{
	char *_SP_pCommandString = NULL;
	BaseTransaction baseTransaction;
	BaseTransaction **ppBaseTransactions = NULL;
	estrStackCreateSize(&_SP_pCommandString, 4096);
	estrConcatf(&_SP_pCommandString, "remotecommand RemoteObjBroadcastMessageEx ");
	estrAppend2(&_SP_pCommandString, " \"");
	if (pTitle) estrAppendEscaped(&_SP_pCommandString, pTitle);
	estrAppend2(&_SP_pCommandString, "\" ");
	estrConcatf(&_SP_pCommandString, " ");
	if (pFmt)
		ParserWriteTextEscaped(&_SP_pCommandString, parse_MessageStruct, pFmt, 0, 0, 0);
	else
		estrConcatf(&_SP_pCommandString, "<& __NULL__ &>");
	baseTransaction.pData = _SP_pCommandString;
	baseTransaction.recipient.containerID = gServerID;
	baseTransaction.recipient.containerType = gServerType;
	baseTransaction.pRequestedTransVariableNames = NULL;
	eaPush(&ppBaseTransactions, &baseTransaction);
	RequestNewTransaction( objLocalManager(), "RemoteObjBroadcastMessageEx", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, NULL, 0 );
	eaDestroy(&ppBaseTransactions);
	estrDestroy(&_SP_pCommandString);
}

//Autogenerated queued wrapper for function RemoteObjBroadcastMessageEx, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_RemoteObjBroadcastMessageEx(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, const char* pTitle, const MessageStruct* pFmt)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d RemoteObjBroadcastMessageEx ", (int) gServerType, gServerID);
	estrAppend2(_SP_pCommandString, " \"");
	if (pTitle) estrAppendEscaped(_SP_pCommandString, pTitle);
	estrAppend2(_SP_pCommandString, "\" ");
	estrConcatf(_SP_pCommandString, " ");
	if (pFmt)
		ParserWriteTextEscaped(_SP_pCommandString, parse_MessageStruct, pFmt, 0, 0, 0);
	else
		estrConcatf(_SP_pCommandString, "<& __NULL__ &>");
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function RemoteObjPrint, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_RemoteObjPrint( GlobalType gServerType, ContainerID gServerID, const char* pString)
{
	char *_SP_pCommandString = NULL;
	BaseTransaction baseTransaction;
	BaseTransaction **ppBaseTransactions = NULL;
	estrStackCreateSize(&_SP_pCommandString, 4096);
	estrConcatf(&_SP_pCommandString, "remotecommand RemoteObjPrint ");
	estrAppend2(&_SP_pCommandString, " \"");
	if (pString) estrAppendEscaped(&_SP_pCommandString, pString);
	estrAppend2(&_SP_pCommandString, "\" ");
	baseTransaction.pData = _SP_pCommandString;
	baseTransaction.recipient.containerID = gServerID;
	baseTransaction.recipient.containerType = gServerType;
	baseTransaction.pRequestedTransVariableNames = NULL;
	eaPush(&ppBaseTransactions, &baseTransaction);
	RequestNewTransaction( objLocalManager(), "RemoteObjPrint", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, NULL, 0 );
	eaDestroy(&ppBaseTransactions);
	estrDestroy(&_SP_pCommandString);
}

//Autogenerated queued wrapper for function RemoteObjPrint, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_RemoteObjPrint(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, const char* pString)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d RemoteObjPrint ", (int) gServerType, gServerID);
	estrAppend2(_SP_pCommandString, " \"");
	if (pString) estrAppendEscaped(_SP_pCommandString, pString);
	estrAppend2(_SP_pCommandString, "\" ");
	PERFINFO_AUTO_STOP();
}
#endif
#if defined(SERVERLIB)

//Autogenerated wrapper for function RequestOnlineCharacterIDFromAccountID, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_RequestOnlineCharacterIDFromAccountID( GlobalType gServerType, ContainerID gServerID, GlobalType eSourceType, ContainerID uSourceID, U32 uRequestID, U32 uAccountID)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "RequestOnlineCharacterIDFromAccountID"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "RequestOnlineCharacterIDFromAccountID", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, eSourceType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, uSourceID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, uRequestID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, uAccountID);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function RequestOnlineCharacterIDFromAccountID, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_RequestOnlineCharacterIDFromAccountID(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, GlobalType eSourceType, ContainerID uSourceID, U32 uRequestID, U32 uAccountID)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d RequestOnlineCharacterIDFromAccountID ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(eSourceType), eSourceType);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(uSourceID), uSourceID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(uRequestID), uRequestID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(uAccountID), uAccountID);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function RemoteSubscribeToContainer, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_RemoteSubscribeToContainer( GlobalType gServerType, ContainerID gServerID, GlobalType ownerType, ContainerID ownerID, GlobalType conType, ContainerID conID, const char* reason)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "RemoteSubscribeToContainer"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "RemoteSubscribeToContainer", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, ownerType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, ownerID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conID);
	pktSendString(_pPacket_StructParser__INTERNAL, reason);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function RemoteSubscribeToContainer, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_RemoteSubscribeToContainer(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, GlobalType ownerType, ContainerID ownerID, GlobalType conType, ContainerID conID, const char* reason)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d RemoteSubscribeToContainer ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(ownerType), ownerType);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(ownerID), ownerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(conType), conType);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(conID), conID);
	estrAppend2(_SP_pCommandString, " \"");
	if (reason) estrAppendEscaped(_SP_pCommandString, reason);
	estrAppend2(_SP_pCommandString, "\" ");
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function RemoteSubscribeToOnlineContainers, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_RemoteSubscribeToOnlineContainers( GlobalType gServerType, ContainerID gServerID, GlobalType ownerType, ContainerID ownerID, GlobalType conType)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "RemoteSubscribeToOnlineContainers"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "RemoteSubscribeToOnlineContainers", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, ownerType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, ownerID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conType);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function RemoteSubscribeToOnlineContainers, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_RemoteSubscribeToOnlineContainers(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, GlobalType ownerType, ContainerID ownerID, GlobalType conType)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d RemoteSubscribeToOnlineContainers ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(ownerType), ownerType);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(ownerID), ownerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(conType), conType);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function RemoteUnsubscribeFromContainer, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_RemoteUnsubscribeFromContainer( GlobalType gServerType, ContainerID gServerID, GlobalType ownerType, ContainerID ownerID, GlobalType conType, ContainerID conID, const char* reason)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "RemoteUnsubscribeFromContainer"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "RemoteUnsubscribeFromContainer", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, ownerType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, ownerID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conID);
	pktSendString(_pPacket_StructParser__INTERNAL, reason);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function RemoteUnsubscribeFromContainer, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_RemoteUnsubscribeFromContainer(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, GlobalType ownerType, ContainerID ownerID, GlobalType conType, ContainerID conID, const char* reason)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d RemoteUnsubscribeFromContainer ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(ownerType), ownerType);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(ownerID), ownerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(conType), conType);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(conID), conID);
	estrAppend2(_SP_pCommandString, " \"");
	if (reason) estrAppendEscaped(_SP_pCommandString, reason);
	estrAppend2(_SP_pCommandString, "\" ");
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function RemoteUnsubscribeFromOnlineContainers, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_RemoteUnsubscribeFromOnlineContainers( GlobalType gServerType, ContainerID gServerID, GlobalType ownerType, ContainerID ownerID, GlobalType conType)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "RemoteUnsubscribeFromOnlineContainers"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "RemoteUnsubscribeFromOnlineContainers", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, ownerType);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, ownerID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, conType);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function RemoteUnsubscribeFromOnlineContainers, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_RemoteUnsubscribeFromOnlineContainers(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, GlobalType ownerType, ContainerID ownerID, GlobalType conType)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d RemoteUnsubscribeFromOnlineContainers ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(ownerType), ownerType);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(ownerID), ownerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(conType), conType);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function ResourceDB_ReceiveMessage, source file: I:\Night\Night\src\libs\ServerLib\ResourceDBSupport.c
typedef struct Message Message;
extern ParseTable parse_Message[];
#define TYPE_parse_Message Message
void RemoteCommand_ResourceDB_ReceiveMessage( GlobalType gServerType, ContainerID gServerID, const char* pName, const Message* ppMessage, const char* pComment)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "ResourceDB_ReceiveMessage"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "ResourceDB_ReceiveMessage", NULL, NULL, NULL);
	pktSendString(_pPacket_StructParser__INTERNAL, pName);
	if (ppMessage)
	{
		pktSendBits(_pPacket_StructParser__INTERNAL, 1, 1);
		ParserSendStruct(parse_Message, _pPacket_StructParser__INTERNAL, ppMessage);
	}
	else
	{
		pktSendBits(_pPacket_StructParser__INTERNAL, 1, 0);
	}
	pktSendString(_pPacket_StructParser__INTERNAL, pComment);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function ResourceDB_ReceiveMessage, source file: I:\Night\Night\src\libs\ServerLib\ResourceDBSupport.c
void QueueRemoteCommand_ResourceDB_ReceiveMessage(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, const char* pName, const Message* ppMessage, const char* pComment)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d ResourceDB_ReceiveMessage ", (int) gServerType, gServerID);
	estrAppend2(_SP_pCommandString, " \"");
	if (pName) estrAppendEscaped(_SP_pCommandString, pName);
	estrAppend2(_SP_pCommandString, "\" ");
	estrConcatf(_SP_pCommandString, " ");
	if (ppMessage)
		ParserWriteTextEscaped(_SP_pCommandString, parse_Message, ppMessage, 0, 0, 0);
	else
		estrConcatf(_SP_pCommandString, "<& __NULL__ &>");
	estrAppend2(_SP_pCommandString, " \"");
	if (pComment) estrAppendEscaped(_SP_pCommandString, pComment);
	estrAppend2(_SP_pCommandString, "\" ");
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function ReturnOnlineCharacterIDForAccountID, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_ReturnOnlineCharacterIDForAccountID( GlobalType gServerType, ContainerID gServerID, U32 requestID, U32 resultID)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "ReturnOnlineCharacterIDForAccountID"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "ReturnOnlineCharacterIDForAccountID", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, requestID);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, resultID);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function ReturnOnlineCharacterIDForAccountID, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_ReturnOnlineCharacterIDForAccountID(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, U32 requestID, U32 resultID)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d ReturnOnlineCharacterIDForAccountID ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(requestID), requestID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(resultID), resultID);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function RunLocalCommandAndReturnStringToControllerScripting, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_RunLocalCommandAndReturnStringToControllerScripting( GlobalType gServerType, ContainerID gServerID, const char* pLocalCommand)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "RunLocalCommandAndReturnStringToControllerScripting"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "RunLocalCommandAndReturnStringToControllerScripting", NULL, NULL, NULL);
	pktSendString(_pPacket_StructParser__INTERNAL, pLocalCommand);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function RunLocalCommandAndReturnStringToControllerScripting, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_RunLocalCommandAndReturnStringToControllerScripting(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, const char* pLocalCommand)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d RunLocalCommandAndReturnStringToControllerScripting ", (int) gServerType, gServerID);
	estrAppend2(_SP_pCommandString, " \"");
	if (pLocalCommand) estrAppendEscaped(_SP_pCommandString, pLocalCommand);
	estrAppend2(_SP_pCommandString, "\" ");
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function SendAutoSettingFromController, source file: I:\Night\Night\src\libs\ServerLib\AutoSettings.c
void RemoteCommand_SendAutoSettingFromController( GlobalType gServerType, ContainerID gServerID, const char* pCommandString)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "SendAutoSettingFromController"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "SendAutoSettingFromController", NULL, NULL, NULL);
	pktSendString(_pPacket_StructParser__INTERNAL, pCommandString);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function SendAutoSettingFromController, source file: I:\Night\Night\src\libs\ServerLib\AutoSettings.c
void QueueRemoteCommand_SendAutoSettingFromController(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, const char* pCommandString)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d SendAutoSettingFromController ", (int) gServerType, gServerID);
	estrAppend2(_SP_pCommandString, " \"");
	if (pCommandString) estrAppendEscaped(_SP_pCommandString, pCommandString);
	estrAppend2(_SP_pCommandString, "\" ");
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function SendDebugTransferMessage, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_SendDebugTransferMessage( GlobalType gServerType, ContainerID gServerID, U32 iCookie, const char* pMessage)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "SendDebugTransferMessage"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "SendDebugTransferMessage", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iCookie);
	pktSendString(_pPacket_StructParser__INTERNAL, pMessage);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function SendDebugTransferMessage, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_SendDebugTransferMessage(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, U32 iCookie, const char* pMessage)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d SendDebugTransferMessage ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iCookie), iCookie);
	estrAppend2(_SP_pCommandString, " \"");
	if (pMessage) estrAppendEscaped(_SP_pCommandString, pMessage);
	estrAppend2(_SP_pCommandString, "\" ");
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function ServerLib_GetXpathForHttp, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
typedef struct UrlArgumentList UrlArgumentList;
extern ParseTable parse_UrlArgumentList[];
#define TYPE_parse_UrlArgumentList UrlArgumentList
typedef enum GetHttpFlags GetHttpFlags;
void RemoteCommand_ServerLib_GetXpathForHttp( GlobalType gServerType, ContainerID gServerID, U32 iReqID1, U32 iReqID2, const UrlArgumentList* pURL, int iAccessLevel, GetHttpFlags eFlags)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "ServerLib_GetXpathForHttp"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "ServerLib_GetXpathForHttp", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iReqID1);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iReqID2);
	if (pURL)
	{
		pktSendBits(_pPacket_StructParser__INTERNAL, 1, 1);
		ParserSendStruct(parse_UrlArgumentList, _pPacket_StructParser__INTERNAL, pURL);
	}
	else
	{
		pktSendBits(_pPacket_StructParser__INTERNAL, 1, 0);
	}
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iAccessLevel);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, eFlags);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function ServerLib_GetXpathForHttp, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_ServerLib_GetXpathForHttp(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, U32 iReqID1, U32 iReqID2, const UrlArgumentList* pURL, int iAccessLevel, GetHttpFlags eFlags)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d ServerLib_GetXpathForHttp ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iReqID1), iReqID1);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iReqID2), iReqID2);
	estrConcatf(_SP_pCommandString, " ");
	if (pURL)
		ParserWriteTextEscaped(_SP_pCommandString, parse_UrlArgumentList, pURL, 0, 0, 0);
	else
		estrConcatf(_SP_pCommandString, "<& __NULL__ &>");
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iAccessLevel), iAccessLevel);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(eFlags), eFlags);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function ShardIsLocked, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_ShardIsLocked( GlobalType gServerType, ContainerID gServerID, bool bLocked)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "ShardIsLocked"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "ShardIsLocked", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, bLocked);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function ShardIsLocked, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_ShardIsLocked(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, bool bLocked)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d ShardIsLocked ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(bLocked), bLocked);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function SlowCmdNeverReturns, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_SlowCmdNeverReturns( TransactionReturnVal *pReturnValStruct, GlobalType gServerType, ContainerID gServerID, int x, int y)
{
	char *_SP_pCommandString = NULL;
	BaseTransaction baseTransaction;
	BaseTransaction **ppBaseTransactions = NULL;
	estrStackCreateSize(&_SP_pCommandString, 4096);
	estrConcatf(&_SP_pCommandString, "slowremotecommand SlowCmdNeverReturns ");
	estrConcatf(&_SP_pCommandString, PRINTF_CODE_FOR_INT(x), x);
	estrConcatf(&_SP_pCommandString, PRINTF_CODE_FOR_INT(y), y);
	baseTransaction.pData = _SP_pCommandString;
	baseTransaction.recipient.containerID = gServerID;
	baseTransaction.recipient.containerType = gServerType;
	baseTransaction.pRequestedTransVariableNames = NULL;
	eaPush(&ppBaseTransactions, &baseTransaction);
	if (pReturnValStruct)
	{
		RequestNewTransaction( objLocalManager(), "SlowCmdNeverReturns", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, pReturnValStruct, 0 );
	}
	else
	{
		RequestNewTransaction( objLocalManager(), "SlowCmdNeverReturns", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, NULL, 0 );
	}
	eaDestroy(&ppBaseTransactions);
	estrDestroy(&_SP_pCommandString);
}

//Autogenerated function return function SlowCmdNeverReturns, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
enumTransactionOutcome RemoteCommandCheck_SlowCmdNeverReturns(TransactionReturnVal *pTransReturnStruct, int* pRetVal)
{
	switch (pTransReturnStruct->eOutcome)
	{
	case TRANSACTION_OUTCOME_FAILURE:
		return TRANSACTION_OUTCOME_FAILURE;
	case TRANSACTION_OUTCOME_SUCCESS:
		StringToInt_Multisize_AssumeGoodInput(pTransReturnStruct->pBaseReturnVals[0].returnString, pRetVal);
		return TRANSACTION_OUTCOME_SUCCESS;
	}
	return TRANSACTION_OUTCOME_NONE;
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function StopTestTransactions, source file: I:\Night\Night\src\libs\ServerLib\ServerLibCmdParse.c
void RemoteCommand_StopTestTransactions( GlobalType gServerType, ContainerID gServerID)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "StopTestTransactions"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "StopTestTransactions", NULL, NULL, NULL);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function StopTestTransactions, source file: I:\Night\Night\src\libs\ServerLib\ServerLibCmdParse.c
void QueueRemoteCommand_StopTestTransactions(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d StopTestTransactions ", (int) gServerType, gServerID);
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function TestIntershardPrintfCommand, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_Intershard_TestIntershardPrintfCommand(const char *pShardName, GlobalType gServerType, ContainerID gServerID, const char* pStringToPrint)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "TestIntershardPrintfCommand"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServerToOtherShard(pManager, __pTracker, pShardName, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "TestIntershardPrintfCommand", NULL, NULL, NULL);
	pktSendString(_pPacket_StructParser__INTERNAL, pStringToPrint);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated wrapper for function TestIntershardPrintfCommand, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void RemoteCommand_TestIntershardPrintfCommand( GlobalType gServerType, ContainerID gServerID, const char* pStringToPrint)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "TestIntershardPrintfCommand"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "TestIntershardPrintfCommand", NULL, NULL, NULL);
	pktSendString(_pPacket_StructParser__INTERNAL, pStringToPrint);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function TestIntershardPrintfCommand, source file: I:\Night\Night\src\libs\ServerLib\ServerLib.c
void QueueRemoteCommand_TestIntershardPrintfCommand(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, const char* pStringToPrint)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d TestIntershardPrintfCommand ", (int) gServerType, gServerID);
	estrAppend2(_SP_pCommandString, " \"");
	if (pStringToPrint) estrAppendEscaped(_SP_pCommandString, pStringToPrint);
	estrAppend2(_SP_pCommandString, "\" ");
	PERFINFO_AUTO_STOP();
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function TestJobStep, source file: I:\Night\Night\src\libs\ServerLib\JobManagerSupport.c
void RemoteCommand_TestJobStep( TransactionReturnVal *pReturnValStruct, GlobalType gServerType, ContainerID gServerID, int x, const char* pJobName, int y)
{
	char *_SP_pCommandString = NULL;
	BaseTransaction baseTransaction;
	BaseTransaction **ppBaseTransactions = NULL;
	estrStackCreateSize(&_SP_pCommandString, 4096);
	estrConcatf(&_SP_pCommandString, "slowremotecommand TestJobStep ");
	estrConcatf(&_SP_pCommandString, PRINTF_CODE_FOR_INT(x), x);
	estrAppend2(&_SP_pCommandString, " \"");
	if (pJobName) estrAppendEscaped(&_SP_pCommandString, pJobName);
	estrAppend2(&_SP_pCommandString, "\" ");
	estrConcatf(&_SP_pCommandString, PRINTF_CODE_FOR_INT(y), y);
	baseTransaction.pData = _SP_pCommandString;
	baseTransaction.recipient.containerID = gServerID;
	baseTransaction.recipient.containerType = gServerType;
	baseTransaction.pRequestedTransVariableNames = NULL;
	eaPush(&ppBaseTransactions, &baseTransaction);
	if (pReturnValStruct)
	{
		RequestNewTransaction( objLocalManager(), "TestJobStep", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, pReturnValStruct, 0 );
	}
	else
	{
		RequestNewTransaction( objLocalManager(), "TestJobStep", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, NULL, 0 );
	}
	eaDestroy(&ppBaseTransactions);
	estrDestroy(&_SP_pCommandString);
}

//Autogenerated function return function TestJobStep, source file: I:\Night\Night\src\libs\ServerLib\JobManagerSupport.c
enumTransactionOutcome RemoteCommandCheck_TestJobStep(TransactionReturnVal *pTransReturnStruct, int* pRetVal)
{
	switch (pTransReturnStruct->eOutcome)
	{
	case TRANSACTION_OUTCOME_FAILURE:
		return TRANSACTION_OUTCOME_FAILURE;
	case TRANSACTION_OUTCOME_SUCCESS:
		StringToInt_Multisize_AssumeGoodInput(pTransReturnStruct->pBaseReturnVals[0].returnString, pRetVal);
		return TRANSACTION_OUTCOME_SUCCESS;
	}
	return TRANSACTION_OUTCOME_NONE;
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function UpdateJobLogging, source file: I:\Night\Night\src\libs\ServerLib\JobManagerSupport.c
void RemoteCommand_UpdateJobLogging( GlobalType gServerType, ContainerID gServerID, U32 iUserData, const char* pName, const char* pString)
{
	Packet *_pPacket_StructParser__INTERNAL;
	static PacketTracker *__pTracker;
	
	LocalTransactionManager *pManager = objLocalManager();
	if (!pManager) return;
	ONCE(__pTracker = PacketTrackerFind("RemoteCommand", 0, "UpdateJobLogging"));
	_pPacket_StructParser__INTERNAL = GetPacketToSendThroughTransactionServer(pManager, __pTracker, gServerType, gServerID, TRANSPACKETCMD_REMOTECOMMAND, "UpdateJobLogging", NULL, NULL, NULL);
	pktSendBits(_pPacket_StructParser__INTERNAL, 32, iUserData);
	pktSendString(_pPacket_StructParser__INTERNAL, pName);
	pktSendString(_pPacket_StructParser__INTERNAL, pString);
	SendPacketThroughTransactionServer(pManager, &_pPacket_StructParser__INTERNAL);
}

//Autogenerated queued wrapper for function UpdateJobLogging, source file: I:\Night\Night\src\libs\ServerLib\JobManagerSupport.c
void QueueRemoteCommand_UpdateJobLogging(char **_SP_pCommandString, GlobalType gServerType, ContainerID gServerID, U32 iUserData, const char* pName, const char* pString)
{	if (!_SP_pCommandString) return;
	PERFINFO_AUTO_START_FUNC();
	if (*_SP_pCommandString) estrConcatStatic(_SP_pCommandString, "\n");
	estrConcatf(_SP_pCommandString, "remotecommand %d %d UpdateJobLogging ", (int) gServerType, gServerID);
	estrConcatf(_SP_pCommandString, PRINTF_CODE_FOR_INT(iUserData), iUserData);
	estrAppend2(_SP_pCommandString, " \"");
	if (pName) estrAppendEscaped(_SP_pCommandString, pName);
	estrAppend2(_SP_pCommandString, "\" ");
	estrAppend2(_SP_pCommandString, " \"");
	if (pString) estrAppendEscaped(_SP_pCommandString, pString);
	estrAppend2(_SP_pCommandString, "\" ");
	PERFINFO_AUTO_STOP();
}
#endif
#if defined(SERVERLIB)

//Autogenerated wrapper for function XMLRPC_RemoteCAEC, source file: I:\Night\Night\src\libs\ServerLib\RemoteXMLRPC.c
typedef struct XMLMethodCall XMLMethodCall;
extern ParseTable parse_XMLMethodCall[];
#define TYPE_parse_XMLMethodCall XMLMethodCall
void RemoteCommand_XMLRPC_RemoteCAEC( TransactionReturnVal *pReturnValStruct, GlobalType gServerType, ContainerID gServerID, const XMLMethodCall* method)
{
	char *_SP_pCommandString = NULL;
	BaseTransaction baseTransaction;
	BaseTransaction **ppBaseTransactions = NULL;
	estrStackCreateSize(&_SP_pCommandString, 4096);
	estrConcatf(&_SP_pCommandString, "remotecommand XMLRPC_RemoteCAEC ");
	estrConcatf(&_SP_pCommandString, " ");
	if (method)
		ParserWriteTextEscaped(&_SP_pCommandString, parse_XMLMethodCall, method, 0, 0, 0);
	else
		estrConcatf(&_SP_pCommandString, "<& __NULL__ &>");
	baseTransaction.pData = _SP_pCommandString;
	baseTransaction.recipient.containerID = gServerID;
	baseTransaction.recipient.containerType = gServerType;
	baseTransaction.pRequestedTransVariableNames = NULL;
	eaPush(&ppBaseTransactions, &baseTransaction);
	if (pReturnValStruct)
	{
		RequestNewTransaction( objLocalManager(), "XMLRPC_RemoteCAEC", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, pReturnValStruct, 0 );
	}
	else
	{
		RequestNewTransaction( objLocalManager(), "XMLRPC_RemoteCAEC", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, NULL, 0 );
	}
	eaDestroy(&ppBaseTransactions);
	estrDestroy(&_SP_pCommandString);
}

//Autogenerated function return function XMLRPC_RemoteCAEC, source file: I:\Night\Night\src\libs\ServerLib\RemoteXMLRPC.c
enumTransactionOutcome RemoteCommandCheck_XMLRPC_RemoteCAEC(TransactionReturnVal *pTransReturnStruct, char** pRetVal)
{
	switch (pTransReturnStruct->eOutcome)
	{
	case TRANSACTION_OUTCOME_FAILURE:
		return TRANSACTION_OUTCOME_FAILURE;
	case TRANSACTION_OUTCOME_SUCCESS:
		estrCopy2(pRetVal, pTransReturnStruct->pBaseReturnVals[0].returnString);
		return TRANSACTION_OUTCOME_SUCCESS;
	}
	return TRANSACTION_OUTCOME_NONE;
}
#endif
#if !defined(PROJ_SPECIFIC_COMMANDS_ONLY)

//Autogenerated wrapper for function slowTest, source file: I:\Night\Night\src\libs\ServerLib\serverlib_structparsertests.c
void RemoteCommand_slowTest( TransactionReturnVal *pReturnValStruct, GlobalType gServerType, ContainerID gServerID, int x)
{
	char *_SP_pCommandString = NULL;
	BaseTransaction baseTransaction;
	BaseTransaction **ppBaseTransactions = NULL;
	estrStackCreateSize(&_SP_pCommandString, 4096);
	estrConcatf(&_SP_pCommandString, "slowremotecommand slowTest ");
	estrConcatf(&_SP_pCommandString, PRINTF_CODE_FOR_INT(x), x);
	baseTransaction.pData = _SP_pCommandString;
	baseTransaction.recipient.containerID = gServerID;
	baseTransaction.recipient.containerType = gServerType;
	baseTransaction.pRequestedTransVariableNames = NULL;
	eaPush(&ppBaseTransactions, &baseTransaction);
	if (pReturnValStruct)
	{
		RequestNewTransaction( objLocalManager(), "slowTest", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, pReturnValStruct, 0 );
	}
	else
	{
		RequestNewTransaction( objLocalManager(), "slowTest", ppBaseTransactions, TRANS_TYPE_SEQUENTIAL_ATOMIC, NULL, 0 );
	}
	eaDestroy(&ppBaseTransactions);
	estrDestroy(&_SP_pCommandString);
}

//Autogenerated function return function slowTest, source file: I:\Night\Night\src\libs\ServerLib\serverlib_structparsertests.c
enumTransactionOutcome RemoteCommandCheck_slowTest(TransactionReturnVal *pTransReturnStruct, char** pRetVal)
{
	switch (pTransReturnStruct->eOutcome)
	{
	case TRANSACTION_OUTCOME_FAILURE:
		return TRANSACTION_OUTCOME_FAILURE;
	case TRANSACTION_OUTCOME_SUCCESS:
		estrCopy2(pRetVal, pTransReturnStruct->pBaseReturnVals[0].returnString);
		return TRANSACTION_OUTCOME_SUCCESS;
	}
	return TRANSACTION_OUTCOME_NONE;
}
#endif
