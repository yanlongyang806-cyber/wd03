#include "textparser.h"

//auto-generated staticdefine for enum GlobalPlayerFlags
//autogeneratednocheckin
StaticDefineInt GlobalPlayerFlagsEnum[] =
{
	DEFINE_INT
	{ "PLAYERFLAG_NEW_CHARACTER", PLAYERFLAG_NEW_CHARACTER},
	DEFINE_END
};
void autoEnum_fixup_GlobalPlayerFlags(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(GlobalPlayerFlagsEnum, "GlobalPlayerFlags");
}

//auto-generated staticdefine for enum PlayerType
//autogeneratednocheckin
StaticDefineInt PlayerTypeEnum[] =
{
	DEFINE_INT
	{ "None", kPlayerType_None},
	{ "Standard", kPlayerType_Standard},
	{ "Premium", kPlayerType_Premium},
	{ "SuperPremium", kPlayerType_SuperPremium},
	DEFINE_END
};
void autoEnum_fixup_PlayerType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PlayerTypeEnum, "PlayerType");
}

//auto-generated staticdefine for enum GuildState
//autogeneratednocheckin
StaticDefineInt GuildStateEnum[] =
{
	DEFINE_INT
	{ "Member", GuildState_Member},
	{ "Invitee", GuildState_Invitee},
	DEFINE_END
};
void autoEnum_fixup_GuildState(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(GuildStateEnum, "GuildState");
}

//auto-generated staticdefine for enum PlayerMapMoveType
//autogeneratednocheckin
StaticDefineInt PlayerMapMoveTypeEnum[] =
{
	DEFINE_INT
	{ "PowerPurchase", kPlayerMapMove_PowerPurchase},
	{ "Permission", kPlayerMapMove_Permission},
	{ "Warp", kPlayerMapMove_Warp},
	DEFINE_END
};
void autoEnum_fixup_PlayerMapMoveType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PlayerMapMoveTypeEnum, "PlayerMapMoveType");
}

//auto-generated staticdefine for enum PlayerWhitelistFlags
//autogeneratednocheckin
StaticDefineInt PlayerWhitelistFlagsEnum[] =
{
	DEFINE_INT
	{ "None", kPlayerWhitelistFlags_None},
	{ "Invites", kPlayerWhitelistFlags_Invites},
	{ "Trades", kPlayerWhitelistFlags_Trades},
	{ "PvPInvites", kPlayerWhitelistFlags_PvPInvites},
	DEFINE_END
};
void autoEnum_fixup_PlayerWhitelistFlags(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PlayerWhitelistFlagsEnum, "PlayerWhitelistFlags");
}

//auto-generated staticdefine for enum MapIconInfoType
//autogeneratednocheckin
StaticDefineInt MapIconInfoTypeEnum[] =
{
	DEFINE_INT
	{ "None", MapIconInfoType_None},
	{ "Self", MapIconInfoType_Self},
	{ "Pet", MapIconInfoType_Pet},
	{ "Team", MapIconInfoType_Team},
	{ "Guild", MapIconInfoType_Guild},
	{ "Player", MapIconInfoType_Player},
	{ "Foe", MapIconInfoType_Foe},
	{ "NPC", MapIconInfoType_NPC},
	{ "Contact", MapIconInfoType_Contact},
	{ "PowerTrainer", MapIconInfoType_PowerTrainer},
	{ "CraftingTrainer", MapIconInfoType_CraftingTrainer},
	{ "GuildContact", MapIconInfoType_GuildContact},
	{ "Vendor", MapIconInfoType_Vendor},
	{ "Bank", MapIconInfoType_Bank},
	{ "SharedBank", MapIconInfoType_SharedBank},
	{ "GuildBank", MapIconInfoType_GuildBank},
	{ "Mail", MapIconInfoType_Mail},
	{ "Tailor", MapIconInfoType_Tailor},
	{ "PvP", MapIconInfoType_PvP},
	{ "Nemesis", MapIconInfoType_Nemesis},
	{ "Omega", MapIconInfoType_Omega},
	{ "MissionContact", MapIconInfoType_MissionContact},
	{ "MissionContactRepeatable", MapIconInfoType_MissionContactRepeatable},
	{ "MissionContactUnavailable", MapIconInfoType_MissionContactUnavailable},
	{ "MissionContactLowLevel", MapIconInfoType_MissionContactLowLevel},
	{ "OpenMission", MapIconInfoType_OpenMission},
	{ "MissionWaypoint", MapIconInfoType_MissionWaypoint},
	{ "Landmark", MapIconInfoType_Landmark},
	{ "Waypoint", MapIconInfoType_Waypoint},
	{ "SavedWaypoint", MapIconInfoType_SavedWaypoint},
	{ "HarvestNode", MapIconInfoType_HarvestNode},
	{ "Camera", MapIconInfoType_Camera},
	{ "PlayerCharacter", MapIconInfoType_PlayerCharacter},
	{ "AnyMissionContact", MapIconInfoType_AnyMissionContact},
	{ "AnyContact", MapIconInfoType_AnyContact},
	{ "Entity", MapIconInfoType_Entity},
	{ "All", MapIconInfoType_All},
	DEFINE_END
};
void autoEnum_fixup_MapIconInfoType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(MapIconInfoTypeEnum, "MapIconInfoType");
}

//auto-generated staticdefine for enum OverHeadEntityFlags
//autogeneratednocheckin
StaticDefineInt OverHeadEntityFlagsEnum[] =
{
	DEFINE_INT
	{ "OVERHEAD_ENTITY_FLAG_NEVER", OVERHEAD_ENTITY_FLAG_NEVER},
	{ "OVERHEAD_ENTITY_FLAG_MOUSE_OVER_NAME", OVERHEAD_ENTITY_FLAG_MOUSE_OVER_NAME},
	{ "OVERHEAD_ENTITY_FLAG_TARGETED_NAME", OVERHEAD_ENTITY_FLAG_TARGETED_NAME},
	{ "OVERHEAD_ENTITY_FLAG_ALWAYS_NAME", OVERHEAD_ENTITY_FLAG_ALWAYS_NAME},
	{ "OVERHEAD_ENTITY_FLAG_MOUSE_OVER_LIFE", OVERHEAD_ENTITY_FLAG_MOUSE_OVER_LIFE},
	{ "OVERHEAD_ENTITY_FLAG_TARGETED_LIFE", OVERHEAD_ENTITY_FLAG_TARGETED_LIFE},
	{ "OVERHEAD_ENTITY_FLAG_ALWAYS_LIFE", OVERHEAD_ENTITY_FLAG_ALWAYS_LIFE},
	{ "OVERHEAD_ENTITY_FLAG_MOUSE_OVER_RETICLE", OVERHEAD_ENTITY_FLAG_MOUSE_OVER_RETICLE},
	{ "OVERHEAD_ENTITY_FLAG_TARGETED_RETICLE", OVERHEAD_ENTITY_FLAG_TARGETED_RETICLE},
	{ "OVERHEAD_ENTITY_FLAG_ALWAYS_RETICLE", OVERHEAD_ENTITY_FLAG_ALWAYS_RETICLE},
	{ "OVERHEAD_ENTITY_FLAG_DAMAGED_NAME", OVERHEAD_ENTITY_FLAG_DAMAGED_NAME},
	{ "OVERHEAD_ENTITY_FLAG_DAMAGED_LIFE", OVERHEAD_ENTITY_FLAG_DAMAGED_LIFE},
	{ "OVERHEAD_ENTITY_FLAG_DAMAGED_RETICLE", OVERHEAD_ENTITY_FLAG_DAMAGED_RETICLE},
	{ "OVERHEAD_ENTITY_FLAG_TARGETOFTARGET_NAME", OVERHEAD_ENTITY_FLAG_TARGETOFTARGET_NAME},
	{ "OVERHEAD_ENTITY_FLAG_TARGETOFTARGET_LIFE", OVERHEAD_ENTITY_FLAG_TARGETOFTARGET_LIFE},
	{ "OVERHEAD_ENTITY_FLAG_TARGETOFTARGET_RETICLE", OVERHEAD_ENTITY_FLAG_TARGETOFTARGET_RETICLE},
	{ "OVERHEAD_ENTITY_FLAG_ALWAYS_NAME_CONTACTS", OVERHEAD_ENTITY_FLAG_ALWAYS_NAME_CONTACTS},
	{ "OVERHEAD_ENTITY_FLAG_MOUSE_OVER_POWERMODENAME", OVERHEAD_ENTITY_FLAG_MOUSE_OVER_POWERMODENAME},
	{ "OVERHEAD_ENTITY_FLAG_TARGETED_POWERMODENAME", OVERHEAD_ENTITY_FLAG_TARGETED_POWERMODENAME},
	{ "OVERHEAD_ENTITY_FLAG_ALWAYS_POWERMODENAME", OVERHEAD_ENTITY_FLAG_ALWAYS_POWERMODENAME},
	{ "OVERHEAD_ENTITY_FLAG_DAMAGED_POWERMODENAME", OVERHEAD_ENTITY_FLAG_DAMAGED_POWERMODENAME},
	{ "OVERHEAD_ENTITY_FLAG_TARGETOFTARGET_POWERMODENAME", OVERHEAD_ENTITY_FLAG_TARGETOFTARGET_POWERMODENAME},
	{ "OVERHEAD_ENTITY_FLAG_MOUSE_OVER_POWERMODELIFE", OVERHEAD_ENTITY_FLAG_MOUSE_OVER_POWERMODELIFE},
	{ "OVERHEAD_ENTITY_FLAG_TARGETED_POWERMODELIFE", OVERHEAD_ENTITY_FLAG_TARGETED_POWERMODELIFE},
	{ "OVERHEAD_ENTITY_FLAG_ALWAYS_POWERMODELIFE", OVERHEAD_ENTITY_FLAG_ALWAYS_POWERMODELIFE},
	{ "OVERHEAD_ENTITY_FLAG_DAMAGED_POWERMODELIFE", OVERHEAD_ENTITY_FLAG_DAMAGED_POWERMODELIFE},
	{ "OVERHEAD_ENTITY_FLAG_TARGETOFTARGET_POWERMODELIFE", OVERHEAD_ENTITY_FLAG_TARGETOFTARGET_POWERMODELIFE},
	{ "OVERHEAD_ENTITY_FLAG_MOUSE_OVER_POWERMODERETICLE", OVERHEAD_ENTITY_FLAG_MOUSE_OVER_POWERMODERETICLE},
	{ "OVERHEAD_ENTITY_FLAG_TARGETED_POWERMODERETICLE", OVERHEAD_ENTITY_FLAG_TARGETED_POWERMODERETICLE},
	{ "OVERHEAD_ENTITY_FLAG_ALWAYS_POWERMODERETICLE", OVERHEAD_ENTITY_FLAG_ALWAYS_POWERMODERETICLE},
	{ "OVERHEAD_ENTITY_FLAG_DAMAGED_POWERMODERETICLE", OVERHEAD_ENTITY_FLAG_DAMAGED_POWERMODERETICLE},
	{ "OVERHEAD_ENTITY_FLAG_TARGETOFTARGET_POWERMODERETICLE", OVERHEAD_ENTITY_FLAG_TARGETOFTARGET_POWERMODERETICLE},
	{ "OVERHEAD_ENTITY_FLAG_MOUSE_OVER", OVERHEAD_ENTITY_FLAG_MOUSE_OVER},
	{ "OVERHEAD_ENTITY_FLAG_TARGETED", OVERHEAD_ENTITY_FLAG_TARGETED},
	{ "OVERHEAD_ENTITY_FLAG_ALWAYS", OVERHEAD_ENTITY_FLAG_ALWAYS},
	{ "OVERHEAD_ENTITY_FLAG_DAMAGED", OVERHEAD_ENTITY_FLAG_DAMAGED},
	{ "OVERHEAD_ENTITY_FLAG_TARGETOFTARGET", OVERHEAD_ENTITY_FLAG_TARGETOFTARGET},
	{ "OVERHEAD_ENTITY_FLAG_MOUSE_OVER_POWERMODE", OVERHEAD_ENTITY_FLAG_MOUSE_OVER_POWERMODE},
	{ "OVERHEAD_ENTITY_FLAG_TARGETED_POWERMODE", OVERHEAD_ENTITY_FLAG_TARGETED_POWERMODE},
	{ "OVERHEAD_ENTITY_FLAG_ALWAYS_POWERMODE", OVERHEAD_ENTITY_FLAG_ALWAYS_POWERMODE},
	{ "OVERHEAD_ENTITY_FLAG_DAMAGED_POWERMODE", OVERHEAD_ENTITY_FLAG_DAMAGED_POWERMODE},
	{ "OVERHEAD_ENTITY_FLAG_TARGETOFTARGET_POWERMODE", OVERHEAD_ENTITY_FLAG_TARGETOFTARGET_POWERMODE},
	{ "OVERHEAD_ENTITY_FLAG_ALL", OVERHEAD_ENTITY_FLAG_ALL},
	{ "OVERHEAD_ENTITY_FLAG_POWERMODEALL", OVERHEAD_ENTITY_FLAG_POWERMODEALL},
	{ "OVERHEAD_ENTITY_FLAG_PLAYERDEFAULTS", OVERHEAD_ENTITY_FLAG_PLAYERDEFAULTS},
	{ "OVERHEAD_ENTITY_FLAG_NPCDEFAULTS", OVERHEAD_ENTITY_FLAG_NPCDEFAULTS},
	DEFINE_END
};
void autoEnum_fixup_OverHeadEntityFlags(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(OverHeadEntityFlagsEnum, "OverHeadEntityFlags");
}

//auto-generated staticdefine for enum OverHeadEntityTypes
//autogeneratednocheckin
StaticDefineInt OverHeadEntityTypesEnum[] =
{
	DEFINE_INT
	{ "OVERHEAD_ENTITY_TYPE_ENEMY", OVERHEAD_ENTITY_TYPE_ENEMY},
	{ "OVERHEAD_ENTITY_TYPE_FRIENDLY_NPC", OVERHEAD_ENTITY_TYPE_FRIENDLY_NPC},
	{ "OVERHEAD_ENTITY_TYPE_FRIEND", OVERHEAD_ENTITY_TYPE_FRIEND},
	{ "OVERHEAD_ENTITY_TYPE_SUPERGROUP", OVERHEAD_ENTITY_TYPE_SUPERGROUP},
	{ "OVERHEAD_ENTITY_TYPE_TEAM", OVERHEAD_ENTITY_TYPE_TEAM},
	{ "OVERHEAD_ENTITY_TYPE_PET", OVERHEAD_ENTITY_TYPE_PET},
	{ "OVERHEAD_ENTITY_TYPE_PLAYER", OVERHEAD_ENTITY_TYPE_PLAYER},
	{ "OVERHEAD_ENTITY_TYPE_ENEMY_PLAYER", OVERHEAD_ENTITY_TYPE_ENEMY_PLAYER},
	{ "OVERHEAD_ENTITY_TYPE_SELF", OVERHEAD_ENTITY_TYPE_SELF},
	{ "OVERHEAD_ENTITY_TYPE_COUNT", OVERHEAD_ENTITY_TYPE_COUNT},
	DEFINE_END
};
void autoEnum_fixup_OverHeadEntityTypes(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(OverHeadEntityTypesEnum, "OverHeadEntityTypes");
}

//auto-generated staticdefine for enum OverHeadReticleFlags
//autogeneratednocheckin
StaticDefineInt OverHeadReticleFlagsEnum[] =
{
	DEFINE_INT
	{ "OVERHEAD_RETICLE_HIGHLIGHT", OVERHEAD_RETICLE_HIGHLIGHT},
	{ "OVERHEAD_RETICLE_BOX", OVERHEAD_RETICLE_BOX},
	DEFINE_END
};
void autoEnum_fixup_OverHeadReticleFlags(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(OverHeadReticleFlagsEnum, "OverHeadReticleFlags");
}

//auto-generated staticdefine for enum PlayerNotifyAudioMode
//autogeneratednocheckin
StaticDefineInt PlayerNotifyAudioModeEnum[] =
{
	DEFINE_INT
	{ "Unset", PlayerNotifyAudioMode_Unset},
	{ "Off", PlayerNotifyAudioMode_Off},
	{ "Standard", PlayerNotifyAudioMode_Standard},
	{ "Suggestion", PlayerNotifyAudioMode_Suggestion},
	DEFINE_END
};
void autoEnum_fixup_PlayerNotifyAudioMode(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PlayerNotifyAudioModeEnum, "PlayerNotifyAudioMode");
}

//auto-generated staticdefine for enum NPCEmailType
//autogeneratednocheckin
StaticDefineInt NPCEmailTypeEnum[] =
{
	DEFINE_INT
	{ "Default", kNPCEmailType_Default},
	{ "ExpiredAuction", kNPCEmailType_ExpiredAuction},
	DEFINE_END
};
void autoEnum_fixup_NPCEmailType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(NPCEmailTypeEnum, "NPCEmailType");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ActivatedPlayerSpawn
#define TYPE_parse_ActivatedPlayerSpawn ActivatedPlayerSpawn
ParseTable parse_ActivatedPlayerSpawn[] =
{
	{ "ActivatedPlayerSpawn", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ActivatedPlayerSpawn), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "mapName",				TOK_PERSIST | TOK_POOL_STRING_DB | TOK_STRING(ActivatedPlayerSpawn, mapName, 0), NULL },
	{ "spawnPointName",			TOK_PERSIST | TOK_POOL_STRING_DB | TOK_STRING(ActivatedPlayerSpawn, spawnPointName, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ActivatedPlayerSpawn()
{
	int iSize = sizeof(ActivatedPlayerSpawn);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ActivatedPlayerSpawn, iSize, "ActivatedPlayerSpawn", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct GamePermissionNumerics
#define TYPE_parse_GamePermissionNumerics GamePermissionNumerics
ParseTable parse_GamePermissionNumerics[] =
{
	{ "GamePermissionNumerics", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(GamePermissionNumerics), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Key",					TOK_PERSIST | TOK_ESTRING | TOK_KEY | TOK_STRING(GamePermissionNumerics, pchKey, 0), NULL },
	{ "pchKey",					TOK_REDUNDANTNAME | TOK_PERSIST | TOK_ESTRING | TOK_STRING(GamePermissionNumerics, pchKey, 0), NULL },
	{ "iValue",					TOK_PERSIST | TOK_AUTOINT(GamePermissionNumerics, iValue, 0), NULL },
	{ "bIsNumeric",				TOK_PERSIST | TOK_AUTOINT(GamePermissionNumerics, bIsNumeric, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_GamePermissionNumerics()
{
	int iSize = sizeof(GamePermissionNumerics);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_GamePermissionNumerics, iSize, "GamePermissionNumerics", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribValuePair[];
#define TYPE_parse_AttribValuePair AttribValuePair
extern ParseTable parse_GamePermissionNumerics[];
#define TYPE_parse_GamePermissionNumerics GamePermissionNumerics
extern ParseTable parse_GameAccountDataExtract[];
#define TYPE_parse_GameAccountDataExtract GameAccountDataExtract
//Structparser.exe autogenerated ParseTable for struct PlayerAccountData
#define TYPE_parse_PlayerAccountData PlayerAccountData
ParseTable parse_PlayerAccountData[] =
{
	{ "PlayerAccountData", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerAccountData), 0, NULL, 0, NULL },
	{ "{",									TOK_START, 0 },
	{ "iAccountID",							TOK_PERSIST | TOK_AUTOINT(PlayerAccountData, iAccountID, 0), NULL },
	{ "iVersion",							TOK_PERSIST | TOK_AUTOINT(PlayerAccountData, iVersion, 0), NULL },
	{ "eaPendingKeys",						TOK_PERSIST | TOK_STRUCT(PlayerAccountData, eaPendingKeys, parse_AttribValuePair) },
	{ "hData",								TOK_PERSIST | TOK_REFERENCE(PlayerAccountData, hData, 0, "CopyDict_GameAccountData") , 0 , "EXPORT_CONTAINER_TYPE = \"GameAccountData\""},
	{ "hTempData",							TOK_NO_NETSEND | TOK_REFERENCE(PlayerAccountData, hTempData, 0, "CopyDict_GameAccountData") },
	{ "eaGamePermissionMaxValueNumerics",	TOK_PERSIST | TOK_SELF_ONLY | TOK_STRUCT(PlayerAccountData, eaGamePermissionMaxValueNumerics, parse_GamePermissionNumerics) },
	{ "uExtractLastUpdated",				TOK_NO_NETSEND | TOK_AUTOINT(PlayerAccountData, uExtractLastUpdated, 0), NULL },
	{ "pExtract",							TOK_NO_NETSEND | TOK_OPTIONALSTRUCT(PlayerAccountData, pExtract, parse_GameAccountDataExtract) },
	{ "bSteamLogin",						TOK_NO_NETSEND | TOK_BIT, 0, 8, NULL},
	{ "}",									TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PlayerAccountData()
{
	int iSize = sizeof(PlayerAccountData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerAccountData, iSize, "PlayerAccountData", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(PlayerAccountData)) + 7) / 4;
		NOCONST(PlayerAccountData) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bSteamLogin = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerAccountData[10]);
		pTemp->bSteamLogin = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PlayerNemesisState[];
#define TYPE_parse_PlayerNemesisState PlayerNemesisState
//Structparser.exe autogenerated ParseTable for struct PlayerNemesisInfo
#define TYPE_parse_PlayerNemesisInfo PlayerNemesisInfo
ParseTable parse_PlayerNemesisInfo[] =
{
	{ "PlayerNemesisInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerNemesisInfo), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "dirtyBit",			TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(PlayerNemesisInfo, dirtyBit, 0), NULL },
	{ "eaNemesisStates",	TOK_PERSIST | TOK_SUBSCRIBE | TOK_STRUCT(PlayerNemesisInfo, eaNemesisStates, parse_PlayerNemesisState) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerNemesisInfo()
{
	int iSize = sizeof(PlayerNemesisInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerNemesisInfo, iSize, "PlayerNemesisInfo", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct LogoutTimer
#define TYPE_parse_LogoutTimer LogoutTimer
ParseTable parse_LogoutTimer[] =
{
	{ "LogoutTimer", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(LogoutTimer), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Type",			TOK_AUTOINT(LogoutTimer, eType, 0), LogoutTimerTypeEnum },
	{ "expirationTime",	TOK_AUTOINT(LogoutTimer, expirationTime, 0), NULL },
	{ "timeRemaining",	TOK_AUTOINT(LogoutTimer, timeRemaining, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_LogoutTimer()
{
	int iSize = sizeof(LogoutTimer);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_LogoutTimer, iSize, "LogoutTimer", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerPowersWarpToData
#define TYPE_parse_PlayerPowersWarpToData PlayerPowersWarpToData
ParseTable parse_PlayerPowersWarpToData[] =
{
	{ "PlayerPowersWarpToData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerPowersWarpToData), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "pchMap",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(PlayerPowersWarpToData, pchMap, 0), NULL },
	{ "vecPos",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_VEC3(PlayerPowersWarpToData, vecPos), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerPowersWarpToData()
{
	int iSize = sizeof(PlayerPowersWarpToData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerPowersWarpToData, iSize, "PlayerPowersWarpToData", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerWarpToData
#define TYPE_parse_PlayerWarpToData PlayerWarpToData
ParseTable parse_PlayerWarpToData[] =
{
	{ "PlayerWarpToData", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerWarpToData), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "iEntID",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerWarpToData, iEntID, 0), NULL },
	{ "eContType",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerWarpToData, eContType, 0), GlobalTypeEnum },
	{ "iTeamID",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerWarpToData, iTeamID, 0), NULL },
	{ "iAccountID",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerWarpToData, iAccountID, 0), NULL },
	{ "pchMap",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(PlayerWarpToData, pchMap, 0), NULL },
	{ "pcMapVariables",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_POOL_STRING | TOK_STRING(PlayerWarpToData, pcMapVariables, 0), NULL },
	{ "iMapID",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerWarpToData, iMapID, 0), NULL },
	{ "uPartitionID",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerWarpToData, uPartitionID, 0), NULL },
	{ "iInstance",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerWarpToData, iInstance, 0), NULL },
	{ "pchSpawn",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(PlayerWarpToData, pchSpawn, 0), NULL },
	{ "vecTarget",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_VEC3(PlayerWarpToData, vecTarget), NULL },
	{ "uiItemId",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerWarpToData, uiItemId, 0), NULL },
	{ "iTimestamp",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerWarpToData, iTimestamp, 0), NULL },
	{ "pchAllegiance",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(PlayerWarpToData, pchAllegiance, 0), NULL },
	{ "bRecruitWarp",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_BIT, 0, 8, NULL},
	{ "bMustBeTeamed",			TOK_BIT, 0, 8, NULL},
	{ "bMustBeSameAllegiance",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PlayerWarpToData()
{
	int iSize = sizeof(PlayerWarpToData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerWarpToData, iSize, "PlayerWarpToData", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(PlayerWarpToData)) + 7) / 4;
		NOCONST(PlayerWarpToData) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bRecruitWarp = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerWarpToData[16]);
		pTemp->bRecruitWarp = 0;
		pTemp->bMustBeTeamed = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerWarpToData[17]);
		pTemp->bMustBeTeamed = 0;
		pTemp->bMustBeSameAllegiance = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerWarpToData[18]);
		pTemp->bMustBeSameAllegiance = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerGuildLog
#define TYPE_parse_PlayerGuildLog PlayerGuildLog
ParseTable parse_PlayerGuildLog[] =
{
	{ "PlayerGuildLog", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerGuildLog), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "LogEntry",		TOK_STRING(PlayerGuildLog, pcLogEntry, 0), NULL },
	{ "time",			TOK_AUTOINT(PlayerGuildLog, time, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerGuildLog()
{
	int iSize = sizeof(PlayerGuildLog);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerGuildLog, iSize, "PlayerGuildLog", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerGuildOfficerComments
#define TYPE_parse_PlayerGuildOfficerComments PlayerGuildOfficerComments
ParseTable parse_PlayerGuildOfficerComments[] =
{
	{ "PlayerGuildOfficerComments", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerGuildOfficerComments), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "EntID",						TOK_AUTOINT(PlayerGuildOfficerComments, iEntID, 0), NULL },
	{ "OfficerComment",				TOK_STRING(PlayerGuildOfficerComments, pcOfficerComment, 0), NULL },
	{ "WhoOfficerComment",			TOK_STRING(PlayerGuildOfficerComments, pcWhoOfficerComment, 0), NULL },
	{ "OfficerCommentTime",			TOK_AUTOINT(PlayerGuildOfficerComments, iOfficerCommentTime, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerGuildOfficerComments()
{
	int iSize = sizeof(PlayerGuildOfficerComments);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerGuildOfficerComments, iSize, "PlayerGuildOfficerComments", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PlayerGuildLog[];
#define TYPE_parse_PlayerGuildLog PlayerGuildLog
extern ParseTable parse_PlayerCostumeHolder[];
#define TYPE_parse_PlayerCostumeHolder PlayerCostumeHolder
extern ParseTable parse_PlayerGuildOfficerComments[];
#define TYPE_parse_PlayerGuildOfficerComments PlayerGuildOfficerComments
//Structparser.exe autogenerated ParseTable for struct PlayerGuild
#define TYPE_parse_PlayerGuild PlayerGuild
ParseTable parse_PlayerGuild[] =
{
	{ "PlayerGuild", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerGuild), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "iGuildID",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(PlayerGuild, iGuildID, 0), NULL },
	{ "hGuild",						TOK_REFERENCE(PlayerGuild, hGuild, 0, "CopyDict_GUILD") },
	{ "hGuildBank",					TOK_REFERENCE(PlayerGuild, hGuildBank, 0, "CopyDict_EntityGuildBank") },
	{ "iTimeSinceHandleInit",		TOK_NO_NETSEND | TOK_AUTOINT(PlayerGuild, iTimeSinceHandleInit, 0), NULL },
	{ "iTimeSinceLastUpdate",		TOK_NO_NETSEND | TOK_AUTOINT(PlayerGuild, iTimeSinceLastUpdate, 0), NULL },
	{ "eState",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(PlayerGuild, eState, 0), GuildStateEnum },
	{ "pcInviterName",				TOK_PERSIST | TOK_STRING(PlayerGuild, pcInviterName, 0), NULL },
	{ "pcInviterHandle",			TOK_PERSIST | TOK_STRING(PlayerGuild, pcInviterHandle, 0), NULL },
	{ "iVersion",					TOK_NO_NETSEND | TOK_AUTOINT(PlayerGuild, iVersion, 0), NULL },
	{ "bJoinedGuild",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerGuild, bJoinedGuild, 0), NULL },
	{ "iGuildChat",					TOK_NO_NETSEND | TOK_AUTOINT(PlayerGuild, iGuildChat, 0), NULL },
	{ "iOfficerChat",				TOK_NO_NETSEND | TOK_AUTOINT(PlayerGuild, iOfficerChat, 0), NULL },
	{ "fLastUpdate",				TOK_NO_NETSEND | TOK_F32(PlayerGuild, fLastUpdate, 0), NULL },
	{ "uiDisplayedMotD",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_AUTOINT(PlayerGuild, uiDisplayedMotD, 0), NULL },
	{ "uiDisplayedEvent",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_AUTOINT(PlayerGuild, uiDisplayedEvent, 0), NULL },
	{ "eaBankLog",					TOK_STRUCT(PlayerGuild, eaBankLog, parse_PlayerGuildLog) },
	{ "iBankLogSize",				TOK_AUTOINT(PlayerGuild, iBankLogSize, 0), NULL },
	{ "iUpdated",					TOK_AUTOINT(PlayerGuild, iUpdated, 0), NULL },
	{ "eaGuildCostumes",			TOK_STRUCT(PlayerGuild, eaGuildCostumes, parse_PlayerCostumeHolder) },
	{ "bUpdatedOfficerComments",	TOK_NO_NETSEND | TOK_AUTOINT(PlayerGuild, bUpdatedOfficerComments, 0), NULL },
	{ "iOCVersion",					TOK_NO_NETSEND | TOK_AUTOINT(PlayerGuild, iOCVersion, 0), NULL },
	{ "eaOfficerComments",			TOK_STRUCT(PlayerGuild, eaOfficerComments, parse_PlayerGuildOfficerComments) },
	{ "hGroupProjectContainer",		TOK_REFERENCE(PlayerGuild, hGroupProjectContainer, 0, "CopyDict_GroupProjectContainerGuild") },
	{ "dirtyBit",					TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(PlayerGuild, dirtyBit, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerGuild()
{
	int iSize = sizeof(PlayerGuild);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerGuild, iSize, "PlayerGuild", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_MicroTransactionPurchase[];
#define TYPE_parse_MicroTransactionPurchase MicroTransactionPurchase
//Structparser.exe autogenerated ParseTable for struct PlayerMTInfo
#define TYPE_parse_PlayerMTInfo PlayerMTInfo
ParseTable parse_PlayerMTInfo[] =
{
	{ "PlayerMTInfo", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerMTInfo), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "dirtyBit",			TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(PlayerMTInfo, dirtyBit, 0), NULL },
	{ "eaOneTimePurchases",	TOK_PERSIST | TOK_STRINGARRAY(PlayerMTInfo, eaOneTimePurchases), NULL },
	{ "eaFirstPurchases",	TOK_PERSIST | TOK_STRUCT(PlayerMTInfo, eaFirstPurchases, parse_MicroTransactionPurchase) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerMTInfo()
{
	int iSize = sizeof(PlayerMTInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerMTInfo, iSize, "PlayerMTInfo", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PlayerQueueInstance[];
#define TYPE_parse_PlayerQueueInstance PlayerQueueInstance
//Structparser.exe autogenerated ParseTable for struct PlayerQueue
#define TYPE_parse_PlayerQueue PlayerQueue
ParseTable parse_PlayerQueue[] =
{
	{ "PlayerQueue", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerQueue), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "QueueName",			TOK_POOL_STRING | TOK_KEY | TOK_STRING(PlayerQueue, pchQueueName, 0), NULL },
	{ "hDef",				TOK_REFERENCE(PlayerQueue, hDef, 0, "QueueDef") },
	{ "CannotUseReason",	TOK_AUTOINT(PlayerQueue, eCannotUseReason, 0), QueueCannotUseReasonEnum },
	{ "Instances",			TOK_STRUCT(PlayerQueue, eaInstances, parse_PlayerQueueInstance) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerQueue()
{
	int iSize = sizeof(PlayerQueue);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerQueue, iSize, "PlayerQueue", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PlayerQueue[];
#define TYPE_parse_PlayerQueue PlayerQueue
extern ParseTable parse_QueueFailRequirementsData[];
#define TYPE_parse_QueueFailRequirementsData QueueFailRequirementsData
extern ParseTable parse_PlayerQueuePenaltyData[];
#define TYPE_parse_PlayerQueuePenaltyData PlayerQueuePenaltyData
extern ParseTable parse_QueueInstantiationInfo[];
#define TYPE_parse_QueueInstantiationInfo QueueInstantiationInfo
//Structparser.exe autogenerated ParseTable for struct PlayerQueueInfo
#define TYPE_parse_PlayerQueueInfo PlayerQueueInfo
ParseTable parse_PlayerQueueInfo[] =
{
	{ "PlayerQueueInfo", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerQueueInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Queues",					TOK_STRUCT(PlayerQueueInfo, eaQueues, parse_PlayerQueue) },
	{ "FailsAllReqs",			TOK_SELF_ONLY | TOK_STRUCT(PlayerQueueInfo, eaFailsAllReqs, parse_QueueFailRequirementsData) },
	{ "PenaltyData",			TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(PlayerQueueInfo, pPenaltyData, parse_PlayerQueuePenaltyData) },
	{ "uLeaverPenaltyDuration",	TOK_SELF_ONLY | TOK_AUTOINT(PlayerQueueInfo, uLeaverPenaltyDuration, 0), NULL },
	{ "QueueInstantiationInfo",	TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(PlayerQueueInfo, pQueueInstantiationInfo, parse_QueueInstantiationInfo) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerQueueInfo()
{
	int iSize = sizeof(PlayerQueueInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerQueueInfo, iSize, "PlayerQueueInfo", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_MicroTransactionRef[];
#define TYPE_parse_MicroTransactionRef MicroTransactionRef
//Structparser.exe autogenerated ParseTable for struct PlayerMapMoveClient
#define TYPE_parse_PlayerMapMoveClient PlayerMapMoveClient
ParseTable parse_PlayerMapMoveClient[] =
{
	{ "PlayerMapMoveClient", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerMapMoveClient), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_AUTOINT(PlayerMapMoveClient, eType, 0), PlayerMapMoveTypeEnum },
	{ "MTRefs",					TOK_STRUCT(PlayerMapMoveClient, ppMTRefs, parse_MicroTransactionRef) },
	{ "hDisplayName",			TOK_REFERENCE(PlayerMapMoveClient, hDisplayName, 0, "Message") },
	{ "RequestingEnt",			TOK_STRING(PlayerMapMoveClient, pchRequestingEnt, 0), NULL },
	{ "uiTimeStart",			TOK_AUTOINT(PlayerMapMoveClient, uiTimeStart, 0), NULL },
	{ "uiTimeToConfirm",		TOK_AUTOINT(PlayerMapMoveClient, uiTimeToConfirm, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerMapMoveClient()
{
	int iSize = sizeof(PlayerMapMoveClient);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerMapMoveClient, iSize, "PlayerMapMoveClient", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_WorldVariable[];
#define TYPE_parse_WorldVariable WorldVariable
extern ParseTable parse_WorldScope[];
#define TYPE_parse_WorldScope WorldScope
extern ParseTable parse_PlayerWarpToData[];
#define TYPE_parse_PlayerWarpToData PlayerWarpToData
//Structparser.exe autogenerated ParseTable for struct PlayerMapMoveConfirm
#define TYPE_parse_PlayerMapMoveConfirm PlayerMapMoveConfirm
ParseTable parse_PlayerMapMoveConfirm[] =
{
	{ "PlayerMapMoveConfirm", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerMapMoveConfirm), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_AUTOINT(PlayerMapMoveConfirm, eType, 0), PlayerMapMoveTypeEnum },
	{ "MapName",				TOK_STRING(PlayerMapMoveConfirm, pcMapName, 0), NULL },
	{ "NamedSpawnPoint",		TOK_STRING(PlayerMapMoveConfirm, pcNamedSpawnPoint, 0), NULL },
	{ "QueueName",				TOK_STRING(PlayerMapMoveConfirm, pcQueueName, 0), NULL },
	{ "OwnerType",				TOK_AUTOINT(PlayerMapMoveConfirm, eOwnerType, 0), GlobalTypeEnum },
	{ "uOwnerID",				TOK_AUTOINT(PlayerMapMoveConfirm, uOwnerID, 0), NULL },
	{ "Variables",				TOK_STRUCT(PlayerMapMoveConfirm, eaVariables, parse_WorldVariable) },
	{ "Scope",					TOK_OPTIONALSTRUCT(PlayerMapMoveConfirm, pScope, parse_WorldScope) },
	{ "Warp",					TOK_OPTIONALSTRUCT(PlayerMapMoveConfirm, pWarp, parse_PlayerWarpToData) },
	{ "uiTimeStart",			TOK_AUTOINT(PlayerMapMoveConfirm, uiTimeStart, 0), NULL },
	{ "uiTimeToConfirm",		TOK_AUTOINT(PlayerMapMoveConfirm, uiTimeToConfirm, 0), NULL },
	{ "Flags",					TOK_AUTOINT(PlayerMapMoveConfirm, eFlags, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerMapMoveConfirm()
{
	int iSize = sizeof(PlayerMapMoveConfirm);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerMapMoveConfirm, iSize, "PlayerMapMoveConfirm", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct UIPersistedPosition
#define TYPE_parse_UIPersistedPosition UIPersistedPosition
ParseTable parse_UIPersistedPosition[] =
{
	{ "UIPersistedPosition", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(UIPersistedPosition), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "pchName",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_POOL_STRING_DB | TOK_KEY | TOK_STRING(UIPersistedPosition, pchName, 0), NULL },
	{ "eOffsetFrom",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(UIPersistedPosition, eOffsetFrom, 0), NULL },
	{ "iX",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(UIPersistedPosition, iX, 0), NULL },
	{ "iY",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(UIPersistedPosition, iY, 0), NULL },
	{ "fPercentX",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(UIPersistedPosition, fPercentX, 0), NULL },
	{ "fPercentY",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(UIPersistedPosition, fPercentY, 0), NULL },
	{ "fWidth",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(UIPersistedPosition, fWidth, 0), NULL },
	{ "fHeight",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(UIPersistedPosition, fHeight, 0), NULL },
	{ "iVersion",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(UIPersistedPosition, iVersion, 0), NULL },
	{ "chPriority",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(UIPersistedPosition, chPriority, 0), NULL },
	{ "uiTime",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(UIPersistedPosition, uiTime, 0), NULL },
	{ "pchContents",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(UIPersistedPosition, pchContents, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_UIPersistedPosition()
{
	int iSize = sizeof(UIPersistedPosition);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_UIPersistedPosition, iSize, "UIPersistedPosition", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct UIPersistedColumn
#define TYPE_parse_UIPersistedColumn UIPersistedColumn
ParseTable parse_UIPersistedColumn[] =
{
	{ "UIPersistedColumn", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(UIPersistedColumn), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "pchColName",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(UIPersistedColumn, pchColName, 0), NULL },
	{ "fPercentWidth",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(UIPersistedColumn, fPercentWidth, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_UIPersistedColumn()
{
	int iSize = sizeof(UIPersistedColumn);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_UIPersistedColumn, iSize, "UIPersistedColumn", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_UIPersistedColumn[];
#define TYPE_parse_UIPersistedColumn UIPersistedColumn
//Structparser.exe autogenerated ParseTable for struct UIPersistedList
#define TYPE_parse_UIPersistedList UIPersistedList
ParseTable parse_UIPersistedList[] =
{
	{ "UIPersistedList", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(UIPersistedList), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "pchName",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_KEY | TOK_STRING(UIPersistedList, pchName, 0), NULL },
	{ "iVersion",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(UIPersistedList, iVersion, 0), NULL },
	{ "uiTime",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(UIPersistedList, uiTime, 0), NULL },
	{ "eaColumns",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_NO_INDEX | TOK_STRUCT(UIPersistedList, eaColumns, parse_UIPersistedColumn) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_UIPersistedList()
{
	int iSize = sizeof(UIPersistedList);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_UIPersistedList, iSize, "UIPersistedList", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct UIPersistedWindow
#define TYPE_parse_UIPersistedWindow UIPersistedWindow
ParseTable parse_UIPersistedWindow[] =
{
	{ "UIPersistedWindow", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(UIPersistedWindow), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "pchName",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_KEY | TOK_STRING(UIPersistedWindow, pchName, 0), NULL },
	{ "uiTime",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(UIPersistedWindow, uiTime, 0), NULL },
	{ "bfWindows",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(UIPersistedWindow, bfWindows), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_UIPersistedWindow()
{
	int iSize = sizeof(UIPersistedWindow);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_UIPersistedWindow, iSize, "UIPersistedWindow", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct EntityKeyBind
#define TYPE_parse_EntityKeyBind EntityKeyBind
ParseTable parse_EntityKeyBind[] =
{
	{ "EntityKeyBind", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(EntityKeyBind), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Key",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(EntityKeyBind, pchKey, 0), NULL },
	{ "pchKey",			TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(EntityKeyBind, pchKey, 0), NULL },
	{ "Command",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(EntityKeyBind, pchCommand, 0), NULL },
	{ "pchCommand",		TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(EntityKeyBind, pchCommand, 0), NULL },
	{ "SchemeRegions",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(EntityKeyBind, eSchemeRegions, 0), ControlSchemeRegionTypeEnum  ,  TOK_FORMAT_FLAGS},
	{ "eSchemeRegions",	TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(EntityKeyBind, eSchemeRegions, 0), ControlSchemeRegionTypeEnum  ,  TOK_FORMAT_FLAGS},
	{ "Secondary",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_BIT, 0, 8, NULL},
	{ "bSecondary",		TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_BIT, 0, 8, NULL},
	{ "Regions",		TOK_IGNORE, 0 },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_EntityKeyBind()
{
	int iSize = sizeof(EntityKeyBind);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_EntityKeyBind, iSize, "EntityKeyBind", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(EntityKeyBind)) + 7) / 4;
		NOCONST(EntityKeyBind) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bSecondary = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntityKeyBind[8]);
		pTemp->bSecondary = 0;
		pTemp->bSecondary = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_EntityKeyBind[9]);
		pTemp->bSecondary = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_EntityKeyBind[];
#define TYPE_parse_EntityKeyBind EntityKeyBind
//Structparser.exe autogenerated ParseTable for struct EntityKeyBinds
#define TYPE_parse_EntityKeyBinds EntityKeyBinds
ParseTable parse_EntityKeyBinds[] =
{
	{ "EntityKeyBinds", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(EntityKeyBinds), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Profile",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(EntityKeyBinds, pchProfile, 0), NULL },
	{ "pchProfile",		TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(EntityKeyBinds, pchProfile, 0), NULL },
	{ "KeyBind",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRUCT(EntityKeyBinds, eaBinds, parse_EntityKeyBind) },
	{ "eaBinds",		TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRUCT(EntityKeyBinds, eaBinds, parse_EntityKeyBind) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_EntityKeyBinds()
{
	int iSize = sizeof(EntityKeyBinds);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_EntityKeyBinds, iSize, "EntityKeyBinds", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerShowOverhead
#define TYPE_parse_PlayerShowOverhead PlayerShowOverhead
ParseTable parse_PlayerShowOverhead[] =
{
	{ "PlayerShowOverhead", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerShowOverhead), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "ShowEnemy",						TOK_AUTOINT(PlayerShowOverhead, eShowEnemy, OVERHEAD_ENTITY_FLAG_NPCDEFAULTS), OverHeadEntityFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "ShowFriendlyNPC",				TOK_AUTOINT(PlayerShowOverhead, eShowFriendlyNPC, OVERHEAD_ENTITY_FLAG_NPCDEFAULTS), OverHeadEntityFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "ShowFriends",					TOK_AUTOINT(PlayerShowOverhead, eShowFriends, OVERHEAD_ENTITY_FLAG_PLAYERDEFAULTS), OverHeadEntityFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "ShowTeam",						TOK_AUTOINT(PlayerShowOverhead, eShowTeam, OVERHEAD_ENTITY_FLAG_PLAYERDEFAULTS), OverHeadEntityFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "ShowSupergroup",					TOK_AUTOINT(PlayerShowOverhead, eShowSupergroup, OVERHEAD_ENTITY_FLAG_PLAYERDEFAULTS), OverHeadEntityFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "ShowPet",						TOK_AUTOINT(PlayerShowOverhead, eShowPet, OVERHEAD_ENTITY_FLAG_PLAYERDEFAULTS), OverHeadEntityFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "ShowEnemyPlayer",				TOK_AUTOINT(PlayerShowOverhead, eShowEnemyPlayer, OVERHEAD_ENTITY_FLAG_PLAYERDEFAULTS), OverHeadEntityFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "ShowPlayer",						TOK_AUTOINT(PlayerShowOverhead, eShowPlayer, OVERHEAD_ENTITY_FLAG_PLAYERDEFAULTS), OverHeadEntityFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "ShowSelf",						TOK_AUTOINT(PlayerShowOverhead, eShowSelf, OVERHEAD_ENTITY_FLAG_NEVER), OverHeadEntityFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "ShowPlayerTitles",				TOK_AUTOINT(PlayerShowOverhead, bShowPlayerTitles, true), NULL },
	{ "ShowPlayerRoles",				TOK_AUTOINT(PlayerShowOverhead, bShowPlayerRoles, true), NULL },
	{ "ShowDamageFloaters",				TOK_AUTOINT(PlayerShowOverhead, bShowDamageFloaters, true), NULL },
	{ "ShowPetDamageFloaters",			TOK_AUTOINT(PlayerShowOverhead, bShowPetDamageFloaters, true), NULL },
	{ "ShowTeamDamageFloaters",			TOK_AUTOINT(PlayerShowOverhead, bShowTeamDamageFloaters, true), NULL },
	{ "ShowAllPlayerDamageFloaters",	TOK_AUTOINT(PlayerShowOverhead, bShowAllPlayerDamageFloaters, true), NULL },
	{ "ShowOwnedEntityDamageFloaters",	TOK_AUTOINT(PlayerShowOverhead, bShowOwnedEntityDamageFloaters, true), NULL },
	{ "ShowInteractionIcons",			TOK_AUTOINT(PlayerShowOverhead, bShowInteractionIcons, true), NULL },
	{ "ShowPlayerPowerDisplayNames",	TOK_AUTOINT(PlayerShowOverhead, bShowPlayerPowerDisplayNames, true), NULL },
	{ "ShowUnrelatedDamageFloaters",	TOK_AUTOINT(PlayerShowOverhead, bShowUnrelatedDamageFloaters, 0), NULL },
	{ "ShowHostileHealingFloaters",		TOK_AUTOINT(PlayerShowOverhead, bShowHostileHealingFloaters, 0), NULL },
	{ "DontShowPlayerOutgoing",			TOK_AUTOINT(PlayerShowOverhead, bDontShowPlayerOutgoing, 0), NULL },
	{ "DontShowPlayerIncoming",			TOK_AUTOINT(PlayerShowOverhead, bDontShowPlayerIncoming, 0), NULL },
	{ "ShowCriticalStatusInfo",			TOK_AUTOINT(PlayerShowOverhead, bShowCriticalStatusInfo, true), NULL },
	{ "ShowReticlesAs",					TOK_AUTOINT(PlayerShowOverhead, eShowReticlesAs, OVERHEAD_RETICLE_HIGHLIGHT), OverHeadReticleFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerShowOverhead()
{
	int iSize = sizeof(PlayerShowOverhead);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerShowOverhead, iSize, "PlayerShowOverhead", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PlayerShowOverhead[];
#define TYPE_parse_PlayerShowOverhead PlayerShowOverhead
//Structparser.exe autogenerated ParseTable for struct PlayerHUDOptions
#define TYPE_parse_PlayerHUDOptions PlayerHUDOptions
ParseTable parse_PlayerHUDOptions[] =
{
	{ "PlayerHUDOptions", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerHUDOptions), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Region",				TOK_AUTOINT(PlayerHUDOptions, eRegion, kControlSchemeRegionType_None), ControlSchemeRegionTypeEnum },
	{ "NotifyAudioMode",	TOK_AUTOINT(PlayerHUDOptions, eNotifyAudioMode, PlayerNotifyAudioMode_Standard), PlayerNotifyAudioModeEnum },
	{ "ShowOverhead",		TOK_EMBEDDEDSTRUCT(PlayerHUDOptions, ShowOverhead, parse_PlayerShowOverhead)},
	{ "TrayMode",			TOK_AUTOINT(PlayerHUDOptions, uiTrayMode, 0), NULL },
	{ "PowerLevelsMode",	TOK_AUTOINT(PlayerHUDOptions, uiPowerLevelsMode, 0), NULL },
	{ "HideTrayTooltips",	TOK_AUTOINT(PlayerHUDOptions, bHideTrayTooltips, 0), NULL },
	{ "MapIconFlags",		TOK_AUTOINT(PlayerHUDOptions, eMapIconFlags, MapIconInfoType_All), MapIconInfoTypeEnum },
	{ "Version",			TOK_AUTOINT(PlayerHUDOptions, iVersion, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerHUDOptions()
{
	int iSize = sizeof(PlayerHUDOptions);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerHUDOptions, iSize, "PlayerHUDOptions", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerHUDOptionsPowerMode
#define TYPE_parse_PlayerHUDOptionsPowerMode PlayerHUDOptionsPowerMode
ParseTable parse_PlayerHUDOptionsPowerMode[] =
{
	{ "PlayerHUDOptionsPowerMode", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerHUDOptionsPowerMode), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Region",						TOK_AUTOINT(PlayerHUDOptionsPowerMode, eRegion, kControlSchemeRegionType_None), ControlSchemeRegionTypeEnum },
	{ "PowerMode",					TOK_INTARRAY(PlayerHUDOptionsPowerMode, eaiPowerModes),  PowerModeEnum},
	{ "EnableType",					TOK_INTARRAY(PlayerHUDOptionsPowerMode, eaiEnableTypes),  OverHeadEntityTypesEnum},
	{ "EnableName",					TOK_AUTOINT(PlayerHUDOptionsPowerMode, bEnableName, 0), NULL },
	{ "EnableLife",					TOK_AUTOINT(PlayerHUDOptionsPowerMode, bEnableLife, 0), NULL },
	{ "EnableReticle",				TOK_AUTOINT(PlayerHUDOptionsPowerMode, bEnableReticle, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerHUDOptionsPowerMode()
{
	int iSize = sizeof(PlayerHUDOptionsPowerMode);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerHUDOptionsPowerMode, iSize, "PlayerHUDOptionsPowerMode", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PlayerHUDOptions[];
#define TYPE_parse_PlayerHUDOptions PlayerHUDOptions
extern ParseTable parse_PlayerHUDOptionsPowerMode[];
#define TYPE_parse_PlayerHUDOptionsPowerMode PlayerHUDOptionsPowerMode
//Structparser.exe autogenerated ParseTable for struct PlayerHUDOptionsStruct
#define TYPE_parse_PlayerHUDOptionsStruct PlayerHUDOptionsStruct
ParseTable parse_PlayerHUDOptionsStruct[] =
{
	{ "PlayerHUDOptionsStruct", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerHUDOptionsStruct), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "HUDOptions",				TOK_STRUCT(PlayerHUDOptionsStruct, eaHUDOptions, parse_PlayerHUDOptions) },
	{ "PowerModeOptions",		TOK_STRUCT(PlayerHUDOptionsStruct, eaPowerModeOptions, parse_PlayerHUDOptionsPowerMode) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerHUDOptionsStruct()
{
	int iSize = sizeof(PlayerHUDOptionsStruct);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerHUDOptionsStruct, iSize, "PlayerHUDOptionsStruct", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerPetPersistedOrder
#define TYPE_parse_PlayerPetPersistedOrder PlayerPetPersistedOrder
ParseTable parse_PlayerPetPersistedOrder[] =
{
	{ "PlayerPetPersistedOrder", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerPetPersistedOrder), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Slot",						TOK_KEY | TOK_AUTOINT(PlayerPetPersistedOrder, iSlot, 0), NULL },
	{ "Command",					TOK_POOL_STRING | TOK_STRING(PlayerPetPersistedOrder, pchCommand, 0), NULL },
	{ "uTime",						TOK_AUTOINT(PlayerPetPersistedOrder, uTime, 0), NULL },
	{ "Power",						TOK_BIT, 0, 8, NULL},
	{ "AiState",					TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PlayerPetPersistedOrder()
{
	int iSize = sizeof(PlayerPetPersistedOrder);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerPetPersistedOrder, iSize, "PlayerPetPersistedOrder", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PlayerPetPersistedOrder) + 7) / 4;
		PlayerPetPersistedOrder *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bPower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerPetPersistedOrder[5]);
		pTemp->bPower = 0;
		pTemp->bAiState = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerPetPersistedOrder[6]);
		pTemp->bAiState = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_SavedCartPower[];
#define TYPE_parse_SavedCartPower SavedCartPower
extern ParseTable parse_UIPersistedWindow[];
#define TYPE_parse_UIPersistedWindow UIPersistedWindow
extern ParseTable parse_PlayerHUDOptions[];
#define TYPE_parse_PlayerHUDOptions PlayerHUDOptions
extern ParseTable parse_PlayerPetPersistedOrder[];
#define TYPE_parse_PlayerPetPersistedOrder PlayerPetPersistedOrder
extern ParseTable parse_PlayerShowOverhead[];
#define TYPE_parse_PlayerShowOverhead PlayerShowOverhead
//Structparser.exe autogenerated ParseTable for struct PlayerLooseUI
#define TYPE_parse_PlayerLooseUI PlayerLooseUI
ParseTable parse_PlayerLooseUI[] =
{
	{ "PlayerLooseUI", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerLooseUI), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "SavedCartPowers",		TOK_STRUCT(PlayerLooseUI, ppSavedCartPowers, parse_SavedCartPower) },
	{ "PersistedWindow",		TOK_STRUCT(PlayerLooseUI, eaPersistedWindows, parse_UIPersistedWindow) },
	{ "PlayingStyles",			TOK_STRING(PlayerLooseUI, pchPlayingStyles, 0), NULL },
	{ "HUDOptions",				TOK_STRUCT(PlayerLooseUI, eaHUDOptions, parse_PlayerHUDOptions) },
	{ "PetCommandOrder",		TOK_STRUCT(PlayerLooseUI, eaPetCommandOrder, parse_PlayerPetPersistedOrder) },
	{ "LockTray",				TOK_BIT, 0, 8, NULL},
	{ "AutoSideKick",			TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "ShowAstrometrics",		TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "ShowDistantSystems",		TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "ShowNearSystems",		TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "ShowNearSystemTooltips",	TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "eNotifyAudioMode",		TOK_AUTOINT(PlayerLooseUI, eNotifyAudioMode_Obsolete, PlayerNotifyAudioMode_Standard), PlayerNotifyAudioModeEnum },
	{ "ShowOverhead",			TOK_OPTIONALSTRUCT(PlayerLooseUI, pShowOverhead_Obsolete, parse_PlayerShowOverhead) },
	{ "uiTrayMode",				TOK_AUTOINT(PlayerLooseUI, uiTrayMode_Obsolete, 0), NULL },
	{ "uiPowerLevelsMode",		TOK_AUTOINT(PlayerLooseUI, uiPowerLevelsMode_Obsolete, 0), NULL },
	{ "ShowMapChoice",			TOK_IGNORE, 0 },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PlayerLooseUI()
{
	int iSize = sizeof(PlayerLooseUI);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerLooseUI, iSize, "PlayerLooseUI", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PlayerLooseUI) + 7) / 4;
		PlayerLooseUI *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bLockTray = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerLooseUI[7]);
		pTemp->bLockTray = 0;
		pTemp->bAutoSidekick = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerLooseUI[8]);
		pTemp->bAutoSidekick = 0;
		pTemp->bShowAstrometrics = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerLooseUI[9]);
		pTemp->bShowAstrometrics = 0;
		pTemp->bShowDistantSystems = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerLooseUI[10]);
		pTemp->bShowDistantSystems = 0;
		pTemp->bShowNearSystems = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerLooseUI[11]);
		pTemp->bShowNearSystems = 0;
		pTemp->bShowNearSystemTooltips = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerLooseUI[12]);
		pTemp->bShowNearSystemTooltips = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerUIPair
#define TYPE_parse_PlayerUIPair PlayerUIPair
ParseTable parse_PlayerUIPair[] =
{
	{ "PlayerUIPair", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerUIPair), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "pchKey",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_KEY | TOK_STRING(PlayerUIPair, pchKey, 0), NULL },
	{ "pchValue",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(PlayerUIPair, pchValue, 0), NULL },
	{ "uiTime",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerUIPair, uiTime, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerUIPair()
{
	int iSize = sizeof(PlayerUIPair);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerUIPair, iSize, "PlayerUIPair", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerMacro
#define TYPE_parse_PlayerMacro PlayerMacro
ParseTable parse_PlayerMacro[] =
{
	{ "PlayerMacro", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerMacro), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "MacroID",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_KEY | TOK_AUTOINT(PlayerMacro, uMacroID, 0), NULL },
	{ "uMacroID",		TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerMacro, uMacroID, 0), NULL },
	{ "Macro",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(PlayerMacro, pchMacro, 0), NULL },
	{ "pchMacro",		TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(PlayerMacro, pchMacro, 0), NULL },
	{ "Desc",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(PlayerMacro, pchDescription, 0), NULL },
	{ "pchDescription",	TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(PlayerMacro, pchDescription, 0), NULL },
	{ "Icon",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_POOL_STRING | TOK_STRING(PlayerMacro, pchIcon, 0), NULL },
	{ "pchIcon",		TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_POOL_STRING | TOK_STRING(PlayerMacro, pchIcon, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerMacro()
{
	int iSize = sizeof(PlayerMacro);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerMacro, iSize, "PlayerMacro", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerUIMapRegionScale
#define TYPE_parse_PlayerUIMapRegionScale PlayerUIMapRegionScale
ParseTable parse_PlayerUIMapRegionScale[] =
{
	{ "PlayerUIMapRegionScale", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerUIMapRegionScale), 0, NULL, 0, NULL },
	{ "eType",					TOK_STRUCTPARAM | TOK_PERSIST | TOK_NO_TRANSACT | TOK_KEY | TOK_REQUIRED | TOK_AUTOINT(PlayerUIMapRegionScale, eType, 0), WorldRegionTypeEnum },
	{ "fScale",					TOK_STRUCTPARAM | TOK_PERSIST | TOK_NO_TRANSACT | TOK_REQUIRED | TOK_F32(PlayerUIMapRegionScale, fScale, 0), NULL },
	{ "\n",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerUIMapRegionScale()
{
	int iSize = sizeof(PlayerUIMapRegionScale);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerUIMapRegionScale, iSize, "PlayerUIMapRegionScale", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_UIPersistedPosition[];
#define TYPE_parse_UIPersistedPosition UIPersistedPosition
extern ParseTable parse_UIPersistedList[];
#define TYPE_parse_UIPersistedList UIPersistedList
extern ParseTable parse_PlayerUIPair[];
#define TYPE_parse_PlayerUIPair PlayerUIPair
extern ParseTable parse_ControlSchemes[];
#define TYPE_parse_ControlSchemes ControlSchemes
extern ParseTable parse_MapRevealInfo[];
#define TYPE_parse_MapRevealInfo MapRevealInfo
extern ParseTable parse_PlayerMacro[];
#define TYPE_parse_PlayerMacro PlayerMacro
extern ParseTable parse_NotifySetting[];
#define TYPE_parse_NotifySetting NotifySetting
extern ParseTable parse_ChatMailList[];
#define TYPE_parse_ChatMailList ChatMailList
extern ParseTable parse_ChatConfig[];
#define TYPE_parse_ChatConfig ChatConfig
extern ParseTable parse_ChatState[];
#define TYPE_parse_ChatState ChatState
extern ParseTable parse_EntityKeyBinds[];
#define TYPE_parse_EntityKeyBinds EntityKeyBinds
extern ParseTable parse_PlayerLooseUI[];
#define TYPE_parse_PlayerLooseUI PlayerLooseUI
extern ParseTable parse_PlayerUIMapRegionScale[];
#define TYPE_parse_PlayerUIMapRegionScale PlayerUIMapRegionScale
//Structparser.exe autogenerated ParseTable for struct PlayerUI
#define TYPE_parse_PlayerUI PlayerUI
ParseTable parse_PlayerUI[] =
{
	{ "PlayerUI", 							TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerUI), 0, NULL, 0, NULL },
	{ "{",									TOK_START, 0 },
	{ "eaStoredPositions",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRUCT(PlayerUI, eaStoredPositions, parse_UIPersistedPosition) },
	{ "eaStoredLists",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRUCT(PlayerUI, eaStoredLists, parse_UIPersistedList) },
	{ "eaPairs",							TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRUCT(PlayerUI, eaPairs, parse_PlayerUIPair) },
	{ "ePowerTooltipDetail",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerUI, ePowerTooltipDetail, 0), AutoDescDetailEnum },
	{ "ePowerInspectDetail",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerUI, ePowerInspectDetail, 0), AutoDescDetailEnum },
	{ "pSchemes",							TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_ALWAYS_ALLOC | TOK_OPTIONALSTRUCT(PlayerUI, pSchemes, parse_ControlSchemes) },
	{ "MapRevealInfo",						TOK_USEROPTIONBIT_2 | TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRUCT(PlayerUI, eaMapRevealInfos, parse_MapRevealInfo) },
	{ "eaMapRevealInfos",					TOK_REDUNDANTNAME | TOK_USEROPTIONBIT_2 | TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRUCT(PlayerUI, eaMapRevealInfos, parse_MapRevealInfo) },
	{ "eaMacros",							TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRUCT(PlayerUI, eaMacros, parse_PlayerMacro) },
	{ "uMacroIDMax",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerUI, uMacroIDMax, 0), NULL },
	{ "NotifySetting",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRUCT(PlayerUI, eaNotifySettings, parse_NotifySetting) },
	{ "eaNotifySettings",					TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRUCT(PlayerUI, eaNotifySettings, parse_NotifySetting) },
	{ "iNotifySettingVersion",				TOK_SELF_ONLY | TOK_AUTOINT(PlayerUI, iNotifySettingVersion, 0), NULL },
	{ "pMailList",							TOK_USEROPTIONBIT_2 | TOK_CLIENT_ONLY | TOK_OPTIONALSTRUCT(PlayerUI, pMailList, parse_ChatMailList) },
	{ "bUnreadMail",						TOK_USEROPTIONBIT_2 | TOK_CLIENT_ONLY | TOK_AUTOINT(PlayerUI, bUnreadMail, 0), NULL },
	{ "pChatConfig",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_OPTIONALSTRUCT(PlayerUI, pChatConfig, parse_ChatConfig) },
	{ "pChatState",							TOK_USEROPTIONBIT_2 | TOK_ALWAYS_ALLOC | TOK_OPTIONALSTRUCT(PlayerUI, pChatState, parse_ChatState) },
	{ "Binds",								TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRUCT(PlayerUI, eaBindProfiles, parse_EntityKeyBinds) },
	{ "eaBindProfiles",						TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRUCT(PlayerUI, eaBindProfiles, parse_EntityKeyBinds) },
	{ "uiLastClientPoke",					TOK_USEROPTIONBIT_2 | TOK_SERVER_ONLY | TOK_AUTOINT(PlayerUI, uiLastClientPoke, 0), NULL },
	{ "bIdleKickWarned",					TOK_USEROPTIONBIT_2 | TOK_SERVER_ONLY | TOK_AUTOINT(PlayerUI, bIdleKickWarned, 0), NULL },
	{ "pLooseUI",							TOK_ALWAYS_ALLOC | TOK_OPTIONALSTRUCT(PlayerUI, pLooseUI, parse_PlayerLooseUI) },
	{ "pchLooseUI",							TOK_USEROPTIONBIT_2 | TOK_PERSIST | TOK_NO_TRANSACT | TOK_ESTRING | TOK_STRING(PlayerUI, pchLooseUI, 0), NULL },
	{ "pchLastEmote",						TOK_USEROPTIONBIT_2 | TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRING(PlayerUI, pchLastEmote, 0), NULL },
	{ "uiLastEmoteTime",					TOK_USEROPTIONBIT_2 | TOK_SERVER_ONLY | TOK_AUTOINT(PlayerUI, uiLastEmoteTime, 0), NULL },
	{ "hLastEmoteTarget",					TOK_USEROPTIONBIT_2 | TOK_SERVER_ONLY | TOK_AUTOINT(PlayerUI, hLastEmoteTarget, 0), NULL },
	{ "eLastRegion",						TOK_USEROPTIONBIT_2 | TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerUI, eLastRegion, 0), WorldRegionTypeEnum },
	{ "eaRegionScales",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRUCT(PlayerUI, eaRegionScales, parse_PlayerUIMapRegionScale) },
	{ "pchUserColorPalette",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRING(PlayerUI, pchUserColorPalette, 0), NULL },
	{ "ubfColorPaletteStateDisables",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerUI, ubfColorPaletteStateDisables, 0), NULL },
	{ "bGoldenPathActive",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerUI, bGoldenPathActive, 1), NULL },
	{ "bDisallowGuildInvites",				TOK_USEROPTIONBIT_2 | TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerUI, bDisallowGuildInvites, 0), NULL },
	{ "dirtyBit",							TOK_USEROPTIONBIT_2 | TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(PlayerUI, dirtyBit, 0), NULL },
	{ "uiLastLevelPowersMenuAt",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerUI, uiLastLevelPowersMenuAt, 1), NULL },
	{ "uiLevelUpWizardDismissedAt",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerUI, uiLevelUpWizardDismissedAt, 1), NULL },
	{ "uiCompactMode",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_BIT, 0, 8, NULL},
	{ "uiDisableDamageOverlays",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_BIT, 0, 8, NULL},
	{ "iKeybindsVersion",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerUI, iKeybindsVersion, 0), NULL },
	{ "uiStickerBookHasUnviewedChanges",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PlayerUI, uiStickerBookHasUnviewedChanges, 0), NULL },
	{ "}",									TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PlayerUI()
{
	int iSize = sizeof(PlayerUI);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerUI, iSize, "PlayerUI", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(PlayerUI)) + 7) / 4;
		NOCONST(PlayerUI) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->uiCompactMode = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerUI[37]);
		pTemp->uiCompactMode = 0;
		pTemp->uiDisableDamageOverlays = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerUI[38]);
		pTemp->uiDisableDamageOverlays = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PetCooldownTimer
#define TYPE_parse_PetCooldownTimer PetCooldownTimer
ParseTable parse_PetCooldownTimer[] =
{
	{ "PetCooldownTimer", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PetCooldownTimer), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "PowerCategory",		TOK_AUTOINT(PetCooldownTimer, iPowerCategory, 0), NULL },
	{ "Cooldown",			TOK_F32(PetCooldownTimer, fCooldown, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PetCooldownTimer()
{
	int iSize = sizeof(PetCooldownTimer);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PetCooldownTimer, iSize, "PetCooldownTimer", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PetPowerState
#define TYPE_parse_PetPowerState PetPowerState
ParseTable parse_PetPowerState[] =
{
	{ "PetPowerState", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PetPowerState), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "hdef",				TOK_REFERENCE(PetPowerState, hdef, 0, "PowerDef") },
	{ "TimerRecharge",		TOK_CLIENT_ONLY | TOK_F32(PetPowerState, fTimerRecharge, 0), NULL },
	{ "TimerRechargeBase",	TOK_CLIENT_ONLY | TOK_F32(PetPowerState, fTimerRechargeBase, 0), NULL },
	{ "QueuedForUse",		TOK_BIT, 0, 8, NULL},
	{ "AIUsageDisabled",	TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PetPowerState()
{
	int iSize = sizeof(PetPowerState);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PetPowerState, iSize, "PetPowerState", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PetPowerState) + 7) / 4;
		PetPowerState *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bQueuedForUse = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PetPowerState[5]);
		pTemp->bQueuedForUse = 0;
		pTemp->bAIUsageDisabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PetPowerState[6]);
		pTemp->bAIUsageDisabled = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PetCommandNameInfo
#define TYPE_parse_PetCommandNameInfo PetCommandNameInfo
ParseTable parse_PetCommandNameInfo[] =
{
	{ "PetCommandNameInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PetCommandNameInfo), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Name",				TOK_POOL_STRING | TOK_STRING(PetCommandNameInfo, pchName, 0), NULL },
	{ "DisplayName",		TOK_REFERENCE(PetCommandNameInfo, pchDisplayName, 0, "Message") },
	{ "Icon",				TOK_GLOBAL_NAME | TOK_POOL_STRING | TOK_STRING(PetCommandNameInfo, pchIcon, 0), "Texture" },
	{ "Hidden",				TOK_AUTOINT(PetCommandNameInfo, bHidden, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PetCommandNameInfo()
{
	int iSize = sizeof(PetCommandNameInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PetCommandNameInfo, iSize, "PetCommandNameInfo", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PetCommandNameInfo[];
#define TYPE_parse_PetCommandNameInfo PetCommandNameInfo
//Structparser.exe autogenerated ParseTable for struct PetStanceInfo
#define TYPE_parse_PetStanceInfo PetStanceInfo
ParseTable parse_PetStanceInfo[] =
{
	{ "PetStanceInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PetStanceInfo), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "curStance",		TOK_POOL_STRING | TOK_STRING(PetStanceInfo, curStance, 0), NULL },
	{ "validStances",	TOK_STRUCT(PetStanceInfo, validStances, parse_PetCommandNameInfo) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PetStanceInfo()
{
	int iSize = sizeof(PetStanceInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PetStanceInfo, iSize, "PetStanceInfo", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PetCommandNameInfo[];
#define TYPE_parse_PetCommandNameInfo PetCommandNameInfo
extern ParseTable parse_PetStanceInfo[];
#define TYPE_parse_PetStanceInfo PetStanceInfo
extern ParseTable parse_PetPowerState[];
#define TYPE_parse_PetPowerState PetPowerState
extern ParseTable parse_PetCooldownTimer[];
#define TYPE_parse_PetCooldownTimer PetCooldownTimer
//Structparser.exe autogenerated ParseTable for struct PlayerPetInfo
#define TYPE_parse_PlayerPetInfo PlayerPetInfo
ParseTable parse_PlayerPetInfo[] =
{
	{ "PlayerPetInfo", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerPetInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "PartitionIdx",			TOK_AUTOINT(PlayerPetInfo, iPartitionIdx, 0), NULL },
	{ "PetRef",					TOK_AUTOINT(PlayerPetInfo, iPetRef, 0), NULL },
	{ "curPetState",			TOK_POOL_STRING | TOK_STRING(PlayerPetInfo, curPetState, 0), NULL },
	{ "validStates",			TOK_STRUCT(PlayerPetInfo, validStates, parse_PetCommandNameInfo) },
	{ "Stances",				TOK_STRUCT(PlayerPetInfo, eaStances, parse_PetStanceInfo) },
	{ "PowerStates",			TOK_STRUCT(PlayerPetInfo, ppPowerStates, parse_PetPowerState) },
	{ "CooldownTimers",			TOK_STRUCT(PlayerPetInfo, ppCooldownTimers, parse_PetCooldownTimer) },
	{ "AttribSpeedRecharge",	TOK_F32(PlayerPetInfo, fAttribSpeedRecharge, 0), NULL },
	{ "AttribSpeedCooldown",	TOK_F32(PlayerPetInfo, fAttribSpeedCooldown, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerPetInfo()
{
	int iSize = sizeof(PlayerPetInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerPetInfo, iSize, "PlayerPetInfo", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CSRListenerInfo
#define TYPE_parse_CSRListenerInfo CSRListenerInfo
ParseTable parse_CSRListenerInfo[] =
{
	{ "CSRListenerInfo", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CSRListenerInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "listenerType",			TOK_AUTOINT(CSRListenerInfo, listenerType, 0), GlobalTypeEnum },
	{ "listenerID",				TOK_AUTOINT(CSRListenerInfo, listenerID, 0), NULL },
	{ "listenerName",			TOK_STRING(CSRListenerInfo, listenerName, 0), NULL },
	{ "listenerAccount",		TOK_STRING(CSRListenerInfo, listenerAccount, 0), NULL },
	{ "uValidUntilTime",		TOK_AUTOINT(CSRListenerInfo, uValidUntilTime, 0), NULL },
	{ "listenerAccessLevel",	TOK_AUTOINT(CSRListenerInfo, listenerAccessLevel, 0), AccessLevelEnum },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CSRListenerInfo()
{
	int iSize = sizeof(CSRListenerInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CSRListenerInfo, iSize, "CSRListenerInfo", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_CombatDebugPerfEvent[];
#define TYPE_parse_CombatDebugPerfEvent CombatDebugPerfEvent
extern ParseTable parse_EncounterDebug[];
#define TYPE_parse_EncounterDebug EncounterDebug
extern ParseTable parse_AIDebug[];
#define TYPE_parse_AIDebug AIDebug
extern ParseTable parse_BeaconDebugInfo[];
#define TYPE_parse_BeaconDebugInfo BeaconDebugInfo
//Structparser.exe autogenerated ParseTable for struct PlayerDebug
#define TYPE_parse_PlayerDebug PlayerDebug
ParseTable parse_PlayerDebug[] =
{
	{ "PlayerDebug", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerDebug), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "CombatEvents",				TOK_STRUCT(PlayerDebug, ppCombatEvents, parse_CombatDebugPerfEvent) },
	{ "encDebug",					TOK_OPTIONALSTRUCT(PlayerDebug, encDebug, parse_EncounterDebug) },
	{ "showServerFPS",				TOK_AUTOINT(PlayerDebug, showServerFPS, 0), NULL },
	{ "currServerFPS",				TOK_F32(PlayerDebug, currServerFPS, 0), NULL },
	{ "clientsLoggedInCount",		TOK_AUTOINT(PlayerDebug, clientsLoggedInCount, 0), NULL },
	{ "clientsNotLoggedInCount",	TOK_AUTOINT(PlayerDebug, clientsNotLoggedInCount, 0), NULL },
	{ "numSpawnedEnts",				TOK_AUTOINT(PlayerDebug, numSpawnedEnts, 0), NULL },
	{ "numRunningEncs",				TOK_AUTOINT(PlayerDebug, numRunningEncs, 0), NULL },
	{ "numTotalEncs",				TOK_AUTOINT(PlayerDebug, numTotalEncs, 0), NULL },
	{ "spawnedFSMCost",				TOK_AUTOINT(PlayerDebug, spawnedFSMCost, 0), NULL },
	{ "potentialFSMCost",			TOK_AUTOINT(PlayerDebug, potentialFSMCost, 0), NULL },
	{ "canRepeatMissions",			TOK_AUTOINT(PlayerDebug, canRepeatMissions, 0), NULL },
	{ "aiDebugInfo",				TOK_OPTIONALSTRUCT(PlayerDebug, aiDebugInfo, parse_AIDebug) },
	{ "bcnDebugInfo",				TOK_OPTIONALSTRUCT(PlayerDebug, bcnDebugInfo, parse_BeaconDebugInfo) },
	{ "showPathPerfCmds",			TOK_BIT, 0, 8, NULL},
	{ "showPathPerfLiving",			TOK_BIT, 0, 8, NULL},
	{ "showPhysicsPerfMenu",		TOK_BIT, 0, 8, NULL},
	{ "combatDebugPerf",			TOK_BIT, 0, 8, NULL},
	{ "showMissionDebugMenu",		TOK_BIT, 0, 8, NULL},
	{ "allowAllInteractions",		TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PlayerDebug()
{
	int iSize = sizeof(PlayerDebug);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerDebug, iSize, "PlayerDebug", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PlayerDebug) + 7) / 4;
		PlayerDebug *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->showPathPerfCmds = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerDebug[16]);
		pTemp->showPathPerfCmds = 0;
		pTemp->showPathPerfLiving = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerDebug[17]);
		pTemp->showPathPerfLiving = 0;
		pTemp->showPhysicsPerfMenu = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerDebug[18]);
		pTemp->showPhysicsPerfMenu = 0;
		pTemp->combatDebugPerf = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerDebug[19]);
		pTemp->combatDebugPerf = 0;
		pTemp->showMissionDebugMenu = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerDebug[20]);
		pTemp->showMissionDebugMenu = 0;
		pTemp->allowAllInteractions = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PlayerDebug[21]);
		pTemp->allowAllInteractions = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InventorySlot[];
#define TYPE_parse_InventorySlot InventorySlot
//Structparser.exe autogenerated ParseTable for struct NPCEMailData
#define TYPE_parse_NPCEMailData NPCEMailData
ParseTable parse_NPCEMailData[] =
{
	{ "NPCEMailData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(NPCEMailData), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "iNPCEMailID",	TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(NPCEMailData, iNPCEMailID, 0), NULL },
	{ "sentTime",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(NPCEMailData, sentTime, 0), NULL },
	{ "fromName",		TOK_PERSIST | TOK_ESTRING | TOK_SUBSCRIBE | TOK_STRING(NPCEMailData, fromName, 0), NULL },
	{ "subject",		TOK_PERSIST | TOK_ESTRING | TOK_SUBSCRIBE | TOK_STRING(NPCEMailData, subject, 0), NULL },
	{ "body",			TOK_PERSIST | TOK_ESTRING | TOK_SUBSCRIBE | TOK_STRING(NPCEMailData, body, 0), NULL },
	{ "ppItemSlot",		TOK_PERSIST | TOK_NO_INDEX | TOK_SUBSCRIBE | TOK_STRUCT(NPCEMailData, ppItemSlot, parse_InventorySlot) },
	{ "bRead",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(NPCEMailData, bRead, 0), NULL },
	{ "eType",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(NPCEMailData, eType, 0), NPCEmailTypeEnum },
	{ "pReason",		TOK_PERSIST | TOK_ESTRING | TOK_SUBSCRIBE | TOK_STRING(NPCEMailData, pReason, 0), NULL },
	{ "pDetail",		TOK_PERSIST | TOK_ESTRING | TOK_SUBSCRIBE | TOK_STRING(NPCEMailData, pDetail, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_NPCEMailData()
{
	int iSize = sizeof(NPCEMailData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_NPCEMailData, iSize, "NPCEMailData", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_NPCEMailData[];
#define TYPE_parse_NPCEMailData NPCEMailData
//Structparser.exe autogenerated ParseTable for struct NPCEMail
#define TYPE_parse_NPCEMail NPCEMail
ParseTable parse_NPCEMail[] =
{
	{ "NPCEMail", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(NPCEMail), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "iLastUsedID",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(NPCEMail, iLastUsedID, 0), NULL },
	{ "mail",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_STRUCT(NPCEMail, mail, parse_NPCEMailData) },
	{ "uNextFutureDelivery",	TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(NPCEMail, uNextFutureDelivery, 0), NULL },
	{ "bUnreadMail",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(NPCEMail, bUnreadMail, 0), NULL },
	{ "bReadAll",				TOK_IGNORE, 0 },
	{ "uLastSyncTime",			TOK_IGNORE, 0 },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_NPCEMail()
{
	int iSize = sizeof(NPCEMail);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_NPCEMail, iSize, "NPCEMail", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InventorySlotV1[];
#define TYPE_parse_InventorySlotV1 InventorySlotV1
//Structparser.exe autogenerated ParseTable for struct NPCEMailDataV1
#define TYPE_parse_NPCEMailDataV1 NPCEMailDataV1
ParseTable parse_NPCEMailDataV1[] =
{
	{ "NPCEMailDataV1", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(NPCEMailDataV1), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "iNPCEMailID",	TOK_PERSIST | TOK_AUTOINT(NPCEMailDataV1, iNPCEMailID, 0), NULL },
	{ "sentTime",		TOK_PERSIST | TOK_AUTOINT(NPCEMailDataV1, sentTime, 0), NULL },
	{ "fromName",		TOK_PERSIST | TOK_ESTRING | TOK_STRING(NPCEMailDataV1, fromName, 0), NULL },
	{ "subject",		TOK_PERSIST | TOK_ESTRING | TOK_STRING(NPCEMailDataV1, subject, 0), NULL },
	{ "body",			TOK_PERSIST | TOK_ESTRING | TOK_STRING(NPCEMailDataV1, body, 0), NULL },
	{ "ppItemSlot",		TOK_PERSIST | TOK_NO_INDEX | TOK_STRUCT(NPCEMailDataV1, ppItemSlot, parse_InventorySlotV1) },
	{ "bRead",			TOK_PERSIST | TOK_AUTOINT(NPCEMailDataV1, bRead, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_NPCEMailDataV1()
{
	int iSize = sizeof(NPCEMailDataV1);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_NPCEMailDataV1, iSize, "NPCEMailDataV1", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_NPCEMailDataV1[];
#define TYPE_parse_NPCEMailDataV1 NPCEMailDataV1
//Structparser.exe autogenerated ParseTable for struct NPCEMailV1
#define TYPE_parse_NPCEMailV1 NPCEMailV1
ParseTable parse_NPCEMailV1[] =
{
	{ "NPCEMailV1", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(NPCEMailV1), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "iLastUsedID",	TOK_PERSIST | TOK_AUTOINT(NPCEMailV1, iLastUsedID, 0), NULL },
	{ "mail",			TOK_PERSIST | TOK_STRUCT(NPCEMailV1, mail, parse_NPCEMailDataV1) },
	{ "uLastSyncTime",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(NPCEMailV1, uLastSyncTime, 0), NULL },
	{ "bReadAll",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(NPCEMailV1, bReadAll, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_NPCEMailV1()
{
	int iSize = sizeof(NPCEMailV1);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_NPCEMailV1, iSize, "NPCEMailV1", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerActivityEntry
#define TYPE_parse_PlayerActivityEntry PlayerActivityEntry
ParseTable parse_PlayerActivityEntry[] =
{
	{ "PlayerActivityEntry", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerActivityEntry), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "service",				TOK_PERSIST | TOK_POOL_STRING | TOK_STRING(PlayerActivityEntry, service, 0), NULL },
	{ "type",					TOK_PERSIST | TOK_POOL_STRING | TOK_STRING(PlayerActivityEntry, type, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerActivityEntry()
{
	int iSize = sizeof(PlayerActivityEntry);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerActivityEntry, iSize, "PlayerActivityEntry", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerActivityEnrollment
#define TYPE_parse_PlayerActivityEnrollment PlayerActivityEnrollment
ParseTable parse_PlayerActivityEnrollment[] =
{
	{ "PlayerActivityEnrollment", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerActivityEnrollment), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "service",					TOK_PERSIST | TOK_POOL_STRING | TOK_STRING(PlayerActivityEnrollment, service, 0), NULL },
	{ "state",						TOK_PERSIST | TOK_AUTOINT(PlayerActivityEnrollment, state, 0), NULL },
	{ "userdata",					TOK_PERSIST | TOK_ESTRING | TOK_STRING(PlayerActivityEnrollment, userdata, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerActivityEnrollment()
{
	int iSize = sizeof(PlayerActivityEnrollment);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerActivityEnrollment, iSize, "PlayerActivityEnrollment", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerActivityVerbosity
#define TYPE_parse_PlayerActivityVerbosity PlayerActivityVerbosity
ParseTable parse_PlayerActivityVerbosity[] =
{
	{ "PlayerActivityVerbosity", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerActivityVerbosity), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "service",					TOK_PERSIST | TOK_POOL_STRING | TOK_STRING(PlayerActivityVerbosity, service, 0), NULL },
	{ "level",						TOK_PERSIST | TOK_AUTOINT(PlayerActivityVerbosity, level, 0), ActivityVerbosityEnum },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerActivityVerbosity()
{
	int iSize = sizeof(PlayerActivityVerbosity);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerActivityVerbosity, iSize, "PlayerActivityVerbosity", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PlayerActivityEntry[];
#define TYPE_parse_PlayerActivityEntry PlayerActivityEntry
extern ParseTable parse_PlayerActivityEnrollment[];
#define TYPE_parse_PlayerActivityEnrollment PlayerActivityEnrollment
extern ParseTable parse_PlayerActivityVerbosity[];
#define TYPE_parse_PlayerActivityVerbosity PlayerActivityVerbosity
//Structparser.exe autogenerated ParseTable for struct PlayerActivity
#define TYPE_parse_PlayerActivity PlayerActivity
ParseTable parse_PlayerActivity[] =
{
	{ "PlayerActivity", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerActivity), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "disabled",		TOK_PERSIST | TOK_STRUCT(PlayerActivity, disabled, parse_PlayerActivityEntry) },
	{ "enrollment",		TOK_PERSIST | TOK_STRUCT(PlayerActivity, enrollment, parse_PlayerActivityEnrollment) },
	{ "verbosity",		TOK_PERSIST | TOK_STRUCT(PlayerActivity, verbosity, parse_PlayerActivityVerbosity) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerActivity()
{
	int iSize = sizeof(PlayerActivity);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerActivity, iSize, "PlayerActivity", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerVisitedMap
#define TYPE_parse_PlayerVisitedMap PlayerVisitedMap
ParseTable parse_PlayerVisitedMap[] =
{
	{ "PlayerVisitedMap", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerVisitedMap), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "pchMapName",			TOK_PERSIST | TOK_POOL_STRING | TOK_KEY | TOK_STRING(PlayerVisitedMap, pchMapName, 0), NULL },
	{ "eaMapVariables",		TOK_PERSIST | TOK_STRINGARRAY(PlayerVisitedMap, eaMapVariables), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerVisitedMap()
{
	int iSize = sizeof(PlayerVisitedMap);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerVisitedMap, iSize, "PlayerVisitedMap", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PlayerVisitedMap[];
#define TYPE_parse_PlayerVisitedMap PlayerVisitedMap
//Structparser.exe autogenerated ParseTable for struct PlayerVisitedMaps
#define TYPE_parse_PlayerVisitedMaps PlayerVisitedMaps
ParseTable parse_PlayerVisitedMaps[] =
{
	{ "PlayerVisitedMaps", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerVisitedMaps), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "dirtyBit",			TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(PlayerVisitedMaps, dirtyBit, 0), NULL },
	{ "eaMaps",				TOK_PERSIST | TOK_STRUCT(PlayerVisitedMaps, eaMaps, parse_PlayerVisitedMap) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerVisitedMaps()
{
	int iSize = sizeof(PlayerVisitedMaps);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerVisitedMaps, iSize, "PlayerVisitedMaps", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InteriorRef
#define TYPE_parse_InteriorRef InteriorRef
ParseTable parse_InteriorRef[] =
{
	{ "InteriorRef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InteriorRef), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "hDef",			TOK_PERSIST | TOK_REFERENCE(InteriorRef, hDef, 0, "InteriorDef") },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InteriorRef()
{
	int iSize = sizeof(InteriorRef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InteriorRef, iSize, "InteriorRef", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DaboBet
#define TYPE_parse_DaboBet DaboBet
ParseTable parse_DaboBet[] =
{
	{ "DaboBet", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DaboBet), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "BetIndex",	TOK_PERSIST | TOK_KEY | TOK_AUTOINT(DaboBet, iBetIndex, 0), NULL },
	{ "uSpinIndex",	TOK_REDUNDANTNAME | TOK_PERSIST | TOK_AUTOINT(DaboBet, iBetIndex, 0), NULL },
	{ "iBetIndex",	TOK_REDUNDANTNAME | TOK_PERSIST | TOK_AUTOINT(DaboBet, iBetIndex, 0), NULL },
	{ "pchNumeric",	TOK_PERSIST | TOK_POOL_STRING | TOK_STRING(DaboBet, pchNumeric, 0), NULL },
	{ "iBetAmount",	TOK_PERSIST | TOK_AUTOINT(DaboBet, iBetAmount, 0), NULL },
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DaboBet()
{
	int iSize = sizeof(DaboBet);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DaboBet, iSize, "DaboBet", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DaboBet[];
#define TYPE_parse_DaboBet DaboBet
//Structparser.exe autogenerated ParseTable for struct MinigameData
#define TYPE_parse_MinigameData MinigameData
ParseTable parse_MinigameData[] =
{
	{ "MinigameData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MinigameData), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "DaboBets",		TOK_PERSIST | TOK_STRUCT(MinigameData, eaDaboBets, parse_DaboBet) },
	{ "pDaboBet",		TOK_REDUNDANTNAME | TOK_PERSIST | TOK_STRUCT(MinigameData, eaDaboBets, parse_DaboBet) },
	{ "eaDaboBets",		TOK_REDUNDANTNAME | TOK_PERSIST | TOK_STRUCT(MinigameData, eaDaboBets, parse_DaboBet) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MinigameData()
{
	int iSize = sizeof(MinigameData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MinigameData, iSize, "MinigameData", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerEntCopyForInfo
#define TYPE_parse_PlayerEntCopyForInfo PlayerEntCopyForInfo
ParseTable parse_PlayerEntCopyForInfo[] =
{
	{ "PlayerEntCopyForInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerEntCopyForInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "myContainerID",			TOK_AUTOINT(PlayerEntCopyForInfo, myContainerID, 0), NULL },
	{ "myEntityType",			TOK_AUTOINT(PlayerEntCopyForInfo, myEntityType, 0), GlobalTypeEnum },
	{ "hEnt",					TOK_REFERENCE(PlayerEntCopyForInfo, hEnt, 0, "CopyDict_ENTITYPLAYER") },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerEntCopyForInfo()
{
	int iSize = sizeof(PlayerEntCopyForInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerEntCopyForInfo, iSize, "PlayerEntCopyForInfo", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerAuctionData
#define TYPE_parse_PlayerAuctionData PlayerAuctionData
ParseTable parse_PlayerAuctionData[] =
{
	{ "PlayerAuctionData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerAuctionData), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "eaiAuctionsBid",		TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_INTARRAY(PlayerAuctionData, eaiAuctionsBid),  NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerAuctionData()
{
	int iSize = sizeof(PlayerAuctionData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerAuctionData, iSize, "PlayerAuctionData", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerNumericThreshold
#define TYPE_parse_PlayerNumericThreshold PlayerNumericThreshold
ParseTable parse_PlayerNumericThreshold[] =
{
	{ "PlayerNumericThreshold", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerNumericThreshold), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "astrThresholdName",		TOK_PERSIST | TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_KEY | TOK_STRING(PlayerNumericThreshold, astrThresholdName, 0), NULL },
	{ "iNumericEarned",			TOK_PERSIST | TOK_SERVER_ONLY | TOK_AUTOINT(PlayerNumericThreshold, iNumericEarned, 0), NULL },
	{ "uTimestamp",				TOK_PERSIST | TOK_SERVER_ONLY | TOK_AUTOINT(PlayerNumericThreshold, uTimestamp, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerNumericThreshold()
{
	int iSize = sizeof(PlayerNumericThreshold);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerNumericThreshold, iSize, "PlayerNumericThreshold", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PlayerNumericThreshold[];
#define TYPE_parse_PlayerNumericThreshold PlayerNumericThreshold
//Structparser.exe autogenerated ParseTable for struct PlayerNumericThresholds
#define TYPE_parse_PlayerNumericThresholds PlayerNumericThresholds
ParseTable parse_PlayerNumericThresholds[] =
{
	{ "PlayerNumericThresholds", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerNumericThresholds), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "astrItemDefName",			TOK_PERSIST | TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_KEY | TOK_STRING(PlayerNumericThresholds, astrItemDefName, 0), NULL },
	{ "eaPlayerNumericThreshold",	TOK_PERSIST | TOK_SERVER_ONLY | TOK_STRUCT(PlayerNumericThresholds, eaPlayerNumericThreshold, parse_PlayerNumericThreshold) },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerNumericThresholds()
{
	int iSize = sizeof(PlayerNumericThresholds);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerNumericThresholds, iSize, "PlayerNumericThresholds", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerQueueCooldown
#define TYPE_parse_PlayerQueueCooldown PlayerQueueCooldown
ParseTable parse_PlayerQueueCooldown[] =
{
	{ "PlayerQueueCooldown", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerQueueCooldown), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "pchCooldownDef",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_POOL_STRING | TOK_KEY | TOK_STRING(PlayerQueueCooldown, pchCooldownDef, 0), NULL },
	{ "uStartTime",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_AUTOINT(PlayerQueueCooldown, uStartTime, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerQueueCooldown()
{
	int iSize = sizeof(PlayerQueueCooldown);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerQueueCooldown, iSize, "PlayerQueueCooldown", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PlayerSubscribedEvent
#define TYPE_parse_PlayerSubscribedEvent PlayerSubscribedEvent
ParseTable parse_PlayerSubscribedEvent[] =
{
	{ "PlayerSubscribedEvent", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerSubscribedEvent), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Event",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_KEY | TOK_REFERENCE(PlayerSubscribedEvent, hEvent, 0, "EventDef") },
	{ "hEvent",						TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_REFERENCE(PlayerSubscribedEvent, hEvent, 0, "EventDef") },
	{ "EventStartTime",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_AUTOINT(PlayerSubscribedEvent, uEventStartTime, 0), NULL },
	{ "uEventStartTime",			TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_AUTOINT(PlayerSubscribedEvent, uEventStartTime, 0), NULL },
	{ "EventEndTime",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_AUTOINT(PlayerSubscribedEvent, uEventEndTime, 0), NULL },
	{ "uEventEndTime",				TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_AUTOINT(PlayerSubscribedEvent, uEventEndTime, 0), NULL },
	{ "bPreEventNotificationSent",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_AUTOINT(PlayerSubscribedEvent, bPreEventNotificationSent, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerSubscribedEvent()
{
	int iSize = sizeof(PlayerSubscribedEvent);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerSubscribedEvent, iSize, "PlayerSubscribedEvent", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_CalendarEvent[];
#define TYPE_parse_CalendarEvent CalendarEvent
extern ParseTable parse_CalendarEvent[];
#define TYPE_parse_CalendarEvent CalendarEvent
extern ParseTable parse_CalendarRequest[];
#define TYPE_parse_CalendarRequest CalendarRequest
extern ParseTable parse_PendingCalendarRequest[];
#define TYPE_parse_PendingCalendarRequest PendingCalendarRequest
extern ParseTable parse_PlayerSubscribedEvent[];
#define TYPE_parse_PlayerSubscribedEvent PlayerSubscribedEvent
//Structparser.exe autogenerated ParseTable for struct PlayerEventInfo
#define TYPE_parse_PlayerEventInfo PlayerEventInfo
ParseTable parse_PlayerEventInfo[] =
{
	{ "PlayerEventInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PlayerEventInfo), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "dirtyBit",			TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(PlayerEventInfo, dirtyBit, 0), NULL },
	{ "uLastRequestTime",	TOK_SERVER_ONLY | TOK_AUTOINT(PlayerEventInfo, uLastRequestTime, 0), NULL },
	{ "uRequestStartDate",	TOK_SELF_ONLY | TOK_AUTOINT(PlayerEventInfo, uRequestStartDate, 0), NULL },
	{ "uRequestEndDate",	TOK_SELF_ONLY | TOK_AUTOINT(PlayerEventInfo, uRequestEndDate, 0), NULL },
	{ "eaRequestedEvents",	TOK_SELF_ONLY | TOK_STRUCT(PlayerEventInfo, eaRequestedEvents, parse_CalendarEvent) },
	{ "eaActiveEvents",		TOK_SELF_ONLY | TOK_STRUCT(PlayerEventInfo, eaActiveEvents, parse_CalendarEvent) },
	{ "pServerCalendar",	TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(PlayerEventInfo, pServerCalendar, parse_CalendarRequest) },
	{ "eaPendingRequests",	TOK_SERVER_ONLY | TOK_STRUCT(PlayerEventInfo, eaPendingRequests, parse_PendingCalendarRequest) },
	{ "eaSubscribedEvents",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_STRUCT(PlayerEventInfo, eaSubscribedEvents, parse_PlayerSubscribedEvent) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PlayerEventInfo()
{
	int iSize = sizeof(PlayerEventInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PlayerEventInfo, iSize, "PlayerEventInfo", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct GatewayInfo
#define TYPE_parse_GatewayInfo GatewayInfo
ParseTable parse_GatewayInfo[] =
{
	{ "GatewayInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(GatewayInfo), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "bHidden",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_BIT, 0, 8, NULL},
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_GatewayInfo()
{
	int iSize = sizeof(GatewayInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_GatewayInfo, iSize, "GatewayInfo", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(GatewayInfo)) + 7) / 4;
		NOCONST(GatewayInfo) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bHidden = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_GatewayInfo[2]);
		pTemp->bHidden = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct StickerBookItemInfo
#define TYPE_parse_StickerBookItemInfo StickerBookItemInfo
ParseTable parse_StickerBookItemInfo[] =
{
	{ "StickerBookItemInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(StickerBookItemInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "astrItemDefName",		TOK_PERSIST | TOK_SELF_ONLY | TOK_POOL_STRING | TOK_SUBSCRIBE | TOK_KEY | TOK_STRING(StickerBookItemInfo, astrItemDefName, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_StickerBookItemInfo()
{
	int iSize = sizeof(StickerBookItemInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_StickerBookItemInfo, iSize, "StickerBookItemInfo", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct StickerBookItemSetInfo
#define TYPE_parse_StickerBookItemSetInfo StickerBookItemSetInfo
ParseTable parse_StickerBookItemSetInfo[] =
{
	{ "StickerBookItemSetInfo", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(StickerBookItemSetInfo), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "astrStickerBookItemSetRef",	TOK_PERSIST | TOK_SELF_ONLY | TOK_POOL_STRING | TOK_SUBSCRIBE | TOK_KEY | TOK_STRING(StickerBookItemSetInfo, astrStickerBookItemSetRef, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_StickerBookItemSetInfo()
{
	int iSize = sizeof(StickerBookItemSetInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_StickerBookItemSetInfo, iSize, "StickerBookItemSetInfo", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct StickerBookPointCacheData
#define TYPE_parse_StickerBookPointCacheData StickerBookPointCacheData
ParseTable parse_StickerBookPointCacheData[] =
{
	{ "StickerBookPointCacheData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(StickerBookPointCacheData), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "TotalPointsValid",			TOK_AUTOINT(StickerBookPointCacheData, bTotalPointsValid, 0), NULL },
	{ "TotalPoints",				TOK_AUTOINT(StickerBookPointCacheData, iTotalPoints, 0), NULL },
	{ "LastItemInfoSize",			TOK_AUTOINT(StickerBookPointCacheData, iLastItemInfoSize, -1), NULL },
	{ "Points",						TOK_AUTOINT(StickerBookPointCacheData, iPoints, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_StickerBookPointCacheData()
{
	int iSize = sizeof(StickerBookPointCacheData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_StickerBookPointCacheData, iSize, "StickerBookPointCacheData", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_StickerBookPointCacheData[];
#define TYPE_parse_StickerBookPointCacheData StickerBookPointCacheData
//Structparser.exe autogenerated ParseTable for struct StickerBookPointCacheByCollectionType
#define TYPE_parse_StickerBookPointCacheByCollectionType StickerBookPointCacheByCollectionType
ParseTable parse_StickerBookPointCacheByCollectionType[] =
{
	{ "StickerBookPointCacheByCollectionType", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(StickerBookPointCacheByCollectionType), 0, NULL, 0, NULL },
	{ "{",										TOK_START, 0 },
	{ "type",									TOK_KEY | TOK_AUTOINT(StickerBookPointCacheByCollectionType, type, 0), NULL },
	{ "pointCacheData",							TOK_EMBEDDEDSTRUCT(StickerBookPointCacheByCollectionType, pointCacheData, parse_StickerBookPointCacheData)},
	{ "}",										TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_StickerBookPointCacheByCollectionType()
{
	int iSize = sizeof(StickerBookPointCacheByCollectionType);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_StickerBookPointCacheByCollectionType, iSize, "StickerBookPointCacheByCollectionType", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_StickerBookPointCacheData[];
#define TYPE_parse_StickerBookPointCacheData StickerBookPointCacheData
//Structparser.exe autogenerated ParseTable for struct StickerBookPointCacheBySet
#define TYPE_parse_StickerBookPointCacheBySet StickerBookPointCacheBySet
ParseTable parse_StickerBookPointCacheBySet[] =
{
	{ "StickerBookPointCacheBySet", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(StickerBookPointCacheBySet), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "astrSetName",				TOK_POOL_STRING | TOK_KEY | TOK_STRING(StickerBookPointCacheBySet, astrSetName, 0), NULL },
	{ "pointCacheData",				TOK_EMBEDDEDSTRUCT(StickerBookPointCacheBySet, pointCacheData, parse_StickerBookPointCacheData)},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_StickerBookPointCacheBySet()
{
	int iSize = sizeof(StickerBookPointCacheBySet);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_StickerBookPointCacheBySet, iSize, "StickerBookPointCacheBySet", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_StickerBookPointCacheData[];
#define TYPE_parse_StickerBookPointCacheData StickerBookPointCacheData
extern ParseTable parse_StickerBookPointCacheBySet[];
#define TYPE_parse_StickerBookPointCacheBySet StickerBookPointCacheBySet
//Structparser.exe autogenerated ParseTable for struct StickerBookPointCacheByCollection
#define TYPE_parse_StickerBookPointCacheByCollection StickerBookPointCacheByCollection
ParseTable parse_StickerBookPointCacheByCollection[] =
{
	{ "StickerBookPointCacheByCollection", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(StickerBookPointCacheByCollection), 0, NULL, 0, NULL },
	{ "{",									TOK_START, 0 },
	{ "astrCollectionName",					TOK_POOL_STRING | TOK_KEY | TOK_STRING(StickerBookPointCacheByCollection, astrCollectionName, 0), NULL },
	{ "pointCacheData",						TOK_EMBEDDEDSTRUCT(StickerBookPointCacheByCollection, pointCacheData, parse_StickerBookPointCacheData)},
	{ "PointCacheBySet",					TOK_STRUCT(StickerBookPointCacheByCollection, eaPointCacheBySet, parse_StickerBookPointCacheBySet) },
	{ "}",									TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_StickerBookPointCacheByCollection()
{
	int iSize = sizeof(StickerBookPointCacheByCollection);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_StickerBookPointCacheByCollection, iSize, "StickerBookPointCacheByCollection", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_StickerBookPointCacheData[];
#define TYPE_parse_StickerBookPointCacheData StickerBookPointCacheData
extern ParseTable parse_StickerBookPointCacheByCollectionType[];
#define TYPE_parse_StickerBookPointCacheByCollectionType StickerBookPointCacheByCollectionType
extern ParseTable parse_StickerBookPointCacheByCollection[];
#define TYPE_parse_StickerBookPointCacheByCollection StickerBookPointCacheByCollection
//Structparser.exe autogenerated ParseTable for struct StickerBookPointCache
#define TYPE_parse_StickerBookPointCache StickerBookPointCache
ParseTable parse_StickerBookPointCache[] =
{
	{ "StickerBookPointCache", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(StickerBookPointCache), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "pointCacheData",				TOK_EMBEDDEDSTRUCT(StickerBookPointCache, pointCacheData, parse_StickerBookPointCacheData)},
	{ "PointCacheByCollectionType",	TOK_STRUCT(StickerBookPointCache, eaPointCacheByCollectionType, parse_StickerBookPointCacheByCollectionType) },
	{ "PointCacheByCollection",		TOK_STRUCT(StickerBookPointCache, eaPointCacheByCollection, parse_StickerBookPointCacheByCollection) },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_StickerBookPointCache()
{
	int iSize = sizeof(StickerBookPointCache);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_StickerBookPointCache, iSize, "StickerBookPointCache", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PlayerNumericThresholds[];
#define TYPE_parse_PlayerNumericThresholds PlayerNumericThresholds
extern ParseTable parse_ProgressionInfo[];
#define TYPE_parse_ProgressionInfo ProgressionInfo
extern ParseTable parse_MissionInfo[];
#define TYPE_parse_MissionInfo MissionInfo
extern ParseTable parse_PlayerStatsInfo[];
#define TYPE_parse_PlayerStatsInfo PlayerStatsInfo
extern ParseTable parse_ActivatedPlayerSpawn[];
#define TYPE_parse_ActivatedPlayerSpawn ActivatedPlayerSpawn
extern ParseTable parse_PlayerVisitedMaps[];
#define TYPE_parse_PlayerVisitedMaps PlayerVisitedMaps
extern ParseTable parse_InteriorRef[];
#define TYPE_parse_InteriorRef InteriorRef
extern ParseTable parse_PlayerNemesisInfo[];
#define TYPE_parse_PlayerNemesisInfo PlayerNemesisInfo
extern ParseTable parse_LogoutTimer[];
#define TYPE_parse_LogoutTimer LogoutTimer
extern ParseTable parse_CutsceneDef[];
#define TYPE_parse_CutsceneDef CutsceneDef
extern ParseTable parse_InteractInfo[];
#define TYPE_parse_InteractInfo InteractInfo
extern ParseTable parse_PlayerPowersWarpToData[];
#define TYPE_parse_PlayerPowersWarpToData PlayerPowersWarpToData
extern ParseTable parse_PlayerGuild[];
#define TYPE_parse_PlayerGuild PlayerGuild
extern ParseTable parse_PlayerQueueInfo[];
#define TYPE_parse_PlayerQueueInfo PlayerQueueInfo
extern ParseTable parse_PlayerQueueCooldown[];
#define TYPE_parse_PlayerQueueCooldown PlayerQueueCooldown
extern ParseTable parse_PlayerActivity[];
#define TYPE_parse_PlayerActivity PlayerActivity
extern ParseTable parse_PlayerUI[];
#define TYPE_parse_PlayerUI PlayerUI
extern ParseTable parse_MinimapWaypoint[];
#define TYPE_parse_MinimapWaypoint MinimapWaypoint
extern ParseTable parse_MinigameData[];
#define TYPE_parse_MinigameData MinigameData
extern ParseTable parse_ItemAssignmentPersistedData[];
#define TYPE_parse_ItemAssignmentPersistedData ItemAssignmentPersistedData
extern ParseTable parse_ItemAssignmentPlayerData[];
#define TYPE_parse_ItemAssignmentPlayerData ItemAssignmentPlayerData
extern ParseTable parse_TradeBag[];
#define TYPE_parse_TradeBag TradeBag
extern ParseTable parse_PlayerPetInfo[];
#define TYPE_parse_PlayerPetInfo PlayerPetInfo
extern ParseTable parse_PlayerEntCopyForInfo[];
#define TYPE_parse_PlayerEntCopyForInfo PlayerEntCopyForInfo
extern ParseTable parse_CSRListenerInfo[];
#define TYPE_parse_CSRListenerInfo CSRListenerInfo
extern ParseTable parse_ArmamentSwapInfo[];
#define TYPE_parse_ArmamentSwapInfo ArmamentSwapInfo
extern ParseTable parse_PlayerDebug[];
#define TYPE_parse_PlayerDebug PlayerDebug
extern ParseTable parse_NPCEMail[];
#define TYPE_parse_NPCEMail NPCEMail
extern ParseTable parse_NPCEMailV1[];
#define TYPE_parse_NPCEMailV1 NPCEMailV1
extern ParseTable parse_PlayerMTInfo[];
#define TYPE_parse_PlayerMTInfo PlayerMTInfo
extern ParseTable parse_PlayerAccountData[];
#define TYPE_parse_PlayerAccountData PlayerAccountData
extern ParseTable parse_PlayerAuctionData[];
#define TYPE_parse_PlayerAuctionData PlayerAuctionData
extern ParseTable parse_MapDescription[];
#define TYPE_parse_MapDescription MapDescription
extern ParseTable parse_PlayerMapMoveConfirm[];
#define TYPE_parse_PlayerMapMoveConfirm PlayerMapMoveConfirm
extern ParseTable parse_PlayerWarpToData[];
#define TYPE_parse_PlayerWarpToData PlayerWarpToData
extern ParseTable parse_InteriorInvite[];
#define TYPE_parse_InteriorInvite InteriorInvite
extern ParseTable parse_GuildMapInvite[];
#define TYPE_parse_GuildMapInvite GuildMapInvite
extern ParseTable parse_XBoxSpecificData[];
#define TYPE_parse_XBoxSpecificData XBoxSpecificData
extern ParseTable parse_AccountProxyKeyValueInfo[];
#define TYPE_parse_AccountProxyKeyValueInfo AccountProxyKeyValueInfo
extern ParseTable parse_RewardModifier[];
#define TYPE_parse_RewardModifier RewardModifier
extern ParseTable parse_RewardGatedTypeData[];
#define TYPE_parse_RewardGatedTypeData RewardGatedTypeData
extern ParseTable parse_RewardGatedTypeData[];
#define TYPE_parse_RewardGatedTypeData RewardGatedTypeData
extern ParseTable parse_RewardGatedRewardTable[];
#define TYPE_parse_RewardGatedRewardTable RewardGatedRewardTable
extern ParseTable parse_NumericConversionState[];
#define TYPE_parse_NumericConversionState NumericConversionState
extern ParseTable parse_PlayerEventInfo[];
#define TYPE_parse_PlayerEventInfo PlayerEventInfo
extern ParseTable parse_ItemBuyBack[];
#define TYPE_parse_ItemBuyBack ItemBuyBack
extern ParseTable parse_UGCAccount[];
#define TYPE_parse_UGCAccount UGCAccount
extern ParseTable parse_GroupProjectRecentUnlock[];
#define TYPE_parse_GroupProjectRecentUnlock GroupProjectRecentUnlock
extern ParseTable parse_SimpleCpuData[];
#define TYPE_parse_SimpleCpuData SimpleCpuData
extern ParseTable parse_GatewayInfo[];
#define TYPE_parse_GatewayInfo GatewayInfo
extern ParseTable parse_StickerBookItemInfo[];
#define TYPE_parse_StickerBookItemInfo StickerBookItemInfo
extern ParseTable parse_StickerBookItemSetInfo[];
#define TYPE_parse_StickerBookItemSetInfo StickerBookItemSetInfo
extern ParseTable parse_StickerBookPointCache[];
#define TYPE_parse_StickerBookPointCache StickerBookPointCache
//Structparser.exe autogenerated ParseTable for struct Player
#define TYPE_parse_Player Player
ParseTable parse_Player[] =
{
	{ "Player", 										TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(Player), 0, NULL, 0, NULL },
	{ "{",											TOK_START, 0 },
	{ "accessLevel",								TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_AUTOINT(Player, accessLevel, 0), AccessLevelEnum },
	{ "accountAccessLevel",							TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_AUTOINT(Player, accountAccessLevel, 0), AccessLevelEnum },
	{ "privateAccountName",							TOK_PERSIST | TOK_SELF_ONLY | TOK_FIXEDSTR(Player, privateAccountName), NULL },
	{ "publicAccountName",							TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_FIXEDSTR(Player, publicAccountName), NULL },
	{ "accountID",									TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(Player, accountID, 0), NULL },
	{ "loginCookie",								TOK_PERSIST | TOK_SELF_ONLY | TOK_AUTOINT(Player, loginCookie, 0), NULL },
	{ "langID",										TOK_PERSIST | TOK_SOMETIMES_TRANSACT | TOK_SUBSCRIBE | TOK_AUTOINT(Player, langID, 0), NULL },
	{ "playerFlags",								TOK_PERSIST | TOK_SERVER_ONLY | TOK_AUTOINT(Player, playerFlags, 0), GlobalPlayerFlagsEnum  ,  TOK_FORMAT_FLAGS},
	{ "playerType",									TOK_PERSIST | TOK_AUTOINT(Player, playerType, kPlayerType_Premium), PlayerTypeEnum },
	{ "uiRespecConversions",						TOK_PERSIST | TOK_SELF_ONLY | TOK_AUTOINT(Player, uiRespecConversions, 0), NULL },
	{ "iCreatedTime",								TOK_PERSIST | TOK_SELF_ONLY | TOK_AUTOINT(Player, iCreatedTime, 0), NULL , 0 , "HTML_SECS_AGO_SHORT = 1"},
	{ "iLastPlayedTime",							TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_AUTOINT(Player, iLastPlayedTime, 0), NULL },
	{ "fTotalPlayTime",								TOK_PUPPET_NO_COPY | TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_F32(Player, fTotalPlayTime, 0), NULL },
	{ "uRecentBulletinTime",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_AUTOINT(Player, uRecentBulletinTime, 0), NULL },
	{ "iKillCreditCounter",							TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_AUTOINT(Player, iKillCreditCounter, 0), NULL },
	{ "eaPlayerNumericThresholds",					TOK_PERSIST | TOK_SERVER_ONLY | TOK_STRUCT(Player, eaPlayerNumericThresholds, parse_PlayerNumericThresholds) },
	{ "uiRespawnTime",								TOK_SELF_ONLY | TOK_AUTOINT(Player, uiRespawnTime, 0), NULL },
	{ "ProgressionInfo",							TOK_PERSIST | TOK_SELF_AND_TEAM_ONLY | TOK_ALWAYS_ALLOC | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(Player, pProgressionInfo, parse_ProgressionInfo) },
	{ "pProgressionInfo",							TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SELF_AND_TEAM_ONLY | TOK_ALWAYS_ALLOC | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(Player, pProgressionInfo, parse_ProgressionInfo) },
	{ "missionInfo",								TOK_PERSIST | TOK_SELF_AND_TEAM_ONLY | TOK_ALWAYS_ALLOC | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(Player, missionInfo, parse_MissionInfo) },
	{ "pStatsInfo",									TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_ALWAYS_ALLOC | TOK_OPTIONALSTRUCT(Player, pStatsInfo, parse_PlayerStatsInfo) },
	{ "ActivatedSpawns",							TOK_PERSIST | TOK_SELF_ONLY | TOK_STRUCT(Player, eaPersistActivatedSpawns, parse_ActivatedPlayerSpawn) },
	{ "eaPersistActivatedSpawns",					TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SELF_ONLY | TOK_STRUCT(Player, eaPersistActivatedSpawns, parse_ActivatedPlayerSpawn) },
	{ "pVisitedMaps",								TOK_PERSIST | TOK_SELF_ONLY | TOK_ALWAYS_ALLOC | TOK_OPTIONALSTRUCT(Player, pVisitedMaps, parse_PlayerVisitedMaps) },
	{ "eaInteriorUnlocks",							TOK_PERSIST | TOK_SELF_ONLY | TOK_STRUCT(Player, eaInteriorUnlocks, parse_InteriorRef) },
	{ "eaRecentContacts",							TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRINGARRAY(Player, eaRecentContacts), NULL },
	{ "uRecentContactsIndex",						TOK_SERVER_ONLY | TOK_AUTOINT(Player, uRecentContactsIndex, 0), NULL },
	{ "nemesisInfo",								TOK_PERSIST | TOK_SELF_AND_TEAM_ONLY | TOK_SUBSCRIBE | TOK_EMBEDDEDSTRUCT(Player, nemesisInfo, parse_PlayerNemesisInfo)},
	{ "nextAmbushTime",								TOK_SERVER_ONLY | TOK_AUTOINT(Player, nextAmbushTime, 0), NULL },
	{ "lastCalloutTime",							TOK_SERVER_ONLY | TOK_AUTOINT(Player, lastCalloutTime, 0), NULL },
	{ "lastOnClickReportTime",						TOK_SERVER_ONLY | TOK_AUTOINT(Player, lastOnClickReportTime, 0), NULL },
	{ "lastKillCalloutTime",						TOK_SERVER_ONLY | TOK_AUTOINT(Player, lastKillCalloutTime, 0), NULL },
	{ "iDifficulty",								TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(Player, iDifficulty, 0), NULL },
	{ "pLogoutTimer",								TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Player, pLogoutTimer, parse_LogoutTimer) },
	{ "fLogoffTime",								TOK_SELF_ONLY | TOK_F32(Player, fLogoffTime, 0), NULL },
	{ "pCutscene",									TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Player, pCutscene, parse_CutsceneDef) },
	{ "pInteractInfo",								TOK_SELF_ONLY | TOK_ALWAYS_ALLOC | TOK_OPTIONALSTRUCT(Player, pInteractInfo, parse_InteractInfo) },
	{ "InteractStatus",								TOK_SELF_ONLY | TOK_AUTOINT(Player, InteractStatus, 0), EntInteractStatusEnum },
	{ "ItemUpgradeInfo",							TOK_SELF_ONLY | TOK_AUTOINT(Player, ItemUpgradeInfo, 0), ItemUpgradeInfoEnum },
	{ "pWarpTo",									TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_OPTIONALSTRUCT(Player, pWarpTo, parse_PlayerPowersWarpToData) },
	{ "fMovementThrottle",							TOK_SELF_ONLY | TOK_F32(Player, fMovementThrottle, 1), NULL },
	{ "SkillType",									TOK_PERSIST | TOK_SELF_ONLY | TOK_AUTOINT(Player, SkillType, 0), SkillTypeEnum },
	{ "eSkillSpecialization",						TOK_PERSIST | TOK_SELF_ONLY | TOK_INTARRAY(Player, eSkillSpecialization),  ItemTagEnum},
	{ "eaSubscribedChannels",						TOK_NO_NETSEND | TOK_STRINGARRAY(Player, eaSubscribedChannels), NULL },
	{ "pGuild",										TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(Player, pGuild, parse_PlayerGuild) },
	{ "pcGuildName",								TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_STRING(Player, pcGuildName, 0), NULL },
	{ "iGuildID",									TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(Player, iGuildID, 0), NULL },
	{ "uiLastGuildStatsInfoVersion",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(Player, uiLastGuildStatsInfoVersion, 0), NULL },
	{ "pPlayerQueueInfo",							TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Player, pPlayerQueueInfo, parse_PlayerQueueInfo) },
	{ "eaQueueCooldowns",							TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_STRUCT(Player, eaQueueCooldowns, parse_PlayerQueueCooldown) },
	{ "pActivity",									TOK_PERSIST | TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Player, pActivity, parse_PlayerActivity) },
	{ "pchActivityString",							TOK_SELF_AND_TEAM_ONLY | TOK_STRING(Player, pchActivityString, 0), NULL },
	{ "eLFGMode",									TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(Player, eLFGMode, 0), TeamModeEnum },
	{ "eLFGDifficultyMode",							TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(Player, eLFGDifficultyMode, 0), LFGDifficultyModeEnum },
	{ "eWhitelistFlags",							TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_AUTOINT(Player, eWhitelistFlags, 0), PlayerWhitelistFlagsEnum },
	{ "lastAdvertTime",								TOK_PERSIST | TOK_NO_TRANSACT | TOK_NO_NETSEND | TOK_AUTOINT(Player, lastAdvertTime, 0), NULL },
	{ "xuid",										TOK_PERSIST | TOK_SUBSCRIBE | TOK_STRING(Player, xuid, 0), NULL },
	{ "pUI",										TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_ALWAYS_ALLOC | TOK_OPTIONALSTRUCT(Player, pUI, parse_PlayerUI) },
	{ "ppMyWaypoints",								TOK_SELF_ONLY | TOK_STRUCT(Player, ppMyWaypoints, parse_MinimapWaypoint) },
	{ "pTitleMsgKey",								TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(Player, pTitleMsgKey, 0, "Message") },
	{ "pMinigameData",								TOK_PERSIST | TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Player, pMinigameData, parse_MinigameData) },
	{ "pItemAssignmentPersistedData",				TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(Player, pItemAssignmentPersistedData, parse_ItemAssignmentPersistedData) },
	{ "pItemAssignmentData",						TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Player, pItemAssignmentData, parse_ItemAssignmentPlayerData) },
	{ "pchLastItemAssignmentVolume",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRING(Player, pchLastItemAssignmentVolume, 0), NULL },
	{ "hSharedBank",								TOK_SELF_ONLY | TOK_REFERENCE(Player, hSharedBank, 0, "CopyDict_EntitySharedBank") },
	{ "uSharedBankInitTime",						TOK_SELF_ONLY | TOK_AUTOINT(Player, uSharedBankInitTime, 0), NULL },
	{ "pTradeBag",									TOK_OPTIONALSTRUCT(Player, pTradeBag, parse_TradeBag) },
	{ "erTradePartner",								TOK_AUTOINT(Player, erTradePartner, 0), NULL },
	{ "petInfo",									TOK_SELF_ONLY | TOK_STRUCT(Player, petInfo, parse_PlayerPetInfo) },
	{ "eaPlayerEntCopyForInfo",						TOK_SERVER_ONLY | TOK_STRUCT(Player, eaPlayerEntCopyForInfo, parse_PlayerEntCopyForInfo) },
	{ "pCSRListener",								TOK_SERVER_ONLY | TOK_OPTIONALSTRUCT(Player, pCSRListener, parse_CSRListenerInfo) },
	{ "iStasis",									TOK_PERSIST | TOK_SELF_ONLY | TOK_AUTOINT(Player, iStasis, 0), NULL },
	{ "iTimeLastScanForInteractables",				TOK_SELF_ONLY | TOK_AUTOINT(Player, iTimeLastScanForInteractables, 0), NULL },
	{ "pArmamentSwapInfo",							TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Player, pArmamentSwapInfo, parse_ArmamentSwapInfo) },
	{ "debugInfo",									TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Player, debugInfo, parse_PlayerDebug) },
	{ "pEmailV2",									TOK_PERSIST | TOK_SELF_ONLY | TOK_ALWAYS_ALLOC | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(Player, pEmailV2, parse_NPCEMail) },
	{ "pEmailV2_Deprecated",						TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SELF_ONLY | TOK_ALWAYS_ALLOC | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(Player, pEmailV2, parse_NPCEMail) },
	{ "pEmailV1_Deprecated",						TOK_PERSIST | TOK_SELF_ONLY | TOK_ALWAYS_ALLOC | TOK_OPTIONALSTRUCT(Player, pEmailV1_Deprecated, parse_NPCEMailV1) },
	{ "pEmail",										TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SELF_ONLY | TOK_ALWAYS_ALLOC | TOK_OPTIONALSTRUCT(Player, pEmailV1_Deprecated, parse_NPCEMailV1) },
	{ "pMicroTransInfo",							TOK_PERSIST | TOK_SELF_ONLY | TOK_ALWAYS_ALLOC | TOK_OPTIONALSTRUCT(Player, pMicroTransInfo, parse_PlayerMTInfo) },
	{ "pPlayerAccountData",							TOK_PERSIST | TOK_SELF_ONLY | TOK_ALWAYS_ALLOC | TOK_OPTIONALSTRUCT(Player, pPlayerAccountData, parse_PlayerAccountData) },
	{ "pPlayerAuctionData",							TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(Player, pPlayerAuctionData, parse_PlayerAuctionData) },
	{ "bMapTransferPending",						TOK_SERVER_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bMovingToLocation",							TOK_SELF_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bStuckRespawn",								TOK_SELF_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bDisableRespawn",							TOK_SELF_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bUseFacingPitch",							TOK_SELF_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bIgnoreBootTimer",							TOK_PERSIST | TOK_BIT, 0, 8, NULL},
	{ "bAutoJoinTeamVoiceChat",						TOK_PERSIST | TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "bIsGM",										TOK_PERSIST | TOK_BIT, 0, 8, NULL},
	{ "bWipeEmail",									TOK_PERSIST | TOK_SERVER_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bTimeControlPause",							TOK_SELF_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bTimeControlAllowed",						TOK_SELF_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bIsFirstSessionLogin",						TOK_PERSIST | TOK_SOMETIMES_TRANSACT | TOK_SERVER_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bIsDev",										TOK_PERSIST | TOK_BIT, 0, 8, NULL},
	{ "bDoneMailAuctionItemsFixup",					TOK_PERSIST | TOK_BIT, 0, 8, NULL},
	{ "bIgnoreClientPowerActivations",				TOK_SELF_ONLY | TOK_BIT, 0, 8, NULL},
	{ "iPrevDoorRegion",							TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_AUTOINT(Player, iPrevDoorRegion, -1), WorldRegionTypeEnum },
	{ "pMovieMapTransfer",							TOK_SERVER_ONLY | TOK_OPTIONALSTRUCT(Player, pMovieMapTransfer, parse_MapDescription) },
	{ "pchActiveMovieName",							TOK_SERVER_ONLY | TOK_STRING(Player, pchActiveMovieName, 0), NULL },
	{ "pchTransitionSequence",						TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRING(Player, pchTransitionSequence, 0), NULL },
	{ "pMapMoveConfirm",							TOK_SERVER_ONLY | TOK_OPTIONALSTRUCT(Player, pMapMoveConfirm, parse_PlayerMapMoveConfirm) },
	{ "pchLastUsedDoorIdentifier",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_POOL_STRING | TOK_SELF_AND_TEAM_ONLY | TOK_SUBSCRIBE | TOK_STRING(Player, pchLastUsedDoorIdentifier, 0), NULL },
	{ "pchLastUsedDoorMapName",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_POOL_STRING | TOK_SELF_AND_TEAM_ONLY | TOK_SUBSCRIBE | TOK_STRING(Player, pchLastUsedDoorMapName, 0), NULL },
	{ "pchLastUsedDoorSpawnPointName",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_POOL_STRING | TOK_SELF_AND_TEAM_ONLY | TOK_SUBSCRIBE | TOK_STRING(Player, pchLastUsedDoorSpawnPointName, 0), NULL },
	{ "uLastUsedDoorMapID",							TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_AND_TEAM_ONLY | TOK_SUBSCRIBE | TOK_AUTOINT(Player, uLastUsedDoorMapID, 0), NULL },
	{ "uLastUsedDoorPartitionID",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_AND_TEAM_ONLY | TOK_SUBSCRIBE | TOK_AUTOINT(Player, uLastUsedDoorPartitionID, 0), NULL },
	{ "pWarp",										TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_OPTIONALSTRUCT(Player, pWarp, parse_PlayerWarpToData) },
	{ "pRecruitWarp",								TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_OPTIONALSTRUCT(Player, pWarp, parse_PlayerWarpToData) },
	{ "RecruitWarp",								TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_OPTIONALSTRUCT(Player, pWarp, parse_PlayerWarpToData) },
	{ "uiLastRecruitWarpTime",						TOK_PERSIST | TOK_SELF_ONLY | TOK_AUTOINT(Player, uiLastRecruitWarpTime, 0), NULL },
	{ "iCurrentCharacterIDs",						TOK_PERSIST | TOK_SERVER_ONLY | TOK_INTARRAY(Player, iCurrentCharacterIDs),  NULL},
	{ "interiorInvites",							TOK_SELF_ONLY | TOK_STRUCT(Player, interiorInvites, parse_InteriorInvite) },
	{ "eaGuildMapInvites",							TOK_SELF_ONLY | TOK_STRUCT(Player, eaGuildMapInvites, parse_GuildMapInvite) },
	{ "dirtyBit",									TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(Player, dirtyBit, 0), NULL },
	{ "pXBoxSpecificData",							TOK_PERSIST | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(Player, pXBoxSpecificData, parse_XBoxSpecificData) },
	{ "ppKeyValueCache",							TOK_STRUCT(Player, ppKeyValueCache, parse_AccountProxyKeyValueInfo) },
	{ "iVirtualShardID",							TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(Player, iVirtualShardID, 0), NULL },
	{ "eaRewardMods",								TOK_PERSIST | TOK_SELF_ONLY | TOK_STRUCT(Player, eaRewardMods, parse_RewardModifier) },
	{ "uLastRewardTeam",							TOK_SERVER_ONLY | TOK_AUTOINT(Player, uLastRewardTeam, 0), NULL },
	{ "uLastRewardCount",							TOK_SERVER_ONLY | TOK_AUTOINT(Player, uLastRewardCount, 0), NULL },
	{ "uiLastRewardTime",							TOK_SERVER_ONLY | TOK_AUTOINT(Player, uiLastRewardTime, 0), NULL },
	{ "eaRewardGatedData",							TOK_PERSIST | TOK_SOMETIMES_TRANSACT | TOK_SELF_ONLY | TOK_STRUCT(Player, eaRewardGatedData, parse_RewardGatedTypeData) },
	{ "eaAccountRewardGatedData",					TOK_PERSIST | TOK_SELF_ONLY | TOK_STRUCT(Player, eaAccountRewardGatedData, parse_RewardGatedTypeData) },
	{ "eaPendingAccountRewards",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_STRUCT(Player, eaPendingAccountRewards, parse_RewardGatedRewardTable) },
	{ "uLastLotsPostedByPlayer",					TOK_SELF_ONLY | TOK_AUTOINT(Player, uLastLotsPostedByPlayer, 0), NULL },
	{ "eaNumericConversionStates",					TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_STRUCT(Player, eaNumericConversionStates, parse_NumericConversionState) },
	{ "hCurrencyExchangeAccountData",				TOK_SELF_ONLY | TOK_REFERENCE(Player, hCurrencyExchangeAccountData, 0, "CopyDict_CurrencyExchange") },
	{ "timeLastVerifyEntityMissionData",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_AUTOINT(Player, timeLastVerifyEntityMissionData, 0), NULL },
	{ "pEventInfo",									TOK_PERSIST | TOK_NO_TRANSACT | TOK_SELF_ONLY | TOK_ALWAYS_ALLOC | TOK_OPTIONALSTRUCT(Player, pEventInfo, parse_PlayerEventInfo) },
	{ "eaItemBuyBackList",							TOK_SELF_ONLY | TOK_STRUCT(Player, eaItemBuyBackList, parse_ItemBuyBack) },
	{ "uBuyBackId",									TOK_SELF_ONLY | TOK_AUTOINT(Player, uBuyBackId, 0), NULL },
	{ "uBuyBackTime",								TOK_SELF_ONLY | TOK_AUTOINT(Player, uBuyBackTime, 0), NULL },
	{ "hUGCAccount",								TOK_SELF_ONLY | TOK_REFERENCE(Player, hUGCAccount, 0, "CopyDict_UGCAccount") },
	{ "pUGCAccount",								TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Player, pUGCAccount, parse_UGCAccount) },
	{ "iLastUGCAccountRequestTimestamp",			TOK_SELF_ONLY | TOK_AUTOINT(Player, iLastUGCAccountRequestTimestamp, 0), NULL },
	{ "hGroupProjectContainer",						TOK_REFERENCE(Player, hGroupProjectContainer, 0, "CopyDict_GroupProjectContainerPlayer") },
	{ "eaRecentUnlocks",							TOK_SERVER_ONLY | TOK_STRUCT(Player, eaRecentUnlocks, parse_GroupProjectRecentUnlock) },
	{ "SimpleCpuData",								TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Player, pSimpleCpuData, parse_SimpleCpuData) },
	{ "pSimpleCpuData",								TOK_REDUNDANTNAME | TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(Player, pSimpleCpuData, parse_SimpleCpuData) },
	{ "pGatewayInfo",								TOK_PERSIST | TOK_SELF_ONLY | TOK_ALWAYS_ALLOC | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(Player, pGatewayInfo, parse_GatewayInfo) },
	{ "addictionPlaySessionEndTime",				TOK_PERSIST | TOK_AUTOINT(Player, addictionPlaySessionEndTime, 0), NULL },
	{ "addictionReminderTimeIdx",					TOK_SERVER_ONLY | TOK_AUTOINT(Player, addictionReminderTimeIdx, -1), NULL },
	{ "eaAstrRecentlyAcquiredStickerBookItems",		TOK_PERSIST | TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRINGARRAY(Player, eaAstrRecentlyAcquiredStickerBookItems), NULL },
	{ "eaAstrRecentlyModifiedStickerBookItemSets",	TOK_PERSIST | TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRINGARRAY(Player, eaAstrRecentlyModifiedStickerBookItemSets), NULL },
	{ "eaStickerBookItemInfo",						TOK_PERSIST | TOK_SELF_ONLY | TOK_STRUCT(Player, eaStickerBookItemInfo, parse_StickerBookItemInfo) },
	{ "eaStickerBookItemSetInfo",					TOK_PERSIST | TOK_SELF_ONLY | TOK_STRUCT(Player, eaStickerBookItemSetInfo, parse_StickerBookItemSetInfo) },
	{ "pStickerBookPointCache",						TOK_NO_NETSEND | TOK_OPTIONALSTRUCT(Player, pStickerBookPointCache, parse_StickerBookPointCache) },
	{ "eaAwayTeamPetIDs",							TOK_IGNORE, 0 },
	{ "eaAwayTeamCritterIDs",						TOK_IGNORE, 0 },
	{ "bNotLookingForGroup",						TOK_IGNORE, 0 },
	{ "bAnonymous",									TOK_IGNORE, 0 },
	{ "uPreviousBulletinTime",						TOK_IGNORE, 0 },
	{ "pUGCSubscription",							TOK_IGNORE | TOK_IGNORE_STRUCT , 0 },
	{ "pUGCKillCreditLimit",						TOK_IGNORE | TOK_IGNORE_STRUCT , 0 },
	{ "eaPlayerUGCKillCreditLimit2",				TOK_IGNORE | TOK_IGNORE_STRUCT , 0 },
	{ "eaAstrRecentlyBoundStickerBookItems",		TOK_IGNORE | TOK_IGNORE_STRUCT , 0 },
	{ "}",											TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_Player()
{
	int iSize = sizeof(Player);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_Player, iSize, "Player", NULL, "Player.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(Player)) + 7) / 4;
		NOCONST(Player) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bMapTransferPending = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Player[84]);
		pTemp->bMapTransferPending = 0;
		pTemp->bMovingToLocation = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Player[85]);
		pTemp->bMovingToLocation = 0;
		pTemp->bStuckRespawn = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Player[86]);
		pTemp->bStuckRespawn = 0;
		pTemp->bDisableRespawn = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Player[87]);
		pTemp->bDisableRespawn = 0;
		pTemp->bUseFacingPitch = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Player[88]);
		pTemp->bUseFacingPitch = 0;
		pTemp->bIgnoreBootTimer = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Player[89]);
		pTemp->bIgnoreBootTimer = 0;
		pTemp->bAutoJoinTeamVoiceChat = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Player[90]);
		pTemp->bAutoJoinTeamVoiceChat = 0;
		pTemp->bIsGM = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Player[91]);
		pTemp->bIsGM = 0;
		pTemp->bWipeEmail = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Player[92]);
		pTemp->bWipeEmail = 0;
		pTemp->bTimeControlPause = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Player[93]);
		pTemp->bTimeControlPause = 0;
		pTemp->bTimeControlAllowed = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Player[94]);
		pTemp->bTimeControlAllowed = 0;
		pTemp->bIsFirstSessionLogin = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Player[95]);
		pTemp->bIsFirstSessionLogin = 0;
		pTemp->bIsDev = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Player[96]);
		pTemp->bIsDev = 0;
		pTemp->bDoneMailAuctionItemsFixup = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Player[97]);
		pTemp->bDoneMailAuctionItemsFixup = 0;
		pTemp->bIgnoreClientPowerActivations = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Player[98]);
		pTemp->bIgnoreClientPowerActivations = 0;
	}
	parse_Player[42].param = GET_INTPTR_FROM_FLOAT((float)1);
	return 0;
};
