#include "textparser.h"

//auto-generated staticdefine for enum AIDebugFlags
//autogeneratednocheckin
StaticDefineInt AIDebugFlagsEnum[] =
{
	DEFINE_INT
	{ "basicInfo", AI_DEBUG_FLAG_BASIC_INFO},
	{ "statustable", AI_DEBUG_FLAG_STATUS_TABLE},
	{ "statusextern", AI_DEBUG_FLAG_STATUS_EXTERN},
	{ "powers", AI_DEBUG_FLAG_POWERS},
	{ "movement", AI_DEBUG_FLAG_MOVEMENT},
	{ "ratings", AI_DEBUG_FLAG_LOC_RATINGS},
	{ "team", AI_DEBUG_FLAG_TEAM},
	{ "cteam", AI_DEBUG_FLAG_COMBATTEAM},
	{ "formation", AI_DEBUG_FLAG_FORMATION},
	{ "heightcache", AI_DEBUG_FLAG_HEIGHT_CACHE},
	{ "vars", AI_DEBUG_FLAG_VARS},
	{ "xvars", AI_DEBUG_FLAG_EXVARS},
	{ "msgs", AI_DEBUG_FLAG_MSGS},
	{ "configmods", AI_DEBUG_FLAG_CONFIG_MODS},
	{ "avoid", AI_DEBUG_FLAG_AVOID},
	{ "aggro", AI_DEBUG_FLAG_AGGRO},
	{ "logs", AI_DEBUG_FLAG_LOG},
	{ "all", AI_DEBUG_FLAGS_ALL},
	DEFINE_END
};
void autoEnum_fixup_AIDebugFlags(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AIDebugFlagsEnum, "AIDebugFlags");
}

//auto-generated staticdefine for enum AIDebugWaypointType
//autogeneratednocheckin
StaticDefineInt AIDebugWaypointTypeEnum[] =
{
	DEFINE_INT
	{ "SHORTCUT", AI_DEBUG_WP_SHORTCUT},
	{ "GROUND", AI_DEBUG_WP_GROUND},
	{ "JUMP", AI_DEBUG_WP_JUMP},
	{ "OTHER", AI_DEBUG_WP_OTHER},
	DEFINE_END
};
void autoEnum_fixup_AIDebugWaypointType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AIDebugWaypointTypeEnum, "AIDebugWaypointType");
}

//auto-generated staticdefine for enum AIDebugTeamAssignmentType
//autogeneratednocheckin
StaticDefineInt AIDebugTeamAssignmentTypeEnum[] =
{
	DEFINE_INT
	{ "HEAL", AI_DEBUG_TEAM_ASSIGNMENT_TYPE_HEAL},
	{ "SHIELD_HEAL", AI_DEBUG_TEAM_ASSIGNMENT_TYPE_SHIELD_HEAL},
	DEFINE_END
};
void autoEnum_fixup_AIDebugTeamAssignmentType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AIDebugTeamAssignmentTypeEnum, "AIDebugTeamAssignmentType");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugBasicInfo
#define TYPE_parse_AIDebugBasicInfo AIDebugBasicInfo
ParseTable parse_AIDebugBasicInfo[] =
{
	{ "AIDebugBasicInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugBasicInfo), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "str",				TOK_STRING(AIDebugBasicInfo, str, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugBasicInfo()
{
	int iSize = sizeof(AIDebugBasicInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugBasicInfo, iSize, "AIDebugBasicInfo", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugVarEntry
#define TYPE_parse_AIDebugVarEntry AIDebugVarEntry
ParseTable parse_AIDebugVarEntry[] =
{
	{ "AIDebugVarEntry", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugVarEntry), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "name",				TOK_STRING(AIDebugVarEntry, name, 0), NULL },
	{ "value",				TOK_STRING(AIDebugVarEntry, value, 0), NULL },
	{ "origin",				TOK_POOL_STRING | TOK_STRING(AIDebugVarEntry, origin, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugVarEntry()
{
	int iSize = sizeof(AIDebugVarEntry);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugVarEntry, iSize, "AIDebugVarEntry", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugMsgEntry
#define TYPE_parse_AIDebugMsgEntry AIDebugMsgEntry
ParseTable parse_AIDebugMsgEntry[] =
{
	{ "AIDebugMsgEntry", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugMsgEntry), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "name",				TOK_STRING(AIDebugMsgEntry, name, 0), NULL },
	{ "timeSince",			TOK_F32(AIDebugMsgEntry, timeSince, 0), NULL },
	{ "count",				TOK_AUTOINT(AIDebugMsgEntry, count, 0), NULL },
	{ "sources",			TOK_STRING(AIDebugMsgEntry, sources, 0), NULL },
	{ "attachedEnts",		TOK_STRING(AIDebugMsgEntry, attachedEnts, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugMsgEntry()
{
	int iSize = sizeof(AIDebugMsgEntry);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugMsgEntry, iSize, "AIDebugMsgEntry", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugStringStringEntry
#define TYPE_parse_AIDebugStringStringEntry AIDebugStringStringEntry
ParseTable parse_AIDebugStringStringEntry[] =
{
	{ "AIDebugStringStringEntry", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugStringStringEntry), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "name",						TOK_STRING(AIDebugStringStringEntry, name, 0), NULL },
	{ "val",						TOK_STRING(AIDebugStringStringEntry, val, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugStringStringEntry()
{
	int iSize = sizeof(AIDebugStringStringEntry);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugStringStringEntry, iSize, "AIDebugStringStringEntry", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CharacterAITargetInfo
#define TYPE_parse_CharacterAITargetInfo CharacterAITargetInfo
ParseTable parse_CharacterAITargetInfo[] =
{
	{ "CharacterAITargetInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CharacterAITargetInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "entRef",					TOK_AUTOINT(CharacterAITargetInfo, entRef, 0), NULL },
	{ "totalBaseDangerVal",		TOK_F32(CharacterAITargetInfo, totalBaseDangerVal, 0), NULL },
	{ "relativeDangerVal",		TOK_F32(CharacterAITargetInfo, relativeDangerVal, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CharacterAITargetInfo()
{
	int iSize = sizeof(CharacterAITargetInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CharacterAITargetInfo, iSize, "CharacterAITargetInfo", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugAggroBucket
#define TYPE_parse_AIDebugAggroBucket AIDebugAggroBucket
ParseTable parse_AIDebugAggroBucket[] =
{
	{ "AIDebugAggroBucket", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugAggroBucket), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Value",				TOK_F32(AIDebugAggroBucket, fValue, 0), NULL },
	{ "Gauge",				TOK_F32(AIDebugAggroBucket, fGauge, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugAggroBucket()
{
	int iSize = sizeof(AIDebugAggroBucket);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugAggroBucket, iSize, "AIDebugAggroBucket", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIDebugAggroBucket[];
#define TYPE_parse_AIDebugAggroBucket AIDebugAggroBucket
//Structparser.exe autogenerated ParseTable for struct AIDebugStatusTableEntry
#define TYPE_parse_AIDebugStatusTableEntry AIDebugStatusTableEntry
ParseTable parse_AIDebugStatusTableEntry[] =
{
	{ "AIDebugStatusTableEntry", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugStatusTableEntry), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "name",						TOK_STRING(AIDebugStatusTableEntry, name, 0), NULL },
	{ "index",						TOK_AUTOINT(AIDebugStatusTableEntry, index, 0), NULL },
	{ "entRef",						TOK_AUTOINT(AIDebugStatusTableEntry, entRef, 0), NULL },
	{ "AggroBuckets",				TOK_STRUCT(AIDebugStatusTableEntry, eaAggroBuckets, parse_AIDebugAggroBucket) },
	{ "aggroCounterTotal",			TOK_F32(AIDebugStatusTableEntry, aggroCounterTotal, 0), NULL },
	{ "aggroGaugeTotal",			TOK_F32(AIDebugStatusTableEntry, aggroGaugeTotal, 0), NULL },
	{ "totalBaseDangerVal",			TOK_F32(AIDebugStatusTableEntry, totalBaseDangerVal, 0), NULL },
	{ "inFrontArc",					TOK_BIT, 0, 8, NULL},
	{ "legalTarget",				TOK_BIT, 0, 8, NULL},
	{ "taunter",					TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIDebugStatusTableEntry()
{
	int iSize = sizeof(AIDebugStatusTableEntry);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugStatusTableEntry, iSize, "AIDebugStatusTableEntry", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIDebugStatusTableEntry) + 7) / 4;
		AIDebugStatusTableEntry *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->inFrontArc = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIDebugStatusTableEntry[9]);
		pTemp->inFrontArc = 0;
		pTemp->legalTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIDebugStatusTableEntry[10]);
		pTemp->legalTarget = 0;
		pTemp->taunter = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIDebugStatusTableEntry[11]);
		pTemp->taunter = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugAggroTableHeader
#define TYPE_parse_AIDebugAggroTableHeader AIDebugAggroTableHeader
ParseTable parse_AIDebugAggroTableHeader[] =
{
	{ "AIDebugAggroTableHeader", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugAggroTableHeader), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Name",						TOK_POOL_STRING | TOK_STRING(AIDebugAggroTableHeader, pchName, 0), NULL },
	{ "isGauge",					TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIDebugAggroTableHeader()
{
	int iSize = sizeof(AIDebugAggroTableHeader);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugAggroTableHeader, iSize, "AIDebugAggroTableHeader", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIDebugAggroTableHeader) + 7) / 4;
		AIDebugAggroTableHeader *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->isGauge = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIDebugAggroTableHeader[3]);
		pTemp->isGauge = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugWaypoint
#define TYPE_parse_AIDebugWaypoint AIDebugWaypoint
ParseTable parse_AIDebugWaypoint[] =
{
	{ "AIDebugWaypoint", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugWaypoint), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "type",				TOK_AUTOINT(AIDebugWaypoint, type, 0), AIDebugWaypointTypeEnum },
	{ "pos",				TOK_VEC3(AIDebugWaypoint, pos), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugWaypoint()
{
	int iSize = sizeof(AIDebugWaypoint);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugWaypoint, iSize, "AIDebugWaypoint", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugLogEntryClient
#define TYPE_parse_AIDebugLogEntryClient AIDebugLogEntryClient
ParseTable parse_AIDebugLogEntryClient[] =
{
	{ "AIDebugLogEntryClient", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugLogEntryClient), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "timeInSec",				TOK_F32(AIDebugLogEntryClient, timeInSec, 0), NULL },
	{ "str",					TOK_STRING(AIDebugLogEntryClient, str, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugLogEntryClient()
{
	int iSize = sizeof(AIDebugLogEntryClient);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugLogEntryClient, iSize, "AIDebugLogEntryClient", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugPowersInfo
#define TYPE_parse_AIDebugPowersInfo AIDebugPowersInfo
ParseTable parse_AIDebugPowersInfo[] =
{
	{ "AIDebugPowersInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugPowersInfo), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "powerName",			TOK_STRING(AIDebugPowersInfo, powerName, 0), NULL },
	{ "rechargeTime",		TOK_F32(AIDebugPowersInfo, rechargeTime, 0), NULL },
	{ "curRating",			TOK_F32(AIDebugPowersInfo, curRating, 0), NULL },
	{ "aiMinRange",			TOK_F32(AIDebugPowersInfo, aiMinRange, 0), NULL },
	{ "aiMaxRange",			TOK_F32(AIDebugPowersInfo, aiMaxRange, 0), NULL },
	{ "absWeight",			TOK_F32(AIDebugPowersInfo, absWeight, 0), NULL },
	{ "modifierWeight",		TOK_F32(AIDebugPowersInfo, modifierWeight, 0), NULL },
	{ "lastUsed",			TOK_AUTOINT(AIDebugPowersInfo, lastUsed, 0), NULL },
	{ "timesUsed",			TOK_AUTOINT(AIDebugPowersInfo, timesUsed, 0), NULL },
	{ "tags",				TOK_STRING(AIDebugPowersInfo, tags, 0), NULL },
	{ "aiExpr",				TOK_STRING(AIDebugPowersInfo, aiExpr, 0), NULL },
	{ "chainTarget",		TOK_STRING(AIDebugPowersInfo, chainTarget, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugPowersInfo()
{
	int iSize = sizeof(AIDebugPowersInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugPowersInfo, iSize, "AIDebugPowersInfo", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIDebugWaypoint[];
#define TYPE_parse_AIDebugWaypoint AIDebugWaypoint
//Structparser.exe autogenerated ParseTable for struct AIDebugMovementInfo
#define TYPE_parse_AIDebugMovementInfo AIDebugMovementInfo
ParseTable parse_AIDebugMovementInfo[] =
{
	{ "AIDebugMovementInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugMovementInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "curPos",					TOK_VEC3(AIDebugMovementInfo, curPos), NULL },
	{ "targetPos",				TOK_VEC3(AIDebugMovementInfo, targetPos), NULL },
	{ "curWp",					TOK_AUTOINT(AIDebugMovementInfo, curWp, 0), NULL },
	{ "curPath",				TOK_STRUCT(AIDebugMovementInfo, curPath, parse_AIDebugWaypoint) },
	{ "splineTarget",			TOK_VEC3(AIDebugMovementInfo, splineTarget), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugMovementInfo()
{
	int iSize = sizeof(AIDebugMovementInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugMovementInfo, iSize, "AIDebugMovementInfo", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugTeamMember
#define TYPE_parse_AIDebugTeamMember AIDebugTeamMember
ParseTable parse_AIDebugTeamMember[] =
{
	{ "AIDebugTeamMember", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugTeamMember), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "ref",					TOK_AUTOINT(AIDebugTeamMember, ref, 0), NULL },
	{ "pos",					TOK_VEC3(AIDebugTeamMember, pos), NULL },
	{ "job_name",				TOK_STRING(AIDebugTeamMember, job_name, 0), NULL },
	{ "critter_name",			TOK_STRING(AIDebugTeamMember, critter_name, 0), NULL },
	{ "role_name",				TOK_STRING(AIDebugTeamMember, role_name, 0), NULL },
	{ "combatTokens",			TOK_F32(AIDebugTeamMember, combatTokens, 0), NULL },
	{ "combatTokenRateSelf",	TOK_F32(AIDebugTeamMember, combatTokenRateSelf, 0), NULL },
	{ "combatTokenRateSocial",	TOK_F32(AIDebugTeamMember, combatTokenRateSocial, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugTeamMember()
{
	int iSize = sizeof(AIDebugTeamMember);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugTeamMember, iSize, "AIDebugTeamMember", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugTeamMemberAssignment
#define TYPE_parse_AIDebugTeamMemberAssignment AIDebugTeamMemberAssignment
ParseTable parse_AIDebugTeamMemberAssignment[] =
{
	{ "AIDebugTeamMemberAssignment", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugTeamMemberAssignment), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "targetName",						TOK_STRING(AIDebugTeamMemberAssignment, targetName, 0), NULL },
	{ "type",							TOK_AUTOINT(AIDebugTeamMemberAssignment, type, 0), AIDebugTeamAssignmentTypeEnum },
	{ "assigneeName",					TOK_STRING(AIDebugTeamMemberAssignment, assigneeName, 0), NULL },
	{ "powerName",						TOK_STRING(AIDebugTeamMemberAssignment, powerName, 0), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugTeamMemberAssignment()
{
	int iSize = sizeof(AIDebugTeamMemberAssignment);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugTeamMemberAssignment, iSize, "AIDebugTeamMemberAssignment", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIDebugTeamMember[];
#define TYPE_parse_AIDebugTeamMember AIDebugTeamMember
extern ParseTable parse_AIDebugBasicInfo[];
#define TYPE_parse_AIDebugBasicInfo AIDebugBasicInfo
extern ParseTable parse_AIDebugTeamMemberAssignment[];
#define TYPE_parse_AIDebugTeamMemberAssignment AIDebugTeamMemberAssignment
//Structparser.exe autogenerated ParseTable for struct AIDebugTeamInfo
#define TYPE_parse_AIDebugTeamInfo AIDebugTeamInfo
ParseTable parse_AIDebugTeamInfo[] =
{
	{ "AIDebugTeamInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugTeamInfo), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "members",			TOK_STRUCT(AIDebugTeamInfo, members, parse_AIDebugTeamMember) },
	{ "teamBasicInfo",		TOK_STRUCT(AIDebugTeamInfo, teamBasicInfo, parse_AIDebugBasicInfo) },
	{ "healingAssignments",	TOK_STRUCT(AIDebugTeamInfo, healingAssignments, parse_AIDebugTeamMemberAssignment) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugTeamInfo()
{
	int iSize = sizeof(AIDebugTeamInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugTeamInfo, iSize, "AIDebugTeamInfo", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugLocRating
#define TYPE_parse_AIDebugLocRating AIDebugLocRating
ParseTable parse_AIDebugLocRating[] =
{
	{ "AIDebugLocRating", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugLocRating), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "arcDistance",				TOK_F32(AIDebugLocRating, arcDistance, 0), NULL },
	{ "clumping",					TOK_F32(AIDebugLocRating, clumping, 0), NULL },
	{ "softAvoid",					TOK_F32(AIDebugLocRating, softAvoid, 0), NULL },
	{ "avoidOccupiedPositions",		TOK_F32(AIDebugLocRating, avoidOccupiedPositions, 0), NULL },
	{ "stayTogether",				TOK_F32(AIDebugLocRating, stayTogether, 0), NULL },
	{ "flanking",					TOK_F32(AIDebugLocRating, flanking, 0), NULL },
	{ "targetShields",				TOK_F32(AIDebugLocRating, targetShields, 0), NULL },
	{ "turnWeakShieldTo",			TOK_F32(AIDebugLocRating, turnWeakShieldTo, 0), NULL },
	{ "turnStrongShieldTo",			TOK_F32(AIDebugLocRating, turnStrongShieldTo, 0), NULL },
	{ "turnWeakShieldToMostDamage",	TOK_F32(AIDebugLocRating, turnWeakShieldToMostDamage, 0), NULL },
	{ "preferArcLimitedLocations",	TOK_F32(AIDebugLocRating, preferArcLimitedLocations, 0), NULL },
	{ "yOffset",					TOK_F32(AIDebugLocRating, yOffset, 0), NULL },
	{ "sameLocPenalty",				TOK_F32(AIDebugLocRating, sameLocPenalty, 0), NULL },
	{ "rayCollResult",				TOK_AUTOINT(AIDebugLocRating, rayCollResult, 0), NULL },
	{ "bestThisTick",				TOK_BIT, 0, 8, NULL},
	{ "combatPosSlotIndex",			TOK_AUTOINT(AIDebugLocRating, combatPosSlotIndex, 0), NULL },
	{ "CombatPosSlot",				TOK_VEC3(AIDebugLocRating, vCombatPosSlot), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIDebugLocRating()
{
	int iSize = sizeof(AIDebugLocRating);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugLocRating, iSize, "AIDebugLocRating", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIDebugLocRating) + 7) / 4;
		AIDebugLocRating *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bestThisTick = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIDebugLocRating[16]);
		pTemp->bestThisTick = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugFormationPosition
#define TYPE_parse_AIDebugFormationPosition AIDebugFormationPosition
ParseTable parse_AIDebugFormationPosition[] =
{
	{ "AIDebugFormationPosition", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugFormationPosition), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "offset",						TOK_VEC3(AIDebugFormationPosition, offset), NULL },
	{ "assignee",					TOK_AUTOINT(AIDebugFormationPosition, assignee, 0), NULL },
	{ "blocked",					TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIDebugFormationPosition()
{
	int iSize = sizeof(AIDebugFormationPosition);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugFormationPosition, iSize, "AIDebugFormationPosition", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIDebugFormationPosition) + 7) / 4;
		AIDebugFormationPosition *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->blocked = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIDebugFormationPosition[4]);
		pTemp->blocked = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIDebugFormationPosition[];
#define TYPE_parse_AIDebugFormationPosition AIDebugFormationPosition
//Structparser.exe autogenerated ParseTable for struct AIDebugFormation
#define TYPE_parse_AIDebugFormation AIDebugFormation
ParseTable parse_AIDebugFormation[] =
{
	{ "AIDebugFormation", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugFormation), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "formationPos",		TOK_VEC3(AIDebugFormation, formationPos), NULL },
	{ "positions",			TOK_STRUCT(AIDebugFormation, positions, parse_AIDebugFormationPosition) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugFormation()
{
	int iSize = sizeof(AIDebugFormation);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugFormation, iSize, "AIDebugFormation", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugAvoidBcn
#define TYPE_parse_AIDebugAvoidBcn AIDebugAvoidBcn
ParseTable parse_AIDebugAvoidBcn[] =
{
	{ "AIDebugAvoidBcn", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugAvoidBcn), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "pos",				TOK_VEC3(AIDebugAvoidBcn, pos), NULL },
	{ "Avoid",				TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIDebugAvoidBcn()
{
	int iSize = sizeof(AIDebugAvoidBcn);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugAvoidBcn, iSize, "AIDebugAvoidBcn", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIDebugAvoidBcn) + 7) / 4;
		AIDebugAvoidBcn *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->avoid = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIDebugAvoidBcn[3]);
		pTemp->avoid = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugAvoidVolume
#define TYPE_parse_AIDebugAvoidVolume AIDebugAvoidVolume
ParseTable parse_AIDebugAvoidVolume[] =
{
	{ "AIDebugAvoidVolume", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugAvoidVolume), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Pos",				TOK_VEC3(AIDebugAvoidVolume, vPos), NULL },
	{ "rot_mtxBox",			TOK_MAT4PYR_ROT(AIDebugAvoidVolume, mtxBox), NULL },
	{ "pos_mtxBox",			TOK_MAT4PYR_POS(AIDebugAvoidVolume, mtxBox), NULL },
	{ "BoxMin",				TOK_VEC3(AIDebugAvoidVolume, vBoxMin), NULL },
	{ "BoxMax",				TOK_VEC3(AIDebugAvoidVolume, vBoxMax), NULL },
	{ "Radius",				TOK_F32(AIDebugAvoidVolume, fRadius, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugAvoidVolume()
{
	int iSize = sizeof(AIDebugAvoidVolume);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugAvoidVolume, iSize, "AIDebugAvoidVolume", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIDebugAvoidBcn[];
#define TYPE_parse_AIDebugAvoidBcn AIDebugAvoidBcn
extern ParseTable parse_AIDebugAvoidVolume[];
#define TYPE_parse_AIDebugAvoidVolume AIDebugAvoidVolume
//Structparser.exe autogenerated ParseTable for struct AIDebugAvoid
#define TYPE_parse_AIDebugAvoid AIDebugAvoid
ParseTable parse_AIDebugAvoid[] =
{
	{ "AIDebugAvoid", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugAvoid), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "bcns",			TOK_STRUCT(AIDebugAvoid, bcns, parse_AIDebugAvoidBcn) },
	{ "volumes",		TOK_STRUCT(AIDebugAvoid, volumes, parse_AIDebugAvoidVolume) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugAvoid()
{
	int iSize = sizeof(AIDebugAvoid);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugAvoid, iSize, "AIDebugAvoid", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugAggro
#define TYPE_parse_AIDebugAggro AIDebugAggro
ParseTable parse_AIDebugAggro[] =
{
	{ "AIDebugAggro", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugAggro), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "defAggro",		TOK_F32(AIDebugAggro, defAggro, 0), NULL },
	{ "defAware",		TOK_F32(AIDebugAggro, defAware, 0), NULL },
	{ "defSocPrim",		TOK_F32(AIDebugAggro, defSocPrim, 0), NULL },
	{ "defSocSec",		TOK_F32(AIDebugAggro, defSocSec, 0), NULL },
	{ "socialEnabled",	TOK_BIT, 0, 8, NULL},
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIDebugAggro()
{
	int iSize = sizeof(AIDebugAggro);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugAggro, iSize, "AIDebugAggro", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIDebugAggro) + 7) / 4;
		AIDebugAggro *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->socialEnabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIDebugAggro[6]);
		pTemp->socialEnabled = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugPerEntity
#define TYPE_parse_AIDebugPerEntity AIDebugPerEntity
ParseTable parse_AIDebugPerEntity[] =
{
	{ "AIDebugPerEntity", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugPerEntity), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "myRef",				TOK_AUTOINT(AIDebugPerEntity, myRef, 0), NULL },
	{ "aggro",				TOK_F32(AIDebugPerEntity, aggro, 0), NULL },
	{ "aware",				TOK_F32(AIDebugPerEntity, aware, 0), NULL },
	{ "socPrim",			TOK_F32(AIDebugPerEntity, socPrim, 0), NULL },
	{ "socSec",				TOK_F32(AIDebugPerEntity, socSec, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugPerEntity()
{
	int iSize = sizeof(AIDebugPerEntity);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugPerEntity, iSize, "AIDebugPerEntity", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugSettings
#define TYPE_parse_AIDebugSettings AIDebugSettings
ParseTable parse_AIDebugSettings[] =
{
	{ "AIDebugSettings", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugSettings), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "flags",				TOK_AUTOINT(AIDebugSettings, flags, 0), AIDebugFlagsEnum },
	{ "logSettings",		TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(AIDebugSettings, logSettings), NULL },
	{ "debugEntRef",		TOK_AUTOINT(AIDebugSettings, debugEntRef, 0), NULL },
	{ "layerFSMName",		TOK_POOL_STRING | TOK_STRING(AIDebugSettings, layerFSMName, 0), NULL },
	{ "pfsmName",			TOK_POOL_STRING | TOK_STRING(AIDebugSettings, pfsmName, 0), NULL },
	{ "updateSelected",		TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIDebugSettings()
{
	int iSize = sizeof(AIDebugSettings);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugSettings, iSize, "AIDebugSettings", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIDebugSettings) + 7) / 4;
		AIDebugSettings *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->updateSelected = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIDebugSettings[7]);
		pTemp->updateSelected = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIDebugSettings[];
#define TYPE_parse_AIDebugSettings AIDebugSettings
extern ParseTable parse_AIDebugBasicInfo[];
#define TYPE_parse_AIDebugBasicInfo AIDebugBasicInfo
extern ParseTable parse_AIDebugAggroTableHeader[];
#define TYPE_parse_AIDebugAggroTableHeader AIDebugAggroTableHeader
extern ParseTable parse_AIDebugStatusTableEntry[];
#define TYPE_parse_AIDebugStatusTableEntry AIDebugStatusTableEntry
extern ParseTable parse_AIDebugStatusTableEntry[];
#define TYPE_parse_AIDebugStatusTableEntry AIDebugStatusTableEntry
extern ParseTable parse_AIDebugPerEntity[];
#define TYPE_parse_AIDebugPerEntity AIDebugPerEntity
extern ParseTable parse_AIDebugLogEntryClient[];
#define TYPE_parse_AIDebugLogEntryClient AIDebugLogEntryClient
extern ParseTable parse_AIDebugBasicInfo[];
#define TYPE_parse_AIDebugBasicInfo AIDebugBasicInfo
extern ParseTable parse_AIDebugPowersInfo[];
#define TYPE_parse_AIDebugPowersInfo AIDebugPowersInfo
extern ParseTable parse_AIDebugTeamInfo[];
#define TYPE_parse_AIDebugTeamInfo AIDebugTeamInfo
extern ParseTable parse_AIDebugTeamInfo[];
#define TYPE_parse_AIDebugTeamInfo AIDebugTeamInfo
extern ParseTable parse_AIDebugVarEntry[];
#define TYPE_parse_AIDebugVarEntry AIDebugVarEntry
extern ParseTable parse_AIDebugVarEntry[];
#define TYPE_parse_AIDebugVarEntry AIDebugVarEntry
extern ParseTable parse_AIDebugMsgEntry[];
#define TYPE_parse_AIDebugMsgEntry AIDebugMsgEntry
extern ParseTable parse_AIDebugMovementInfo[];
#define TYPE_parse_AIDebugMovementInfo AIDebugMovementInfo
extern ParseTable parse_AIDebugLocRating[];
#define TYPE_parse_AIDebugLocRating AIDebugLocRating
extern ParseTable parse_AIDebugFormation[];
#define TYPE_parse_AIDebugFormation AIDebugFormation
extern ParseTable parse_AIDebugStringStringEntry[];
#define TYPE_parse_AIDebugStringStringEntry AIDebugStringStringEntry
extern ParseTable parse_AIDebugAvoid[];
#define TYPE_parse_AIDebugAvoid AIDebugAvoid
extern ParseTable parse_AIDebugAggro[];
#define TYPE_parse_AIDebugAggro AIDebugAggro
//Structparser.exe autogenerated ParseTable for struct AIDebug
#define TYPE_parse_AIDebug AIDebug
ParseTable parse_AIDebug[] =
{
	{ "AIDebug", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebug), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "settings",					TOK_EMBEDDEDSTRUCT(AIDebug, settings, parse_AIDebugSettings)},
	{ "attackTargetRef",			TOK_AUTOINT(AIDebug, attackTargetRef, 0), NULL },
	{ "basicInfo",					TOK_STRUCT(AIDebug, basicInfo, parse_AIDebugBasicInfo) },
	{ "AggroTableHeaders",			TOK_STRUCT(AIDebug, eaAggroTableHeaders, parse_AIDebugAggroTableHeader) },
	{ "debugStatusEntries",			TOK_STRUCT(AIDebug, debugStatusEntries, parse_AIDebugStatusTableEntry) },
	{ "debugStatusExternEntries",	TOK_STRUCT(AIDebug, debugStatusExternEntries, parse_AIDebugStatusTableEntry) },
	{ "entInfo",					TOK_STRUCT(AIDebug, entInfo, parse_AIDebugPerEntity) },
	{ "logEntries",					TOK_STRUCT(AIDebug, logEntries, parse_AIDebugLogEntryClient) },
	{ "powerBasicInfo",				TOK_STRUCT(AIDebug, powerBasicInfo, parse_AIDebugBasicInfo) },
	{ "powersInfo",					TOK_STRUCT(AIDebug, powersInfo, parse_AIDebugPowersInfo) },
	{ "teamInfo",					TOK_OPTIONALSTRUCT(AIDebug, teamInfo, parse_AIDebugTeamInfo) },
	{ "combatTeamInfo",				TOK_OPTIONALSTRUCT(AIDebug, combatTeamInfo, parse_AIDebugTeamInfo) },
	{ "varInfo",					TOK_STRUCT(AIDebug, varInfo, parse_AIDebugVarEntry) },
	{ "exVarInfo",					TOK_STRUCT(AIDebug, exVarInfo, parse_AIDebugVarEntry) },
	{ "msgInfo",					TOK_STRUCT(AIDebug, msgInfo, parse_AIDebugMsgEntry) },
	{ "movementInfo",				TOK_OPTIONALSTRUCT(AIDebug, movementInfo, parse_AIDebugMovementInfo) },
	{ "locRatings",					TOK_STRUCT(AIDebug, locRatings, parse_AIDebugLocRating) },
	{ "formation",					TOK_OPTIONALSTRUCT(AIDebug, formation, parse_AIDebugFormation) },
	{ "configMods",					TOK_STRUCT(AIDebug, configMods, parse_AIDebugStringStringEntry) },
	{ "avoidInfo",					TOK_OPTIONALSTRUCT(AIDebug, avoidInfo, parse_AIDebugAvoid) },
	{ "aggroInfo",					TOK_OPTIONALSTRUCT(AIDebug, aggroInfo, parse_AIDebugAggro) },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebug()
{
	int iSize = sizeof(AIDebug);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebug, iSize, "AIDebug", NULL, "aiDebugShared.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
