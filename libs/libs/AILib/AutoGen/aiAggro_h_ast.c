#include "textparser.h"

//auto-generated staticdefine for enum AIAggroCounterType
//autogeneratednocheckin
StaticDefineInt AIAggroCounterTypeEnum[] =
{
	DEFINE_INT
	{ "Expression", AI_AGGRO_COUNTER_DATA},
	{ "COUNT", AI_AGGRO_COUNTER_COUNT},
	DEFINE_END
};
extern StaticDefineInt AINotifyTypeEnum[];
void autoEnum_fixup_AIAggroCounterType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AIAggroCounterTypeEnum, "AIAggroCounterType");
	StaticDefineIntAddTailList(AIAggroCounterTypeEnum, AINotifyTypeEnum);
}

//auto-generated staticdefine for enum AIAggroGaugeType
//autogeneratednocheckin
StaticDefineInt AIAggroGaugeTypeEnum[] =
{
	DEFINE_INT
	{ "Distance", AI_AGGRO_GAUGE_DIST},
	{ "Sticky", AI_AGGRO_GAUGE_STICKY},
	{ "Expression", AI_AGGRO_GAUGE_DATA},
	DEFINE_END
};
void autoEnum_fixup_AIAggroGaugeType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AIAggroGaugeTypeEnum, "AIAggroGaugeType");
}

//auto-generated staticdefine for enum AIAggroGaugeScaleType
//autogeneratednocheckin
StaticDefineInt AIAggroGaugeScaleTypeEnum[] =
{
	DEFINE_INT
	{ "Counter", AI_AGGRO_GAUGE_SCALE_COUNTER},
	{ "PostCounters", AI_AGGRO_GAUGE_SCALE_POST_COUNTERS},
	{ "PostAll", AI_AGGRO_GAUGE_SCALE_POST_ALL},
	{ "MaxTotalCounter", AI_AGGRO_GAUGE_SCALE_MAX_TOTALCOUNTER},
	DEFINE_END
};
void autoEnum_fixup_AIAggroGaugeScaleType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AIAggroGaugeScaleTypeEnum, "AIAggroGaugeScaleType");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIAggroDefBucketOverride
#define TYPE_parse_AIAggroDefBucketOverride AIAggroDefBucketOverride
ParseTable parse_AIAggroDefBucketOverride[] =
{
	{ "AIAggroDefBucketOverride", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIAggroDefBucketOverride), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Name",						TOK_POOL_STRING | TOK_STRING(AIAggroDefBucketOverride, pchName, 0), NULL },
	{ "PostScale",					TOK_F32(AIAggroDefBucketOverride, fPostScale, 0), NULL },
	{ "Enabled",					TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIAggroDefBucketOverride()
{
	int iSize = sizeof(AIAggroDefBucketOverride);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIAggroDefBucketOverride, iSize, "AIAggroDefBucketOverride", NULL, "aiAggro.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIAggroDefBucketOverride) + 7) / 4;
		AIAggroDefBucketOverride *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bEnabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIAggroDefBucketOverride[4]);
		pTemp->bEnabled = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIAggroGaugeDef
#define TYPE_parse_AIAggroGaugeDef AIAggroGaugeDef
ParseTable parse_AIAggroGaugeDef[] =
{
	{ "AIAggroGaugeDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIAggroGaugeDef), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "name",				TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(AIAggroGaugeDef, name, 0), NULL },
	{ "desc",				TOK_STRING(AIAggroGaugeDef, desc, 0), NULL },
	{ "gaugeType",			TOK_AUTOINT(AIAggroGaugeDef, gaugeType, 0), AIAggroGaugeTypeEnum },
	{ "ExprBlock",			TOK_OPTIONALLATEBINDSTRUCT(AIAggroGaugeDef, expr) },
	{ "Expr",				TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AIAggroGaugeDef, expr) },
	{ "postScale",			TOK_F32(AIAggroGaugeDef, postScale, 1), NULL },
	{ "scaleType",			TOK_AUTOINT(AIAggroGaugeDef, scaleType, 0), AIAggroGaugeScaleTypeEnum },
	{ "scaleCounterType",	TOK_AUTOINT(AIAggroGaugeDef, scaleCounterType, 0), AIAggroCounterTypeEnum },
	{ "scaleTargetType",	TOK_AUTOINT(AIAggroGaugeDef, scaleTargetType, 0), AINotifyTargetTypeEnum },
	{ "enabled",			TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIAggroGaugeDef()
{
	int iSize = sizeof(AIAggroGaugeDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIAggroGaugeDef, iSize, "AIAggroGaugeDef", NULL, "aiAggro.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIAggroGaugeDef) + 7) / 4;
		AIAggroGaugeDef *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->enabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIAggroGaugeDef[11]);
		pTemp->enabled = 0;
	}
	parse_AIAggroGaugeDef[7].param = GET_INTPTR_FROM_FLOAT((float)1);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_AIAggroGaugeDef(void)
{
	DoAutoStructLateBind(parse_AIAggroGaugeDef, 5, "Expression");
	DoAutoStructLateBind(parse_AIAggroGaugeDef, 6, "Expression_StructParam");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIAggroCounterDef
#define TYPE_parse_AIAggroCounterDef AIAggroCounterDef
ParseTable parse_AIAggroCounterDef[] =
{
	{ "AIAggroCounterDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIAggroCounterDef), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "name",				TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(AIAggroCounterDef, name, 0), NULL },
	{ "desc",				TOK_STRING(AIAggroCounterDef, desc, 0), NULL },
	{ "counterType",		TOK_AUTOINT(AIAggroCounterDef, counterType, 0), AIAggroCounterTypeEnum },
	{ "targetType",			TOK_AUTOINT(AIAggroCounterDef, targetType, 0), AINotifyTargetTypeEnum },
	{ "ExprBlock",			TOK_OPTIONALLATEBINDSTRUCT(AIAggroCounterDef, expr) },
	{ "Expr",				TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AIAggroCounterDef, expr) },
	{ "postScale",			TOK_F32(AIAggroCounterDef, postScale, 1), NULL },
	{ "ExprDecayRateBlock",	TOK_OPTIONALLATEBINDSTRUCT(AIAggroCounterDef, pExprDecayRate) },
	{ "DecayRate",			TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AIAggroCounterDef, pExprDecayRate) },
	{ "decayDelay",			TOK_F32(AIAggroCounterDef, decayDelay, 0), NULL },
	{ "enabled",			TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIAggroCounterDef()
{
	int iSize = sizeof(AIAggroCounterDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIAggroCounterDef, iSize, "AIAggroCounterDef", NULL, "aiAggro.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIAggroCounterDef) + 7) / 4;
		AIAggroCounterDef *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->enabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIAggroCounterDef[12]);
		pTemp->enabled = 0;
	}
	parse_AIAggroCounterDef[8].param = GET_INTPTR_FROM_FLOAT((float)1);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_AIAggroCounterDef(void)
{
	DoAutoStructLateBind(parse_AIAggroCounterDef, 6, "Expression");
	DoAutoStructLateBind(parse_AIAggroCounterDef, 7, "Expression_StructParam");
	DoAutoStructLateBind(parse_AIAggroCounterDef, 9, "Expression");
	DoAutoStructLateBind(parse_AIAggroCounterDef, 10, "Expression_StructParam");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIAggroEvent
#define TYPE_parse_AIAggroEvent AIAggroEvent
ParseTable parse_AIAggroEvent[] =
{
	{ "AIAggroEvent", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIAggroEvent), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "name",			TOK_STRUCTPARAM | TOK_STRING(AIAggroEvent, name, 0), NULL },
	{ "notifyType",		TOK_AUTOINT(AIAggroEvent, notifyType, 0), AINotifyTypeEnum },
	{ "ExprBlock",		TOK_OPTIONALLATEBINDSTRUCT(AIAggroEvent, expr) },
	{ "Expr",			TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AIAggroEvent, expr) },
	{ "enabled",		TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIAggroEvent()
{
	int iSize = sizeof(AIAggroEvent);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIAggroEvent, iSize, "AIAggroEvent", NULL, "aiAggro.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIAggroEvent) + 7) / 4;
		AIAggroEvent *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->enabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIAggroEvent[6]);
		pTemp->enabled = 0;
	}
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_AIAggroEvent(void)
{
	DoAutoStructLateBind(parse_AIAggroEvent, 4, "Expression");
	DoAutoStructLateBind(parse_AIAggroEvent, 5, "Expression_StructParam");
}
//autogeneratednocheckin
extern ParseTable parse_AIAggroCounterDef[];
#define TYPE_parse_AIAggroCounterDef AIAggroCounterDef
extern ParseTable parse_AIAggroGaugeDef[];
#define TYPE_parse_AIAggroGaugeDef AIAggroGaugeDef
extern ParseTable parse_AIAggroEvent[];
#define TYPE_parse_AIAggroEvent AIAggroEvent
//Structparser.exe autogenerated ParseTable for struct AIAggroDef
#define TYPE_parse_AIAggroDef AIAggroDef
ParseTable parse_AIAggroDef[] =
{
	{ "AIAggroDef", 						TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIAggroDef), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "name",							TOK_STRUCTPARAM | TOK_KEY | TOK_STRING(AIAggroDef, name, 0), NULL },
	{ "Counter",						TOK_STRUCT(AIAggroDef, aggroCounters, parse_AIAggroCounterDef) },
	{ "Gauge",							TOK_STRUCT(AIAggroDef, aggroGauges, parse_AIAggroGaugeDef) },
	{ "Event",							TOK_STRUCT(AIAggroDef, aggroEvents, parse_AIAggroEvent) },
	{ "filename",						TOK_POOL_STRING | TOK_CURRENTFILE(AIAggroDef, filename), NULL},
	{ "initialPullThreat",				TOK_AUTOINT(AIAggroDef, initialPullThreat, 0), NULL },
	{ "powerMissedThreat",				TOK_AUTOINT(AIAggroDef, powerMissedThreat, 0), NULL },
	{ "MeleeRange",						TOK_F32(AIAggroDef, fMeleeRange, 8), NULL },
	{ "TimeSinceSpawnToIgnoreHealing",	TOK_F32(AIAggroDef, fTimeSinceSpawnToIgnoreHealing, 0), NULL },
	{ "scaleHealingByLegalTargets",		TOK_BIT, 0, 8, NULL},
	{ "separateHealingByAttackTarget",	TOK_BIT, 0, 8, NULL},
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIAggroDef()
{
	int iSize = sizeof(AIAggroDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIAggroDef, iSize, "AIAggroDef", NULL, "aiAggro.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIAggroDef) + 7) / 4;
		AIAggroDef *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->scaleHealingByLegalTargets = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIAggroDef[11]);
		pTemp->scaleHealingByLegalTargets = 0;
		pTemp->separateHealingByAttackTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIAggroDef[12]);
		pTemp->separateHealingByAttackTarget = 0;
	}
	parse_AIAggroDef[9].param = GET_INTPTR_FROM_FLOAT((float)8);
	return 0;
};
