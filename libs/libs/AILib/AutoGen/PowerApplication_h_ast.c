#include "textparser.h"
//autogeneratednocheckin
extern ParseTable parse_CombatEventTracker[];
#define TYPE_parse_CombatEventTracker CombatEventTracker
//Structparser.exe autogenerated ParseTable for struct PATrigger
#define TYPE_parse_PATrigger PATrigger
ParseTable parse_PATrigger[] =
{
	{ "PATrigger", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PATrigger), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Mag",				TOK_F32(PATrigger, fMag, 0), NULL },
	{ "MagScale",			TOK_F32(PATrigger, fMagScale, 0), NULL },
	{ "MagPreResist",		TOK_F32(PATrigger, fMagPreResist, 0), NULL },
	{ "CombatEventTracker",	TOK_UNOWNED | TOK_OPTIONALSTRUCT(PATrigger, pCombatEventTracker, parse_CombatEventTracker) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PATrigger()
{
	int iSize = sizeof(PATrigger);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PATrigger, iSize, "PATrigger", NULL, "PowerApplication.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PACritical
#define TYPE_parse_PACritical PACritical
ParseTable parse_PACritical[] =
{
	{ "PACritical", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PACritical), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "Success",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_BIT, 0, 8, NULL},
	{ "Hit",		TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_BIT, 0, 8, NULL},
	{ "bSuccess",	TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_BIT, 0, 8, NULL},
	{ "Roll",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(PACritical, fRoll, 0), NULL },
	{ "fRoll",		TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(PACritical, fRoll, 0), NULL },
	{ "Threshold",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(PACritical, fThreshold, 0), NULL },
	{ "fThreshold",	TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(PACritical, fThreshold, 0), NULL },
	{ "Severity",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(PACritical, fSeverity, 0), NULL },
	{ "fSeverity",	TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(PACritical, fSeverity, 0), NULL },
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PACritical()
{
	int iSize = sizeof(PACritical);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PACritical, iSize, "PACritical", NULL, "PowerApplication.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(PACritical)) + 7) / 4;
		NOCONST(PACritical) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bSuccess = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PACritical[2]);
		pTemp->bSuccess = 0;
		pTemp->bSuccess = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PACritical[3]);
		pTemp->bSuccess = 0;
		pTemp->bSuccess = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PACritical[4]);
		pTemp->bSuccess = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PAAvoidance
#define TYPE_parse_PAAvoidance PAAvoidance
ParseTable parse_PAAvoidance[] =
{
	{ "PAAvoidance", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PAAvoidance), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Success",		TOK_BIT, 0, 8, NULL},
	{ "Roll",			TOK_F32(PAAvoidance, fRoll, 0), NULL },
	{ "Threshold",		TOK_F32(PAAvoidance, fThreshold, 0), NULL },
	{ "Severity",		TOK_F32(PAAvoidance, fSeverity, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PAAvoidance()
{
	int iSize = sizeof(PAAvoidance);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PAAvoidance, iSize, "PAAvoidance", NULL, "PowerApplication.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PAAvoidance) + 7) / 4;
		PAAvoidance *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bSuccess = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PAAvoidance[2]);
		pTemp->bSuccess = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PowerDef[];
#define TYPE_parse_PowerDef PowerDef
extern ParseTable parse_PowerSubtargetChoice[];
#define TYPE_parse_PowerSubtargetChoice PowerSubtargetChoice
extern ParseTable parse_PowerActivation[];
#define TYPE_parse_PowerActivation PowerActivation
extern ParseTable parse_PACritical[];
#define TYPE_parse_PACritical PACritical
extern ParseTable parse_PAAvoidance[];
#define TYPE_parse_PAAvoidance PAAvoidance
extern ParseTable parse_PATrigger[];
#define TYPE_parse_PATrigger PATrigger
//Structparser.exe autogenerated ParseTable for struct PowerApplication
#define TYPE_parse_PowerApplication PowerApplication
ParseTable parse_PowerApplication[] =
{
	{ "PowerApplication", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerApplication), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "PowerDef",				TOK_OPTIONALSTRUCT(PowerApplication, pdef, parse_PowerDef) },
	{ "Level",					TOK_AUTOINT(PowerApplication, iLevel, 0), NULL },
	{ "IdxMulti",				TOK_AUTOINT(PowerApplication, iIdxMulti, 0), NULL },
	{ "TableScale",				TOK_F32(PowerApplication, fTableScale, 0), NULL },
	{ "Subtarget",				TOK_OPTIONALSTRUCT(PowerApplication, pSubtarget, parse_PowerSubtargetChoice) },
	{ "NumTargets",				TOK_AUTOINT(PowerApplication, iNumTargets, 0), NULL },
	{ "Activation",				TOK_OPTIONALSTRUCT(PowerApplication, pact, parse_PowerActivation) },
	{ "Critical",				TOK_EMBEDDEDSTRUCT(PowerApplication, critical, parse_PACritical)},
	{ "Avoidance",				TOK_EMBEDDEDSTRUCT(PowerApplication, avoidance, parse_PAAvoidance)},
	{ "DamageTrigger",			TOK_EMBEDDEDSTRUCT(PowerApplication, trigger, parse_PATrigger)},
	{ "Random",					TOK_F32(PowerApplication, fRandom, 0), NULL },
	{ "Period",					TOK_AUTOINT(PowerApplication, uiPeriod, 0), NULL },
	{ "AngleToTarget",			TOK_F32(PowerApplication, fAngleToTarget, 0), NULL },
	{ "AngleToSource",			TOK_F32(PowerApplication, fAngleToSource, 0), NULL },
	{ "AngleToTargetVertical",	TOK_F32(PowerApplication, fAngleToTargetVertical, 0), NULL },
	{ "AngleToSourceVertical",	TOK_F32(PowerApplication, fAngleToSourceVertical, 0), NULL },
	{ "PrimaryTarget",			TOK_BIT, 0, 8, NULL},
	{ "Glancing",				TOK_BIT, 0, 8, NULL},
	{ "MissMods",				TOK_BIT, 0, 8, NULL},
	{ "CountModsAsPostApplied",	TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PowerApplication()
{
	int iSize = sizeof(PowerApplication);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerApplication, iSize, "PowerApplication", NULL, "PowerApplication.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PowerApplication) + 7) / 4;
		PowerApplication *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bPrimaryTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerApplication[18]);
		pTemp->bPrimaryTarget = 0;
		pTemp->bGlancing = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerApplication[19]);
		pTemp->bGlancing = 0;
		pTemp->bMissMods = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerApplication[20]);
		pTemp->bMissMods = 0;
		pTemp->bCountModsAsPostApplied = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerApplication[21]);
		pTemp->bCountModsAsPostApplied = 0;
	}
	return 0;
};
