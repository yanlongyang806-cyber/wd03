#include "textparser.h"

//auto-generated staticdefine for enum ModTarget
//autogeneratednocheckin
StaticDefineInt ModTargetEnum[] =
{
	DEFINE_INT
	{ "Self", kModTarget_Self},
	{ "Target", kModTarget_Target},
	{ "SelfOnce", kModTarget_SelfOnce},
	DEFINE_END
};
void autoEnum_fixup_ModTarget(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ModTargetEnum, "ModTarget");
}

//auto-generated staticdefine for enum ModType
//autogeneratednocheckin
StaticDefineInt ModTypeEnum[] =
{
	DEFINE_INT
	{ "None", kModType_None},
	{ "Magnitude", kModType_Magnitude},
	{ "Duration", kModType_Duration},
	{ "Both", kModType_Both},
	DEFINE_END
};
void autoEnum_fixup_ModType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ModTypeEnum, "ModType");
}

//auto-generated staticdefine for enum StackEntity
//autogeneratednocheckin
StaticDefineInt StackEntityEnum[] =
{
	DEFINE_INT
	{ "Source", kStackEntity_Source},
	{ "Owner", kStackEntity_Owner},
	{ "None", kStackEntity_None},
	DEFINE_END
};
void autoEnum_fixup_StackEntity(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(StackEntityEnum, "StackEntity");
}

//auto-generated staticdefine for enum StackType
//autogeneratednocheckin
StaticDefineInt StackTypeEnum[] =
{
	DEFINE_INT
	{ "Stack", kStackType_Stack},
	{ "Extend", kStackType_Extend},
	{ "Replace", kStackType_Replace},
	{ "Discard", kStackType_Discard},
	{ "KeepBest", kStackType_KeepBest},
	{ "RefreshDuration", kStackType_RefreshDuration},
	DEFINE_END
};
void autoEnum_fixup_StackType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(StackTypeEnum, "StackType");
}

//auto-generated staticdefine for enum ModHitTest
//autogeneratednocheckin
StaticDefineInt ModHitTestEnum[] =
{
	DEFINE_INT
	{ "Hit", kModHitTest_Hit},
	{ "Miss", kModHitTest_Miss},
	{ "HitOrMiss", kModHitTest_HitOrMiss},
	DEFINE_END
};
void autoEnum_fixup_ModHitTest(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ModHitTestEnum, "ModHitTest");
}

//auto-generated staticdefine for enum CombatEventResponse
//autogeneratednocheckin
StaticDefineInt CombatEventResponseEnum[] =
{
	DEFINE_INT
	{ "None", kCombatEventResponse_None},
	{ "CancelIfNew", kCombatEventResponse_CancelIfNew},
	{ "IgnoreIfNew", kCombatEventResponse_IgnoreIfNew},
	{ "Cancel", kCombatEventResponse_Cancel},
	{ "Ignore", kCombatEventResponse_Ignore},
	DEFINE_END
};
void autoEnum_fixup_CombatEventResponse(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(CombatEventResponseEnum, "CombatEventResponse");
}

//auto-generated staticdefine for enum ModExpirationReason
//autogeneratednocheckin
StaticDefineInt ModExpirationReasonEnum[] =
{
	DEFINE_INT
	{ "Unset", kModExpirationReason_Unset},
	{ "AttribModExpire", kModExpirationReason_AttribModExpire},
	{ "Chance", kModExpirationReason_Chance},
	{ "CombatEventCancel", kModExpirationReason_CombatEventCancel},
	{ "Duration", kModExpirationReason_Duration},
	{ "FragileDeath", kModExpirationReason_FragileDeath},
	{ "Immunity", kModExpirationReason_Immunity},
	{ "CharacterDeath", kModExpirationReason_CharacterDeath},
	{ "Charges", kModExpirationReason_Charges},
	{ "AttribLinkExpire", kModExpirationReason_AttribLinkExpire},
	DEFINE_END
};
void autoEnum_fixup_ModExpirationReason(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ModExpirationReasonEnum, "ModExpirationReason");
}

//auto-generated staticdefine for enum ModExpirationEntity
//autogeneratednocheckin
StaticDefineInt ModExpirationEntityEnum[] =
{
	DEFINE_INT
	{ "ModOwner", kModExpirationEntity_ModOwner},
	{ "ModSource", kModExpirationEntity_ModSource},
	{ "ModSourceTargetDual", kModExpirationEntity_ModSourceTargetDual},
	{ "ModTarget", kModExpirationEntity_ModTarget},
	{ "RandomNotSource", kModExpirationEntity_RandomNotSource},
	DEFINE_END
};
void autoEnum_fixup_ModExpirationEntity(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ModExpirationEntityEnum, "ModExpirationEntity");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AttribSet
#define TYPE_parse_AttribSet AttribSet
ParseTable parse_AttribSet[] =
{
	{ "AttribSet", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribSet), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "Name",		TOK_STRUCTPARAM | TOK_STRING(AttribSet, pchName, 0), NULL },
	{ "Attribs",	TOK_INTARRAY(AttribSet, poffAttribs),  AttribTypeEnum},
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AttribSet()
{
	int iSize = sizeof(AttribSet);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribSet, iSize, "AttribSet", NULL, "AttribMod.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribSet[];
#define TYPE_parse_AttribSet AttribSet
//Structparser.exe autogenerated ParseTable for struct AttribSets
#define TYPE_parse_AttribSets AttribSets
ParseTable parse_AttribSets[] =
{
	{ "AttribSets", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribSets), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "Set",		TOK_STRUCT(AttribSets, ppSets, parse_AttribSet) },
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AttribSets()
{
	int iSize = sizeof(AttribSets);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribSets, iSize, "AttribSets", NULL, "AttribMod.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerTagsStruct
#define TYPE_parse_PowerTagsStruct PowerTagsStruct
ParseTable parse_PowerTagsStruct[] =
{
	{ "PowerTagsStruct", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerTagsStruct), 0, NULL, 0, NULL },
	{ "Tags",				TOK_STRUCTPARAM | TOK_INTARRAY(PowerTagsStruct, piTags),  PowerTagsEnum},
	{ "\n",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerTagsStruct()
{
	int iSize = sizeof(PowerTagsStruct);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerTagsStruct, iSize, "PowerTagsStruct", NULL, "AttribMod.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ModExpiration
#define TYPE_parse_ModExpiration ModExpiration
ParseTable parse_ModExpiration[] =
{
	{ "ModExpiration", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ModExpiration), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Def",						TOK_REFERENCE(ModExpiration, hDef, 0, "PowerDef") },
	{ "Target",						TOK_AUTOINT(ModExpiration, eTarget, 0), ModExpirationEntityEnum },
	{ "ExprBlockRequiresExpire",	TOK_OPTIONALLATEBINDSTRUCT(ModExpiration, pExprRequiresExpire) },
	{ "Periodic",					TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_ModExpiration()
{
	int iSize = sizeof(ModExpiration);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ModExpiration, iSize, "ModExpiration", NULL, "AttribMod.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(ModExpiration) + 7) / 4;
		ModExpiration *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bPeriodic = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ModExpiration[5]);
		pTemp->bPeriodic = 0;
	}
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_ModExpiration(void)
{
	DoAutoStructLateBind(parse_ModExpiration, 4, "Expression");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AttribModDefParams
#define TYPE_parse_AttribModDefParams AttribModDefParams
ParseTable parse_AttribModDefParams[] =
{
	{ "AttribModDefParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribModDefParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(AttribModDefParams, eType, 0), AttribTypeEnum },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
//filled in by autogenerated fixup-time calls to AddEntryToPolyTable()
ParseTable polyTable_AttribModDefParams[] = 
{
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 1 }
};
int autoStruct_fixup_AttribModDefParams()
{
	int iSize = sizeof(AttribModDefParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribModDefParams, iSize, "AttribModDefParams", NULL, "AttribMod.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PowerFXParam[];
#define TYPE_parse_PowerFXParam PowerFXParam
extern ParseTable parse_PowerFXParam[];
#define TYPE_parse_PowerFXParam PowerFXParam
//Structparser.exe autogenerated ParseTable for struct AttribModAnimFX
#define TYPE_parse_AttribModAnimFX AttribModAnimFX
ParseTable parse_AttribModAnimFX[] =
{
	{ "AttribModAnimFX", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribModAnimFX), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "ContinuingBits",				TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRINGARRAY(AttribModAnimFX, ppchContinuingBits), NULL },
	{ "ContinuingFX",				TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRINGARRAY(AttribModAnimFX, ppchContinuingFX), NULL },
	{ "StanceWord",					TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRINGARRAY(AttribModAnimFX, ppchStanceWord_unused), NULL },
	{ "AnimKeyword",				TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRING(AttribModAnimFX, pchAnimKeyword_unsued, 0), NULL },
	{ "ContinuingFXParamBlock",		TOK_SERVER_ONLY | TOK_STRUCT(AttribModAnimFX, ppContinuingFXParams, parse_PowerFXParam) },
	{ "ContinuingFxParam",			TOK_REDUNDANTNAME | TOK_SERVER_ONLY | TOK_STRUCT(AttribModAnimFX, ppContinuingFXParams, parse_PowerFXParam_StructParam) },
	{ "ConditionalBits",			TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRINGARRAY(AttribModAnimFX, ppchConditionalBits), NULL },
	{ "ConditionalFX",				TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRINGARRAY(AttribModAnimFX, ppchConditionalFX), NULL },
	{ "ConditionalFXParamBlock",	TOK_SERVER_ONLY | TOK_STRUCT(AttribModAnimFX, ppConditionalFXParams, parse_PowerFXParam) },
	{ "ConditionalFxParam",			TOK_REDUNDANTNAME | TOK_SERVER_ONLY | TOK_STRUCT(AttribModAnimFX, ppConditionalFXParams, parse_PowerFXParam_StructParam) },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AttribModAnimFX()
{
	int iSize = sizeof(AttribModAnimFX);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribModAnimFX, iSize, "AttribModAnimFX", NULL, "AttribMod.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable polyTable_AttribModDefParams[];
extern ParseTable parse_PowerTagsStruct[];
#define TYPE_parse_PowerTagsStruct PowerTagsStruct
extern ParseTable parse_ModDefFragility[];
#define TYPE_parse_ModDefFragility ModDefFragility
extern ParseTable parse_ModExpiration[];
#define TYPE_parse_ModExpiration ModExpiration
extern ParseTable parse_AttribModAnimFX[];
#define TYPE_parse_AttribModAnimFX AttribModAnimFX
extern ParseTable parse_PowerFXParam[];
#define TYPE_parse_PowerFXParam PowerFXParam
extern ParseTable parse_PowerFXParam[];
#define TYPE_parse_PowerFXParam PowerFXParam
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
//Structparser.exe autogenerated ParseTable for struct AttribModDef
#define TYPE_parse_AttribModDef AttribModDef
ParseTable parse_AttribModDef[] =
{
	{ "AttribModDef", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribModDef), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "Attrib",							TOK_AUTOINT(AttribModDef, offAttrib, -1), AttribTypeEnum },
	{ "Aspect",							TOK_AUTOINT(AttribModDef, offAspect, -1), AttribAspectEnum },
	{ "Params",							TOK_OPTIONALPOLYMORPH(AttribModDef, pParams, polyTable_AttribModDefParams) },
	{ "Tags",							TOK_EMBEDDEDSTRUCT(AttribModDef, tags, parse_PowerTagsStruct)},
	{ "",								TOK_AUTOINT(AttribModDef, uiDefIdx, 0), NULL },
	{ "ApplyPriority",					TOK_F32(AttribModDef, fApplyPriority, 0), NULL },
	{ "Key",							TOK_SERVER_ONLY | TOK_KEY | TOK_AUTOINT(AttribModDef, iKey, 0), NULL },
	{ "ExprBlockDuration",				TOK_OPTIONALLATEBINDSTRUCT(AttribModDef, pExprDuration) },
	{ "ExprDurationBlock",				TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AttribModDef, pExprDuration) },
	{ "ExprDuration",					TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AttribModDef, pExprDuration) },
	{ "ExprBlockMagnitude",				TOK_OPTIONALLATEBINDSTRUCT(AttribModDef, pExprMagnitude) },
	{ "ExprMagnitudeBlock",				TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AttribModDef, pExprMagnitude) },
	{ "ExprMagnitude",					TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AttribModDef, pExprMagnitude) },
	{ "TableDefault",					TOK_POOL_STRING | TOK_STRING(AttribModDef, pchTableDefault, 0), NULL },
	{ "Variance",						TOK_F32(AttribModDef, fVariance, 0), NULL },
	{ "Fragility",						TOK_SERVER_ONLY | TOK_OPTIONALSTRUCT(AttribModDef, pFragility, parse_ModDefFragility) },
	{ "Sensitivity",					TOK_SERVER_ONLY | TOK_INTARRAY(AttribModDef, piSensitivities),  SensitivityModsEnum},
	{ "SensitivityStrength",			TOK_NO_TEXT_SAVE | TOK_F32(AttribModDef, fSensitivityStrength, 1.0), NULL },
	{ "SensitivityResistance",			TOK_NO_TEXT_SAVE | TOK_F32(AttribModDef, fSensitivityResistance, 1.0), NULL },
	{ "SensitivityImmune",				TOK_NO_TEXT_SAVE | TOK_F32(AttribModDef, fSensitivityImmune, 1.0), NULL },
	{ "Delay",							TOK_F32(AttribModDef, fDelay, 0), NULL },
	{ "Period",							TOK_F32(AttribModDef, fPeriod, 0), NULL },
	{ "ExprBlockRequires",				TOK_OPTIONALLATEBINDSTRUCT(AttribModDef, pExprRequires) },
	{ "ExprRequiresBlock",				TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AttribModDef, pExprRequires) },
	{ "ExprRequires",					TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AttribModDef, pExprRequires) },
	{ "ExprBlockAffects",				TOK_OPTIONALLATEBINDSTRUCT(AttribModDef, pExprAffects) },
	{ "ExprAffectsBlock",				TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AttribModDef, pExprAffects) },
	{ "ExprAffects",					TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AttribModDef, pExprAffects) },
	{ "ExprBlockIgnores",				TOK_OPTIONALLATEBINDSTRUCT(AttribModDef, pExprIgnores) },
	{ "ExprIgnoresBlock",				TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AttribModDef, pExprIgnores) },
	{ "ExprIgnores",					TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AttribModDef, pExprIgnores) },
	{ "ArcAffects",						TOK_F32(AttribModDef, fArcAffects, 0), NULL },
	{ "Yaw",							TOK_F32(AttribModDef, fYaw, 0), NULL },
	{ "ExprChanceBlock",				TOK_OPTIONALLATEBINDSTRUCT(AttribModDef, pExprChance) },
	{ "Chance",							TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AttribModDef, pExprChance) },
	{ "CombatEvents",					TOK_INTARRAY(AttribModDef, piCombatEvents),  CombatEventEnum},
	{ "CombatEventTime",				TOK_F32(AttribModDef, fCombatEventTime, 0), NULL },
	{ "Expiration",						TOK_OPTIONALSTRUCT(AttribModDef, pExpiration, parse_ModExpiration) },
	{ "StackLimit",						TOK_AUTOINT(AttribModDef, uiStackLimit, 0), NULL },
	{ "AnimFX",							TOK_SERVER_ONLY | TOK_OPTIONALSTRUCT(AttribModDef, pAnimFX, parse_AttribModAnimFX) },
	{ "ContinuingBits",					TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRINGARRAY(AttribModDef, ppchContinuingBits), NULL },
	{ "StanceWord",						TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRINGARRAY(AttribModDef, ppchAttribModDefStanceWordText), NULL },
	{ "AnimKeyword",					TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRING(AttribModDef, pchAttribModDefAnimKeywordText, 0), NULL },
	{ "ContinuingFX",					TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRINGARRAY(AttribModDef, ppchContinuingFX), NULL },
	{ "ContinuingFXParamBlock",			TOK_SERVER_ONLY | TOK_STRUCT(AttribModDef, ppContinuingFXParams, parse_PowerFXParam) },
	{ "ContinuingFxParam",				TOK_REDUNDANTNAME | TOK_SERVER_ONLY | TOK_STRUCT(AttribModDef, ppContinuingFXParams, parse_PowerFXParam_StructParam) },
	{ "ConditionalBits",				TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRINGARRAY(AttribModDef, ppchConditionalBits), NULL },
	{ "ConditionalFX",					TOK_POOL_STRING | TOK_SERVER_ONLY | TOK_STRINGARRAY(AttribModDef, ppchConditionalFX), NULL },
	{ "ConditionalFXParamBlock",		TOK_SERVER_ONLY | TOK_STRUCT(AttribModDef, ppConditionalFXParams, parse_PowerFXParam) },
	{ "ConditionalFxParam",				TOK_REDUNDANTNAME | TOK_SERVER_ONLY | TOK_STRUCT(AttribModDef, ppConditionalFXParams, parse_PowerFXParam_StructParam) },
	{ "msgAutoDesc",					TOK_EMBEDDEDSTRUCT(AttribModDef, msgAutoDesc, parse_DisplayMessage)},
	{ "AutoDescOrder",					TOK_AUTOINT(AttribModDef, iAutoDescOrder, 0), NULL },
	{ "AutoDescKey",					TOK_BIT, 0, 8, NULL},
	{ "AutoDescMagnitudeScale",			TOK_F32(AttribModDef, fAutoDescMagnitudeScale, 0), NULL },
	{ "Target",							TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, ModTargetEnum, 0 , " SPECIAL_DEFAULT = \"2\" "},
	{ "Type",							TOK_BIT, 0, 8, ModTypeEnum},
	{ "HitTest",						TOK_BIT, 0, 8, ModHitTestEnum},
	{ "Flags",							TOK_BIT, 0, 8, CombatTrackerFlagEnum ,  TOK_FORMAT_FLAGS},
	{ "Error",							TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, PowerErrorEnum},
	{ "CombatEventResponse",			TOK_BIT, 0, 8, CombatEventResponseEnum},
	{ "StackEntity",					TOK_BIT, 0, 8, StackEntityEnum},
	{ "Stack",							TOK_BIT, 0, 8, StackTypeEnum},
	{ "StackGroup",						TOK_BIT, 0, 8, ModStackGroupEnum},
	{ "StackGroupPending",				TOK_BIT, 0, 8, ModStackGroupEnum},
	{ "ContinuingFXAsLocation",			TOK_BIT, 0, 8, NULL},
	{ "Personal",						TOK_BIT, 0, 8, NULL},
	{ "EnhancementExtension",			TOK_BIT, 0, 8, NULL},
	{ "EnhancementExtendDef",			TOK_REDUNDANTNAME | TOK_BIT, 0, 8, NULL},
	{ "IgnoreFirstTick",				TOK_BIT, 0, 8, NULL},
	{ "ReplaceKeepsTimer",				TOK_BIT, 0, 8, NULL},
	{ "ChanceNormalized",				TOK_BIT, 0, 8, NULL},
	{ "CancelOnChance",					TOK_BIT, 0, 8, NULL},
	{ "SurviveTargetDeath",				TOK_BIT, 0, 8, NULL},
	{ "KeepWhenImmune",					TOK_BIT, 0, 8, NULL},
	{ "IgnoreAttribModExpire",			TOK_BIT, 0, 8, NULL},
	{ "AutoDescDisabled",				TOK_BIT, 0, 8, NULL},
	{ "DerivedInternally",				TOK_BIT, 0, 8, NULL},
	{ "IgnoredDuringPVP",				TOK_BIT, 0, 8, NULL},
	{ "PowerInstanceStacking",			TOK_BIT, 0, 8, NULL},
	{ "ProcessOfflineTimeOnLogin",		TOK_BIT, 0, 8, NULL},
	{ "UIShowSpecial",					TOK_BIT, 0, 8, NULL},
	{ "NotifyGameEventOnApplication",	TOK_BIT, 0, 8, NULL},
	{ "IncludeInEstimatedDamage",		TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "Forever",						TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "HasAnimFX",						TOK_SERVER_ONLY | TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "SaveApplyStrengths",				TOK_SERVER_ONLY | TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "EntCreateSaveApplyStrengths",	TOK_SERVER_ONLY | TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "SaveSourceDetails",				TOK_SERVER_ONLY | TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "SaveHue",						TOK_SERVER_ONLY | TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "PowerIconCFX",					TOK_SERVER_ONLY | TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "AttribLinkToSource",				TOK_BIT, 0, 8, NULL},
	{ "AffectsOnlyOnFirstModTick",		TOK_BIT, 0, 8, NULL},
	{ "DeactivationLeavesMod",			TOK_SERVER_ONLY | TOK_BIT, 0, 8, NULL},
	{ "Resist",							TOK_IGNORE, 0 },
	{ "Strength",						TOK_IGNORE, 0 },
	{ "Name",							TOK_IGNORE | TOK_STRUCTPARAM, 0 },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AttribModDef()
{
	int iSize = sizeof(AttribModDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribModDef, iSize, "AttribModDef", NULL, "AttribMod.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AttribModDef) + 7) / 4;
		AttribModDef *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->uiAutoDescKey = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[54]);
		pTemp->uiAutoDescKey = 0;
		pTemp->eTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[56]);
		pTemp->eTarget = 0;
		pTemp->eType = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[57]);
		pTemp->eType = 0;
		pTemp->eHitTest = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[58]);
		pTemp->eHitTest = 0;
		pTemp->eFlags = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[59]);
		pTemp->eFlags = 0;
		pTemp->eError = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[60]);
		pTemp->eError = 0;
		pTemp->eCombatEventResponse = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[61]);
		pTemp->eCombatEventResponse = 0;
		pTemp->eStackEntity = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[62]);
		pTemp->eStackEntity = 0;
		pTemp->eStack = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[63]);
		pTemp->eStack = 0;
		pTemp->eStackGroup = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[64]);
		pTemp->eStackGroup = 0;
		pTemp->eStackGroupPending = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[65]);
		pTemp->eStackGroupPending = 0;
		pTemp->bContinuingFXAsLocation = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[66]);
		pTemp->bContinuingFXAsLocation = 0;
		pTemp->bPersonal = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[67]);
		pTemp->bPersonal = 0;
		pTemp->bEnhancementExtension = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[68]);
		pTemp->bEnhancementExtension = 0;
		pTemp->bEnhancementExtension = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[69]);
		pTemp->bEnhancementExtension = 0;
		pTemp->bIgnoreFirstTick = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[70]);
		pTemp->bIgnoreFirstTick = 0;
		pTemp->bReplaceKeepsTimer = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[71]);
		pTemp->bReplaceKeepsTimer = 0;
		pTemp->bChanceNormalized = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[72]);
		pTemp->bChanceNormalized = 0;
		pTemp->bCancelOnChance = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[73]);
		pTemp->bCancelOnChance = 0;
		pTemp->bSurviveTargetDeath = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[74]);
		pTemp->bSurviveTargetDeath = 0;
		pTemp->bKeepWhenImmune = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[75]);
		pTemp->bKeepWhenImmune = 0;
		pTemp->bIgnoreAttribModExpire = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[76]);
		pTemp->bIgnoreAttribModExpire = 0;
		pTemp->bAutoDescDisabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[77]);
		pTemp->bAutoDescDisabled = 0;
		pTemp->bDerivedInternally = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[78]);
		pTemp->bDerivedInternally = 0;
		pTemp->bIgnoredDuringPVP = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[79]);
		pTemp->bIgnoredDuringPVP = 0;
		pTemp->bPowerInstanceStacking = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[80]);
		pTemp->bPowerInstanceStacking = 0;
		pTemp->bProcessOfflineTimeOnLogin = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[81]);
		pTemp->bProcessOfflineTimeOnLogin = 0;
		pTemp->bUIShowSpecial = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[82]);
		pTemp->bUIShowSpecial = 0;
		pTemp->bNotifyGameEventOnApplication = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[83]);
		pTemp->bNotifyGameEventOnApplication = 0;
		pTemp->bIncludeInEstimatedDamage = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[84]);
		pTemp->bIncludeInEstimatedDamage = 0;
		pTemp->bForever = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[85]);
		pTemp->bForever = 0;
		pTemp->bHasAnimFX = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[86]);
		pTemp->bHasAnimFX = 0;
		pTemp->bSaveApplyStrengths = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[87]);
		pTemp->bSaveApplyStrengths = 0;
		pTemp->bEntCreateSaveApplyStrengths = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[88]);
		pTemp->bEntCreateSaveApplyStrengths = 0;
		pTemp->bSaveSourceDetails = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[89]);
		pTemp->bSaveSourceDetails = 0;
		pTemp->bSaveHue = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[90]);
		pTemp->bSaveHue = 0;
		pTemp->bPowerIconCFX = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[91]);
		pTemp->bPowerIconCFX = 0;
		pTemp->bAttribLinkToSource = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[92]);
		pTemp->bAttribLinkToSource = 0;
		pTemp->bAffectsOnlyOnFirstModTick = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[93]);
		pTemp->bAffectsOnlyOnFirstModTick = 0;
		pTemp->bDeactivationLeavesMod = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModDef[94]);
		pTemp->bDeactivationLeavesMod = 0;
	}
	parse_AttribModDef[19].param = GET_INTPTR_FROM_FLOAT((float)1.0);
	parse_AttribModDef[20].param = GET_INTPTR_FROM_FLOAT((float)1.0);
	parse_AttribModDef[21].param = GET_INTPTR_FROM_FLOAT((float)1.0);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_AttribModDef(void)
{
	DoAutoStructLateBind(parse_AttribModDef, 9, "Expression");
	DoAutoStructLateBind(parse_AttribModDef, 10, "Expression");
	DoAutoStructLateBind(parse_AttribModDef, 11, "Expression_StructParam");
	DoAutoStructLateBind(parse_AttribModDef, 12, "Expression");
	DoAutoStructLateBind(parse_AttribModDef, 13, "Expression");
	DoAutoStructLateBind(parse_AttribModDef, 14, "Expression_StructParam");
	DoAutoStructLateBind(parse_AttribModDef, 24, "Expression");
	DoAutoStructLateBind(parse_AttribModDef, 25, "Expression");
	DoAutoStructLateBind(parse_AttribModDef, 26, "Expression_StructParam");
	DoAutoStructLateBind(parse_AttribModDef, 27, "Expression");
	DoAutoStructLateBind(parse_AttribModDef, 28, "Expression");
	DoAutoStructLateBind(parse_AttribModDef, 29, "Expression_StructParam");
	DoAutoStructLateBind(parse_AttribModDef, 30, "Expression");
	DoAutoStructLateBind(parse_AttribModDef, 31, "Expression");
	DoAutoStructLateBind(parse_AttribModDef, 32, "Expression_StructParam");
	DoAutoStructLateBind(parse_AttribModDef, 35, "Expression");
	DoAutoStructLateBind(parse_AttribModDef, 36, "Expression_StructParam");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerApplyStrength
#define TYPE_parse_PowerApplyStrength PowerApplyStrength
ParseTable parse_PowerApplyStrength[] =
{
	{ "PowerApplyStrength", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerApplyStrength), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "hdef",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_REFERENCE(PowerApplyStrength, hdef, 0, "PowerDef") },
	{ "uiVersion",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PowerApplyStrength, uiVersion, 0), NULL },
	{ "pfModStrengths",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32ARRAY(PowerApplyStrength, pfModStrengths), NULL },
	{ "pfModStrAdd",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32ARRAY(PowerApplyStrength, pfModStrAdd), NULL },
	{ "piModFlags",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_INTARRAY(PowerApplyStrength, piModFlags),  NULL},
	{ "pfModCritThreshold",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32ARRAY(PowerApplyStrength, pfModCritThreshold), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
typedef struct MemoryPoolImp *MemoryPool;
extern MemoryPool memPoolPowerApplyStrength;
int autoStruct_fixup_PowerApplyStrength()
{
	int iSize = sizeof(PowerApplyStrength);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerApplyStrength, iSize, "PowerApplyStrength", NULL, "AttribMod.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	ParserSetTPIUsesSingleThreadedMemPool(parse_PowerApplyStrength, &memPoolPowerApplyStrength);
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerClone
#define TYPE_parse_PowerClone PowerClone
ParseTable parse_PowerClone[] =
{
	{ "PowerClone", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerClone), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "hdef",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_REFERENCE(PowerClone, hdef, 0, "PowerDef") },
	{ "iLevel",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(PowerClone, iLevel, 0), NULL },
	{ "fTableScale",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(PowerClone, fTableScale, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerClone()
{
	int iSize = sizeof(PowerClone);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerClone, iSize, "PowerClone", NULL, "AttribMod.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PowerClone[];
#define TYPE_parse_PowerClone PowerClone
extern ParseTable parse_PACritical[];
#define TYPE_parse_PACritical PACritical
//Structparser.exe autogenerated ParseTable for struct AttribModSourceDetails
#define TYPE_parse_AttribModSourceDetails AttribModSourceDetails
ParseTable parse_AttribModSourceDetails[] =
{
	{ "AttribModSourceDetails", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribModSourceDetails), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "hClass",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_REFERENCE(AttribModSourceDetails, hClass, 0, "CharacterClass") },
	{ "iLevel",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(AttribModSourceDetails, iLevel, 0), NULL },
	{ "iIdxMulti",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(AttribModSourceDetails, iIdxMulti, 0), NULL },
	{ "fTableScale",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_F32(AttribModSourceDetails, fTableScale, 0), NULL },
	{ "ppEnhancements",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_STRUCT(AttribModSourceDetails, ppEnhancements, parse_PowerClone) },
	{ "pCritical",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_OPTIONALSTRUCT(AttribModSourceDetails, pCritical, parse_PACritical) },
	{ "erTargetApplication",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(AttribModSourceDetails, erTargetApplication, 0), NULL },
	{ "vecTargetApplication",	TOK_PERSIST | TOK_NO_TRANSACT | TOK_VEC3(AttribModSourceDetails, vecTargetApplication), NULL },
	{ "iItemID",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(AttribModSourceDetails, iItemID, 0), NULL },
	{ "bLevelAdjusting",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
typedef struct MemoryPoolImp *MemoryPool;
extern MemoryPool memPoolAttribModSourceDetails;
int autoStruct_fixup_AttribModSourceDetails()
{
	int iSize = sizeof(AttribModSourceDetails);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribModSourceDetails, iSize, "AttribModSourceDetails", NULL, "AttribMod.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	ParserSetTPIUsesSingleThreadedMemPool(parse_AttribModSourceDetails, &memPoolAttribModSourceDetails);
	{
		int iSizeInWords = (sizeof(NOCONST(AttribModSourceDetails)) + 7) / 4;
		NOCONST(AttribModSourceDetails) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bLevelAdjusting = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModSourceDetails[11]);
		pTemp->bLevelAdjusting = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AttribModParams
#define TYPE_parse_AttribModParams AttribModParams
ParseTable parse_AttribModParams[] =
{
	{ "AttribModParams", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribModParams), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "vecParam",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_VEC3(AttribModParams, vecParam), NULL },
	{ "vecTarget",			TOK_VEC3(AttribModParams, vecTarget), NULL },
	{ "fFacing",			TOK_F32(AttribModParams, fFacing, 0), NULL },
	{ "erParam",			TOK_AUTOINT(AttribModParams, erParam, 0), NULL },
	{ "iParam",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_AUTOINT(AttribModParams, iParam, 0), NULL },
	{ "hNodeParam",			TOK_REFERENCE(AttribModParams, hNodeParam, 0, "WorldInteractionNode") },
	{ "eDynamicCachedType",	TOK_AUTOINT(AttribModParams, eDynamicCachedType, 0), AttribTypeEnum },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AttribModParams()
{
	int iSize = sizeof(AttribModParams);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribModParams, iSize, "AttribModParams", NULL, "AttribMod.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AttribStat
#define TYPE_parse_AttribStat AttribStat
ParseTable parse_AttribStat[] =
{
	{ "AttribStat", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribStat), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "KeyName",			TOK_STRING(AttribStat, pchKeyName, 0), NULL },
	{ "estrNameMessage",	TOK_STRING(AttribStat, estrNameMessage, 0), NULL },
	{ "estrDescMessage",	TOK_STRING(AttribStat, estrDescMessage, 0), NULL },
	{ "Current",			TOK_F32(AttribStat, fCurrent, 0), NULL },
	{ "Base",				TOK_F32(AttribStat, fBase, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AttribStat()
{
	int iSize = sizeof(AttribStat);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribStat, iSize, "AttribStat", NULL, "AttribMod.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AttribModLink
#define TYPE_parse_AttribModLink AttribModLink
ParseTable parse_AttribModLink[] =
{
	{ "AttribModLink", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribModLink), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "uiLinkedApplyID",		TOK_AUTOINT(AttribModLink, uiLinkedApplyID, 0), NULL },
	{ "uiLinkedActIDServer",	TOK_AUTOINT(AttribModLink, uiLinkedActIDServer, 0), NULL },
	{ "uiLinkedDefIdx",			TOK_AUTOINT(AttribModLink, uiLinkedDefIdx, 0), NULL },
	{ "erTarget",				TOK_AUTOINT(AttribModLink, erTarget, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
typedef struct MemoryPoolImp *MemoryPool;
extern MemoryPool memPoolAttribModLink;
int autoStruct_fixup_AttribModLink()
{
	int iSize = sizeof(AttribModLink);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribModLink, iSize, "AttribModLink", NULL, "AttribMod.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	ParserSetTPIUsesSingleThreadedMemPool(parse_AttribModLink, &memPoolAttribModLink);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AttribModParams[];
#define TYPE_parse_AttribModParams AttribModParams
extern ParseTable parse_ModFragility[];
#define TYPE_parse_ModFragility ModFragility
extern ParseTable parse_Power[];
#define TYPE_parse_Power Power
extern ParseTable parse_PowerSubtargetChoice[];
#define TYPE_parse_PowerSubtargetChoice PowerSubtargetChoice
extern ParseTable parse_PowerApplyStrength[];
#define TYPE_parse_PowerApplyStrength PowerApplyStrength
extern ParseTable parse_AttribModSourceDetails[];
#define TYPE_parse_AttribModSourceDetails AttribModSourceDetails
//Structparser.exe autogenerated ParseTable for struct AttribMod
#define TYPE_parse_AttribMod AttribMod
ParseTable parse_AttribMod[] =
{
	{ "AttribMod", 						TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribMod), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "hPowerDef",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_REFERENCE(AttribMod, hPowerDef, 0, "PowerDef") },
	{ "uiVersion",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_AUTOINT(AttribMod, uiVersion, 0), NULL },
	{ "uiDefIdx",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_AUTOINT(AttribMod, uiDefIdx, 0), NULL },
	{ "uiApplyID",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_AUTOINT(AttribMod, uiApplyID, 0), NULL },
	{ "uiPowerID",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_AUTOINT(AttribMod, uiPowerID, 0), NULL },
	{ "iPowerIDSub",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_AUTOINT(AttribMod, iPowerIDSub, 0), NULL },
	{ "iPowerIDLinkedSub",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_AUTOINT(AttribMod, iPowerIDLinkedSub, 0), NULL },
	{ "erPersonal",						TOK_AUTOINT(AttribMod, erPersonal, 0), NULL },
	{ "pParams",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_OPTIONALSTRUCT(AttribMod, pParams, parse_AttribModParams) },
	{ "fHue",							TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_F32(AttribMod, fHue, 0), NULL },
	{ "bActive",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_BIT, 0, 8, NULL},
	{ "bDisabled",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bProcessOfflineTimeOnLogin",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_BIT, 0, 8, NULL},
	{ "bDeathPeekCompleted",			TOK_BIT, 0, 8, NULL},
	{ "bPostFirstTickApply",			TOK_BIT, 0, 8, NULL},
	{ "bProcessedDisplayNameTraker",	TOK_BIT, 0, 8, NULL},
	{ "fDuration",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_F32(AttribMod, fDuration, 0), NULL },
	{ "fDurationOriginal",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_F32(AttribMod, fDurationOriginal, 0), NULL },
	{ "fMagnitude",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_F32(AttribMod, fMagnitude, 0), NULL },
	{ "fMagnitudeOriginal",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_F32(AttribMod, fMagnitudeOriginal, 0), NULL },
	{ "pFragility",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(AttribMod, pFragility, parse_ModFragility) },
	{ "fAvoidance",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_F32(AttribMod, fAvoidance, 0), NULL },
	{ "fTimer",							TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_F32(AttribMod, fTimer, 0), NULL },
	{ "erCreated",						TOK_AUTOINT(AttribMod, erCreated, 0), NULL },
	{ "ppPowersCreated",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_NO_INDEX | TOK_SUBSCRIBE | TOK_STRUCT(AttribMod, ppPowersCreated, parse_Power) },
	{ "pSubtarget",						TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(AttribMod, pSubtarget, parse_PowerSubtargetChoice) },
	{ "ppApplyStrengths",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_STRUCT(AttribMod, ppApplyStrengths, parse_PowerApplyStrength) },
	{ "pSourceDetails",					TOK_PERSIST | TOK_NO_TRANSACT | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(AttribMod, pSourceDetails, parse_AttribModSourceDetails) },
	{ "eFlags",							TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_AUTOINT(AttribMod, eFlags, 0), CombatTrackerFlagEnum  ,  TOK_FORMAT_FLAGS},
	{ "eModPowerSource",				TOK_IGNORE, 0 },
	{ "fCheckTimer",					TOK_IGNORE, 0 },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
typedef struct MemoryPoolImp *MemoryPool;
extern MemoryPool memPoolAttribMod;
int autoStruct_fixup_AttribMod()
{
	int iSize = sizeof(AttribMod);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribMod, iSize, "AttribMod", NULL, "AttribMod.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	ParserSetTPIUsesSingleThreadedMemPool(parse_AttribMod, &memPoolAttribMod);
	{
		int iSizeInWords = (sizeof(NOCONST(AttribMod)) + 7) / 4;
		NOCONST(AttribMod) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bActive = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribMod[12]);
		pTemp->bActive = 0;
		pTemp->bDisabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribMod[13]);
		pTemp->bDisabled = 0;
		pTemp->bProcessOfflineTimeOnLogin = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribMod[14]);
		pTemp->bProcessOfflineTimeOnLogin = 0;
		pTemp->bDeathPeekCompleted = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribMod[15]);
		pTemp->bDeathPeekCompleted = 0;
		pTemp->bPostFirstTickApply = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribMod[16]);
		pTemp->bPostFirstTickApply = 0;
		pTemp->bProcessedDisplayNameTraker = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribMod[17]);
		pTemp->bProcessedDisplayNameTraker = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AttribModNet
#define TYPE_parse_AttribModNet AttribModNet
ParseTable parse_AttribModNet[] =
{
	{ "AttribModNet", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AttribModNet), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "dirtyBit",			TOK_DIRTY_BIT | TOK_SERVER_ONLY | TOK_AUTOINT(AttribModNet, dirtyBit, 0), NULL },
	{ "hPowerDef",			TOK_REFERENCE(AttribModNet, hPowerDef, 0, "PowerDef") },
	{ "uiDefIdx",			TOK_AUTOINT(AttribModNet, uiDefIdx, 0), NULL },
	{ "uiDurationOriginal",	TOK_AUTOINT(AttribModNet, uiDurationOriginal, 0), NULL },
	{ "Magnitude",			TOK_AUTOINT(AttribModNet, iMagnitude, 0), NULL },
	{ "MagnitudeOriginal",	TOK_AUTOINT(AttribModNet, iMagnitudeOriginal, 0), NULL },
	{ "Health",				TOK_AUTOINT(AttribModNet, iHealth, 0), NULL },
	{ "HealthMax",			TOK_AUTOINT(AttribModNet, iHealthMax, 0), NULL },
	{ "ResistPositive",		TOK_BIT, 0, 8, NULL},
	{ "ResistNegative",		TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
typedef struct MemoryPoolImp *MemoryPool;
extern MemoryPool memPoolAttribModNet;
int autoStruct_fixup_AttribModNet()
{
	int iSize = sizeof(AttribModNet);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AttribModNet, iSize, "AttribModNet", NULL, "AttribMod.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	ParserSetTPIUsesSingleThreadedMemPool(parse_AttribModNet, &memPoolAttribModNet);
	{
		int iSizeInWords = (sizeof(AttribModNet) + 7) / 4;
		AttribModNet *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bResistPositive = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModNet[10]);
		pTemp->bResistPositive = 0;
		pTemp->bResistNegative = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AttribModNet[11]);
		pTemp->bResistNegative = 0;
	}
	return 0;
};
