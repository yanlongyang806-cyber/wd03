#include "textparser.h"

//auto-generated staticdefine for enum PTNodeFlag
//autogeneratednocheckin
StaticDefineInt PTNodeFlagEnum[] =
{
	DEFINE_INT
	{ "SneakPower", kNodeFlag_Deprecated},
	{ "StrugglePower", kNodeFlag_Deprecated},
	{ "TravelPower", kNodeFlag_Deprecated},
	{ "EndurancePower", kNodeFlag_Deprecated},
	{ "BlockPower", kNodeFlag_Deprecated},
	{ "PickUpPower", kNodeFlag_Deprecated},
	{ "AutoBuy", kNodeFlag_AutoBuy},
	{ "AutoAttack", kNodeFlag_AutoAttack},
	{ "HideNode", kNodeFlag_HideNode},
	{ "AutoSlot", kNodeFlag_AutoSlot},
	{ "MasterNode", kNodeFlag_MasterNode},
	{ "RequireTraining", kNodeFlag_RequireTraining},
	DEFINE_END
};
void autoEnum_fixup_PTNodeFlag(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PTNodeFlagEnum, "PTNodeFlag");
}

//auto-generated staticdefine for enum PTRespecGroupType
//autogeneratednocheckin
extern DefineContext *g_PTRespecGroupType;
StaticDefineInt PTRespecGroupTypeEnum[] =
{
	DEFINE_INT
	{ "kPTRespecGroup_ALL", kPTRespecGroup_ALL},
	DEFINE_EMBEDDYNAMIC_INT(g_PTRespecGroupType)
	DEFINE_END
};
void autoEnum_fixup_PTRespecGroupType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PTRespecGroupTypeEnum, "PTRespecGroupType");
}

//auto-generated staticdefine for enum PTNodeUICategory
//autogeneratednocheckin
extern DefineContext *g_pNodeUICategories;
StaticDefineInt PTNodeUICategoryEnum[] =
{
	DEFINE_INT
	{ "None", kPTNodeUICategory_None},
	DEFINE_EMBEDDYNAMIC_INT(g_pNodeUICategories)
	DEFINE_END
};
void autoEnum_fixup_PTNodeUICategory(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PTNodeUICategoryEnum, "PTNodeUICategory");
}

//auto-generated staticdefine for enum PowerTreeRelationship
//autogeneratednocheckin
StaticDefineInt PowerTreeRelationshipEnum[] =
{
	DEFINE_INT
	{ "Unknown", kPowerTreeRelationship_Unknown},
	{ "DependsOn", kPowerTreeRelationship_DependsOn},
	{ "DependencyOf", kPowerTreeRelationship_DependencyOf},
	DEFINE_END
};
void autoEnum_fixup_PowerTreeRelationship(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PowerTreeRelationshipEnum, "PowerTreeRelationship");
}

//auto-generated staticdefine for enum PowerTreeUICategory
//autogeneratednocheckin
extern DefineContext *g_pUICategories;
StaticDefineInt PowerTreeUICategoryEnum[] =
{
	DEFINE_INT
	DEFINE_EMBEDDYNAMIC_INT(g_pUICategories)
	DEFINE_END
};
void autoEnum_fixup_PowerTreeUICategory(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PowerTreeUICategoryEnum, "PowerTreeUICategory");
}

//auto-generated staticdefine for enum PowerTreeRespec
//autogeneratednocheckin
StaticDefineInt PowerTreeRespecEnum[] =
{
	DEFINE_INT
	{ "None", kPowerTreeRespec_None},
	{ "Remove", kPowerTreeRespec_Remove},
	{ "Reset", kPowerTreeRespec_Reset},
	DEFINE_END
};
void autoEnum_fixup_PowerTreeRespec(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(PowerTreeRespecEnum, "PowerTreeRespec");
}

//auto-generated staticdefine for enum Respec_Type
//autogeneratednocheckin
StaticDefineInt Respec_TypeEnum[] =
{
	DEFINE_INT
	{ "All", kRespecType_All},
	{ "PowersAndTrees", kRespecType_PowersAndTrees},
	DEFINE_END
};
void autoEnum_fixup_Respec_Type(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(Respec_TypeEnum, "Respec_Type");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PTRespecGroupTypeName
#define TYPE_parse_PTRespecGroupTypeName PTRespecGroupTypeName
ParseTable parse_PTRespecGroupTypeName[] =
{
	{ "PTRespecGroupTypeName", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PTRespecGroupTypeName), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Name",					TOK_STRING(PTRespecGroupTypeName, pcName, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PTRespecGroupTypeName()
{
	int iSize = sizeof(PTRespecGroupTypeName);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PTRespecGroupTypeName, iSize, "PTRespecGroupTypeName", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PTRespecGroupTypeName[];
#define TYPE_parse_PTRespecGroupTypeName PTRespecGroupTypeName
//Structparser.exe autogenerated ParseTable for struct PTRespecGroupTypeNames
#define TYPE_parse_PTRespecGroupTypeNames PTRespecGroupTypeNames
ParseTable parse_PTRespecGroupTypeNames[] =
{
	{ "PTRespecGroupTypeNames", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PTRespecGroupTypeNames), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Names",					TOK_STRUCT(PTRespecGroupTypeNames, eaNames, parse_PTRespecGroupTypeName) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PTRespecGroupTypeNames()
{
	int iSize = sizeof(PTRespecGroupTypeNames);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PTRespecGroupTypeNames, iSize, "PTRespecGroupTypeNames", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PTTypeDef
#define TYPE_parse_PTTypeDef PTTypeDef
ParseTable parse_PTTypeDef[] =
{
	{ "PTTypeDef", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PTTypeDef), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Name",					TOK_STRUCTPARAM | TOK_KEY | TOK_STRING(PTTypeDef, pchTreeType, 0), NULL },
	{ "PurchaseExpression",		TOK_OPTIONALLATEBINDSTRUCT(PTTypeDef, pExprPurchase) },
	{ "TableScale",				TOK_F32(PTTypeDef, fTableScale, 1.0), NULL },
	{ "CostScale",				TOK_F32ARRAY(PTTypeDef, pfCostScale), NULL },
	{ "Order",					TOK_AUTOINT(PTTypeDef, iOrder, 0), NULL },
	{ "RespecGroup",			TOK_INTARRAY(PTTypeDef, eaiRespecGroupType),  PTRespecGroupTypeEnum},
	{ "NonRefundable",			TOK_BIT, 0, 8, NULL},
	{ "SpentPointsNonDynamic",	TOK_BIT, 0, 8, NULL},
	{ "OnlyRespecUsingFull",	TOK_BIT, 0, 8, NULL},
	{ "HasAutoBuyTrees",		TOK_BIT, 0, 8, NULL},
	{ "SpentPointsNumeric",		TOK_STRING(PTTypeDef, pchSpentPointsNumeric, 0), NULL },
	{ "DisregardPath",			TOK_BIT, 0, 8, NULL},
	{ "FirstGroupMax",			TOK_IGNORE, 0 },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PTTypeDef()
{
	int iSize = sizeof(PTTypeDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PTTypeDef, iSize, "PTTypeDef", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PTTypeDef) + 7) / 4;
		PTTypeDef *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bNonRefundable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PTTypeDef[8]);
		pTemp->bNonRefundable = 0;
		pTemp->bSpentPointsNonDynamic = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PTTypeDef[9]);
		pTemp->bSpentPointsNonDynamic = 0;
		pTemp->bOnlyRespecUsingFull = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PTTypeDef[10]);
		pTemp->bOnlyRespecUsingFull = 0;
		pTemp->bHasAutoBuyTrees = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PTTypeDef[11]);
		pTemp->bHasAutoBuyTrees = 0;
		pTemp->bDisregardPath = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PTTypeDef[13]);
		pTemp->bDisregardPath = 0;
	}
	parse_PTTypeDef[4].param = GET_INTPTR_FROM_FLOAT((float)1.0);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_PTTypeDef(void)
{
	DoAutoStructLateBind(parse_PTTypeDef, 3, "Expression");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PTNodeTypeDef
#define TYPE_parse_PTNodeTypeDef PTNodeTypeDef
ParseTable parse_PTNodeTypeDef[] =
{
	{ "PTNodeTypeDef", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PTNodeTypeDef), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Name",				TOK_STRUCTPARAM | TOK_KEY | TOK_STRING(PTNodeTypeDef, pchNodeType, 0), NULL },
	{ "PurchaseExpression",	TOK_OPTIONALLATEBINDSTRUCT(PTNodeTypeDef, pExpr) },
	{ "SubTypes",			TOK_STRINGARRAY(PTNodeTypeDef, ppchSubTypes), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PTNodeTypeDef()
{
	int iSize = sizeof(PTNodeTypeDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PTNodeTypeDef, iSize, "PTNodeTypeDef", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_PTNodeTypeDef(void)
{
	DoAutoStructLateBind(parse_PTNodeTypeDef, 3, "Expression");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PTEnhTypeDef
#define TYPE_parse_PTEnhTypeDef PTEnhTypeDef
ParseTable parse_PTEnhTypeDef[] =
{
	{ "PTEnhTypeDef", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PTEnhTypeDef), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Name",				TOK_STRUCTPARAM | TOK_KEY | TOK_STRING(PTEnhTypeDef, pchEnhType, 0), NULL },
	{ "PurchaseExpression",	TOK_OPTIONALLATEBINDSTRUCT(PTEnhTypeDef, pExpr) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PTEnhTypeDef()
{
	int iSize = sizeof(PTEnhTypeDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PTEnhTypeDef, iSize, "PTEnhTypeDef", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_PTEnhTypeDef(void)
{
	DoAutoStructLateBind(parse_PTEnhTypeDef, 3, "Expression");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PTPurchaseRequirements
#define TYPE_parse_PTPurchaseRequirements PTPurchaseRequirements
ParseTable parse_PTPurchaseRequirements[] =
{
	{ "PTPurchaseRequirements", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PTPurchaseRequirements), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "hGroup",						TOK_USEROPTIONBIT_1 | TOK_REFERENCE(PTPurchaseRequirements, hGroup, 0, "PowerTreeGroupDef") },
	{ "GroupRequired",				TOK_USEROPTIONBIT_1 | TOK_AUTOINT(PTPurchaseRequirements, iGroupRequired, 1), NULL },
	{ "TableLevel",					TOK_USEROPTIONBIT_1 | TOK_AUTOINT(PTPurchaseRequirements, iTableLevel, 0), NULL },
	{ "CharacterLevel",				TOK_REDUNDANTNAME | TOK_USEROPTIONBIT_1 | TOK_AUTOINT(PTPurchaseRequirements, iTableLevel, 0), NULL },
	{ "DerivedTableLevel",			TOK_NO_TEXT_SAVE | TOK_AUTOINT(PTPurchaseRequirements, iDerivedTableLevel, 0), NULL },
	{ "PointsSpentInThisTree",		TOK_AUTOINT(PTPurchaseRequirements, iMinPointsSpentInThisTree, 0), NULL },
	{ "MinPointsSpentInThisTree",	TOK_REDUNDANTNAME | TOK_AUTOINT(PTPurchaseRequirements, iMinPointsSpentInThisTree, 0), NULL },
	{ "MaxPointsSpentInThisTree",	TOK_AUTOINT(PTPurchaseRequirements, iMaxPointsSpentInThisTree, 0), NULL },
	{ "PointsSpentInAnyTree",		TOK_AUTOINT(PTPurchaseRequirements, iMinPointsSpentInAnyTree, 0), NULL },
	{ "MinPointsSpentInAnyTree",	TOK_REDUNDANTNAME | TOK_AUTOINT(PTPurchaseRequirements, iMinPointsSpentInAnyTree, 0), NULL },
	{ "MaxPointsSpentInAnyTree",	TOK_AUTOINT(PTPurchaseRequirements, iMaxPointsSpentInAnyTree, 0), NULL },
	{ "TableName",					TOK_USEROPTIONBIT_1 | TOK_STRING(PTPurchaseRequirements, pchTableName, "TreePoints"), NULL },
	{ "PurchaseExpression",			TOK_USEROPTIONBIT_1 | TOK_OPTIONALLATEBINDSTRUCT(PTPurchaseRequirements, pExprPurchase) },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PTPurchaseRequirements()
{
	int iSize = sizeof(PTPurchaseRequirements);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PTPurchaseRequirements, iSize, "PTPurchaseRequirements", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_PTPurchaseRequirements(void)
{
	DoAutoStructLateBind(parse_PTPurchaseRequirements, 14, "Expression");
}
//autogeneratednocheckin
extern ParseTable parse_PTPurchaseRequirements[];
#define TYPE_parse_PTPurchaseRequirements PTPurchaseRequirements
//Structparser.exe autogenerated ParseTable for struct PTNodeRankDef
#define TYPE_parse_PTNodeRankDef PTNodeRankDef
ParseTable parse_PTNodeRankDef[] =
{
	{ "PTNodeRankDef", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PTNodeRankDef), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Power",				TOK_REFERENCE(PTNodeRankDef, hPowerDef, 0, "PowerDef") },
	{ "Requires",			TOK_ALWAYS_ALLOC | TOK_OPTIONALSTRUCT(PTNodeRankDef, pRequires, parse_PTPurchaseRequirements) },
	{ "TrainerUnlockNode",	TOK_REFERENCE(PTNodeRankDef, hTrainerUnlockNode, 0, "PTNodeDef") },
	{ "Cost",				TOK_AUTOINT(PTNodeRankDef, iCost, 1), NULL },
	{ "CostScaled",			TOK_NO_TEXT_SAVE | TOK_AUTOINT(PTNodeRankDef, iCostScaled, 0), NULL },
	{ "CostVar",			TOK_STRING(PTNodeRankDef, pchCostVar, 0), NULL },
	{ "CostTable",			TOK_STRING(PTNodeRankDef, pchCostTable, "TreePoints"), NULL },
	{ "Empty",				TOK_AUTOINT(PTNodeRankDef, bEmpty, 0), NULL },
	{ "ForcedAutoBuy",		TOK_AUTOINT(PTNodeRankDef, bForcedAutoBuy, 0), NULL },
	{ "IgnoreRequires",		TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "VariableCost",		TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "Scale",				TOK_IGNORE, 0 },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PTNodeRankDef()
{
	int iSize = sizeof(PTNodeRankDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PTNodeRankDef, iSize, "PTNodeRankDef", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PTNodeRankDef) + 7) / 4;
		PTNodeRankDef *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bIgnoreRequires = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PTNodeRankDef[11]);
		pTemp->bIgnoreRequires = 0;
		pTemp->bVariableCost = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PTNodeRankDef[12]);
		pTemp->bVariableCost = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PTNodeEnhancementDef
#define TYPE_parse_PTNodeEnhancementDef PTNodeEnhancementDef
ParseTable parse_PTNodeEnhancementDef[] =
{
	{ "PTNodeEnhancementDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PTNodeEnhancementDef), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Power",					TOK_REFERENCE(PTNodeEnhancementDef, hPowerDef, 0, "PowerDef") },
	{ "LevelMax",				TOK_AUTOINT(PTNodeEnhancementDef, iLevelMax, 0), NULL },
	{ "Cost",					TOK_AUTOINT(PTNodeEnhancementDef, iCost, 1.0), NULL },
	{ "EnhType",				TOK_REFERENCE(PTNodeEnhancementDef, hEnhType, 0, "PTEnhTypeDef") },
	{ "CostTable",				TOK_STRING(PTNodeEnhancementDef, pchCostTable, "EnhPoints"), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PTNodeEnhancementDef()
{
	int iSize = sizeof(PTNodeEnhancementDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PTNodeEnhancementDef, iSize, "PTNodeEnhancementDef", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PTNodeUICategories
#define TYPE_parse_PTNodeUICategories PTNodeUICategories
ParseTable parse_PTNodeUICategories[] =
{
	{ "PTNodeUICategories", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PTNodeUICategories), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "UICategoryName",		TOK_STRINGARRAY(PTNodeUICategories, pchNames), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PTNodeUICategories()
{
	int iSize = sizeof(PTNodeUICategories);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PTNodeUICategories, iSize, "PTNodeUICategories", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_PTNodeRankDef[];
#define TYPE_parse_PTNodeRankDef PTNodeRankDef
extern ParseTable parse_PTNodeEnhancementDef[];
#define TYPE_parse_PTNodeEnhancementDef PTNodeEnhancementDef
//Structparser.exe autogenerated ParseTable for struct PTNodeDef
#define TYPE_parse_PTNodeDef PTNodeDef
ParseTable parse_PTNodeDef[] =
{
	{ "PTNodeDef", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PTNodeDef), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Name",				TOK_USEROPTIONBIT_1 | TOK_STRING(PTNodeDef, pchName, 0), NULL },
	{ "NameFull",			TOK_STRUCTPARAM | TOK_USEROPTIONBIT_1 | TOK_POOL_STRING | TOK_KEY | TOK_STRING(PTNodeDef, pchNameFull, 0), NULL },
	{ "DisplayMessage",		TOK_USEROPTIONBIT_1 | TOK_EMBEDDEDSTRUCT(PTNodeDef, pDisplayMessage, parse_DisplayMessage)},
	{ "msgRequirements",	TOK_USEROPTIONBIT_1 | TOK_EMBEDDEDSTRUCT(PTNodeDef, msgRequirements, parse_DisplayMessage)},
	{ "hNodeRequire",		TOK_USEROPTIONBIT_1 | TOK_REFERENCE(PTNodeDef, hNodeRequire, 0, "PowerTreeNodeDef") },
	{ "Required",			TOK_USEROPTIONBIT_1 | TOK_AUTOINT(PTNodeDef, iRequired, 1), NULL },
	{ "Clone",				TOK_USEROPTIONBIT_1 | TOK_REFERENCE(PTNodeDef, hNodeClone, 0, "PTNodeDef") },
	{ "NodePowerSlot",		TOK_REFERENCE(PTNodeDef, hNodePowerSlot, 0, "PTNodeDef") },
	{ "AltTrainerNode",		TOK_REFERENCE(PTNodeDef, hNodeAltTrainer, 0, "PTNodeDef") },
	{ "",					TOK_USEROPTIONBIT_1 | TOK_REFERENCE(PTNodeDef, hTreeClone, 0, "PowerTreeDef") },
	{ "GrantSlot",			TOK_REFERENCE(PTNodeDef, hGrantSlot, 0, "PowerReplaceDef") },
	{ "NodeType",			TOK_REFERENCE(PTNodeDef, hNodeType, 0, "PTNodeTypeDef") },
	{ "AccessCondition",	TOK_OPTIONALLATEBINDSTRUCT(PTNodeDef, pExprAccessCondition) },
	{ "Rank",				TOK_NO_INDEX | TOK_STRUCT(PTNodeDef, ppRanks, parse_PTNodeRankDef) },
	{ "Enhancement",		TOK_STRUCT(PTNodeDef, ppEnhancements, parse_PTNodeEnhancementDef) },
	{ "CostMaxEnhancement",	TOK_AUTOINT(PTNodeDef, iCostMaxEnhancement, 0), NULL },
	{ "Attrib",				TOK_AUTOINT(PTNodeDef, eAttrib, -1), AttribTypeEnum },
	{ "AttribPowerTable",	TOK_POOL_STRING | TOK_STRING(PTNodeDef, pchAttribPowerTable, 0), NULL },
	{ "Flags",				TOK_AUTOINT(PTNodeDef, eFlag, 0), PTNodeFlagEnum  ,  TOK_FORMAT_FLAGS},
	{ "Purpose",			TOK_AUTOINT(PTNodeDef, ePurpose, 0), PowerPurposeEnum },
	{ "IconName",			TOK_POOL_STRING | TOK_STRING(PTNodeDef, pchIconName, 0), NULL },
	{ "CloneSystem",		TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "HasCosts",			TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "RankCostTablesVary",	TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "Slave",				TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "ForcedAutoBuy",		TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "UICategory",			TOK_AUTOINT(PTNodeDef, eUICategory, 0), PTNodeUICategoryEnum },
	{ "UIGridRow",			TOK_AUTOINT(PTNodeDef, iUIGridRow, 0), NULL },
	{ "UIGridColumn",		TOK_AUTOINT(PTNodeDef, iUIGridColumn, 0), NULL },
	{ "KeyBind",			TOK_IGNORE, 0 },
	{ "GrantInvSlot",		TOK_IGNORE, 0 },
	{ "Templates",			TOK_IGNORE | TOK_IGNORE_STRUCT , 0 },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PTNodeDef()
{
	int iSize = sizeof(PTNodeDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PTNodeDef, iSize, "PTNodeDef", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PTNodeDef) + 7) / 4;
		PTNodeDef *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bCloneSystem = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PTNodeDef[23]);
		pTemp->bCloneSystem = 0;
		pTemp->bHasCosts = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PTNodeDef[24]);
		pTemp->bHasCosts = 0;
		pTemp->bRankCostTablesVary = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PTNodeDef[25]);
		pTemp->bRankCostTablesVary = 0;
		pTemp->bSlave = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PTNodeDef[26]);
		pTemp->bSlave = 0;
		pTemp->bForcedAutoBuy = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PTNodeDef[27]);
		pTemp->bForcedAutoBuy = 0;
	}
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_PTNodeDef(void)
{
	DoAutoStructLateBind(parse_PTNodeDef, 14, "Expression");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PTNodeDefRef
#define TYPE_parse_PTNodeDefRef PTNodeDefRef
ParseTable parse_PTNodeDefRef[] =
{
	{ "PTNodeDefRef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PTNodeDefRef), 0, NULL, 0, NULL },
	{ "NodeDef",		TOK_STRUCTPARAM | TOK_REFERENCE(PTNodeDefRef, hNodeDef, 0, "PTNodeDef") },
	{ "\n",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PTNodeDefRef()
{
	int iSize = sizeof(PTNodeDefRef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PTNodeDefRef, iSize, "PTNodeDefRef", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PTNodeDefRefCont
#define TYPE_parse_PTNodeDefRefCont PTNodeDefRefCont
ParseTable parse_PTNodeDefRefCont[] =
{
	{ "PTNodeDefRefCont", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PTNodeDefRefCont), 0, NULL, 0, NULL },
	{ "NodeDef",			TOK_STRUCTPARAM | TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(PTNodeDefRefCont, hNodeDef, 0, "PowerTreeNodeDef") },
	{ "hNodeDef",			TOK_REDUNDANTNAME | TOK_STRUCTPARAM | TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(PTNodeDefRefCont, hNodeDef, 0, "PowerTreeNodeDef") },
	{ "\n",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PTNodeDefRefCont()
{
	int iSize = sizeof(PTNodeDefRefCont);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PTNodeDefRefCont, iSize, "PTNodeDefRefCont", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerPurchaseTracker
#define TYPE_parse_PowerPurchaseTracker PowerPurchaseTracker
ParseTable parse_PowerPurchaseTracker[] =
{
	{ "PowerPurchaseTracker", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerPurchaseTracker), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "uiTimeCreated",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(PowerPurchaseTracker, uiTimeCreated, 0), NULL },
	{ "uiOrderCreated",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(PowerPurchaseTracker, uiOrderCreated, 0), NULL },
	{ "bStepIsLocked",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PowerPurchaseTracker()
{
	int iSize = sizeof(PowerPurchaseTracker);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerPurchaseTracker, iSize, "PowerPurchaseTracker", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(PowerPurchaseTracker)) + 7) / 4;
		NOCONST(PowerPurchaseTracker) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bStepIsLocked = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerPurchaseTracker[4]);
		pTemp->bStepIsLocked = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PowerPurchaseTracker[];
#define TYPE_parse_PowerPurchaseTracker PowerPurchaseTracker
//Structparser.exe autogenerated ParseTable for struct PTNodeEnhancementTracker
#define TYPE_parse_PTNodeEnhancementTracker PTNodeEnhancementTracker
ParseTable parse_PTNodeEnhancementTracker[] =
{
	{ "PTNodeEnhancementTracker", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PTNodeEnhancementTracker), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "hDef",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(PTNodeEnhancementTracker, hDef, 0, "PowerDef") },
	{ "ppPurchases",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_STRUCT(PTNodeEnhancementTracker, ppPurchases, parse_PowerPurchaseTracker) },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PTNodeEnhancementTracker()
{
	int iSize = sizeof(PTNodeEnhancementTracker);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PTNodeEnhancementTracker, iSize, "PTNodeEnhancementTracker", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PowerPurchaseTracker[];
#define TYPE_parse_PowerPurchaseTracker PowerPurchaseTracker
extern ParseTable parse_Power[];
#define TYPE_parse_Power Power
extern ParseTable parse_Power[];
#define TYPE_parse_Power Power
extern ParseTable parse_PTNodeEnhancementTracker[];
#define TYPE_parse_PTNodeEnhancementTracker PTNodeEnhancementTracker
//Structparser.exe autogenerated ParseTable for struct PTNode
#define TYPE_parse_PTNode PTNode
ParseTable parse_PTNode[] =
{
	{ "PTNode", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PTNode), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "hDef",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_KEY | TOK_REFERENCE(PTNode, hDef, 0, "PowerTreeNodeDef") },
	{ "iRank",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(PTNode, iRank, 0), NULL },
	{ "bEscrow",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(PTNode, bEscrow, 0), NULL },
	{ "uiPowerReplaceID",		TOK_AUTOINT(PTNode, uiPowerReplaceID, 0), NULL },
	{ "ppPurchaseTracker",		TOK_PERSIST | TOK_NO_INDEX | TOK_SUBSCRIBE | TOK_STRUCT(PTNode, ppPurchaseTracker, parse_PowerPurchaseTracker) },
	{ "ppPowers",				TOK_PERSIST | TOK_NO_INDEX | TOK_SUBSCRIBE | TOK_STRUCT(PTNode, ppPowers, parse_Power) },
	{ "ppEnhancements",			TOK_PERSIST | TOK_NO_INDEX | TOK_SUBSCRIBE | TOK_STRUCT(PTNode, ppEnhancements, parse_Power) },
	{ "ppEnhancementTrackers",	TOK_PERSIST | TOK_SUBSCRIBE | TOK_STRUCT(PTNode, ppEnhancementTrackers, parse_PTNodeEnhancementTracker) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PTNode()
{
	int iSize = sizeof(PTNode);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PTNode, iSize, "PTNode", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_PTPurchaseRequirements[];
#define TYPE_parse_PTPurchaseRequirements PTPurchaseRequirements
extern ParseTable parse_PTNodeDef[];
#define TYPE_parse_PTNodeDef PTNodeDef
//Structparser.exe autogenerated ParseTable for struct PTGroupDef
#define TYPE_parse_PTGroupDef PTGroupDef
ParseTable parse_PTGroupDef[] =
{
	{ "PTGroupDef", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PTGroupDef), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Group",						TOK_STRING(PTGroupDef, pchGroup, 0), NULL },
	{ "NameFull",					TOK_STRUCTPARAM | TOK_KEY | TOK_STRING(PTGroupDef, pchNameFull, 0), NULL },
	{ "DisplayMessage",				TOK_EMBEDDEDSTRUCT(PTGroupDef, pDisplayMessage, parse_DisplayMessage)},
	{ "DisplayDescription",			TOK_EMBEDDEDSTRUCT(PTGroupDef, pDisplayDescription, parse_DisplayMessage)},
	{ "Requires",					TOK_ALWAYS_ALLOC | TOK_OPTIONALSTRUCT(PTGroupDef, pRequires, parse_PTPurchaseRequirements) },
	{ "Max",						TOK_AUTOINT(PTGroupDef, iMax, 0), NULL },
	{ "x",							TOK_AUTOINT(PTGroupDef, x, 0), NULL },
	{ "y",							TOK_AUTOINT(PTGroupDef, y, 0), NULL },
	{ "Order",						TOK_AUTOINT(PTGroupDef, iOrder, 0), NULL },
	{ "Node",						TOK_NO_INDEX | TOK_STRUCT(PTGroupDef, ppNodes, parse_PTNodeDef) },
	{ "UIGridRow",					TOK_AUTOINT(PTGroupDef, iUIGridRow, 0), NULL },
	{ "UIIgnoreGroupRequirements",	TOK_AUTOINT(PTGroupDef, bUIIgnoreGroupRequirements, 0), NULL },
	{ "HasMasterNode",				TOK_NO_TEXT_SAVE | TOK_BIT, 0, 8, NULL},
	{ "isFirst",					TOK_IGNORE, 0 },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PTGroupDef()
{
	int iSize = sizeof(PTGroupDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PTGroupDef, iSize, "PTGroupDef", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PTGroupDef) + 7) / 4;
		PTGroupDef *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bHasMasterNode = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PTGroupDef[14]);
		pTemp->bHasMasterNode = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerTreeLink
#define TYPE_parse_PowerTreeLink PowerTreeLink
ParseTable parse_PowerTreeLink[] =
{
	{ "PowerTreeLink", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerTreeLink), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "hTree",			TOK_REFERENCE(PowerTreeLink, hTree, 0, "PowerTreeDef") },
	{ "Type",			TOK_AUTOINT(PowerTreeLink, eType, 0), PowerTreeRelationshipEnum },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerTreeLink()
{
	int iSize = sizeof(PowerTreeLink);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerTreeLink, iSize, "PowerTreeLink", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerTreeUICategories
#define TYPE_parse_PowerTreeUICategories PowerTreeUICategories
ParseTable parse_PowerTreeUICategories[] =
{
	{ "PowerTreeUICategories", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerTreeUICategories), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "UICategoryName",			TOK_STRINGARRAY(PowerTreeUICategories, pchNames), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerTreeUICategories()
{
	int iSize = sizeof(PowerTreeUICategories);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerTreeUICategories, iSize, "PowerTreeUICategories", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PowerTreeDef[];
#define TYPE_parse_PowerTreeDef PowerTreeDef
//Structparser.exe autogenerated ParseTable for struct RespecPowerTreePlayer
#define TYPE_parse_RespecPowerTreePlayer RespecPowerTreePlayer
ParseTable parse_RespecPowerTreePlayer[] =
{
	{ "RespecPowerTreePlayer", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(RespecPowerTreePlayer), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "PowerTreeDef",			TOK_UNOWNED | TOK_OPTIONALSTRUCT(RespecPowerTreePlayer, pPowerTreeDef, parse_PowerTreeDef) },
	{ "PurchaseTime",			TOK_AUTOINT(RespecPowerTreePlayer, iPurchaseTime, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_RespecPowerTreePlayer()
{
	int iSize = sizeof(RespecPowerTreePlayer);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_RespecPowerTreePlayer, iSize, "RespecPowerTreePlayer", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PowerDef[];
#define TYPE_parse_PowerDef PowerDef
//Structparser.exe autogenerated ParseTable for struct RespecPowerPlayer
#define TYPE_parse_RespecPowerPlayer RespecPowerPlayer
ParseTable parse_RespecPowerPlayer[] =
{
	{ "RespecPowerPlayer", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(RespecPowerPlayer), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "PowerDef",			TOK_UNOWNED | TOK_OPTIONALSTRUCT(RespecPowerPlayer, pPowerDef, parse_PowerDef) },
	{ "PurchaseTime",		TOK_AUTOINT(RespecPowerPlayer, iPurchaseTime, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_RespecPowerPlayer()
{
	int iSize = sizeof(RespecPowerPlayer);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_RespecPowerPlayer, iSize, "RespecPowerPlayer", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct RespecPowerTree
#define TYPE_parse_RespecPowerTree RespecPowerTree
ParseTable parse_RespecPowerTree[] =
{
	{ "RespecPowerTree", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(RespecPowerTree), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "respecTreeDef",		TOK_REFERENCE(RespecPowerTree, respecTreeDef, 0, "PowerTreeDef") },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_RespecPowerTree()
{
	int iSize = sizeof(RespecPowerTree);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_RespecPowerTree, iSize, "RespecPowerTree", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct RespecPower
#define TYPE_parse_RespecPower RespecPower
ParseTable parse_RespecPower[] =
{
	{ "RespecPower", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(RespecPower), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "respecPowerDef",	TOK_REFERENCE(RespecPower, respecPowerDef, 0, "PowerDef") },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_RespecPower()
{
	int iSize = sizeof(RespecPower);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_RespecPower, iSize, "RespecPower", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_RespecPower[];
#define TYPE_parse_RespecPower RespecPower
extern ParseTable parse_RespecPowerTree[];
#define TYPE_parse_RespecPowerTree RespecPowerTree
//Structparser.exe autogenerated ParseTable for struct Respec
#define TYPE_parse_Respec Respec
ParseTable parse_Respec[] =
{
	{ "Respec", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(Respec), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "RespecTimeString",		TOK_STRING(Respec, pchRespecTimeString, 0), NULL },
	{ "Date",					TOK_REDUNDANTNAME | TOK_STRING(Respec, pchRespecTimeString, 0), NULL },
	{ "uiDerivedRespecTime",	TOK_NO_TEXT_SAVE | TOK_AUTOINT(Respec, uiDerivedRespecTime, 0), NULL },
	{ "RespecType",				TOK_AUTOINT(Respec, eRespecType, 0), Respec_TypeEnum },
	{ "RespecPowers",			TOK_STRUCT(Respec, eaPowers, parse_RespecPower) },
	{ "RespecPowerTrees",		TOK_STRUCT(Respec, eaTrees, parse_RespecPowerTree) },
	{ "IsForcedRespec",			TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_Respec()
{
	int iSize = sizeof(Respec);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_Respec, iSize, "Respec", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(Respec) + 7) / 4;
		Respec *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bIsForcedRespec = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Respec[8]);
		pTemp->bIsForcedRespec = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_Respec[];
#define TYPE_parse_Respec Respec
//Structparser.exe autogenerated ParseTable for struct Respecs
#define TYPE_parse_Respecs Respecs
ParseTable parse_Respecs[] =
{
	{ "Respecs", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(Respecs), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "Respecs",	TOK_STRUCT(Respecs, eaRespecs, parse_Respec) },
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_Respecs()
{
	int iSize = sizeof(Respecs);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_Respecs, iSize, "Respecs", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerTreeClientInfo
#define TYPE_parse_PowerTreeClientInfo PowerTreeClientInfo
ParseTable parse_PowerTreeClientInfo[] =
{
	{ "PowerTreeClientInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerTreeClientInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Name",					TOK_POOL_STRING | TOK_SUBSCRIBE | TOK_STRING(PowerTreeClientInfo, pchName, 0), NULL },
	{ "hDisplayMessage",		TOK_VITAL_REF | TOK_SUBSCRIBE | TOK_REFERENCE(PowerTreeClientInfo, hDisplayMessage, 0, "Message") },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerTreeClientInfo()
{
	int iSize = sizeof(PowerTreeClientInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerTreeClientInfo, iSize, "PowerTreeClientInfo", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PowerTreeClientInfo[];
#define TYPE_parse_PowerTreeClientInfo PowerTreeClientInfo
//Structparser.exe autogenerated ParseTable for struct PowerTreeClientInfoList
#define TYPE_parse_PowerTreeClientInfoList PowerTreeClientInfoList
ParseTable parse_PowerTreeClientInfoList[] =
{
	{ "PowerTreeClientInfoList", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerTreeClientInfoList), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Trees",						TOK_SUBSCRIBE | TOK_STRUCT(PowerTreeClientInfoList, ppTrees, parse_PowerTreeClientInfo) },
	{ "dirtyBit",					TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(PowerTreeClientInfoList, dirtyBit, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerTreeClientInfoList()
{
	int iSize = sizeof(PowerTreeClientInfoList);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerTreeClientInfoList, iSize, "PowerTreeClientInfoList", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_PTGroupDef[];
#define TYPE_parse_PTGroupDef PTGroupDef
extern ParseTable parse_PowerTreeTopDown[];
#define TYPE_parse_PowerTreeTopDown PowerTreeTopDown
extern ParseTable parse_PowerTreeLink[];
#define TYPE_parse_PowerTreeLink PowerTreeLink
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
//Structparser.exe autogenerated ParseTable for struct PowerTreeDef
#define TYPE_parse_PowerTreeDef PowerTreeDef
ParseTable parse_PowerTreeDef[] =
{
	{ "PowerTreeDef", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerTreeDef), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "Name",							TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_KEY | TOK_STRING(PowerTreeDef, pchName, 0), NULL },
	{ "Respec",							TOK_AUTOINT(PowerTreeDef, eRespec, kPowerTreeRespec_Remove), PowerTreeRespecEnum },
	{ "DisplayMessage",					TOK_EMBEDDEDSTRUCT(PowerTreeDef, pDisplayMessage, parse_DisplayMessage)},
	{ "DisplayName",					TOK_REDUNDANTNAME | TOK_EMBEDDEDSTRUCT(PowerTreeDef, pDisplayMessage, parse_DisplayMessage)},
	{ "DescriptionMessage",				TOK_EMBEDDEDSTRUCT(PowerTreeDef, pDescriptionMessage, parse_DisplayMessage)},
	{ "IconName",						TOK_POOL_STRING | TOK_STRING(PowerTreeDef, pchIconName, 0), NULL },
	{ "TreeType",						TOK_REFERENCE(PowerTreeDef, hTreeType, 0, "PowerTreeTypeDef") },
	{ "ExprBlockRequires",				TOK_OPTIONALLATEBINDSTRUCT(PowerTreeDef, pExprRequires) },
	{ "RequiresBlock",					TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerTreeDef, pExprRequires) },
	{ "Requires",						TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(PowerTreeDef, pExprRequires) },
	{ "Group",							TOK_NO_INDEX | TOK_STRUCT(PowerTreeDef, ppGroups, parse_PTGroupDef) },
	{ "File",							TOK_POOL_STRING | TOK_CURRENTFILE(PowerTreeDef, pchFile), NULL},
	{ "Class",							TOK_REFERENCE(PowerTreeDef, hClass, 0, "CharacterClass") },
	{ "TopDown",						TOK_CLIENT_ONLY | TOK_NO_WRITE | TOK_OPTIONALSTRUCT(PowerTreeDef, pTopDown, parse_PowerTreeTopDown) },
	{ "Links",							TOK_NO_TEXT_SAVE | TOK_STRUCT(PowerTreeDef, ppLinks, parse_PowerTreeLink) },
	{ "UICategory",						TOK_AUTOINT(PowerTreeDef, eUICategory, 0), PowerTreeUICategoryEnum },
	{ "DefaultPlayingStyle",			TOK_POOL_STRING | TOK_STRING(PowerTreeDef, pchDefaultPlayingStyle, 0), NULL },
	{ "MaxSpendablePointsCostTable",	TOK_STRING(PowerTreeDef, pchMaxSpendablePointsCostTable, 0), NULL },
	{ "MaxSpendablePoints",				TOK_F32(PowerTreeDef, fMaxSpendablePoints, 0), NULL },
	{ "MinCost",						TOK_NO_TEXT_SAVE | TOK_AUTOINT(PowerTreeDef, iMinCost, 0), NULL },
	{ "AutoBuy",						TOK_AUTOINT(PowerTreeDef, bAutoBuy, 0), NULL },
	{ "Temporary",						TOK_AUTOINT(PowerTreeDef, bTemporary, 0), NULL },
	{ "SendToClient",					TOK_AUTOINT(PowerTreeDef, bSendToClient, 0), NULL },
	{ "IsTalentTree",					TOK_AUTOINT(PowerTreeDef, bIsTalentTree, 0), NULL },
	{ "AnimListToPlayOnGrant",			TOK_REFERENCE(PowerTreeDef, hAnimListToPlayOnGrant, 0, "AIAnimList") },
	{ "GrantMessage",					TOK_EMBEDDEDSTRUCT(PowerTreeDef, pGrantMessage, parse_DisplayMessage)},
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerTreeDef()
{
	int iSize = sizeof(PowerTreeDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerTreeDef, iSize, "PowerTreeDef", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_PowerTreeDef(void)
{
	DoAutoStructLateBind(parse_PowerTreeDef, 9, "Expression");
	DoAutoStructLateBind(parse_PowerTreeDef, 10, "Expression");
	DoAutoStructLateBind(parse_PowerTreeDef, 11, "Expression_StructParam");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerTreeDefRef
#define TYPE_parse_PowerTreeDefRef PowerTreeDefRef
ParseTable parse_PowerTreeDefRef[] =
{
	{ "PowerTreeDefRef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerTreeDefRef), 0, NULL, 0, NULL },
	{ "hRef",				TOK_STRUCTPARAM | TOK_REFERENCE(PowerTreeDefRef, hRef, 0, "PowerTreeDef") },
	{ "\n",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerTreeDefRef()
{
	int iSize = sizeof(PowerTreeDefRef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerTreeDefRef, iSize, "PowerTreeDefRef", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PTGroupTopDown[];
#define TYPE_parse_PTGroupTopDown PTGroupTopDown
extern ParseTable parse_PTNodeTopDown[];
#define TYPE_parse_PTNodeTopDown PTNodeTopDown
//Structparser.exe autogenerated ParseTable for struct PTGroupTopDown
#define TYPE_parse_PTGroupTopDown PTGroupTopDown
ParseTable parse_PTGroupTopDown[] =
{
	{ "PTGroupTopDown", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PTGroupTopDown), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Group",			TOK_REFERENCE(PTGroupTopDown, hGroup, 0, "PowerTreeGroupDef") },
	{ "Groups",			TOK_STRUCT(PTGroupTopDown, ppGroups, parse_PTGroupTopDown) },
	{ "OwnedNodes",		TOK_STRUCT(PTGroupTopDown, ppOwnedNodes, parse_PTNodeTopDown) },
	{ "Depth",			TOK_AUTOINT(PTGroupTopDown, iDepth, 0), NULL },
	{ "Count",			TOK_AUTOINT(PTGroupTopDown, iCount, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PTGroupTopDown()
{
	int iSize = sizeof(PTGroupTopDown);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PTGroupTopDown, iSize, "PTGroupTopDown", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PTNodeTopDown[];
#define TYPE_parse_PTNodeTopDown PTNodeTopDown
//Structparser.exe autogenerated ParseTable for struct PTNodeTopDown
#define TYPE_parse_PTNodeTopDown PTNodeTopDown
ParseTable parse_PTNodeTopDown[] =
{
	{ "PTNodeTopDown", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PTNodeTopDown), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Node",			TOK_REFERENCE(PTNodeTopDown, hNode, 0, "PowerTreeNodeDef") },
	{ "Nodes",			TOK_STRUCT(PTNodeTopDown, ppNodes, parse_PTNodeTopDown) },
	{ "Depth",			TOK_AUTOINT(PTNodeTopDown, iDepth, 0), NULL },
	{ "Count",			TOK_AUTOINT(PTNodeTopDown, iCount, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PTNodeTopDown()
{
	int iSize = sizeof(PTNodeTopDown);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PTNodeTopDown, iSize, "PTNodeTopDown", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PTGroupTopDown[];
#define TYPE_parse_PTGroupTopDown PTGroupTopDown
//Structparser.exe autogenerated ParseTable for struct PowerTreeTopDown
#define TYPE_parse_PowerTreeTopDown PowerTreeTopDown
ParseTable parse_PowerTreeTopDown[] =
{
	{ "PowerTreeTopDown", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerTreeTopDown), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Tree",				TOK_REFERENCE(PowerTreeTopDown, hTree, 0, "PowerTreeDef") },
	{ "Groups",				TOK_STRUCT(PowerTreeTopDown, ppGroups, parse_PTGroupTopDown) },
	{ "Width",				TOK_AUTOINT(PowerTreeTopDown, iWidth, 0), NULL },
	{ "Height",				TOK_AUTOINT(PowerTreeTopDown, iHeight, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerTreeTopDown()
{
	int iSize = sizeof(PowerTreeTopDown);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerTreeTopDown, iSize, "PowerTreeTopDown", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PTNode[];
#define TYPE_parse_PTNode PTNode
//Structparser.exe autogenerated ParseTable for struct PowerTree
#define TYPE_parse_PowerTree PowerTree
ParseTable parse_PowerTree[] =
{
	{ "PowerTree", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerTree), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "dirtyBit",		TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(PowerTree, dirtyBit, 0), NULL },
	{ "hDef",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_KEY | TOK_REFERENCE(PowerTree, hDef, 0, "PowerTreeDef") },
	{ "ppNodes",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_STRUCT(PowerTree, ppNodes, parse_PTNode) },
	{ "uiTimeCreated",	TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(PowerTree, uiTimeCreated, 0), NULL },
	{ "bStepIsLocked",	TOK_PERSIST | TOK_SUBSCRIBE | TOK_BIT, 0, 8, NULL},
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PowerTree()
{
	int iSize = sizeof(PowerTree);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerTree, iSize, "PowerTree", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(PowerTree)) + 7) / 4;
		NOCONST(PowerTree) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bStepIsLocked = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerTree[6]);
		pTemp->bStepIsLocked = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PowerTreeDef[];
#define TYPE_parse_PowerTreeDef PowerTreeDef
//Structparser.exe autogenerated ParseTable for struct PowerTreeDefs
#define TYPE_parse_PowerTreeDefs PowerTreeDefs
ParseTable parse_PowerTreeDefs[] =
{
	{ "PowerTreeDefs", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerTreeDefs), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "PowerTree",		TOK_STRUCT(PowerTreeDefs, ppPowerTrees, parse_PowerTreeDef) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerTreeDefs()
{
	int iSize = sizeof(PowerTreeDefs);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerTreeDefs, iSize, "PowerTreeDefs", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerTreeStep
#define TYPE_parse_PowerTreeStep PowerTreeStep
ParseTable parse_PowerTreeStep[] =
{
	{ "PowerTreeStep", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerTreeStep), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Tree",			TOK_POOL_STRING | TOK_STRING(PowerTreeStep, pchTree, 0), NULL },
	{ "Node",			TOK_POOL_STRING | TOK_STRING(PowerTreeStep, pchNode, 0), NULL },
	{ "Enhancement",	TOK_POOL_STRING | TOK_STRING(PowerTreeStep, pchEnhancement, 0), NULL },
	{ "Rank",			TOK_AUTOINT(PowerTreeStep, iRank, 0), NULL },
	{ "uiTimestamp",	TOK_AUTOINT(PowerTreeStep, uiTimestamp, 0), NULL },
	{ "uiOrderIndex",	TOK_AUTOINT(PowerTreeStep, uiOrderIndex, 0), NULL },
	{ "CostRespec",		TOK_AUTOINT(PowerTreeStep, iCostRespec, 0), NULL },
	{ "StepsImplied",	TOK_CLIENT_ONLY | TOK_AUTOINT(PowerTreeStep, iStepsImplied, 0), NULL },
	{ "Escrow",			TOK_BIT, 0, 8, NULL},
	{ "StepIsLocked",	TOK_BIT, 0, 8, NULL},
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PowerTreeStep()
{
	int iSize = sizeof(PowerTreeStep);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerTreeStep, iSize, "PowerTreeStep", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PowerTreeStep) + 7) / 4;
		PowerTreeStep *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bEscrow = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerTreeStep[10]);
		pTemp->bEscrow = 0;
		pTemp->bStepIsLocked = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerTreeStep[11]);
		pTemp->bStepIsLocked = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PowerTreeStep[];
#define TYPE_parse_PowerTreeStep PowerTreeStep
//Structparser.exe autogenerated ParseTable for struct PowerTreeSteps
#define TYPE_parse_PowerTreeSteps PowerTreeSteps
ParseTable parse_PowerTreeSteps[] =
{
	{ "PowerTreeSteps", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerTreeSteps), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Steps",						TOK_STRUCT(PowerTreeSteps, ppSteps, parse_PowerTreeStep) },
	{ "uiPowerTreeModCount",		TOK_AUTOINT(PowerTreeSteps, uiPowerTreeModCount, 0), NULL },
	{ "RespecSkillpointSpentMin",	TOK_AUTOINT(PowerTreeSteps, iRespecSkillpointSpentMin, 0), NULL },
	{ "UpdatePointsSpent",			TOK_BIT, 0, 8, NULL},
	{ "IsTraining",					TOK_BIT, 0, 8, NULL},
	{ "OnlyLowerPoints",			TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_PowerTreeSteps()
{
	int iSize = sizeof(PowerTreeSteps);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerTreeSteps, iSize, "PowerTreeSteps", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(PowerTreeSteps) + 7) / 4;
		PowerTreeSteps *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bUpdatePointsSpent = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerTreeSteps[5]);
		pTemp->bUpdatePointsSpent = 0;
		pTemp->bIsTraining = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerTreeSteps[6]);
		pTemp->bIsTraining = 0;
		pTemp->bOnlyLowerPoints = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_PowerTreeSteps[7]);
		pTemp->bOnlyLowerPoints = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct PowerTreeRespecName
#define TYPE_parse_PowerTreeRespecName PowerTreeRespecName
ParseTable parse_PowerTreeRespecName[] =
{
	{ "PowerTreeRespecName", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerTreeRespecName), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "RespecGroup",			TOK_AUTOINT(PowerTreeRespecName, eRespecGroup, 0), PTRespecGroupTypeEnum },
	{ "Name",					TOK_POOL_STRING | TOK_STRING(PowerTreeRespecName, pchName, 0), NULL },
	{ "TableName",				TOK_POOL_STRING | TOK_STRING(PowerTreeRespecName, pchTableName, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerTreeRespecName()
{
	int iSize = sizeof(PowerTreeRespecName);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerTreeRespecName, iSize, "PowerTreeRespecName", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_PowerTreeRespecName[];
#define TYPE_parse_PowerTreeRespecName PowerTreeRespecName
extern ParseTable parse_PowerTreeRespecName[];
#define TYPE_parse_PowerTreeRespecName PowerTreeRespecName
extern ParseTable parse_PowerTreeRespecName[];
#define TYPE_parse_PowerTreeRespecName PowerTreeRespecName
//Structparser.exe autogenerated ParseTable for struct PowerTreeRespecConfig
#define TYPE_parse_PowerTreeRespecConfig PowerTreeRespecConfig
ParseTable parse_PowerTreeRespecConfig[] =
{
	{ "PowerTreeRespecConfig", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(PowerTreeRespecConfig), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "ExprCostStep",				TOK_OPTIONALLATEBINDSTRUCT(PowerTreeRespecConfig, pExprCostStep) },
	{ "ExprCostBase",				TOK_OPTIONALLATEBINDSTRUCT(PowerTreeRespecConfig, pExprCostBase) },
	{ "ExprRequiredPointsSpent",	TOK_OPTIONALLATEBINDSTRUCT(PowerTreeRespecConfig, pExprRequiredPointsSpent) },
	{ "Numeric",					TOK_REFERENCE(PowerTreeRespecConfig, hNumeric, 0, "ItemDef") },
	{ "ForceUseFreeRespec",			TOK_AUTOINT(PowerTreeRespecConfig, bForceUseFreeRespec, 0), NULL },
	{ "NoContactRequiredForRespec",	TOK_AUTOINT(PowerTreeRespecConfig, bNoContactRequiredForRespec, 0), NULL },
	{ "File",						TOK_POOL_STRING | TOK_CURRENTFILE(PowerTreeRespecConfig, pchFile), NULL},
	{ "PTItemRespecNames",			TOK_STRUCT(PowerTreeRespecConfig, eaPTItemRespecNames, parse_PowerTreeRespecName) },
	{ "PTGadRespecNames",			TOK_STRUCT(PowerTreeRespecConfig, eaPTGadRespecNames, parse_PowerTreeRespecName) },
	{ "PTNumericRespecNames",		TOK_STRUCT(PowerTreeRespecConfig, eaPTNumericRespecNames, parse_PowerTreeRespecName) },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_PowerTreeRespecConfig()
{
	int iSize = sizeof(PowerTreeRespecConfig);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_PowerTreeRespecConfig, iSize, "PowerTreeRespecConfig", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_PowerTreeRespecConfig(void)
{
	DoAutoStructLateBind(parse_PowerTreeRespecConfig, 2, "Expression");
	DoAutoStructLateBind(parse_PowerTreeRespecConfig, 3, "Expression");
	DoAutoStructLateBind(parse_PowerTreeRespecConfig, 4, "Expression");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct SavedCartPower
#define TYPE_parse_SavedCartPower SavedCartPower
ParseTable parse_SavedCartPower[] =
{
	{ "SavedCartPower", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(SavedCartPower), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "NodeDef",		TOK_PERSIST | TOK_NO_TRANSACT | TOK_REFERENCE(SavedCartPower, hNodeDef, 0, "PowerTreeNodeDef") },
	{ "hNodeDef",		TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_REFERENCE(SavedCartPower, hNodeDef, 0, "PowerTreeNodeDef") },
	{ "iRank",			TOK_AUTOINT(SavedCartPower, iRank, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_SavedCartPower()
{
	int iSize = sizeof(SavedCartPower);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_SavedCartPower, iSize, "SavedCartPower", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_SavedCartPower[];
#define TYPE_parse_SavedCartPower SavedCartPower
//Structparser.exe autogenerated ParseTable for struct SavedCartPowerList
#define TYPE_parse_SavedCartPowerList SavedCartPowerList
ParseTable parse_SavedCartPowerList[] =
{
	{ "SavedCartPowerList", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(SavedCartPowerList), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Nodes",				TOK_STRUCT(SavedCartPowerList, ppNodes, parse_SavedCartPower) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_SavedCartPowerList()
{
	int iSize = sizeof(SavedCartPowerList);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_SavedCartPowerList, iSize, "SavedCartPowerList", NULL, "PowerTree.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
