#include "textparser.h"

//auto-generated staticdefine for enum AITeamAssignmentType
//autogeneratednocheckin
StaticDefineInt AITeamAssignmentTypeEnum[] =
{
	DEFINE_INT
	{ "NULL", AITEAM_ASSIGNMENT_TYPE_NULL},
	{ "HEAL", AITEAM_ASSIGNMENT_TYPE_HEAL},
	{ "SHIELD_HEAL", AITEAM_ASSIGNMENT_TYPE_SHIELD_HEAL},
	{ "CURE", AITEAM_ASSIGNMENT_TYPE_CURE},
	{ "BUFF", AITEAM_ASSIGNMENT_TYPE_BUFF},
	{ "RESSURECT", AITEAM_ASSIGNMENT_TYPE_RESSURECT},
	{ "COUNT", AITEAM_ASSIGNMENT_TYPE_COUNT},
	DEFINE_END
};
void autoEnum_fixup_AITeamAssignmentType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AITeamAssignmentTypeEnum, "AITeamAssignmentType");
}

//auto-generated staticdefine for enum AITeamCombatState
//autogeneratednocheckin
StaticDefineInt AITeamCombatStateEnum[] =
{
	DEFINE_INT
	{ "AMBIENT", AITEAM_COMBAT_STATE_AMBIENT},
	{ "WAITFORFIGHT", AITEAM_COMBAT_STATE_WAITFORFIGHT},
	{ "STAREDOWN", AITEAM_COMBAT_STATE_STAREDOWN},
	{ "FIGHT", AITEAM_COMBAT_STATE_FIGHT},
	{ "LEASH", AITEAM_COMBAT_STATE_LEASH},
	DEFINE_END
};
void autoEnum_fixup_AITeamCombatState(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AITeamCombatStateEnum, "AITeamCombatState");
}

//auto-generated staticdefine for enum EAINotVisibleReason
//autogeneratednocheckin
StaticDefineInt EAINotVisibleReasonEnum[] =
{
	DEFINE_INT
	{ "NONE", EAINotVisibleReason_NONE},
	{ "LOS", EAINotVisibleReason_LOS},
	{ "OUTOF_PERCEPTION", EAINotVisibleReason_OUTOF_PERCEPTION},
	{ "PERCEPTION_STEALTH", EAINotVisibleReason_PERCEPTION_STEALTH},
	{ "UNTARGETABLE", EAINotVisibleReason_UNTARGETABLE},
	DEFINE_END
};
void autoEnum_fixup_EAINotVisibleReason(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(EAINotVisibleReasonEnum, "EAINotVisibleReason");
}

//auto-generated staticdefine for enum AIVolumeType
//autogeneratednocheckin
StaticDefineInt AIVolumeTypeEnum[] =
{
	DEFINE_INT
	{ "AVOID", AIVolumeType_AVOID},
	{ "ATTRACT", AIVolumeType_ATTRACT},
	{ "SOFT_AVOID", AIVolumeType_SOFT_AVOID},
	DEFINE_END
};
void autoEnum_fixup_AIVolumeType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AIVolumeTypeEnum, "AIVolumeType");
}

//auto-generated staticdefine for enum AIPowerActionType
//autogeneratednocheckin
StaticDefineInt AIPowerActionTypeEnum[] =
{
	DEFINE_INT
	{ "USE_POWINFO", AI_POWER_ACTION_USE_POWINFO},
	{ "HEAL", AI_POWER_ACTION_HEAL},
	{ "SHIELD_HEAL", AI_POWER_ACTION_SHIELD_HEAL},
	{ "RES", AI_POWER_ACTION_RES},
	{ "BUFF", AI_POWER_ACTION_BUFF},
	{ "OUT_OF_COMBAT", AI_POWER_ACTION_OUT_OF_COMBAT},
	{ "GOTOPOS", AI_POWER_ACTION_GOTOPOS},
	{ "ROLL", AI_POWER_ACTION_ROLL},
	{ "SAFETY_TELEPORT", AI_POWER_ACTION_SAFETY_TELEPORT},
	DEFINE_END
};
void autoEnum_fixup_AIPowerActionType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AIPowerActionTypeEnum, "AIPowerActionType");
}

//auto-generated staticdefine for enum AILeashState
//autogeneratednocheckin
StaticDefineInt AILeashStateEnum[] =
{
	DEFINE_INT
	{ "START", AI_LEASH_STATE_START},
	{ "FINISH", AI_LEASH_STATE_FINISH},
	{ "DONE", AI_LEASH_STATE_DONE},
	DEFINE_END
};
void autoEnum_fixup_AILeashState(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AILeashStateEnum, "AILeashState");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AITeamTimes
#define TYPE_parse_AITeamTimes AITeamTimes
ParseTable parse_AITeamTimes[] =
{
	{ "AITeamTimes", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AITeamTimes), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "lastTick",						TOK_AUTOINT(AITeamTimes, lastTick, 0), NULL },
	{ "lastDamaged",					TOK_AUTOINT(AITeamTimes, lastDamaged, 0), NULL },
	{ "lastBothered",					TOK_AUTOINT(AITeamTimes, lastBothered, 0), NULL },
	{ "lastCheckedSpawnPosDist",		TOK_AUTOINT(AITeamTimes, lastCheckedSpawnPosDist, 0), NULL },
	{ "lastCheckedReinforce",			TOK_AUTOINT(AITeamTimes, lastCheckedReinforce, 0), NULL },
	{ "lastStartedCombat",				TOK_AUTOINT(AITeamTimes, lastStartedCombat, 0), NULL },
	{ "lastHadLegalTarget",				TOK_AUTOINT(AITeamTimes, lastHadLegalTarget, 0), NULL },
	{ "lastStartedLeashing",			TOK_AUTOINT(AITeamTimes, lastStartedLeashing, 0), NULL },
	{ "lastUpdatedRoamingLeashPoint",	TOK_AUTOINT(AITeamTimes, lastUpdatedRoamingLeashPoint, 0), NULL },
	{ "timeLeashWait",					TOK_AUTOINT(AITeamTimes, timeLeashWait, 0), NULL },
	{ "lastBuff",						TOK_AUTOINT(AITeamTimes, lastBuff, 0), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AITeamTimes()
{
	int iSize = sizeof(AITeamTimes);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AITeamTimes, iSize, "AITeamTimes", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_Entity[];
#define TYPE_parse_Entity Entity
//Structparser.exe autogenerated ParseTable for struct AITeamMember
#define TYPE_parse_AITeamMember AITeamMember
ParseTable parse_AITeamMember[] =
{
	{ "AITeamMember", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AITeamMember), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "memberBE",					TOK_UNOWNED | TOK_OPTIONALSTRUCT(AITeamMember, memberBE, parse_Entity) },
	{ "assignedTarget",				TOK_AUTOINT(AITeamMember, assignedTarget, 0), NULL },
	{ "timeLastActedOn",			TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(AITeamMember, timeLastActedOn), NULL },
	{ "timeLastResed",				TOK_AUTOINT(AITeamMember, timeLastResed, 0), NULL },
	{ "healthPct",					TOK_F32(AITeamMember, healthPct, 0), NULL },
	{ "shieldPct",					TOK_F32(AITeamMember, shieldPct, 0), NULL },
	{ "timeCombatActiveStarted",	TOK_AUTOINT(AITeamMember, timeCombatActiveStarted, 0), NULL },
	{ "timeCombatActiveEnded",		TOK_AUTOINT(AITeamMember, timeCombatActiveEnded, 0), NULL },
	{ "timeCombatActiveExpires",	TOK_AUTOINT(AITeamMember, timeCombatActiveExpires, 0), NULL },
	{ "timeCombatInactiveExpires",	TOK_AUTOINT(AITeamMember, timeCombatInactiveExpires, 0), NULL },
	{ "numCombatTokens",			TOK_F32(AITeamMember, numCombatTokens, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AITeamMember()
{
	int iSize = sizeof(AITeamMember);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AITeamMember, iSize, "AITeamMember", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AITeam[];
#define TYPE_parse_AITeam AITeam
extern ParseTable parse_AITeamMember[];
#define TYPE_parse_AITeamMember AITeamMember
//Structparser.exe autogenerated ParseTable for struct AITeamStatusEntry
#define TYPE_parse_AITeamStatusEntry AITeamStatusEntry
ParseTable parse_AITeamStatusEntry[] =
{
	{ "AITeamStatusEntry", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AITeamStatusEntry), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "entRef",						TOK_AUTOINT(AITeamStatusEntry, entRef, 0), NULL },
	{ "team",						TOK_STRUCT_NORECURSE | TOK_OPTIONALSTRUCT(AITeamStatusEntry, team, parse_AITeam) },
	{ "assignedTeamMembers",		TOK_STRUCT(AITeamStatusEntry, assignedTeamMembers, parse_AITeamMember) },
	{ "timeLastStatusUpdate",		TOK_AUTOINT(AITeamStatusEntry, timeLastStatusUpdate, 0), NULL },
	{ "timeLastAggressiveAction",	TOK_AUTOINT(AITeamStatusEntry, timeLastAggressiveAction, 0), NULL },
	{ "lastKnownPos",				TOK_VEC3(AITeamStatusEntry, lastKnownPos), NULL },
	{ "legalTarget",				TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AITeamStatusEntry()
{
	int iSize = sizeof(AITeamStatusEntry);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AITeamStatusEntry, iSize, "AITeamStatusEntry", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AITeamStatusEntry) + 7) / 4;
		AITeamStatusEntry *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->legalTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeamStatusEntry[8]);
		pTemp->legalTarget = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AITeamMember[];
#define TYPE_parse_AITeamMember AITeamMember
extern ParseTable parse_AITeamMember[];
#define TYPE_parse_AITeamMember AITeamMember
extern ParseTable parse_AttribModDef[];
#define TYPE_parse_AttribModDef AttribModDef
//Structparser.exe autogenerated ParseTable for struct AITeamMemberAssignment
#define TYPE_parse_AITeamMemberAssignment AITeamMemberAssignment
ParseTable parse_AITeamMemberAssignment[] =
{
	{ "AITeamMemberAssignment", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AITeamMemberAssignment), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "target",					TOK_OPTIONALSTRUCT(AITeamMemberAssignment, target, parse_AITeamMember) },
	{ "type",					TOK_AUTOINT(AITeamMemberAssignment, type, 0), AITeamAssignmentTypeEnum },
	{ "assignee",				TOK_OPTIONALSTRUCT(AITeamMemberAssignment, assignee, parse_AITeamMember) },
	{ "powID",					TOK_AUTOINT(AITeamMemberAssignment, powID, 0), NULL },
	{ "AttribModDef",			TOK_OPTIONALSTRUCT(AITeamMemberAssignment, pAttribModDef, parse_AttribModDef) },
	{ "erSource",				TOK_AUTOINT(AITeamMemberAssignment, erSource, 0), NULL },
	{ "importanceHeur",			TOK_F32(AITeamMemberAssignment, importanceHeur, 0), NULL },
	{ "assignedTime",			TOK_AUTOINT(AITeamMemberAssignment, assignedTime, 0), NULL },
	{ "validAssignment",		TOK_BIT, 0, 8, NULL},
	{ "forcedAssignment",		TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AITeamMemberAssignment()
{
	int iSize = sizeof(AITeamMemberAssignment);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AITeamMemberAssignment, iSize, "AITeamMemberAssignment", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AITeamMemberAssignment) + 7) / 4;
		AITeamMemberAssignment *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->validAssignment = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeamMemberAssignment[10]);
		pTemp->validAssignment = 0;
		pTemp->forcedAssignment = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeamMemberAssignment[11]);
		pTemp->forcedAssignment = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AITeamMemberPowers
#define TYPE_parse_AITeamMemberPowers AITeamMemberPowers
ParseTable parse_AITeamMemberPowers[] =
{
	{ "AITeamMemberPowers", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AITeamMemberPowers), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "CureTags",				TOK_INTARRAY(AITeamMemberPowers, eaCureTags),  NULL},
	{ "hasHealPowers",			TOK_BIT, 0, 8, NULL},
	{ "hasShieldHealPowers",	TOK_BIT, 0, 8, NULL},
	{ "hasResPowers",			TOK_BIT, 0, 8, NULL},
	{ "hasBuffPowers",			TOK_BIT, 0, 8, NULL},
	{ "hasCurePower",			TOK_BIT, 0, 8, NULL},
	{ "hasTeamOrientedPowers",	TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AITeamMemberPowers()
{
	int iSize = sizeof(AITeamMemberPowers);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AITeamMemberPowers, iSize, "AITeamMemberPowers", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AITeamMemberPowers) + 7) / 4;
		AITeamMemberPowers *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->hasHealPowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeamMemberPowers[3]);
		pTemp->hasHealPowers = 0;
		pTemp->hasShieldHealPowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeamMemberPowers[4]);
		pTemp->hasShieldHealPowers = 0;
		pTemp->hasResPowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeamMemberPowers[5]);
		pTemp->hasResPowers = 0;
		pTemp->hasBuffPowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeamMemberPowers[6]);
		pTemp->hasBuffPowers = 0;
		pTemp->hasCurePower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeamMemberPowers[7]);
		pTemp->hasCurePower = 0;
		pTemp->hasTeamOrientedPowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeamMemberPowers[8]);
		pTemp->hasTeamOrientedPowers = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AITeamStatusEntry[];
#define TYPE_parse_AITeamStatusEntry AITeamStatusEntry
extern ParseTable parse_AITeamMember[];
#define TYPE_parse_AITeamMember AITeamMember
extern ParseTable parse_AITeamMemberAssignment[];
#define TYPE_parse_AITeamMemberAssignment AITeamMemberAssignment
extern ParseTable parse_Entity[];
#define TYPE_parse_Entity Entity
extern ParseTable parse_AITeam[];
#define TYPE_parse_AITeam AITeam
extern ParseTable parse_AITeamMember[];
#define TYPE_parse_AITeamMember AITeamMember
extern ParseTable parse_AIJob[];
#define TYPE_parse_AIJob AIJob
extern ParseTable parse_AITeamTimes[];
#define TYPE_parse_AITeamTimes AITeamTimes
extern ParseTable parse_AITeamConfig[];
#define TYPE_parse_AITeamConfig AITeamConfig
extern ParseTable parse_AITeamMemberPowers[];
#define TYPE_parse_AITeamMemberPowers AITeamMemberPowers
extern ParseTable parse_AITeamMember[];
#define TYPE_parse_AITeamMember AITeamMember
//Structparser.exe autogenerated ParseTable for struct AITeam
#define TYPE_parse_AITeam AITeam
ParseTable parse_AITeam[] =
{
	{ "AITeam", 						TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AITeam), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "combatState",				TOK_AUTOINT(AITeam, combatState, 0), AITeamCombatStateEnum },
	{ "statusTable",				TOK_STRUCT(AITeam, statusTable, parse_AITeamStatusEntry) },
	{ "members",					TOK_STRUCT(AITeam, members, parse_AITeamMember) },
	{ "collId",						TOK_AUTOINT(AITeam, collId, 0), NULL },
	{ "partitionIdx",				TOK_AUTOINT(AITeam, partitionIdx, 0), NULL },
	{ "healAssignments",			TOK_STRUCT(AITeam, healAssignments, parse_AITeamMemberAssignment) },
	{ "teamLeaderRef",				TOK_AUTOINT(AITeam, teamLeaderRef, 0), NULL },
	{ "teamOwner",					TOK_UNOWNED | TOK_OPTIONALSTRUCT(AITeam, teamOwner, parse_Entity) },
	{ "reinforceTeam",				TOK_UNOWNED | TOK_OPTIONALSTRUCT(AITeam, reinforceTeam, parse_AITeam) },
	{ "reinforceMember",			TOK_OPTIONALSTRUCT(AITeam, reinforceMember, parse_AITeamMember) },
	{ "teamLevel",					TOK_AUTOINT(AITeam, teamLevel, 0), NULL },
	{ "curHP",						TOK_F32(AITeam, curHP, 0), NULL },
	{ "maxHP",						TOK_F32(AITeam, maxHP, 0), NULL },
	{ "leashDist",					TOK_F32(AITeam, leashDist, 0), NULL },
	{ "jobs",						TOK_STRUCT(AITeam, jobs, parse_AIJob) },
	{ "teamTotalHealth",			TOK_F32(AITeam, teamTotalHealth, 0), NULL },
	{ "spawnPos",					TOK_VEC3(AITeam, spawnPos), NULL },
	{ "roamingLeashPoint",			TOK_VEC3(AITeam, roamingLeashPoint), NULL },
	{ "offsetPatrolName",			TOK_STRING(AITeam, offsetPatrolName, 0), NULL },
	{ "trackedDamageTeam",			TOK_FIXED_ARRAY | TOK_F32_X, offsetof(AITeam, trackedDamageTeam),  AI_NOTIFY_TYPE_TRACKED_COUNT, NULL },
	{ "time",						TOK_EMBEDDEDSTRUCT(AITeam, time, parse_AITeamTimes)},
	{ "minSpawnAggroTime",			TOK_AUTOINT(AITeam, minSpawnAggroTime, 0), NULL },
	{ "config",						TOK_EMBEDDEDSTRUCT(AITeam, config, parse_AITeamConfig)},
	{ "powInfo",					TOK_EMBEDDEDSTRUCT(AITeam, powInfo, parse_AITeamMemberPowers)},
	{ "combatTokenAccum",			TOK_F32(AITeam, combatTokenAccum, 0), NULL },
	{ "nextCombatSwitch",			TOK_AUTOINT(AITeam, nextCombatSwitch, 0), NULL },
	{ "activeCombatants",			TOK_STRUCT(AITeam, activeCombatants, parse_AITeamMember) },
	{ "leashDistPriority",			TOK_AUTOINT(AITeam, leashDistPriority, 0), NULL },
	{ "memberInCombat",				TOK_BIT, 0, 8, NULL},
	{ "calculatedSpawnPos",			TOK_BIT, 0, 8, NULL},
	{ "calcOffsetOnDemand",			TOK_BIT, 0, 8, NULL},
	{ "roamingLeash",				TOK_BIT, 0, 8, NULL},
	{ "roamingLeashPointValid",		TOK_BIT, 0, 8, NULL},
	{ "dontAggroInAggroRadius",		TOK_BIT, 0, 8, NULL},
	{ "noUpdate",					TOK_BIT, 0, 8, NULL},
	{ "dontDestroy",				TOK_BIT, 0, 8, NULL},
	{ "reinforceCandidate",			TOK_BIT, 0, 8, NULL},
	{ "reinforced",					TOK_BIT, 0, 8, NULL},
	{ "dontReinforce",				TOK_BIT, 0, 8, NULL},
	{ "combatTeam",					TOK_BIT, 0, 8, NULL},
	{ "combatSetup",				TOK_BIT, 0, 8, NULL},
	{ "HasControlledPets",			TOK_BIT, 0, 8, NULL},
	{ "LeashOnNonStaticOverride",	TOK_BIT, 0, 8, NULL},
	{ "IgnoreSocialAggroPulse",		TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AITeam()
{
	int iSize = sizeof(AITeam);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AITeam, iSize, "AITeam", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AITeam) + 7) / 4;
		AITeam *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->memberInCombat = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeam[30]);
		pTemp->memberInCombat = 0;
		pTemp->calculatedSpawnPos = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeam[31]);
		pTemp->calculatedSpawnPos = 0;
		pTemp->calcOffsetOnDemand = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeam[32]);
		pTemp->calcOffsetOnDemand = 0;
		pTemp->roamingLeash = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeam[33]);
		pTemp->roamingLeash = 0;
		pTemp->roamingLeashPointValid = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeam[34]);
		pTemp->roamingLeashPointValid = 0;
		pTemp->dontAggroInAggroRadius = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeam[35]);
		pTemp->dontAggroInAggroRadius = 0;
		pTemp->noUpdate = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeam[36]);
		pTemp->noUpdate = 0;
		pTemp->dontDestroy = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeam[37]);
		pTemp->dontDestroy = 0;
		pTemp->reinforceCandidate = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeam[38]);
		pTemp->reinforceCandidate = 0;
		pTemp->reinforced = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeam[39]);
		pTemp->reinforced = 0;
		pTemp->dontReinforce = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeam[40]);
		pTemp->dontReinforce = 0;
		pTemp->combatTeam = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeam[41]);
		pTemp->combatTeam = 0;
		pTemp->combatSetup = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeam[42]);
		pTemp->combatSetup = 0;
		pTemp->bHasControlledPets = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeam[43]);
		pTemp->bHasControlledPets = 0;
		pTemp->bLeashOnNonStaticOverride = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeam[44]);
		pTemp->bLeashOnNonStaticOverride = 0;
		pTemp->bIgnoreSocialAggroPulse = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AITeam[45]);
		pTemp->bIgnoreSocialAggroPulse = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIStatusTableEntryDangerValues
#define TYPE_parse_AIStatusTableEntryDangerValues AIStatusTableEntryDangerValues
ParseTable parse_AIStatusTableEntryDangerValues[] =
{
	{ "AIStatusTableEntryDangerValues", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIStatusTableEntryDangerValues), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "distFromMeVal",					TOK_F32(AIStatusTableEntryDangerValues, distFromMeVal, 0), NULL },
	{ "personalSpaceVal",				TOK_F32(AIStatusTableEntryDangerValues, personalSpaceVal, 0), NULL },
	{ "distFromGuardPointVal",			TOK_F32(AIStatusTableEntryDangerValues, distFromGuardPointVal, 0), NULL },
	{ "damageToMeVal",					TOK_F32(AIStatusTableEntryDangerValues, damageToMeVal, 0), NULL },
	{ "damageToFriendsVal",				TOK_F32(AIStatusTableEntryDangerValues, damageToFriendsVal, 0), NULL },
	{ "statusToMeVal",					TOK_F32(AIStatusTableEntryDangerValues, statusToMeVal, 0), NULL },
	{ "statusToFriendsVal",				TOK_F32(AIStatusTableEntryDangerValues, statusToFriendsVal, 0), NULL },
	{ "healingEnemiesVal",				TOK_F32(AIStatusTableEntryDangerValues, healingEnemiesVal, 0), NULL },
	{ "targetStickinessVal",			TOK_F32(AIStatusTableEntryDangerValues, targetStickinessVal, 0), NULL },
	{ "teamOrdersVal",					TOK_F32(AIStatusTableEntryDangerValues, teamOrdersVal, 0), NULL },
	{ "threatToMeVal",					TOK_F32(AIStatusTableEntryDangerValues, threatToMeVal, 0), NULL },
	{ "threatToFriendsVal",				TOK_F32(AIStatusTableEntryDangerValues, threatToFriendsVal, 0), NULL },
	{ "targetingRatingExprVal",			TOK_F32(AIStatusTableEntryDangerValues, targetingRatingExprVal, 0), NULL },
	{ "leashDecayScaleVal",				TOK_F32(AIStatusTableEntryDangerValues, leashDecayScaleVal, 0), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIStatusTableEntryDangerValues()
{
	int iSize = sizeof(AIStatusTableEntryDangerValues);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIStatusTableEntryDangerValues, iSize, "AIStatusTableEntryDangerValues", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIStatusTableTimes
#define TYPE_parse_AIStatusTableTimes AIStatusTableTimes
ParseTable parse_AIStatusTableTimes[] =
{
	{ "AIStatusTableTimes", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIStatusTableTimes), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "lastCheckedLOS",			TOK_AUTOINT(AIStatusTableTimes, lastCheckedLOS, 0), NULL },
	{ "lastVisible",			TOK_AUTOINT(AIStatusTableTimes, lastVisible, 0), NULL },
	{ "becameAttackTarget",		TOK_AUTOINT(AIStatusTableTimes, becameAttackTarget, 0), NULL },
	{ "enteredAggroRadius",		TOK_AUTOINT(AIStatusTableTimes, enteredAggroRadius, 0), NULL },
	{ "lastAggressiveAction",	TOK_AUTOINT(AIStatusTableTimes, lastAggressiveAction, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIStatusTableTimes()
{
	int iSize = sizeof(AIStatusTableTimes);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIStatusTableTimes, iSize, "AIStatusTableTimes", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AITeamStatusEntry[];
#define TYPE_parse_AITeamStatusEntry AITeamStatusEntry
extern ParseTable parse_AITeamStatusEntry[];
#define TYPE_parse_AITeamStatusEntry AITeamStatusEntry
extern ParseTable parse_AIStatusTableEntryDangerValues[];
#define TYPE_parse_AIStatusTableEntryDangerValues AIStatusTableEntryDangerValues
extern ParseTable parse_AIStatusTableTimes[];
#define TYPE_parse_AIStatusTableTimes AIStatusTableTimes
//Structparser.exe autogenerated ParseTable for struct AIStatusTableEntry
#define TYPE_parse_AIStatusTableEntry AIStatusTableEntry
ParseTable parse_AIStatusTableEntry[] =
{
	{ "AIStatusTableEntry", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIStatusTableEntry), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "entRef",					TOK_AUTOINT(AIStatusTableEntry, entRef, 0), NULL },
	{ "ambientStatus",			TOK_OPTIONALSTRUCT(AIStatusTableEntry, ambientStatus, parse_AITeamStatusEntry) },
	{ "combatStatus",			TOK_OPTIONALSTRUCT(AIStatusTableEntry, combatStatus, parse_AITeamStatusEntry) },
	{ "totalBaseDangerVal",		TOK_F32(AIStatusTableEntry, totalBaseDangerVal, 0), NULL },
	{ "maxDistSQR",				TOK_F32(AIStatusTableEntry, maxDistSQR, 0), NULL },
	{ "maxCollRadius",			TOK_F32(AIStatusTableEntry, maxCollRadius, 0), NULL },
	{ "maxDistSQRCheckTime",	TOK_AUTOINT(AIStatusTableEntry, maxDistSQRCheckTime, 0), NULL },
	{ "dangerVal",				TOK_EMBEDDEDSTRUCT(AIStatusTableEntry, dangerVal, parse_AIStatusTableEntryDangerValues)},
	{ "aggroCounters",			TOK_F32ARRAY(AIStatusTableEntry, aggroCounters), NULL },
	{ "aggroCounterDecay",		TOK_F32ARRAY(AIStatusTableEntry, aggroCounterDecay), NULL },
	{ "aggroGauges",			TOK_F32ARRAY(AIStatusTableEntry, aggroGauges), NULL },
	{ "aggroGaugeValues",		TOK_F32ARRAY(AIStatusTableEntry, aggroGaugeValues), NULL },
	{ "aggroCounterTotal",		TOK_F32(AIStatusTableEntry, aggroCounterTotal, 0), NULL },
	{ "aggroGaugeTotal",		TOK_F32(AIStatusTableEntry, aggroGaugeTotal, 0), NULL },
	{ "dangerValWithPower",		TOK_F32(AIStatusTableEntry, dangerValWithPower, 0), NULL },
	{ "distanceFromMe",			TOK_F32(AIStatusTableEntry, distanceFromMe, 0), NULL },
	{ "distanceFromSpawnPos",	TOK_F32(AIStatusTableEntry, distanceFromSpawnPos, 0), NULL },
	{ "lastNotify",				TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(AIStatusTableEntry, lastNotify), NULL },
	{ "time",					TOK_EMBEDDEDSTRUCT(AIStatusTableEntry, time, parse_AIStatusTableTimes)},
	{ "NotVisibleReason",		TOK_AUTOINT(AIStatusTableEntry, eNotVisibleReason, 0), EAINotVisibleReasonEnum },
	{ "skipCurTick",			TOK_BIT, 0, 8, NULL},
	{ "isAssignedTarget",		TOK_BIT, 0, 8, NULL},
	{ "inAvoidList",			TOK_BIT, 0, 8, NULL},
	{ "inAttractList",			TOK_BIT, 0, 8, NULL},
	{ "inSoftAvoidList",		TOK_BIT, 0, 8, NULL},
	{ "visible",				TOK_BIT, 0, 8, NULL},
	{ "inFrontArc",				TOK_BIT, 0, 8, NULL},
	{ "lostTrack",				TOK_BIT, 0, 8, NULL},
	{ "visitedLastKnown",		TOK_BIT, 0, 8, NULL},
	{ "assignedValues",			TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIStatusTableEntry()
{
	int iSize = sizeof(AIStatusTableEntry);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIStatusTableEntry, iSize, "AIStatusTableEntry", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIStatusTableEntry) + 7) / 4;
		AIStatusTableEntry *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->skipCurTick = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIStatusTableEntry[22]);
		pTemp->skipCurTick = 0;
		pTemp->isAssignedTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIStatusTableEntry[23]);
		pTemp->isAssignedTarget = 0;
		pTemp->inAvoidList = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIStatusTableEntry[24]);
		pTemp->inAvoidList = 0;
		pTemp->inAttractList = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIStatusTableEntry[25]);
		pTemp->inAttractList = 0;
		pTemp->inSoftAvoidList = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIStatusTableEntry[26]);
		pTemp->inSoftAvoidList = 0;
		pTemp->visible = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIStatusTableEntry[27]);
		pTemp->visible = 0;
		pTemp->inFrontArc = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIStatusTableEntry[28]);
		pTemp->inFrontArc = 0;
		pTemp->lostTrack = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIStatusTableEntry[29]);
		pTemp->lostTrack = 0;
		pTemp->visitedLastKnown = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIStatusTableEntry[30]);
		pTemp->visitedLastKnown = 0;
		pTemp->assignedValues = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIStatusTableEntry[31]);
		pTemp->assignedValues = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIVarsTime
#define TYPE_parse_AIVarsTime AIVarsTime
ParseTable parse_AIVarsTime[] =
{
	{ "AIVarsTime", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIVarsTime), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "refreshedProxEnts",			TOK_AUTOINT(AIVarsTime, refreshedProxEnts, 0), NULL },
	{ "lastUsedPower",				TOK_AUTOINT(AIVarsTime, lastUsedPower, 0), NULL },
	{ "lastActivatedPower",			TOK_AUTOINT(AIVarsTime, lastActivatedPower, 0), NULL },
	{ "lastDamage",					TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(AIVarsTime, lastDamage), NULL },
	{ "lastInitialDamage",			TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(AIVarsTime, lastInitialDamage), NULL },
	{ "lastInPreferredRange",		TOK_AUTOINT(AIVarsTime, lastInPreferredRange, 0), NULL },
	{ "lastTargetUpdate",			TOK_AUTOINT(AIVarsTime, lastTargetUpdate, 0), NULL },
	{ "lastPathFind",				TOK_AUTOINT(AIVarsTime, lastPathFind, 0), NULL },
	{ "lastCombatMovement",			TOK_AUTOINT(AIVarsTime, lastCombatMovement, 0), NULL },
	{ "startedRunningAway",			TOK_AUTOINT(AIVarsTime, startedRunningAway, 0), NULL },
	{ "startedSleeping",			TOK_AUTOINT(AIVarsTime, startedSleeping, 0), NULL },
	{ "lastTriedToFollow",			TOK_AUTOINT(AIVarsTime, lastTriedToFollow, 0), NULL },
	{ "startedGrievedState",		TOK_AUTOINT(AIVarsTime, startedGrievedState, 0), NULL },
	{ "endedGrievedState",			TOK_AUTOINT(AIVarsTime, endedGrievedState, 0), NULL },
	{ "pauseUntil",					TOK_AUTOINT(AIVarsTime, pauseUntil, 0), NULL },
	{ "lastEnteredCombat",			TOK_AUTOINT(AIVarsTime, lastEnteredCombat, 0), NULL },
	{ "lastNearSpawnPos",			TOK_AUTOINT(AIVarsTime, lastNearSpawnPos, 0), NULL },
	{ "lastHadStaredownTarget",		TOK_AUTOINT(AIVarsTime, lastHadStaredownTarget, 0), NULL },
	{ "lastChangedCombatYVariance",	TOK_AUTOINT(AIVarsTime, lastChangedCombatYVariance, 0), NULL },
	{ "timeSpawned",				TOK_AUTOINT(AIVarsTime, timeSpawned, 0), NULL },
	{ "timeCutsceneStart",			TOK_AUTOINT(AIVarsTime, timeCutsceneStart, 0), NULL },
	{ "timeLeashWait",				TOK_AUTOINT(AIVarsTime, timeLeashWait, 0), NULL },
	{ "lastHitProxEntsCap",			TOK_AUTOINT(AIVarsTime, lastHitProxEntsCap, 0), NULL },
	{ "lastCombatCoherencyCheck",	TOK_AUTOINT(AIVarsTime, lastCombatCoherencyCheck, 0), NULL },
	{ "enterCombatWaitTime",		TOK_AUTOINT(AIVarsTime, enterCombatWaitTime, 0), NULL },
	{ "lastSocialAggroPulse",		TOK_AUTOINT(AIVarsTime, lastSocialAggroPulse, 0), NULL },
	{ "lastHadCombatTarget",		TOK_AUTOINT(AIVarsTime, lastHadCombatTarget, 0), NULL },
	{ "lastSentAggroUpdate",		TOK_AUTOINT(AIVarsTime, lastSentAggroUpdate, 0), NULL },
	{ "timeStoppedCurrentlyMoving",	TOK_AUTOINT(AIVarsTime, timeStoppedCurrentlyMoving, 0), NULL },
	{ "last_hour",					TOK_AUTOINT(AIVarsTime, last_hour, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIVarsTime()
{
	int iSize = sizeof(AIVarsTime);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIVarsTime, iSize, "AIVarsTime", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_Entity[];
#define TYPE_parse_Entity Entity
//Structparser.exe autogenerated ParseTable for struct AIMovementTarget
#define TYPE_parse_AIMovementTarget AIMovementTarget
ParseTable parse_AIMovementTarget[] =
{
	{ "AIMovementTarget", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIMovementTarget), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "entityTarget",		TOK_UNOWNED | TOK_OPTIONALSTRUCT(AIMovementTarget, entityTarget, parse_Entity) },
	{ "posTarget",			TOK_VEC3(AIMovementTarget, posTarget), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIMovementTarget()
{
	int iSize = sizeof(AIMovementTarget);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIMovementTarget, iSize, "AIMovementTarget", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable polyTable_AIVolumeInstance[];
//Structparser.exe autogenerated ParseTable for struct AIVolumeInstance
#define TYPE_parse_AIVolumeInstance AIVolumeInstance
ParseTable parse_AIVolumeInstance[] =
{
	{ "AIVolumeInstance", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIVolumeInstance), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(AIVolumeInstance, eType, 0), AIVolumeTypeEnum },
	{ "next",				TOK_OPTIONALPOLYMORPH(AIVolumeInstance, next, polyTable_AIVolumeInstance) },
	{ "radius",				TOK_F32(AIVolumeInstance, radius, 0), NULL },
	{ "uid",				TOK_AUTOINT(AIVolumeInstance, uid, 0), NULL },
	{ "refCount",			TOK_AUTOINT(AIVolumeInstance, refCount, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
//filled in by autogenerated fixup-time calls to AddEntryToPolyTable()
ParseTable polyTable_AIVolumeInstance[] = 
{
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 1 }
};
int autoStruct_fixup_AIVolumeInstance()
{
	int iSize = sizeof(AIVolumeInstance);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIVolumeInstance, iSize, "AIVolumeInstance", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIVolumeInstance[];
#define TYPE_parse_AIVolumeInstance AIVolumeInstance
//Structparser.exe autogenerated ParseTable for struct AIVolumeAvoidInstance
#define TYPE_parse_AIVolumeAvoidInstance AIVolumeAvoidInstance
ParseTable parse_AIVolumeAvoidInstance[] =
{
	{ "AIVolumeAvoidInstance", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIVolumeAvoidInstance), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(AIVolumeAvoidInstance, base.eType, AIVolumeType_AVOID), AIVolumeTypeEnum },
	{ "next",					TOK_OPTIONALPOLYMORPH(AIVolumeAvoidInstance, base.next, polyTable_AIVolumeInstance) },
	{ "radius",					TOK_F32(AIVolumeAvoidInstance, base.radius, 0), NULL },
	{ "uid",					TOK_AUTOINT(AIVolumeAvoidInstance, base.uid, 0), NULL },
	{ "refCount",				TOK_AUTOINT(AIVolumeAvoidInstance, base.refCount, 0), NULL },
	{ "maxLevelDiff",			TOK_AUTOINT(AIVolumeAvoidInstance, maxLevelDiff, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AIVolumeInstance[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AIVolumeAvoidInstance()
{
	int iSize = sizeof(AIVolumeAvoidInstance);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIVolumeAvoidInstance, iSize, "AIVolumeAvoidInstance", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AIVolumeInstance, "AIVolumeAvoidInstance", parse_AIVolumeAvoidInstance, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIVolumeInstance[];
#define TYPE_parse_AIVolumeInstance AIVolumeInstance
//Structparser.exe autogenerated ParseTable for struct AIVolumeSoftAvoidInstance
#define TYPE_parse_AIVolumeSoftAvoidInstance AIVolumeSoftAvoidInstance
ParseTable parse_AIVolumeSoftAvoidInstance[] =
{
	{ "AIVolumeSoftAvoidInstance", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIVolumeSoftAvoidInstance), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Type",						TOK_OBJECTTYPE | TOK_AUTOINT(AIVolumeSoftAvoidInstance, base.eType, AIVolumeType_SOFT_AVOID), AIVolumeTypeEnum },
	{ "next",						TOK_OPTIONALPOLYMORPH(AIVolumeSoftAvoidInstance, base.next, polyTable_AIVolumeInstance) },
	{ "radius",						TOK_F32(AIVolumeSoftAvoidInstance, base.radius, 0), NULL },
	{ "uid",						TOK_AUTOINT(AIVolumeSoftAvoidInstance, base.uid, 0), NULL },
	{ "refCount",					TOK_AUTOINT(AIVolumeSoftAvoidInstance, base.refCount, 0), NULL },
	{ "magnitude",					TOK_AUTOINT(AIVolumeSoftAvoidInstance, magnitude, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AIVolumeInstance[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AIVolumeSoftAvoidInstance()
{
	int iSize = sizeof(AIVolumeSoftAvoidInstance);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIVolumeSoftAvoidInstance, iSize, "AIVolumeSoftAvoidInstance", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AIVolumeInstance, "AIVolumeSoftAvoidInstance", parse_AIVolumeSoftAvoidInstance, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIVolumeInstance[];
#define TYPE_parse_AIVolumeInstance AIVolumeInstance
//Structparser.exe autogenerated ParseTable for struct AIVolumeAttractInstance
#define TYPE_parse_AIVolumeAttractInstance AIVolumeAttractInstance
ParseTable parse_AIVolumeAttractInstance[] =
{
	{ "AIVolumeAttractInstance", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIVolumeAttractInstance), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Type",						TOK_OBJECTTYPE | TOK_AUTOINT(AIVolumeAttractInstance, base.eType, AIVolumeType_ATTRACT), AIVolumeTypeEnum },
	{ "next",						TOK_OPTIONALPOLYMORPH(AIVolumeAttractInstance, base.next, polyTable_AIVolumeInstance) },
	{ "radius",						TOK_F32(AIVolumeAttractInstance, base.radius, 0), NULL },
	{ "uid",						TOK_AUTOINT(AIVolumeAttractInstance, base.uid, 0), NULL },
	{ "refCount",					TOK_AUTOINT(AIVolumeAttractInstance, base.refCount, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AIVolumeInstance[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AIVolumeAttractInstance()
{
	int iSize = sizeof(AIVolumeAttractInstance);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIVolumeAttractInstance, iSize, "AIVolumeAttractInstance", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AIVolumeInstance, "AIVolumeAttractInstance", parse_AIVolumeAttractInstance, iSize);
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIVolumeInfo
#define TYPE_parse_AIVolumeInfo AIVolumeInfo
ParseTable parse_AIVolumeInfo[] =
{
	{ "AIVolumeInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIVolumeInfo), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Type",			TOK_OBJECTTYPE | TOK_AUTOINT(AIVolumeInfo, eType, 0), AIVolumeTypeEnum },
	{ "maxRadius",		TOK_F32(AIVolumeInfo, maxRadius, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
//filled in by autogenerated fixup-time calls to AddEntryToPolyTable()
ParseTable polyTable_AIVolumeInfo[] = 
{
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 0 },
	{ "", 0, 1 }
};
int autoStruct_fixup_AIVolumeInfo()
{
	int iSize = sizeof(AIVolumeInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIVolumeInfo, iSize, "AIVolumeInfo", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIAvoidInfoPlaced
#define TYPE_parse_AIAvoidInfoPlaced AIAvoidInfoPlaced
ParseTable parse_AIAvoidInfoPlaced[] =
{
	{ "AIAvoidInfoPlaced", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIAvoidInfoPlaced), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "pos",				TOK_VEC3(AIAvoidInfoPlaced, pos), NULL },
	{ "maxRadius",			TOK_F32(AIAvoidInfoPlaced, maxRadius, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIAvoidInfoPlaced()
{
	int iSize = sizeof(AIAvoidInfoPlaced);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIAvoidInfoPlaced, iSize, "AIAvoidInfoPlaced", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIVolumeInfo[];
#define TYPE_parse_AIVolumeInfo AIVolumeInfo
extern ParseTable parse_AIAvoidInfoPlaced[];
#define TYPE_parse_AIAvoidInfoPlaced AIAvoidInfoPlaced
//Structparser.exe autogenerated ParseTable for struct AIVolumeAvoidInfo
#define TYPE_parse_AIVolumeAvoidInfo AIVolumeAvoidInfo
ParseTable parse_AIVolumeAvoidInfo[] =
{
	{ "AIVolumeAvoidInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIVolumeAvoidInfo), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_OBJECTTYPE | TOK_AUTOINT(AIVolumeAvoidInfo, base.eType, AIVolumeType_AVOID), AIVolumeTypeEnum },
	{ "maxRadius",			TOK_F32(AIVolumeAvoidInfo, base.maxRadius, 0), NULL },
	{ "placed",				TOK_EMBEDDEDSTRUCT(AIVolumeAvoidInfo, placed, parse_AIAvoidInfoPlaced)},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AIVolumeInfo[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AIVolumeAvoidInfo()
{
	int iSize = sizeof(AIVolumeAvoidInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIVolumeAvoidInfo, iSize, "AIVolumeAvoidInfo", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AIVolumeInfo, "AIVolumeAvoidInfo", parse_AIVolumeAvoidInfo, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIVolumeInfo[];
#define TYPE_parse_AIVolumeInfo AIVolumeInfo
//Structparser.exe autogenerated ParseTable for struct AIVolumeSoftAvoidInfo
#define TYPE_parse_AIVolumeSoftAvoidInfo AIVolumeSoftAvoidInfo
ParseTable parse_AIVolumeSoftAvoidInfo[] =
{
	{ "AIVolumeSoftAvoidInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIVolumeSoftAvoidInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(AIVolumeSoftAvoidInfo, base.eType, AIVolumeType_SOFT_AVOID), AIVolumeTypeEnum },
	{ "maxRadius",				TOK_F32(AIVolumeSoftAvoidInfo, base.maxRadius, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AIVolumeInfo[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AIVolumeSoftAvoidInfo()
{
	int iSize = sizeof(AIVolumeSoftAvoidInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIVolumeSoftAvoidInfo, iSize, "AIVolumeSoftAvoidInfo", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AIVolumeInfo, "AIVolumeSoftAvoidInfo", parse_AIVolumeSoftAvoidInfo, iSize);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIVolumeInfo[];
#define TYPE_parse_AIVolumeInfo AIVolumeInfo
//Structparser.exe autogenerated ParseTable for struct AIVolumeAttractInfo
#define TYPE_parse_AIVolumeAttractInfo AIVolumeAttractInfo
ParseTable parse_AIVolumeAttractInfo[] =
{
	{ "AIVolumeAttractInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIVolumeAttractInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_OBJECTTYPE | TOK_AUTOINT(AIVolumeAttractInfo, base.eType, AIVolumeType_ATTRACT), AIVolumeTypeEnum },
	{ "maxRadius",				TOK_F32(AIVolumeAttractInfo, base.maxRadius, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
extern ParseTable polyTable_AIVolumeInfo[];
void AddEntryToPolyTable(ParseTable *polyTable, char *pName, ParseTable *pTable, int iSize);
int autoStruct_fixup_AIVolumeAttractInfo()
{
	int iSize = sizeof(AIVolumeAttractInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIVolumeAttractInfo, iSize, "AIVolumeAttractInfo", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	AddEntryToPolyTable(polyTable_AIVolumeInfo, "AIVolumeAttractInfo", parse_AIVolumeAttractInfo, iSize);
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugLogEntry
#define TYPE_parse_AIDebugLogEntry AIDebugLogEntry
ParseTable parse_AIDebugLogEntry[] =
{
	{ "AIDebugLogEntry", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugLogEntry), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "logType",			TOK_AUTOINT(AIDebugLogEntry, logType, 0), AILogTypeEnum },
	{ "logLevel",			TOK_AUTOINT(AIDebugLogEntry, logLevel, 0), NULL },
	{ "logTag",				TOK_AUTOINT(AIDebugLogEntry, logTag, 0), NULL },
	{ "time",				TOK_AUTOINT(AIDebugLogEntry, time, 0), NULL },
	{ "logEntry",			TOK_FIXEDSTR(AIDebugLogEntry, logEntry), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugLogEntry()
{
	int iSize = sizeof(AIDebugLogEntry);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugLogEntry, iSize, "AIDebugLogEntry", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugAnimSetting
#define TYPE_parse_AIDebugAnimSetting AIDebugAnimSetting
ParseTable parse_AIDebugAnimSetting[] =
{
	{ "AIDebugAnimSetting", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugAnimSetting), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "enabled",			TOK_AUTOINT(AIDebugAnimSetting, enabled, 0), NULL },
	{ "anim",				TOK_STRING(AIDebugAnimSetting, anim, 0), NULL },
	{ "time",				TOK_AUTOINT(AIDebugAnimSetting, time, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugAnimSetting()
{
	int iSize = sizeof(AIDebugAnimSetting);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugAnimSetting, iSize, "AIDebugAnimSetting", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIDebugAnimState
#define TYPE_parse_AIDebugAnimState AIDebugAnimState
ParseTable parse_AIDebugAnimState[] =
{
	{ "AIDebugAnimState", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIDebugAnimState), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "nextSwitch",			TOK_AUTOINT(AIDebugAnimState, nextSwitch, 0), NULL },
	{ "curSetting",			TOK_AUTOINT(AIDebugAnimState, curSetting, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIDebugAnimState()
{
	int iSize = sizeof(AIDebugAnimState);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIDebugAnimState, iSize, "AIDebugAnimState", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIPowerConfig
#define TYPE_parse_AIPowerConfig AIPowerConfig
ParseTable parse_AIPowerConfig[] =
{
	{ "AIPowerConfig", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIPowerConfig), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "powDef",					TOK_STRUCTPARAM | TOK_NON_NULL_REF | TOK_REQUIRED | TOK_REFERENCE(AIPowerConfig, powDef, 0, "PowerDef") },
	{ "Power:",					TOK_REDUNDANTNAME | TOK_STRUCTPARAM | TOK_NON_NULL_REF | TOK_REFERENCE(AIPowerConfig, powDef, 0, "PowerDef") },
	{ "absWeight",				TOK_F32(AIPowerConfig, absWeight, 0), NULL },
	{ "Weight:",				TOK_REDUNDANTNAME | TOK_F32(AIPowerConfig, absWeight, 0), NULL },
	{ "WeightModifier",			TOK_OPTIONALLATEBINDSTRUCT(AIPowerConfig, weightModifier) },
	{ "WeightModifier:",		TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AIPowerConfig, weightModifier) },
	{ "minDist",				TOK_F32(AIPowerConfig, minDist, 0), NULL },
	{ "MinDist:",				TOK_REDUNDANTNAME | TOK_F32(AIPowerConfig, minDist, 0), NULL },
	{ "maxDist",				TOK_F32(AIPowerConfig, maxDist, 0), NULL },
	{ "MaxDist:",				TOK_REDUNDANTNAME | TOK_F32(AIPowerConfig, maxDist, 0), NULL },
	{ "chainTarget",			TOK_POOL_STRING | TOK_STRING(AIPowerConfig, chainTarget, 0), NULL },
	{ "ChainTarget:",			TOK_REDUNDANTNAME | TOK_POOL_STRING | TOK_STRING(AIPowerConfig, chainTarget, 0), NULL },
	{ "chainTime",				TOK_F32(AIPowerConfig, chainTime, 0), NULL },
	{ "ChainTime:",				TOK_REDUNDANTNAME | TOK_F32(AIPowerConfig, chainTime, 0), NULL },
	{ "AIRequires",				TOK_OPTIONALLATEBINDSTRUCT(AIPowerConfig, aiRequires) },
	{ "AIRequires:",			TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AIPowerConfig, aiRequires) },
	{ "AIEndCondition",			TOK_OPTIONALLATEBINDSTRUCT(AIPowerConfig, aiEndCondition) },
	{ "AIEndCondition:",		TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AIPowerConfig, aiEndCondition) },
	{ "ChainRequires",			TOK_OPTIONALLATEBINDSTRUCT(AIPowerConfig, chainRequires) },
	{ "ChainRequires:",			TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AIPowerConfig, chainRequires) },
	{ "TargetOverride",			TOK_OPTIONALLATEBINDSTRUCT(AIPowerConfig, targetOverride) },
	{ "TargetOverride:",		TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AIPowerConfig, targetOverride) },
	{ "CureRequires",			TOK_OPTIONALLATEBINDSTRUCT(AIPowerConfig, cureRequires) },
	{ "CureRequires:",			TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(AIPowerConfig, cureRequires) },
	{ "curePowerTags",			TOK_INTARRAY(AIPowerConfig, curePowerTags),  PowerTagsEnum},
	{ "CureTags",				TOK_REDUNDANTNAME | TOK_INTARRAY(AIPowerConfig, curePowerTags),  PowerTagsEnum},
	{ "maxRandomQueueTime",		TOK_F32(AIPowerConfig, maxRandomQueueTime, 0), NULL },
	{ "MaxRandomQueueTime:",	TOK_REDUNDANTNAME | TOK_F32(AIPowerConfig, maxRandomQueueTime, 0), NULL },
	{ "ChainLocksFacing",		TOK_AUTOINT(AIPowerConfig, bChainLocksFacing, 0), NULL },
	{ "ChainLocksMovement",		TOK_AUTOINT(AIPowerConfig, bChainLocksMovement, 0), NULL },
	{ "filename",				TOK_POOL_STRING | TOK_CURRENTFILE(AIPowerConfig, filename), NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIPowerConfig()
{
	int iSize = sizeof(AIPowerConfig);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIPowerConfig, iSize, "AIPowerConfig", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_AIPowerConfig(void)
{
	DoAutoStructLateBind(parse_AIPowerConfig, 6, "Expression");
	DoAutoStructLateBind(parse_AIPowerConfig, 7, "Expression_StructParam");
	DoAutoStructLateBind(parse_AIPowerConfig, 16, "Expression");
	DoAutoStructLateBind(parse_AIPowerConfig, 17, "Expression_StructParam");
	DoAutoStructLateBind(parse_AIPowerConfig, 18, "Expression");
	DoAutoStructLateBind(parse_AIPowerConfig, 19, "Expression_StructParam");
	DoAutoStructLateBind(parse_AIPowerConfig, 20, "Expression");
	DoAutoStructLateBind(parse_AIPowerConfig, 21, "Expression_StructParam");
	DoAutoStructLateBind(parse_AIPowerConfig, 22, "Expression");
	DoAutoStructLateBind(parse_AIPowerConfig, 23, "Expression_StructParam");
	DoAutoStructLateBind(parse_AIPowerConfig, 24, "Expression");
	DoAutoStructLateBind(parse_AIPowerConfig, 25, "Expression_StructParam");
}
//autogeneratednocheckin
extern ParseTable parse_AIPowerConfig[];
#define TYPE_parse_AIPowerConfig AIPowerConfig
//Structparser.exe autogenerated ParseTable for struct AIPowerConfigList
#define TYPE_parse_AIPowerConfigList AIPowerConfigList
ParseTable parse_AIPowerConfigList[] =
{
	{ "AIPowerConfigList", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIPowerConfigList), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Name:",						TOK_STRUCTPARAM | TOK_KEY | TOK_STRING(AIPowerConfigList, name, 0), NULL },
	{ "filename",					TOK_POOL_STRING | TOK_CURRENTFILE(AIPowerConfigList, filename), NULL},
	{ "PrefMinRange:",				TOK_F32(AIPowerConfigList, prefMinRange, 0), NULL },
	{ "PrefMaxRange:",				TOK_F32(AIPowerConfigList, prefMaxRange, 0), NULL },
	{ "OutOfPrefRangeTolerance:",	TOK_F32(AIPowerConfigList, outOfPrefRangeTolerance, 0), NULL },
	{ "AIPowerConfig:",				TOK_STRUCT(AIPowerConfigList, entries, parse_AIPowerConfig) },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIPowerConfigList()
{
	int iSize = sizeof(AIPowerConfigList);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIPowerConfigList, iSize, "AIPowerConfigList", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_CritterPowerConfig[];
#define TYPE_parse_CritterPowerConfig CritterPowerConfig
extern ParseTable parse_AIPowerConfig[];
#define TYPE_parse_AIPowerConfig AIPowerConfig
extern ParseTable parse_AIPowerConfig[];
#define TYPE_parse_AIPowerConfig AIPowerConfig
extern ParseTable parse_StructMod[];
#define TYPE_parse_StructMod StructMod
//Structparser.exe autogenerated ParseTable for struct AIPowerInfo
#define TYPE_parse_AIPowerInfo AIPowerInfo
ParseTable parse_AIPowerInfo[] =
{
	{ "AIPowerInfo", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIPowerInfo), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "power",						TOK_OPTIONALLATEBINDSTRUCT(AIPowerInfo, power) },
	{ "critterPow",					TOK_OPTIONALSTRUCT(AIPowerInfo, critterPow, parse_CritterPowerConfig) },
	{ "powConfig",					TOK_REFERENCE(AIPowerInfo, powConfig, 0, "AIPowerConfig") },
	{ "defaultPowConfig",			TOK_OPTIONALSTRUCT(AIPowerInfo, defaultPowConfig, parse_AIPowerConfig) },
	{ "localModifiedPowConfig",		TOK_OPTIONALSTRUCT(AIPowerInfo, localModifiedPowConfig, parse_AIPowerConfig) },
	{ "powerConfigMods",			TOK_STRUCT(AIPowerInfo, powerConfigMods, parse_StructMod) },
	{ "curOverrideTargetRef",		TOK_AUTOINT(AIPowerInfo, curOverrideTargetRef, 0), NULL },
	{ "overrideTargetTime",			TOK_AUTOINT(AIPowerInfo, overrideTargetTime, 0), NULL },
	{ "curBonusWeight",				TOK_F32(AIPowerInfo, curBonusWeight, 0), NULL },
	{ "curRating",					TOK_F32(AIPowerInfo, curRating, 0), NULL },
	{ "timesUsed",					TOK_AUTOINT(AIPowerInfo, timesUsed, 0), NULL },
	{ "lastUsed",					TOK_AUTOINT(AIPowerInfo, lastUsed, 0), NULL },
	{ "powerTimeRecharge",			TOK_F32(AIPowerInfo, powerTimeRecharge, 0), NULL },
	{ "areaEffectRange",			TOK_F32(AIPowerInfo, areaEffectRange, 0), NULL },
	{ "aiTagBits",					TOK_AUTOINT(AIPowerInfo, aiTagBits, 0), NULL },
	{ "isAttackPower",				TOK_BIT, 0, 8, NULL},
	{ "isHealPower",				TOK_BIT, 0, 8, NULL},
	{ "isShieldHealPower",			TOK_BIT, 0, 8, NULL},
	{ "isBuffPower",				TOK_BIT, 0, 8, NULL},
	{ "isCurePower",				TOK_BIT, 0, 8, NULL},
	{ "isTargetCreatorPower",		TOK_BIT, 0, 8, NULL},
	{ "isTargetOwnerPower",			TOK_BIT, 0, 8, NULL},
	{ "isLungePower",				TOK_BIT, 0, 8, NULL},
	{ "isResPower",					TOK_BIT, 0, 8, NULL},
	{ "isOutOfCombatPower",			TOK_BIT, 0, 8, NULL},
	{ "isFlyPower",					TOK_BIT, 0, 8, NULL},
	{ "isArcLimitedPower",			TOK_BIT, 0, 8, NULL},
	{ "isControlPower",				TOK_BIT, 0, 8, NULL},
	{ "isAEPower",					TOK_BIT, 0, 8, NULL},
	{ "isSelfTarget",				TOK_BIT, 0, 8, NULL},
	{ "isSelfTargetOnly",			TOK_BIT, 0, 8, NULL},
	{ "isAfterDeathPower",			TOK_BIT, 0, 8, NULL},
	{ "isDeadOrAlivePower",			TOK_BIT, 0, 8, NULL},
	{ "isInterruptedOnMovement",	TOK_BIT, 0, 8, NULL},
	{ "canAffectSelf",				TOK_BIT, 0, 8, NULL},
	{ "resetValid",					TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIPowerInfo()
{
	int iSize = sizeof(AIPowerInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIPowerInfo, iSize, "AIPowerInfo", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIPowerInfo) + 7) / 4;
		AIPowerInfo *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->isAttackPower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[17]);
		pTemp->isAttackPower = 0;
		pTemp->isHealPower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[18]);
		pTemp->isHealPower = 0;
		pTemp->isShieldHealPower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[19]);
		pTemp->isShieldHealPower = 0;
		pTemp->isBuffPower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[20]);
		pTemp->isBuffPower = 0;
		pTemp->isCurePower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[21]);
		pTemp->isCurePower = 0;
		pTemp->isTargetCreatorPower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[22]);
		pTemp->isTargetCreatorPower = 0;
		pTemp->isTargetOwnerPower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[23]);
		pTemp->isTargetOwnerPower = 0;
		pTemp->isLungePower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[24]);
		pTemp->isLungePower = 0;
		pTemp->isResPower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[25]);
		pTemp->isResPower = 0;
		pTemp->isOutOfCombatPower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[26]);
		pTemp->isOutOfCombatPower = 0;
		pTemp->isFlyPower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[27]);
		pTemp->isFlyPower = 0;
		pTemp->isArcLimitedPower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[28]);
		pTemp->isArcLimitedPower = 0;
		pTemp->isControlPower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[29]);
		pTemp->isControlPower = 0;
		pTemp->isAEPower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[30]);
		pTemp->isAEPower = 0;
		pTemp->isSelfTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[31]);
		pTemp->isSelfTarget = 0;
		pTemp->isSelfTargetOnly = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[32]);
		pTemp->isSelfTargetOnly = 0;
		pTemp->isAfterDeathPower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[33]);
		pTemp->isAfterDeathPower = 0;
		pTemp->isDeadOrAlivePower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[34]);
		pTemp->isDeadOrAlivePower = 0;
		pTemp->isInterruptedOnMovement = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[35]);
		pTemp->isInterruptedOnMovement = 0;
		pTemp->canAffectSelf = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[36]);
		pTemp->canAffectSelf = 0;
		pTemp->resetValid = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerInfo[37]);
		pTemp->resetValid = 0;
	}
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_AIPowerInfo(void)
{
	DoAutoStructLateBind(parse_AIPowerInfo, 2, "Power");
}
//autogeneratednocheckin
extern ParseTable parse_AIPowerInfo[];
#define TYPE_parse_AIPowerInfo AIPowerInfo
//Structparser.exe autogenerated ParseTable for struct AIPowerMultiTickAction
#define TYPE_parse_AIPowerMultiTickAction AIPowerMultiTickAction
ParseTable parse_AIPowerMultiTickAction[] =
{
	{ "AIPowerMultiTickAction", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIPowerMultiTickAction), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "targetRef",				TOK_AUTOINT(AIPowerMultiTickAction, targetRef, 0), NULL },
	{ "targetPos",				TOK_VEC3(AIPowerMultiTickAction, targetPos), NULL },
	{ "type",					TOK_AUTOINT(AIPowerMultiTickAction, type, 0), AIPowerActionTypeEnum },
	{ "powInfo",				TOK_OPTIONALSTRUCT(AIPowerMultiTickAction, powInfo, parse_AIPowerInfo) },
	{ "timer",					TOK_AUTOINT(AIPowerMultiTickAction, timer, 0), NULL },
	{ "ForcedActionPriority",	TOK_AUTOINT(AIPowerMultiTickAction, iForcedActionPriority, 0), NULL },
	{ "usedPower",				TOK_BIT, 0, 8, NULL},
	{ "stoppedMoving",			TOK_BIT, 0, 8, NULL},
	{ "hostileTarget",			TOK_BIT, 0, 8, NULL},
	{ "forceUseTarget",			TOK_BIT, 0, 8, NULL},
	{ "finishedAction",			TOK_BIT, 0, 8, NULL},
	{ "combatNoMove",			TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIPowerMultiTickAction()
{
	int iSize = sizeof(AIPowerMultiTickAction);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIPowerMultiTickAction, iSize, "AIPowerMultiTickAction", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIPowerMultiTickAction) + 7) / 4;
		AIPowerMultiTickAction *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->usedPower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerMultiTickAction[8]);
		pTemp->usedPower = 0;
		pTemp->stoppedMoving = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerMultiTickAction[9]);
		pTemp->stoppedMoving = 0;
		pTemp->hostileTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerMultiTickAction[10]);
		pTemp->hostileTarget = 0;
		pTemp->forceUseTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerMultiTickAction[11]);
		pTemp->forceUseTarget = 0;
		pTemp->finishedAction = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerMultiTickAction[12]);
		pTemp->finishedAction = 0;
		pTemp->combatNoMove = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerMultiTickAction[13]);
		pTemp->combatNoMove = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIPowerInfo[];
#define TYPE_parse_AIPowerInfo AIPowerInfo
extern ParseTable parse_AIPowerInfo[];
#define TYPE_parse_AIPowerInfo AIPowerInfo
//Structparser.exe autogenerated ParseTable for struct AIQueuedPower
#define TYPE_parse_AIQueuedPower AIQueuedPower
ParseTable parse_AIQueuedPower[] =
{
	{ "AIQueuedPower", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIQueuedPower), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "powerInfo",			TOK_OPTIONALSTRUCT(AIQueuedPower, powerInfo, parse_AIPowerInfo) },
	{ "targetRef",			TOK_AUTOINT(AIQueuedPower, targetRef, 0), NULL },
	{ "secondaryTargetRef",	TOK_AUTOINT(AIQueuedPower, secondaryTargetRef, 0), NULL },
	{ "chainPowerInfo",		TOK_OPTIONALSTRUCT(AIQueuedPower, chainPowerInfo, parse_AIPowerInfo) },
	{ "targetPos",			TOK_VEC3(AIQueuedPower, targetPos), NULL },
	{ "execTime",			TOK_AUTOINT(AIQueuedPower, execTime, 0), NULL },
	{ "validTargetPos",		TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIQueuedPower()
{
	int iSize = sizeof(AIQueuedPower);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIQueuedPower, iSize, "AIQueuedPower", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIQueuedPower) + 7) / 4;
		AIQueuedPower *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->validTargetPos = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIQueuedPower[8]);
		pTemp->validTargetPos = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIPowerInfo[];
#define TYPE_parse_AIPowerInfo AIPowerInfo
extern ParseTable parse_AIPowerInfo[];
#define TYPE_parse_AIPowerInfo AIPowerInfo
extern ParseTable parse_AIPowerInfo[];
#define TYPE_parse_AIPowerInfo AIPowerInfo
extern ParseTable parse_AIQueuedPower[];
#define TYPE_parse_AIQueuedPower AIQueuedPower
extern ParseTable parse_AIPowerMultiTickAction[];
#define TYPE_parse_AIPowerMultiTickAction AIPowerMultiTickAction
//Structparser.exe autogenerated ParseTable for struct AIPowerEntityInfo
#define TYPE_parse_AIPowerEntityInfo AIPowerEntityInfo
ParseTable parse_AIPowerEntityInfo[] =
{
	{ "AIPowerEntityInfo", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIPowerEntityInfo), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "powerConfigList",			TOK_REFERENCE(AIPowerEntityInfo, powerConfigList, 0, "AIPowerConfigList") },
	{ "powInfos",					TOK_STRUCT(AIPowerEntityInfo, powInfos, parse_AIPowerInfo) },
	{ "preferredPower",				TOK_OPTIONALSTRUCT(AIPowerEntityInfo, preferredPower, parse_AIPowerInfo) },
	{ "lastUsedPower",				TOK_OPTIONALSTRUCT(AIPowerEntityInfo, lastUsedPower, parse_AIPowerInfo) },
	{ "queuedPowers",				TOK_STRUCT(AIPowerEntityInfo, queuedPowers, parse_AIQueuedPower) },
	{ "MultiTickActionQueue",		TOK_STRUCT(AIPowerEntityInfo, ppMultiTickActionQueue, parse_AIPowerMultiTickAction) },
	{ "notAllowedToUsePowersUntil",	TOK_AUTOINT(AIPowerEntityInfo, notAllowedToUsePowersUntil, 0), NULL },
	{ "totalUses",					TOK_AUTOINT(AIPowerEntityInfo, totalUses, 0), NULL },
	{ "preferredAITagBit",			TOK_AUTOINT(AIPowerEntityInfo, preferredAITagBit, 0), NULL },
	{ "currHealingRange",			TOK_F32(AIPowerEntityInfo, currHealingRange, 0), NULL },
	{ "validPowerConfig",			TOK_BIT, 0, 8, NULL},
	{ "hasAttackPowers",			TOK_BIT, 0, 8, NULL},
	{ "hasHealPowers",				TOK_BIT, 0, 8, NULL},
	{ "hasShieldHealPowers",		TOK_BIT, 0, 8, NULL},
	{ "hasBuffPowers",				TOK_BIT, 0, 8, NULL},
	{ "hasCurePower",				TOK_BIT, 0, 8, NULL},
	{ "hasLungePowers",				TOK_BIT, 0, 8, NULL},
	{ "hasResPowers",				TOK_BIT, 0, 8, NULL},
	{ "hasFlightPowers",			TOK_BIT, 0, 8, NULL},
	{ "alwaysFlight",				TOK_BIT, 0, 8, NULL},
	{ "hasAfterDeathPowers",		TOK_BIT, 0, 8, NULL},
	{ "hasDeadOrAlivePowers",		TOK_BIT, 0, 8, NULL},
	{ "hasArcLimitedPowers",		TOK_BIT, 0, 8, NULL},
	{ "hasControlPowers",			TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIPowerEntityInfo()
{
	int iSize = sizeof(AIPowerEntityInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIPowerEntityInfo, iSize, "AIPowerEntityInfo", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIPowerEntityInfo) + 7) / 4;
		AIPowerEntityInfo *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->validPowerConfig = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerEntityInfo[12]);
		pTemp->validPowerConfig = 0;
		pTemp->hasAttackPowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerEntityInfo[13]);
		pTemp->hasAttackPowers = 0;
		pTemp->hasHealPowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerEntityInfo[14]);
		pTemp->hasHealPowers = 0;
		pTemp->hasShieldHealPowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerEntityInfo[15]);
		pTemp->hasShieldHealPowers = 0;
		pTemp->hasBuffPowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerEntityInfo[16]);
		pTemp->hasBuffPowers = 0;
		pTemp->hasCurePower = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerEntityInfo[17]);
		pTemp->hasCurePower = 0;
		pTemp->hasLungePowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerEntityInfo[18]);
		pTemp->hasLungePowers = 0;
		pTemp->hasResPowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerEntityInfo[19]);
		pTemp->hasResPowers = 0;
		pTemp->hasFlightPowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerEntityInfo[20]);
		pTemp->hasFlightPowers = 0;
		pTemp->alwaysFlight = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerEntityInfo[21]);
		pTemp->alwaysFlight = 0;
		pTemp->hasAfterDeathPowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerEntityInfo[22]);
		pTemp->hasAfterDeathPowers = 0;
		pTemp->hasDeadOrAlivePowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerEntityInfo[23]);
		pTemp->hasDeadOrAlivePowers = 0;
		pTemp->hasArcLimitedPowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerEntityInfo[24]);
		pTemp->hasArcLimitedPowers = 0;
		pTemp->hasControlPowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIPowerEntityInfo[25]);
		pTemp->hasControlPowers = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIRelativeLocList[];
#define TYPE_parse_AIRelativeLocList AIRelativeLocList
//Structparser.exe autogenerated ParseTable for struct AIRelativeLoc
#define TYPE_parse_AIRelativeLoc AIRelativeLoc
ParseTable parse_AIRelativeLoc[] =
{
	{ "AIRelativeLoc", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIRelativeLoc), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "entRef",			TOK_AUTOINT(AIRelativeLoc, entRef, 0), NULL },
	{ "range",			TOK_F32(AIRelativeLoc, range, 0), NULL },
	{ "list",			TOK_OPTIONALSTRUCT(AIRelativeLoc, list, parse_AIRelativeLocList) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIRelativeLoc()
{
	int iSize = sizeof(AIRelativeLoc);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIRelativeLoc, iSize, "AIRelativeLoc", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIRelativeLoc[];
#define TYPE_parse_AIRelativeLoc AIRelativeLoc
//Structparser.exe autogenerated ParseTable for struct AIRelativeLocList
#define TYPE_parse_AIRelativeLocList AIRelativeLocList
ParseTable parse_AIRelativeLocList[] =
{
	{ "AIRelativeLocList", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIRelativeLocList), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "locs",				TOK_STRUCT(AIRelativeLocList, locs, parse_AIRelativeLoc) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIRelativeLocList()
{
	int iSize = sizeof(AIRelativeLocList);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIRelativeLocList, iSize, "AIRelativeLocList", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIOfftickConfig[];
#define TYPE_parse_AIOfftickConfig AIOfftickConfig
//Structparser.exe autogenerated ParseTable for struct AIOfftickInstance
#define TYPE_parse_AIOfftickInstance AIOfftickInstance
ParseTable parse_AIOfftickInstance[] =
{
	{ "AIOfftickInstance", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIOfftickInstance), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "otc",				TOK_OPTIONALSTRUCT(AIOfftickInstance, otc, parse_AIOfftickConfig) },
	{ "executed",			TOK_AUTOINT(AIOfftickInstance, executed, 0), NULL },
	{ "executedThisCombat",	TOK_AUTOINT(AIOfftickInstance, executedThisCombat, 0), NULL },
	{ "executedThisTick",	TOK_AUTOINT(AIOfftickInstance, executedThisTick, 0), NULL },
	{ "initialized",		TOK_BIT, 0, 8, NULL},
	{ "activeFine",			TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIOfftickInstance()
{
	int iSize = sizeof(AIOfftickInstance);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIOfftickInstance, iSize, "AIOfftickInstance", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIOfftickInstance) + 7) / 4;
		AIOfftickInstance *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->initialized = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIOfftickInstance[6]);
		pTemp->initialized = 0;
		pTemp->activeFine = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIOfftickInstance[7]);
		pTemp->activeFine = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIOutOfCombatVars
#define TYPE_parse_AIOutOfCombatVars AIOutOfCombatVars
ParseTable parse_AIOutOfCombatVars[] =
{
	{ "AIOutOfCombatVars", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIOutOfCombatVars), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "resOOCTarget",		TOK_BIT, 0, 8, NULL},
	{ "healOOCTarget",		TOK_BIT, 0, 8, NULL},
	{ "buffOOCTarget",		TOK_BIT, 0, 8, NULL},
	{ "timeLastResed",		TOK_AUTOINT(AIOutOfCombatVars, timeLastResed, 0), NULL },
	{ "timeLastHealed",		TOK_AUTOINT(AIOutOfCombatVars, timeLastHealed, 0), NULL },
	{ "timeLastBuffed",		TOK_AUTOINT(AIOutOfCombatVars, timeLastBuffed, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIOutOfCombatVars()
{
	int iSize = sizeof(AIOutOfCombatVars);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIOutOfCombatVars, iSize, "AIOutOfCombatVars", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIOutOfCombatVars) + 7) / 4;
		AIOutOfCombatVars *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->resOOCTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIOutOfCombatVars[2]);
		pTemp->resOOCTarget = 0;
		pTemp->healOOCTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIOutOfCombatVars[3]);
		pTemp->healOOCTarget = 0;
		pTemp->buffOOCTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIOutOfCombatVars[4]);
		pTemp->buffOOCTarget = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIStanceConfigMod
#define TYPE_parse_AIStanceConfigMod AIStanceConfigMod
ParseTable parse_AIStanceConfigMod[] =
{
	{ "AIStanceConfigMod", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIStanceConfigMod), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "configMods",			TOK_INTARRAY(AIStanceConfigMod, configMods),  NULL},
	{ "powerConfigMods",	TOK_INTARRAY(AIStanceConfigMod, powerConfigMods),  NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIStanceConfigMod()
{
	int iSize = sizeof(AIStanceConfigMod);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIStanceConfigMod, iSize, "AIStanceConfigMod", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AIAutoCastPowers
#define TYPE_parse_AIAutoCastPowers AIAutoCastPowers
ParseTable parse_AIAutoCastPowers[] =
{
	{ "AIAutoCastPowers", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIAutoCastPowers), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "configModId",		TOK_AUTOINT(AIAutoCastPowers, configModId, 0), NULL },
	{ "powId",				TOK_AUTOINT(AIAutoCastPowers, powId, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIAutoCastPowers()
{
	int iSize = sizeof(AIAutoCastPowers);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIAutoCastPowers, iSize, "AIAutoCastPowers", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_FSMContext[];
#define TYPE_parse_FSMContext FSMContext
//Structparser.exe autogenerated ParseTable for struct AIOverrideFSM
#define TYPE_parse_AIOverrideFSM AIOverrideFSM
ParseTable parse_AIOverrideFSM[] =
{
	{ "AIOverrideFSM", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIOverrideFSM), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "fsmContext",		TOK_OPTIONALSTRUCT(AIOverrideFSM, fsmContext, parse_FSMContext) },
	{ "id",				TOK_AUTOINT(AIOverrideFSM, id, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AIOverrideFSM()
{
	int iSize = sizeof(AIOverrideFSM);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIOverrideFSM, iSize, "AIOverrideFSM", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AIConfig[];
#define TYPE_parse_AIConfig AIConfig
extern ParseTable parse_StructMod[];
#define TYPE_parse_StructMod StructMod
extern ParseTable parse_Entity[];
#define TYPE_parse_Entity Entity
extern ParseTable parse_AIStatusTableEntry[];
#define TYPE_parse_AIStatusTableEntry AIStatusTableEntry
extern ParseTable parse_AIStatusTableEntry[];
#define TYPE_parse_AIStatusTableEntry AIStatusTableEntry
extern ParseTable parse_AIDebugLocRating[];
#define TYPE_parse_AIDebugLocRating AIDebugLocRating
extern ParseTable parse_AIOutOfCombatVars[];
#define TYPE_parse_AIOutOfCombatVars AIOutOfCombatVars
extern ParseTable parse_AIVarsTime[];
#define TYPE_parse_AIVarsTime AIVarsTime
extern ParseTable parse_AITeam[];
#define TYPE_parse_AITeam AITeam
extern ParseTable parse_AITeamMember[];
#define TYPE_parse_AITeamMember AITeamMember
extern ParseTable parse_AITeam[];
#define TYPE_parse_AITeam AITeam
extern ParseTable parse_AITeamMember[];
#define TYPE_parse_AITeamMember AITeamMember
extern ParseTable parse_AIStatusTableEntry[];
#define TYPE_parse_AIStatusTableEntry AIStatusTableEntry
extern ParseTable parse_Entity[];
#define TYPE_parse_Entity Entity
extern ParseTable parse_AIJob[];
#define TYPE_parse_AIJob AIJob
extern ParseTable parse_AIPowerEntityInfo[];
#define TYPE_parse_AIPowerEntityInfo AIPowerEntityInfo
extern ParseTable parse_AIDebugLogEntry[];
#define TYPE_parse_AIDebugLogEntry AIDebugLogEntry
extern ParseTable parse_AIDebugWaypoint[];
#define TYPE_parse_AIDebugWaypoint AIDebugWaypoint
extern ParseTable parse_AIStanceConfigMod[];
#define TYPE_parse_AIStanceConfigMod AIStanceConfigMod
extern ParseTable parse_AIAutoCastPowers[];
#define TYPE_parse_AIAutoCastPowers AIAutoCastPowers
extern ParseTable parse_AIVolumeAvoidInfo[];
#define TYPE_parse_AIVolumeAvoidInfo AIVolumeAvoidInfo
extern ParseTable parse_AIVolumeSoftAvoidInfo[];
#define TYPE_parse_AIVolumeSoftAvoidInfo AIVolumeSoftAvoidInfo
extern ParseTable parse_AIVolumeAttractInfo[];
#define TYPE_parse_AIVolumeAttractInfo AIVolumeAttractInfo
extern ParseTable polyTable_ExprLocalData[];
extern ParseTable parse_AIDebugAnimState[];
#define TYPE_parse_AIDebugAnimState AIDebugAnimState
//Structparser.exe autogenerated ParseTable for struct AIVarsBase
#define TYPE_parse_AIVarsBase AIVarsBase
ParseTable parse_AIVarsBase[] =
{
	{ "AIVarsBase", 							TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIVarsBase), 0, NULL, 0, NULL },
	{ "{",									TOK_START, 0 },
	{ "config_use_accessor",				TOK_REFERENCE(AIVarsBase, config_use_accessor, 0, "AIConfig") },
	{ "localModifiedAiConfig",				TOK_OPTIONALSTRUCT(AIVarsBase, localModifiedAiConfig, parse_AIConfig) },
	{ "configMods",							TOK_STRUCT(AIVarsBase, configMods, parse_StructMod) },
	{ "lastThinkTick",						TOK_AUTOINT(AIVarsBase, lastThinkTick, 0), NULL },
	{ "thinkAcc",							TOK_AUTOINT(AIVarsBase, thinkAcc, 0), NULL },
	{ "proxEntsCount",						TOK_AUTOINT(AIVarsBase, proxEntsCount, 0), NULL },
	{ "proxEntsMaxCount",					TOK_AUTOINT(AIVarsBase, proxEntsMaxCount, 0), NULL },
	{ "awareRatio",							TOK_F32(AIVarsBase, awareRatio, 0), NULL },
	{ "awareRadius",						TOK_F32(AIVarsBase, awareRadius, 0), NULL },
	{ "aggroRadius",						TOK_F32(AIVarsBase, aggroRadius, 0), NULL },
	{ "proximityRadius",					TOK_F32(AIVarsBase, proximityRadius, 0), NULL },
	{ "baseDangerFactor",					TOK_F32(AIVarsBase, baseDangerFactor, 0), NULL },
	{ "totalTrackedDamage",					TOK_FIXED_ARRAY | TOK_F32_X, offsetof(AIVarsBase, totalTrackedDamage),  AI_NOTIFY_TYPE_TRACKED_COUNT, NULL },
	{ "attackTargetRef",					TOK_AUTOINT(AIVarsBase, attackTargetRef, 0), NULL },
	{ "attackTarget",						TOK_UNOWNED | TOK_OPTIONALSTRUCT(AIVarsBase, attackTargetMutable, parse_Entity) },
	{ "attackTargetDistSQR",				TOK_F32(AIVarsBase, attackTargetDistSQR, 0), NULL },
	{ "attackTargetStatus",					TOK_OPTIONALSTRUCT(AIVarsBase, attackTargetStatus, parse_AIStatusTableEntry) },
	{ "attackTargetStatusOld",				TOK_OPTIONALSTRUCT(AIVarsBase, attackTargetStatusOld, parse_AIStatusTableEntry) },
	{ "ratings",							TOK_STRUCT(AIVarsBase, ratings, parse_AIDebugLocRating) },
	{ "preferredTargetRef",					TOK_AUTOINT(AIVarsBase, preferredTargetRef, 0), NULL },
	{ "ooc",								TOK_EMBEDDEDSTRUCT(AIVarsBase, ooc, parse_AIOutOfCombatVars)},
	{ "spawnPos",							TOK_VEC3(AIVarsBase, spawnPos), NULL },
	{ "spawnRot",							TOK_QUATPYR(AIVarsBase, spawnRot), NULL },
	{ "spawnOffset",						TOK_VEC3(AIVarsBase, spawnOffset), NULL },
	{ "ambientPosition",					TOK_VEC3(AIVarsBase, ambientPosition), NULL },
	{ "leashState",							TOK_AUTOINT(AIVarsBase, leashState, 0), AILeashStateEnum },
	{ "time",								TOK_EMBEDDEDSTRUCT(AIVarsBase, time, parse_AIVarsTime)},
	{ "team",								TOK_OPTIONALSTRUCT(AIVarsBase, team, parse_AITeam) },
	{ "member",								TOK_OPTIONALSTRUCT(AIVarsBase, member, parse_AITeamMember) },
	{ "combatTeam",							TOK_OPTIONALSTRUCT(AIVarsBase, combatTeam, parse_AITeam) },
	{ "combatMember",						TOK_OPTIONALSTRUCT(AIVarsBase, combatMember, parse_AITeamMember) },
	{ "reinforceTarget",					TOK_AUTOINT(AIVarsBase, reinforceTarget, 0), NULL },
	{ "statusTable",						TOK_STRUCT(AIVarsBase, statusTable, parse_AIStatusTableEntry) },
	{ "attackerList",						TOK_UNOWNED | TOK_STRUCT(AIVarsBase, attackerListMutable, parse_Entity) },
	{ "aggroHistory",						TOK_FIXED_ARRAY | TOK_F32_X, offsetof(AIVarsBase, aggroHistory),  AI_MAX_AGGRO_HISTORY_LENGTH, NULL },
	{ "aggroHistoryIdx",					TOK_AUTOINT(AIVarsBase, aggroHistoryIdx, 0), NULL },
	{ "aggroBotheredAvg",					TOK_F32(AIVarsBase, aggroBotheredAvg, 0), NULL },
	{ "combatRunAwayCount",					TOK_AUTOINT(AIVarsBase, combatRunAwayCount, 0), NULL },
	{ "combatCurYVariance",					TOK_F32(AIVarsBase, combatCurYVariance, 0), NULL },
	{ "minGrievedHealthLevel",				TOK_F32(AIVarsBase, minGrievedHealthLevel, 0), NULL },
	{ "job",								TOK_OPTIONALSTRUCT(AIVarsBase, job, parse_AIJob) },
	{ "powers",								TOK_OPTIONALSTRUCT(AIVarsBase, powers, parse_AIPowerEntityInfo) },
	{ "powersModes",						TOK_INTARRAY(AIVarsBase, powersModes),  NULL},
	{ "logEntries",							TOK_STRUCT(AIVarsBase, logEntries, parse_AIDebugLogEntry) },
	{ "curLogEntry",						TOK_AUTOINT(AIVarsBase, curLogEntry, 0), NULL },
	{ "debugCurPath",						TOK_STRUCT(AIVarsBase, debugCurPath, parse_AIDebugWaypoint) },
	{ "debugCurWp",							TOK_AUTOINT(AIVarsBase, debugCurWp, 0), NULL },
	{ "timeDebugCurPathUpdated",			TOK_AUTOINT(AIVarsBase, timeDebugCurPathUpdated, 0), NULL },
	{ "lastShortcutCheckPos",				TOK_VEC3(AIVarsBase, lastShortcutCheckPos), NULL },
	{ "lastShortcutCheckTime",				TOK_AUTOINT(AIVarsBase, lastShortcutCheckTime, 0), NULL },
	{ "stanceConfigMods",					TOK_STRUCT(AIVarsBase, stanceConfigMods, parse_AIStanceConfigMod) },
	{ "stateConfigMods",					TOK_INTARRAY(AIVarsBase, stateConfigMods),  NULL},
	{ "autocastPowers",						TOK_STRUCT(AIVarsBase, autocastPowers, parse_AIAutoCastPowers) },
	{ "avoid",								TOK_EMBEDDEDSTRUCT(AIVarsBase, avoid, parse_AIVolumeAvoidInfo)},
	{ "softAvoid",							TOK_EMBEDDEDSTRUCT(AIVarsBase, softAvoid, parse_AIVolumeSoftAvoidInfo)},
	{ "attract",							TOK_EMBEDDEDSTRUCT(AIVarsBase, attract, parse_AIVolumeAttractInfo)},
	{ "minDynamicPrefRange",				TOK_F32(AIVarsBase, minDynamicPrefRange, 0), NULL },
	{ "maxDynamicPrefRange",				TOK_F32(AIVarsBase, maxDynamicPrefRange, 0), NULL },
	{ "leashType",							TOK_AUTOINT(AIVarsBase, leashType, 0), AILeashTypeEnum },
	{ "leashTypeOverride",					TOK_AUTOINT(AIVarsBase, leashTypeOverride, 0), AILeashTypeEnum },
	{ "erLeashEntity",						TOK_AUTOINT(AIVarsBase, erLeashEntity, 0), NULL },
	{ "rallyPosition",						TOK_VEC3(AIVarsBase, rallyPosition), NULL },
	{ "rallyPositionOverride",				TOK_VEC3(AIVarsBase, rallyPositionOverride), NULL },
	{ "coherencyCombatDistOverride",		TOK_F32(AIVarsBase, coherencyCombatDistOverride, 0), NULL },
	{ "CombatRole",							TOK_STRING(AIVarsBase, pchCombatRole, 0), NULL },
	{ "hConfigSpeedOverride",				TOK_AUTOINT(AIVarsBase, hConfigSpeedOverride, 0), NULL },
	{ "SharedAggroEnts",					TOK_INTARRAY(AIVarsBase, eaSharedAggroEnts),  NULL},
	{ "SeekTargets",						TOK_INTARRAY(AIVarsBase, eaSeekTargets),  NULL},
	{ "localData",							TOK_POLYMORPH(AIVarsBase, localData, polyTable_ExprLocalData) },
	{ "aidAnimState",						TOK_OPTIONALSTRUCT(AIVarsBase, aidAnimState, parse_AIDebugAnimState) },
	{ "vecTargetCombatJobPos",				TOK_VEC3(AIVarsBase, vecTargetCombatJobPos), NULL },
	{ "vecTargetPowersEntCreate",			TOK_VEC3(AIVarsBase, vecTargetPowersEntCreate), NULL },
	{ "uiRespawnApplyID",					TOK_AUTOINT(AIVarsBase, uiRespawnApplyID, 0), NULL },
	{ "lastRespawnTime",					TOK_AUTOINT(AIVarsBase, lastRespawnTime, 0), NULL },
	{ "uiRandomSeed",						TOK_AUTOINT(AIVarsBase, uiRandomSeed, 0), NULL },
	{ "destroying",							TOK_BIT, 0, 8, NULL},
	{ "settingAttackTarget",				TOK_BIT, 0, 8, NULL},
	{ "useDynamicPrefRange",				TOK_BIT, 0, 8, NULL},
	{ "doProximity",						TOK_BIT, 0, 8, NULL},
	{ "doBScript",							TOK_BIT, 0, 8, NULL},
	{ "doAttackAI",							TOK_BIT, 0, 8, NULL},
	{ "doDeathTick",						TOK_BIT, 0, 8, NULL},
	{ "disableAI",							TOK_BIT, 0, 8, NULL},
	{ "isNPC",								TOK_BIT, 0, 8, NULL},
	{ "behaviorRequestOffTickProcessing",	TOK_BIT, 0, 8, NULL},
	{ "overriddenCombat",					TOK_BIT, 0, 8, NULL},
	{ "currentlyMoving",					TOK_BIT, 0, 8, NULL},
	{ "leavingAvoid",						TOK_BIT, 0, 8, NULL},
	{ "dontSleep",							TOK_BIT, 0, 8, NULL},
	{ "sleeping",							TOK_BIT, 0, 8, NULL},
	{ "hadFirstTick",						TOK_BIT, 0, 8, NULL},
	{ "confused",							TOK_BIT, 0, 8, NULL},
	{ "grieved",							TOK_BIT, 0, 8, NULL},
	{ "wandering",							TOK_BIT, 0, 8, NULL},
	{ "inCombat",							TOK_BIT, 0, 8, NULL},
	{ "insideCombatFSM",					TOK_BIT, 0, 8, NULL},
	{ "noCombatMovementInCombatFSM",		TOK_BIT, 0, 8, NULL},
	{ "checkedSpawnBeacon",					TOK_BIT, 0, 8, NULL},
	{ "healing",							TOK_BIT, 0, 8, NULL},
	{ "isHostileToCivilians",				TOK_BIT, 0, 8, NULL},
	{ "failedToLeash",						TOK_BIT, 0, 8, NULL},
	{ "debugPath",							TOK_BIT, 0, 8, NULL},
	{ "skipOnEntry",						TOK_BIT, 0, 8, NULL},
	{ "targetListen",						TOK_BIT, 0, 8, NULL},
	{ "determinedSpawnPoint",				TOK_BIT, 0, 8, NULL},
	{ "calculatedSpawnOffset",				TOK_BIT, 0, 8, NULL},
	{ "spawnOffsetDirtied",					TOK_BIT, 0, 8, NULL},
	{ "hitProxEntsCivCap",					TOK_BIT, 0, 8, NULL},
	{ "forceThinkTick",						TOK_BIT, 0, 8, NULL},
	{ "preferredTargetIsEnemy",				TOK_BIT, 0, 8, NULL},
	{ "isSummonedAndExpires",				TOK_BIT, 0, 8, NULL},
	{ "untargetable",						TOK_BIT, 0, 8, NULL},
	{ "combatRolesDirty",					TOK_BIT, 0, 8, NULL},
	{ "ambientJobFSMDone",					TOK_BIT, 0, 8, NULL},
	{ "disableAmbientTether",				TOK_BIT, 0, 8, NULL},
	{ "lastAttackActionAllowedMovement",	TOK_BIT, 0, 8, NULL},
	{ "thinkTickDebugged",					TOK_BIT, 0, 8, NULL},
	{ "insideCombatJobFSM",					TOK_BIT, 0, 8, NULL},
	{ "noCombatMovementInCombatJobFSM",		TOK_BIT, 0, 8, NULL},
	{ "movingToCombatJob",					TOK_BIT, 0, 8, NULL},
	{ "movementOrderGivenForCombatJob",		TOK_BIT, 0, 8, NULL},
	{ "reachedCombatJob",					TOK_BIT, 0, 8, NULL},
	{ "combatJobFSMDone",					TOK_BIT, 0, 8, NULL},
	{ "encounterJobFSMDone",				TOK_BIT, 0, 8, NULL},
	{ "chainPowerExecutionActive",			TOK_BIT, 0, 8, NULL},
	{ "chainLockedFacing",					TOK_BIT, 0, 8, NULL},
	{ "chainLockedMovement",				TOK_BIT, 0, 8, NULL},
	{ "}",									TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIVarsBase()
{
	int iSize = sizeof(AIVarsBase);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIVarsBase, iSize, "AIVarsBase", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIVarsBase) + 7) / 4;
		AIVarsBase *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->destroying = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[77]);
		pTemp->destroying = 0;
		pTemp->settingAttackTarget = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[78]);
		pTemp->settingAttackTarget = 0;
		pTemp->useDynamicPrefRange = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[79]);
		pTemp->useDynamicPrefRange = 0;
		pTemp->doProximity = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[80]);
		pTemp->doProximity = 0;
		pTemp->doBScript = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[81]);
		pTemp->doBScript = 0;
		pTemp->doAttackAI = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[82]);
		pTemp->doAttackAI = 0;
		pTemp->doDeathTick = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[83]);
		pTemp->doDeathTick = 0;
		pTemp->disableAI = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[84]);
		pTemp->disableAI = 0;
		pTemp->isNPC = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[85]);
		pTemp->isNPC = 0;
		pTemp->behaviorRequestOffTickProcessing = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[86]);
		pTemp->behaviorRequestOffTickProcessing = 0;
		pTemp->overriddenCombat = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[87]);
		pTemp->overriddenCombat = 0;
		pTemp->currentlyMoving = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[88]);
		pTemp->currentlyMoving = 0;
		pTemp->leavingAvoid = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[89]);
		pTemp->leavingAvoid = 0;
		pTemp->dontSleep = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[90]);
		pTemp->dontSleep = 0;
		pTemp->sleeping = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[91]);
		pTemp->sleeping = 0;
		pTemp->hadFirstTick = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[92]);
		pTemp->hadFirstTick = 0;
		pTemp->confused = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[93]);
		pTemp->confused = 0;
		pTemp->grieved = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[94]);
		pTemp->grieved = 0;
		pTemp->wandering = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[95]);
		pTemp->wandering = 0;
		pTemp->inCombat = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[96]);
		pTemp->inCombat = 0;
		pTemp->insideCombatFSM = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[97]);
		pTemp->insideCombatFSM = 0;
		pTemp->noCombatMovementInCombatFSM = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[98]);
		pTemp->noCombatMovementInCombatFSM = 0;
		pTemp->checkedSpawnBeacon = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[99]);
		pTemp->checkedSpawnBeacon = 0;
		pTemp->healing = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[100]);
		pTemp->healing = 0;
		pTemp->isHostileToCivilians = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[101]);
		pTemp->isHostileToCivilians = 0;
		pTemp->failedToLeash = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[102]);
		pTemp->failedToLeash = 0;
		pTemp->debugPath = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[103]);
		pTemp->debugPath = 0;
		pTemp->skipOnEntry = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[104]);
		pTemp->skipOnEntry = 0;
		pTemp->targetListen = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[105]);
		pTemp->targetListen = 0;
		pTemp->determinedSpawnPoint = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[106]);
		pTemp->determinedSpawnPoint = 0;
		pTemp->calculatedSpawnOffset = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[107]);
		pTemp->calculatedSpawnOffset = 0;
		pTemp->spawnOffsetDirtied = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[108]);
		pTemp->spawnOffsetDirtied = 0;
		pTemp->hitProxEntsCivCap = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[109]);
		pTemp->hitProxEntsCivCap = 0;
		pTemp->forceThinkTick = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[110]);
		pTemp->forceThinkTick = 0;
		pTemp->preferredTargetIsEnemy = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[111]);
		pTemp->preferredTargetIsEnemy = 0;
		pTemp->isSummonedAndExpires = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[112]);
		pTemp->isSummonedAndExpires = 0;
		pTemp->untargetable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[113]);
		pTemp->untargetable = 0;
		pTemp->combatRolesDirty = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[114]);
		pTemp->combatRolesDirty = 0;
		pTemp->ambientJobFSMDone = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[115]);
		pTemp->ambientJobFSMDone = 0;
		pTemp->disableAmbientTether = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[116]);
		pTemp->disableAmbientTether = 0;
		pTemp->lastAttackActionAllowedMovement = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[117]);
		pTemp->lastAttackActionAllowedMovement = 0;
		pTemp->thinkTickDebugged = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[118]);
		pTemp->thinkTickDebugged = 0;
		pTemp->insideCombatJobFSM = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[119]);
		pTemp->insideCombatJobFSM = 0;
		pTemp->noCombatMovementInCombatJobFSM = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[120]);
		pTemp->noCombatMovementInCombatJobFSM = 0;
		pTemp->movingToCombatJob = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[121]);
		pTemp->movingToCombatJob = 0;
		pTemp->movementOrderGivenForCombatJob = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[122]);
		pTemp->movementOrderGivenForCombatJob = 0;
		pTemp->reachedCombatJob = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[123]);
		pTemp->reachedCombatJob = 0;
		pTemp->combatJobFSMDone = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[124]);
		pTemp->combatJobFSMDone = 0;
		pTemp->encounterJobFSMDone = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[125]);
		pTemp->encounterJobFSMDone = 0;
		pTemp->chainPowerExecutionActive = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[126]);
		pTemp->chainPowerExecutionActive = 0;
		pTemp->chainLockedFacing = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[127]);
		pTemp->chainLockedFacing = 0;
		pTemp->chainLockedMovement = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIVarsBase[128]);
		pTemp->chainLockedMovement = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CombatPositionSlot
#define TYPE_parse_CombatPositionSlot CombatPositionSlot
ParseTable parse_CombatPositionSlot[] =
{
	{ "CombatPositionSlot", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CombatPositionSlot), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "XOffset",			TOK_F32(CombatPositionSlot, fXOffset, 0), NULL },
	{ "ZOffset",			TOK_F32(CombatPositionSlot, fZOffset, 0), NULL },
	{ "Radius",				TOK_F32(CombatPositionSlot, fRadius, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CombatPositionSlot()
{
	int iSize = sizeof(CombatPositionSlot);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CombatPositionSlot, iSize, "CombatPositionSlot", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_BrawlerCombatGlobalConfig[];
#define TYPE_parse_BrawlerCombatGlobalConfig BrawlerCombatGlobalConfig
extern ParseTable parse_CombatPositionSlot[];
#define TYPE_parse_CombatPositionSlot CombatPositionSlot
//Structparser.exe autogenerated ParseTable for struct AIGlobalSettings
#define TYPE_parse_AIGlobalSettings AIGlobalSettings
ParseTable parse_AIGlobalSettings[] =
{
	{ "AIGlobalSettings", 							TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AIGlobalSettings), 0, NULL, 0, NULL },
	{ "{",											TOK_START, 0 },
	{ "reinforce2",									TOK_F32(AIGlobalSettings, reinforceLevels[0], 0), NULL },
	{ "reinforce3",									TOK_F32(AIGlobalSettings, reinforceLevels[1], 0), NULL },
	{ "reinforce4",									TOK_F32(AIGlobalSettings, reinforceLevels[2], 0), NULL },
	{ "reinforce5",									TOK_F32(AIGlobalSettings, reinforceLevels[3], 0), NULL },
	{ "reinforceTeamDist",							TOK_F32(AIGlobalSettings, reinforceTeamDist, 0), NULL },
	{ "leashHealRate",								TOK_F32(AIGlobalSettings, leashHealRate, 0), NULL },
	{ "DEPRECATED_meleeCombatMovementDistance",		TOK_F32(AIGlobalSettings, DEPRECATED_meleeCombatMovementDistance, 0), NULL },
	{ "meleeCombatMovementDistance",				TOK_REDUNDANTNAME | TOK_F32(AIGlobalSettings, DEPRECATED_meleeCombatMovementDistance, 0), NULL },
	{ "forceMeleeCombatMovement",					TOK_BIT, 0, 8, NULL},
	{ "forceFiveFootMeleeRange",					TOK_REDUNDANTNAME | TOK_BIT, 0, 8, NULL},
	{ "forceMeleeCombatMovementThreshold",			TOK_F32(AIGlobalSettings, forceMeleeCombatMovementThreshold, 5), NULL },
	{ "meleeMaximumDistance",						TOK_F32(AIGlobalSettings, meleeMaximumDistance, 10), NULL },
	{ "combatRoleFormationOverrideMovespeed",		TOK_F32(AIGlobalSettings, combatRoleFormationOverrideMovespeed, 0), NULL },
	{ "dynPrefRange_powerRechargeTimeThreshold",	TOK_F32(AIGlobalSettings, dynPrefRange_powerRechargeTimeThreshold, 5), NULL },
	{ "IgnorePlayerAtSpawnTimeout",					TOK_AUTOINT(AIGlobalSettings, iIgnorePlayerAtSpawnTimeout, 10), NULL },
	{ "useAggroExprFile",							TOK_AUTOINT(AIGlobalSettings, useAggroExprFile, 0), NULL },
	{ "AIAmbientDefaults",							TOK_STRING(AIGlobalSettings, aiAmbientDefaults, "Default"), NULL },
	{ "AICombatJobDefaults",						TOK_STRING(AIGlobalSettings, aiCombatJobDefaults, "Default"), NULL },
	{ "AIGroupCombatDefaults:",						TOK_STRING(AIGlobalSettings, aiGroupCombatDefaults, 0), NULL },
	{ "DefaultPlayerAIConfig:",						TOK_STRING(AIGlobalSettings, pchDefaultPlayerAIConfig, 0), NULL },
	{ "StealthReactAnimList:",						TOK_STRING(AIGlobalSettings, pchStealthReactAnimList, 0), NULL },
	{ "BrawlerConfig",								TOK_OPTIONALSTRUCT(AIGlobalSettings, pBrawlerConfig, parse_BrawlerCombatGlobalConfig) },
	{ "CombatPositionSlot",							TOK_STRUCT(AIGlobalSettings, eaCombatPositionSlots, parse_CombatPositionSlot) },
	{ "OccupancyCheckSensitivity",					TOK_F32(AIGlobalSettings, fCombatPositionOccupancyCheckSensitivity, 0), NULL },
	{ "CombatAngleGranularity",						TOK_AUTOINT(AIGlobalSettings, iCombatAngleGranularity, 10), NULL },
	{ "CombatPositionRangeSensitivity",				TOK_F32(AIGlobalSettings, fCombatPositionRangeSensitivity, 30), NULL },
	{ "AggroIgnoreLevelDelta",						TOK_AUTOINT(AIGlobalSettings, iAggroIgnoreLevelDelta, 5), NULL },
	{ "CombatInactionFaceTargetTime",				TOK_F32(AIGlobalSettings, fCombatInactionFaceTargetTime, 3), NULL },
	{ "useAggro2",									TOK_BIT, 0, 8, NULL},
	{ "leashDontClearMods",							TOK_BIT, 0, 8, NULL},
	{ "leashDontRechargePowers",					TOK_BIT, 0, 8, NULL},
	{ "leashDontRemoveStatusEffects",				TOK_BIT, 0, 8, NULL},
	{ "forceReinforcement",							TOK_BIT, 0, 8, NULL},
	{ "disableLeashMessage",						TOK_BIT, 0, 8, NULL},
	{ "disableLeashingOnNonStaticMaps",				TOK_BIT, 0, 8, NULL},
	{ "disableOverageAggro",						TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "globalRechargeFromStart",					TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "disableInfraTickPowerUsage",					TOK_BIT, 0, 8, NULL},
	{ "disableOnExecutePowerUsage",					TOK_BIT, 0, 8, NULL},
	{ "overrideOnExecutePowerUsageForPlayerPets",	TOK_BIT, 0, 8, NULL},
	{ "allowPowersWithoutConfigs",					TOK_BIT, 0, 8, NULL},
	{ "enableCombatTeams",							TOK_BIT, 0, 8, NULL},
	{ "enableSocialAggroPulse",						TOK_BIT, 0, 8, NULL},
	{ "aggroOnPerceptionStealth",					TOK_BIT, 0, 8, NULL},
	{ "untargetableOnLeash",						TOK_BIT, 0, 8, NULL},
	{ "unselectableOnLeash",						TOK_BIT, 0, 8, NULL},
	{ "selfHealingCountsAsAggro",					TOK_BIT, 0, 8, NULL},
	{ "useFCRPowerTiming",							TOK_BIT, 0, 8, NULL},
	{ "useCombatRoleDamageSharing",					TOK_BIT, 0, 8, NULL},
	{ "stealthAffectsOutOfFOVRange",				TOK_BIT, 0, 8, NULL},
	{ "combatFSMKeepsInCombat",						TOK_BIT, 0, 8, NULL},
	{ "dontAutoLegalTargetTeammates",				TOK_BIT, 0, 8, NULL},
	{ "alwaysUseSpawnAggroDelay",					TOK_BIT, 0, 8, NULL},
	{ "untargetableIsTreatedNotVisible",			TOK_BIT, 0, 8, NULL},
	{ "}",											TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AIGlobalSettings()
{
	int iSize = sizeof(AIGlobalSettings);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AIGlobalSettings, iSize, "AIGlobalSettings", NULL, "aiStruct.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AIGlobalSettings) + 7) / 4;
		AIGlobalSettings *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->forceMeleeCombatMovement = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[10]);
		pTemp->forceMeleeCombatMovement = 0;
		pTemp->forceMeleeCombatMovement = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[11]);
		pTemp->forceMeleeCombatMovement = 0;
		pTemp->useAggro2 = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[30]);
		pTemp->useAggro2 = 0;
		pTemp->leashDontClearMods = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[31]);
		pTemp->leashDontClearMods = 0;
		pTemp->leashDontRechargePowers = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[32]);
		pTemp->leashDontRechargePowers = 0;
		pTemp->leashDontRemoveStatusEffects = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[33]);
		pTemp->leashDontRemoveStatusEffects = 0;
		pTemp->forceReinforcement = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[34]);
		pTemp->forceReinforcement = 0;
		pTemp->disableLeashMessage = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[35]);
		pTemp->disableLeashMessage = 0;
		pTemp->disableLeashingOnNonStaticMaps = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[36]);
		pTemp->disableLeashingOnNonStaticMaps = 0;
		pTemp->disableOverageAggro = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[37]);
		pTemp->disableOverageAggro = 0;
		pTemp->globalRechargeFromStart = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[38]);
		pTemp->globalRechargeFromStart = 0;
		pTemp->disableInfraTickPowerUsage = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[39]);
		pTemp->disableInfraTickPowerUsage = 0;
		pTemp->disableOnExecutePowerUsage = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[40]);
		pTemp->disableOnExecutePowerUsage = 0;
		pTemp->overrideOnExecutePowerUsageForPlayerPets = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[41]);
		pTemp->overrideOnExecutePowerUsageForPlayerPets = 0;
		pTemp->allowPowersWithoutConfigs = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[42]);
		pTemp->allowPowersWithoutConfigs = 0;
		pTemp->enableCombatTeams = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[43]);
		pTemp->enableCombatTeams = 0;
		pTemp->enableSocialAggroPulse = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[44]);
		pTemp->enableSocialAggroPulse = 0;
		pTemp->aggroOnPerceptionStealth = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[45]);
		pTemp->aggroOnPerceptionStealth = 0;
		pTemp->untargetableOnLeash = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[46]);
		pTemp->untargetableOnLeash = 0;
		pTemp->unselectableOnLeash = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[47]);
		pTemp->unselectableOnLeash = 0;
		pTemp->selfHealingCountsAsAggro = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[48]);
		pTemp->selfHealingCountsAsAggro = 0;
		pTemp->useFCRPowerTiming = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[49]);
		pTemp->useFCRPowerTiming = 0;
		pTemp->useCombatRoleDamageSharing = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[50]);
		pTemp->useCombatRoleDamageSharing = 0;
		pTemp->stealthAffectsOutOfFOVRange = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[51]);
		pTemp->stealthAffectsOutOfFOVRange = 0;
		pTemp->combatFSMKeepsInCombat = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[52]);
		pTemp->combatFSMKeepsInCombat = 0;
		pTemp->dontAutoLegalTargetTeammates = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[53]);
		pTemp->dontAutoLegalTargetTeammates = 0;
		pTemp->alwaysUseSpawnAggroDelay = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[54]);
		pTemp->alwaysUseSpawnAggroDelay = 0;
		pTemp->untargetableIsTreatedNotVisible = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AIGlobalSettings[55]);
		pTemp->untargetableIsTreatedNotVisible = 0;
	}
	parse_AIGlobalSettings[12].param = GET_INTPTR_FROM_FLOAT((float)5);
	parse_AIGlobalSettings[13].param = GET_INTPTR_FROM_FLOAT((float)10);
	parse_AIGlobalSettings[15].param = GET_INTPTR_FROM_FLOAT((float)5);
	parse_AIGlobalSettings[27].param = GET_INTPTR_FROM_FLOAT((float)30);
	parse_AIGlobalSettings[29].param = GET_INTPTR_FROM_FLOAT((float)3);
	return 0;
};
