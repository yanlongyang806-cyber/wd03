#include "textparser.h"

//auto-generated staticdefine for enum NavPathConnectType
//autogeneratednocheckin
StaticDefineInt NavPathConnectTypeEnum[] =
{
	DEFINE_INT
	{ "GROUND", NAVPATH_CONNECT_GROUND},
	{ "JUMP", NAVPATH_CONNECT_JUMP},
	{ "FLY", NAVPATH_CONNECT_FLY},
	{ "WIRE", NAVPATH_CONNECT_WIRE},
	{ "ENTERABLE", NAVPATH_CONNECT_ENTERABLE},
	{ "ATTEMPT_SHORTCUT", NAVPATH_CONNECT_ATTEMPT_SHORTCUT},
	{ "COUNT", NAVPATH_CONNECT_COUNT},
	DEFINE_END
};
void autoEnum_fixup_NavPathConnectType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(NavPathConnectTypeEnum, "NavPathConnectType");
}

//auto-generated staticdefine for enum NavSearchResultType
//autogeneratednocheckin
StaticDefineInt NavSearchResultTypeEnum[] =
{
	DEFINE_INT
	{ "CONTINUE", NAV_RESULT_CONTINUE},
	{ "BAD_POSITIONS", NAV_RESULT_BAD_POSITIONS},
	{ "NO_SOURCE_BEACON", NAV_RESULT_NO_SOURCE_BEACON},
	{ "NO_TARGET_BEACON", NAV_RESULT_NO_TARGET_BEACON},
	{ "TARGET_UNREACHABLE", NAV_RESULT_TARGET_UNREACHABLE},
	{ "BLOCK_ERROR", NAV_RESULT_BLOCK_ERROR},
	{ "NO_BLOCK_PATH", NAV_RESULT_NO_BLOCK_PATH},
	{ "NO_BEACON_PATH", NAV_RESULT_NO_BEACON_PATH},
	{ "TIMEOUT", NAV_RESULT_TIMEOUT},
	{ "CLUSTER_CONN_BLOCKED", NAV_RESULT_CLUSTER_CONN_BLOCKED},
	{ "SUCCESS", NAV_RESULT_SUCCESS},
	{ "PARTIAL", NAV_RESULT_PARTIAL},
	DEFINE_END
};
void autoEnum_fixup_NavSearchResultType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(NavSearchResultTypeEnum, "NavSearchResultType");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct NavPathWaypoint
#define TYPE_parse_NavPathWaypoint NavPathWaypoint
ParseTable parse_NavPathWaypoint[] =
{
	{ "NavPathWaypoint", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(NavPathWaypoint), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "pos",				TOK_VEC3(NavPathWaypoint, pos), NULL },
	{ "lastFailPos",		TOK_VEC3(NavPathWaypoint, lastFailPos), NULL },
	{ "lastDirToPos",		TOK_VEC3(NavPathWaypoint, lastDirToPos), NULL },
	{ "connectType",		TOK_AUTOINT(NavPathWaypoint, connectType, 0), NavPathConnectTypeEnum },
	{ "keepWaypoint",		TOK_BIT, 0, 8, NULL},
	{ "dontShortcut",		TOK_BIT, 0, 8, NULL},
	{ "gotStuck",			TOK_BIT, 0, 8, NULL},
	{ "jumped",				TOK_BIT, 0, 8, NULL},
	{ "attempted",			TOK_BIT, 0, 8, NULL},
	{ "requestedRefine",	TOK_BIT, 0, 8, NULL},
	{ "targetWp",			TOK_BIT, 0, 8, NULL},
	{ "avoiding",			TOK_BIT, 0, 8, NULL},
	{ "attemptedShortcut",	TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_NavPathWaypoint()
{
	int iSize = sizeof(NavPathWaypoint);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_NavPathWaypoint, iSize, "NavPathWaypoint", NULL, "beaconPath.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NavPathWaypoint) + 7) / 4;
		NavPathWaypoint *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->keepWaypoint = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_NavPathWaypoint[6]);
		pTemp->keepWaypoint = 0;
		pTemp->dontShortcut = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_NavPathWaypoint[7]);
		pTemp->dontShortcut = 0;
		pTemp->gotStuck = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_NavPathWaypoint[8]);
		pTemp->gotStuck = 0;
		pTemp->jumped = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_NavPathWaypoint[9]);
		pTemp->jumped = 0;
		pTemp->attempted = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_NavPathWaypoint[10]);
		pTemp->attempted = 0;
		pTemp->requestedRefine = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_NavPathWaypoint[11]);
		pTemp->requestedRefine = 0;
		pTemp->targetWp = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_NavPathWaypoint[12]);
		pTemp->targetWp = 0;
		pTemp->avoiding = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_NavPathWaypoint[13]);
		pTemp->avoiding = 0;
		pTemp->attemptedShortcut = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_NavPathWaypoint[14]);
		pTemp->attemptedShortcut = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_NavPathWaypoint[];
#define TYPE_parse_NavPathWaypoint NavPathWaypoint
//Structparser.exe autogenerated ParseTable for struct NavPath
#define TYPE_parse_NavPath NavPath
ParseTable parse_NavPath[] =
{
	{ "NavPath", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(NavPath), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "waypoints",		TOK_STRUCT(NavPath, waypoints, parse_NavPathWaypoint) },
	{ "curWaypoint",	TOK_AUTOINT(NavPath, curWaypoint, 0), NULL },
	{ "circular",		TOK_BIT, 0, 8, NULL},
	{ "pingpong",		TOK_BIT, 0, 8, NULL},
	{ "pingpongRev",	TOK_BIT, 0, 8, NULL},
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_NavPath()
{
	int iSize = sizeof(NavPath);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_NavPath, iSize, "NavPath", NULL, "beaconPath.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NavPath) + 7) / 4;
		NavPath *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->circular = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_NavPath[4]);
		pTemp->circular = 0;
		pTemp->pingpong = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_NavPath[5]);
		pTemp->pingpong = 0;
		pTemp->pingpongRev = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_NavPath[6]);
		pTemp->pingpongRev = 0;
	}
	return 0;
};
