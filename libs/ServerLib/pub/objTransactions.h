/***************************************************************************



***************************************************************************/

#ifndef OBJTRANSACTIONS_H_
#define OBJTRANSACTIONS_H_

// This implements a transaction manager that handles object operations

#include "GlobalTypeEnum.h"
#include "LocalTransactionManager.h"
#include "cmdparse.h"
#include "objPath.h"
#include "referencesystem.h"

typedef struct Container Container;
typedef struct LocalTransactionManager LocalTransactionManager;
typedef struct TransactionCommand TransactionCommand;
typedef struct ObjectTransactionManager ObjectTransactionManager;
typedef struct ContainerLock ContainerLock;
typedef struct ContainerBackup ContainerBackup;
typedef struct ContainerSchema ContainerSchema;
typedef struct LocalContainerInfo LocalContainerInfo;
typedef struct LocalContainerInfoCache LocalContainerInfoCache;
typedef struct ObjectIndexHeader ObjectIndexHeader;

#define TRVAR_ARG_SIZE 10

#define OBJ_TRANS_CONTAINER_DOES_NOT_EXIST "Container does not exist"

// Possible states for a Transaction Command to be in
typedef enum
{	
	TRANSTATE_UNKNOWN, //Either yet to be parsed, or already completed. It will go away
	TRANSTATE_PARSED, //we found out if we could run
	TRANSTATE_INVALID, //Was found to be invalid before it could run
	TRANSTATE_ALLOWED, //We were allowed to do this
	TRANSTATE_DISALLOWED, //We were not allowed to do this
	TRANSTATE_BLOCKED, //Something we want to lock is already locked
	TRANSTATE_LOCKED, //We're locked but haven't started execution yet
	TRANSTATE_WAITING, //Waiting for some other thing to happen, check up on it periodically
	TRANSTATE_EXECUTED, //We executed, but haven't confirmed
	TRANSTATE_FAILED, //Attempted to execute, but failed.
	TRANSTATE_COMMITTED, //We executed and confirmed. We're done.
	TRANSTATE_REVERTED, //Found invalid after running, must undo
} TransactionCommandState;


typedef int (*TransactionCommandCB)(TransactionCommand *command);

// Holds all the data a TransactionCommand needs to run. This gets passed in as the userdata of a CmdContext
typedef struct TransactionCommand
{
	// The CmdParse command this was created by
	Cmd *parseCommand;

	// Current state
	TransactionCommandState commandState;

	// Are we seeing if it's possible?
	bool bCheckingIfPossible:1; 

	// Is this command being executed as locked?
	bool bIsLocked:1;

	// Does this command need to be locked in order to be executed?
	bool bLockRequired:1;

	// Is this transaction a remote command?
	bool bRemoteCommand:1;

	// Is this transaction slow?
	bool bSlowTransaction:1; 

	// when committing this transaction, use the backup container rather than the diff string, if possible
	// (presumably only true for character creation
	bool bUseBackupContainerWhenCommitting:1;

	// TRUE for transactions executed on server not connected to a Shard's Transaction Server
	// eg. a Fully Local server like Account Server, Global Chat Server
	bool bShardExternalCommand:1;



	// The transaction ID assocaited with this command
	U32 transactionID;

	// What transaction ID, if any, that is causing this to be blocked
	U32 blockingTransactionID;


	// Name for this transaction, used in logging
	const char *pTransactionName;
	U64 transactionTime;
	int iBytesIn;
	int iBytesOut;


	// The slow transaction this is associated with, if any
	LTMSlowTransactionID slowTransactionID; 


	// Usefully-named places to store parsed data
	GlobalType objectType;
	ContainerID objectID;
	GlobalType sourceType;
	ContainerID sourceID;
	GlobalType destType;
	ContainerID destID;

	//if this is an AUTO_TRANS, type/ID of the server where the transaction will be executed
	GlobalType autoTransExecutionServerType;
	ContainerID autoTransExecutionServerID;

	// Names of transaction variables being used... all EStrings
	char *pTransVarName1;
	char *pTransVarName2;
	char *pTransVarName3;
	char *pTransVarName4;
	char *pTransVarName5;
	char *pTransVarName6;
	char *pTransVarName7;
	char *pTransVarName8;
	
	// Arbitrary string data, commonly useful
	char *stringData;

	// Fields involved in this transaction
	ObjectPathOperation **fieldEntries;

	// Strings used to return info to the transaction system
	char **returnString;
	TransDataBlock *pDatabaseReturnData;
	char **transReturnString;

	char *slowReturnString;
	TransDataBlock slowDatabaseReturnData;
	char *slowTransReturnString;

	// String containing the diff generated by this command, which is sent to the db
	char *diffString;

	// Callbacks for the different phases of execution
	TransactionCommandCB executeCB;
	TransactionCommandCB checkLockCB;
	TransactionCommandCB lockCB;
	TransactionCommandCB commitCB;
	TransactionCommandCB revertCB;
	TransactionCommandCB slowCB;

	// Specific data
	void *userData;

	//a reference-counted shared structure, not always set
	LocalContainerInfoCache *pLocalContainerInfoCache;
} TransactionCommand;

// Structure defining the mapping between the Transaction and Object systems
typedef struct ObjectTransactionManager
{
	// The LTM for this mapping
	LocalTransactionManager *localManager;

	//Hold slow transactions
	StashTable slowTransactions;
	
	// The storage for locks
	StashTable lockTables[GLOBALTYPE_MAXTYPES];

	// The storage for backups
	StashTable backupTables[GLOBALTYPE_MAXTYPES];

	//The type of this server
	GlobalType serverType; 
	
	//The ID for this server.
	U32 serverID;

} ObjectTransactionManager;

extern ObjectTransactionManager gObjectTransactionManager;
// NOTE: accessing the following members of gObjectTransactionManager requires using a critical section.
// At the moment, access to these members is limited to objLocks.c, so the critical section is defined and scoped to there.

// gObjectTransactionManager.lockTables
// gObjectTransactionManager.backupTables


// Returns the global type of this server
GlobalType objServerType(void);

// Returns the Global ID of this server
ContainerID objServerID(void);

// Returns the LocalTransactionManager
LocalTransactionManager *objLocalManager(void);

// Creates a new ObjectTransactionManager and connect to the TransactionServer
#define InitObjectTransactionManager(serverType, serverID, hostName, hostPort, useMultiPlex, ppErrorString) InitObjectTransactionManagerEx(serverType, serverID, hostName, hostPort, useMultiPlex, ppErrorString, NULL)
bool InitObjectTransactionManagerEx(GlobalType serverType, U32 serverID, char * hostName, int hostPort, bool useMultiPlex, char **ppErrorString, PacketCallback *pPacketCB);
bool InitObjectLocalTransactionManager(GlobalType serverType, char **ppErrorString);

// Tick update function for the manager
void UpdateObjectTransactionManager(void);

// Destroys a manager when done
void objShutdownTransactions(void);

// Request a really simple one line transaction
void objRequestTransactionSimple(TransactionReturnVal* returnStruct, GlobalType destinationType, U32 destinationID, const char *pTransactionName, const char *transactionString);
void objRequestTransactionSimplef(TransactionReturnVal* returnStruct, GlobalType destinationType, U32 destinationID, const char *pTransactionName, FORMAT_STR const char *transactionString, ...);
#define objRequestTransactionSimplef(returnStruct, destinationType, destinationID, pTransactionName, transactionString, ...) \
	objRequestTransactionSimplef(returnStruct, destinationType, destinationID, pTransactionName, FORMAT_STRING_CHECKED(transactionString), __VA_ARGS__)

// Request transactions using a TransactionRequest object
TransactionRequest *objCreateTransactionRequest(void);
void objDestroyTransactionRequest(TransactionRequest *pRequest);
void objAddToTransactionRequest(TransactionRequest *request, GlobalType destinationType, U32 destinationID,
								 const char *transactionVariableList, const char *transactionString);
void objAddToTransactionRequestf(TransactionRequest *request, GlobalType destinationType, U32 destinationID,
								  const char *transactionVariableList, FORMAT_STR const char *transactionString, ...);
void objAddToAutoTransactionRequestf(TransactionRequest *request, GlobalType destinationType, U32 destinationID,
								  char *transactionVariableList, const char *transactionString, ...);
int objRequestTransaction(TransactionReturnVal* returnStruct, char *pTransactionName, TransactionRequest *request);
int objRequestTransaction_Flagged(enumTransactionType type, TransactionReturnVal* returnStruct, char *pTransactionName, TransactionRequest *request);

// Auto transaction support
//
//if pTransactionRequest_In is set, then append lines to it and do not actually call the transaction. If it's NULL,
//build one internally and call it
int objRequestAutoTransaction(TransactionRequest *pTransactionRequest_In, TransactionReturnVal* returnStruct, GlobalType eServerTypeToRunOn, ContainerID iServerIDToRunOn, const char *query);
int objRequestAutoTransactionf(TransactionRequest *pTransactionRequest_In, TransactionReturnVal* returnStruct, GlobalType eServerTypeToRunOn, ContainerID iServerIDToRunOn, FORMAT_STR const char *query, ...);

//requests the transaction next time through the main loop... can be called from weird places like transaction commit callbacks
int objRequestAutoTransactionDeferred(TransactionReturnVal* returnStruct, GlobalType eServerTypeToRunOn, ContainerID iServerIDToRunOn, const char *query);


// Request moving a container from one server to another
void objRequestContainerMove(TransactionReturnVal *returnVal, GlobalType containerType, ContainerID containerID, GlobalType sourceType, ContainerID sourceID, GlobalType destType, ContainerID destID);

// Request creation of a new container, with a copy of the data passed in
void objRequestContainerCreate(TransactionReturnVal *returnVal, GlobalType containerType, void *pObject, GlobalType destType, ContainerID destID);

// Request verifying that a container exists moving it to the destination server
void objRequestContainerVerifyAndMove(TransactionReturnVal *returnVal, GlobalType containerType, ContainerID containerID, GlobalType destType, ContainerID destID);

// Request verifying that a container exists and set its data to the copy passed in.
void objRequestContainerVerifyAndSet(TransactionReturnVal *returnVal, GlobalType containerType, ContainerID containerID, void *pObject, GlobalType destType, ContainerID destID);

// Request verifying that a container exists and if it does not, set its data to the copy passed in.
void objRequestContainerVerifyOrCreateAndInit(TransactionReturnVal *returnVal, GlobalType containerType, ContainerID containerID, void *pObject, GlobalType destType, ContainerID destID);
void objAddToTransactionContainerVerifyOrCreateAndInit(TransactionRequest *request, GlobalType containerType, ContainerID containerID, void *pObject, GlobalType destType, ContainerID destID);

// For Local-only stuff
void objRequestContainerCreateLocal(TransactionReturnVal *returnVal, GlobalType containerType, void *pObject);

// Request destruction of a container and its dependents, possibly moving it to ObjectDB first
void objRequestDestroyContainerAndDependents(TransactionReturnVal *returnVal, GlobalType containerType, ContainerID containerID, GlobalType sourceType, ContainerID sourceID);

// Request deletion of a container, possibly moving it to ObjectDB first
void objRequestContainerDelete(TransactionReturnVal *returnVal, GlobalType containerType, ContainerID containerID, GlobalType sourceType, ContainerID sourceID);

void AddContainerUndeleteToRequest(TransactionRequest *request, GlobalType containerType, ContainerID containerID, GlobalType sourceType, ContainerID sourceID, char *namestr);
// Request undeletion of a container, possibly moving it to ObjectDB first
void objRequestContainerUndelete(TransactionReturnVal *returnVal, GlobalType containerType, ContainerID containerID, GlobalType sourceType, ContainerID sourceID, char *namestr);

// Request destruction of a container, possibly moving it to ObjectDB first
void objRequestContainerDestroy(TransactionReturnVal *returnVal, GlobalType containerType, ContainerID containerID, GlobalType sourceType, ContainerID sourceID);

// Request destruction of a deleted container, possibly moving it to ObjectDB first
void objRequestDeletedContainerDestroy(TransactionReturnVal *returnVal, GlobalType containerType, ContainerID containerID, GlobalType sourceType, ContainerID sourceID);

// Request deletion of multiple containers, possibly moving them to ObjectDB first
void objRequestContainersDestroy(TransactionReturnVal *returnVal, ContainerRef **containerRefs, GlobalType sourceType, ContainerID sourceID);

// Populate a request to offline an EntityPlayer and its dependents
void objFillRequestToOfflineEntityPlayerAndDependents(TransactionRequest *request, ContainerID accountID, GlobalType containerType, ContainerID containerID, const ObjectIndexHeader *header, ContainerRef **ppRefs, GlobalType sourceType, ContainerID sourceID);

// Send a request to offline an EntityPlayer and its dependents
void objSendRequestOfOfflineEntityPlayerAndDependents(TransactionReturnVal *returnVal, TransactionRequest *request);

// Request Removal of EntityPlayer and addition to offline hogg (calls objFillRequestToOfflineEntityPlayerAndDependents and objSendRequestOfOfflineEntityPlayerAndDependents)
void objRequestOfflineEntityPlayerAndDependents(TransactionReturnVal *returnVal, ContainerID accountID, GlobalType containerType, ContainerID containerID, const ObjectIndexHeader *header, ContainerRef **ppRefs, GlobalType sourceType, ContainerID sourceID);

// Request removal of an account specific container and addition to the offline hogg
void objRequestOfflineAccountWideContainer(TransactionReturnVal *returnVal, ContainerID accountID, GlobalType containerType, GlobalType sourceType, ContainerID sourceID);

// Request Removal of EntityPlayer from offline hogg
void objRequestRemoveOfflineEntityPlayerAndDependents(TransactionReturnVal *returnVal, ContainerID accountID, GlobalType containerType, ContainerID containerID, ContainerRef **ppRefs, GlobalType sourceType, ContainerID sourceID);

// Request Removal of an account specific container from offline hogg
void objRequestRemoveAccountWideContainerFromOffline(TransactionReturnVal *returnVal, ContainerID accountID, GlobalType containerType, GlobalType sourceType, ContainerID sourceID);

// Request deletion of multiple dependent containers, possibly moving them to ObjectDB first
void objRequestDependentContainersDestroy(TransactionReturnVal *returnVal, ContainerRef *ref, ContainerRef **containerRefs, GlobalType sourceType, ContainerID sourceID);

// Request deletion of a container on a fully local Transaction Manager
void objRequestContainerDestroyLocal(TransactionReturnVal *returnVal, GlobalType containerType, ContainerID containerID);

// Subscribe to all online containers
void objSubscribeToOnlineContainers(GlobalType conType);

// Unsubscribe, which means delete local cache as well
void objUnsubscribeFromOnlineContainers(GlobalType conType);

// Returns a description of where the container is, it will be of type NONE if we don't know
ContainerRef objGetSubscribedContainerLocation(GlobalType conType, ContainerID conID);

// Reference request wrapper for object subscription
void objCopyDictHandleRequest(DictionaryHandleOrName dictHandle, int command, const char *pResourceName, void * pResource, const char* reason);

// Management for active transactions

typedef void (*TransactionReturnCallback)(TransactionReturnVal *returnVal, void *userData);

//create a fresh new "managed" TransactionReturnVal
TransactionReturnVal *objCreateManagedReturnVal(TransactionReturnCallback func, void *userData);

//create a fresh new "managed" TransactionReturnVal which shouldn't be concerned if the transaction takes
//a long time to happen (only use this if you know that it's legitimate for the transaction to respond very
//slowly (ie, > 5 seconds))
TransactionReturnVal *objCreateManagedReturnVal_TransactionMayTakeALongTime(TransactionReturnCallback func, void *userData);

//will return "fail" if nothing has been heard back in iTimeOutTime seconds (narrowly useful, talk to Alex about why you
//think you need this)
TransactionReturnVal *objCreateManagedReturnVal_WithTimeOut(TransactionReturnCallback func, void *userData, U32 iTimeOutTime);

//used by the trans system to validate that a managed return value is fresh and new
void ValidateManagedReturnValFirstTimeInTransSystem(const char *pTransactionName, TransactionReturnVal *pReturnVal);


void objTransactionPrintResultCB(TransactionReturnVal *returnVal, void *userData);

// Returns the result string of the auto transaction
char *objAutoTransactionGetResult(TransactionReturnVal *returnVal);

//call this version if instead of a normal autotransaction, you used the autotransaction stuff to 
//append transaction steps onto steps that you assembled manually.
char *objAutoTransactionGetResult_TransWasAppended(int iNumManualSteps, TransactionReturnVal *returnVal);

// Release a transaction return object. Just a wrapper around the LocalTransactionManager one
void objReleaseTransactionReturn(TransactionReturnVal* returnStruct);



#define objServerType() (gObjectTransactionManager.serverType)
#define objServerID() (gObjectTransactionManager.serverID)

// Callbacks executed when certain special transactions happen
// These functions follow the same rule as auto-transaction functions

typedef enum SpecialTransactionCallbackType
{
	TRANSACTION_CREATE_CONTAINER, // When a container is created. Use this to validate or add data
	TRANSACTION_VERIFY_CONTAINER,
	TRANSACTION_RECEIVE_CONTAINER_FROM, // When container is received on a non-objectdb
	TRANSACTION_MOVE_CONTAINER_TO, // Sent to non-objectdb
	TRANSACTION_RECOVER_CONTAINER_FROM, // Recieved on the objectdb
	TRANSACTION_RETURN_CONTAINER_TO, // Sent to objectdb
} SpecialTransactionCallbackType;


// Called when a new container is created
// ResultString is an estring and is sent back to whoever called the transaction
// locationType/ID is where the command came from/ is going to
// The difference between newObject and backupObject is sent to the DB as an update, both are modifiable
typedef enumTransactionOutcome (*SpecialTransactionCallback)(ATR_ARGS, void *newObject, void *backupObject, GlobalType locationType, ContainerID locationID);

// Register a callback for a specific global type
void objRegisterSpecialTransactionCallback(GlobalType containerType, SpecialTransactionCallbackType transactionType, SpecialTransactionCallback cbFunc);

// Useful callbacks for external transaction commands

// Sees if we can lock an entire container
int CheckFullContainerLockCB(TransactionCommand *cmd);

// Lock an entire container
int FullContainerLockCB(TransactionCommand *cmd);

// Lock an entire deleted container
int FullDeletedContainerLockCB(TransactionCommand *cmd);

// Commit changes to an entire container
int FullContainerCommitCB(TransactionCommand *cmd);

// Unlock a container being deleted or undeleted
int ContainerCacheCommitCB(TransactionCommand *cmd);

// Unlock a container being deleted or undeleted
int ContainerCacheCommitNoBackupCB(TransactionCommand *cmd);

// Return changes to an entire container
int FullContainerRevertCB(TransactionCommand *cmd);

// Sees if we can lock a set of fields
int CheckFieldLockCB(TransactionCommand *cmd);

// Lock a set of fields
int FieldLockCB(TransactionCommand *cmd);

// Commit changes to a set of fields
int FieldCommitCB(TransactionCommand *cmd);

// Return changes to a set of fields
int FieldRevertCB(TransactionCommand *cmd);

// Lock a set of fields, without making a backup
int FieldLockNoBackupCB(TransactionCommand *cmd);

// Commit changes to a set of fields, without making a backup
int FieldCommitNoBackupCB(TransactionCommand *cmd);

// Return changes to a set of fields, without making a backup
int FieldRevertNoBackupCB(TransactionCommand *cmd);

// Lock a full container, without making a backup
int FullContainerLockNoBackupCB(TransactionCommand *cmd);

// Commit changes to a full container, without making a backup
int FullContainerCommitNoBackupCB(TransactionCommand *cmd);

// Return changes to a full container, without making a backup
int FullContainerRevertNoBackupCB(TransactionCommand *cmd);

// Do I own the specified container?
bool IsContainerOwnedByMe(Container *object);


// Parses a string and either returns a TransactionVariable value or the literal value
int TransactionParseIntArgument(TransactionCommand *trCommand, const char *intArg);
F32 TransactionParseFloatArgument(TransactionCommand *trCommand, const char *floatArg);
const char *TransactionParseStringArgument(TransactionCommand *trCommand, const char *strArg);

// Creates a new transaction command
TransactionCommand* CreateTransactionCommand(void);

// Clears and frees a transaction command
void DestroyTransactionCommand(TransactionCommand *holder);

// Gets a locked copy of a container, or the non-locked copy if it's not locked, or NULL if nonexistent
#define GetLockedContainer(containerType, containerID, ownerID, deleted) GetLockedContainerEx(containerType, containerID, ownerID, deleted, true, true)
#define GetLockedContainerNoUnpack(containerType, containerID, ownerID, deleted) GetLockedContainerEx(containerType, containerID, ownerID, deleted, true, false)
Container *GetLockedContainerEx(GlobalType containerType, U32 containerID, U32 ownerID, bool deleted, bool assertIfSparse, bool forceUnpack);

// Gets a base container
Container *GetBaseContainer(GlobalType containerType, U32 containerID, U32 ownerID);

// Returns true if container is in process of being created
int IsContainerBeingCreated(GlobalType containerType, U32 containerID, U32 ownerID);

// Gets a Locked copy of a field, or the non-locked copy if it's not locked, or nothing
int GetLockedField(Container *baseContainer, const char *path, 
				   ParseTable** table, int* column, void** structptr, int* index,
				   char **resultString, char **diffString);

// Marks a container to be deleted at the end of the transaction
void DeleteLockedContainer(GlobalType containerType, U32 containerID);

// Add a slow command to the tracked list
void AddTrackedSlowCommand(TransactionCommand *command);

// Get a tracked slow command
TransactionCommand *GetTrackedSlowCommand(LTMSlowTransactionID id);


// Remote Commands

// Return a slow command
int ReturnSlowCommand(SlowRemoteCommandID id, bool success, const char *returnString);

// set callbacks for remote commands
void SetRemoteCommandCB(TransactionCommandCB cb);
void SetSlowRemoteCommandCB(TransactionCommandCB cb);

// Command lists
extern CmdList gServerTransactionCmdList;
extern CmdList gObjectTransactionCmdList;
extern CmdList gRemoteCmdList;
extern CmdList gSlowRemoteCmdList;



// A list of containerIDs
// The type is assumed when using this struct.
AUTO_STRUCT;
typedef struct ContainerList
{
	U32 type;
	U32 *eaiContainers;
	int storeindex;
} ContainerList;

AUTO_STRUCT;
typedef struct CharacterIDName
{
	U32 id;			AST(KEY)
	char *name;	AST(STRUCTPARAM ESTRING)
} CharacterIDName;

AUTO_STRUCT;
typedef struct CharacterIDNameList
{
	EARRAY_OF(CharacterIDName) list;		AST(FORMATSTRING(XML_DECODE_KEY = 1))
} CharacterIDNameList;


// For Fully-Local Transaction Managers
void LocalTransactionsTakeOwnership(void);


//DO NOT USE THIS UNLESS YOU KNOW WHAT YOU ARE DOING
typedef struct ActiveTransaction ActiveTransaction;
void ManagedReturnValLog_Internal(ActiveTransaction *pTrans, FORMAT_STR const char *pFmt, ...);
extern bool gLogManagedReturnVals;
#define ManagedReturnValLog(pTrans, pFmt, ...) { if (gLogManagedReturnVals) ManagedReturnValLog_Internal(pTrans, pFmt, __VA_ARGS__); }

//if true, then after ReceiveContainerFromCB, stash the temporary copy of the object in 
//the container's temporaryLocalPostReceiveCopy
LATELINK;
bool objTransactions_MaybeLocallyCopyBackupDataDuringReceive(GlobalType eType, void *pMainObject, void *pBackupObject);

#endif
