#include "textparser.h"

//auto-generated staticdefine for enum enumEmotions
//autogeneratednocheckin
StaticDefineInt enumEmotionsEnum[] =
{
	DEFINE_INT
	{ "HAPPY", HAPPY},
	{ "SAD", SAD},
	{ "CRAZY", CRAZY},
	{ "ANGRY", ANGRY},
	DEFINE_END
};
void autoEnum_fixup_enumEmotions(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(enumEmotionsEnum, "enumEmotions");
}

//auto-generated staticdefine for enum enumMoodType
//autogeneratednocheckin
StaticDefineInt enumMoodTypeEnum[] =
{
	DEFINE_INT
	{ "HAPPYSAD", MOOD_HAPPYSAD},
	{ "HAPPYHAPPY", MOOD_HAPPYHAPPY},
	DEFINE_END
};
void autoEnum_fixup_enumMoodType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(enumMoodTypeEnum, "enumMoodType");
}
//autogeneratednocheckin
extern ParseTable parse_recurseStruct1[];
#define TYPE_parse_recurseStruct1 recurseStruct1
extern ParseTable parse_recurseStruct2[];
#define TYPE_parse_recurseStruct2 recurseStruct2
//Structparser.exe autogenerated ParseTable for struct recurseStruct1
#define TYPE_parse_recurseStruct1 recurseStruct1
ParseTable parse_recurseStruct1[] =
{
	{ "recurseStruct1", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(recurseStruct1), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "f1",				TOK_FLOAT_ROUNDING(FLOAT_HUNDREDTHS) | TOK_F32(recurseStruct1, f1, 0), NULL },
	{ "Struct1s",		TOK_STRUCT(recurseStruct1, pStruct1s, parse_recurseStruct1) },
	{ "Struct2s",		TOK_STRUCT(recurseStruct1, pStruct2s, parse_recurseStruct2) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_recurseStruct1()
{
	int iSize = sizeof(recurseStruct1);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_recurseStruct1, iSize, "recurseStruct1", NULL, "serverlib_structparsertests.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_recurseStruct1[];
#define TYPE_parse_recurseStruct1 recurseStruct1
extern ParseTable parse_recurseStruct2[];
#define TYPE_parse_recurseStruct2 recurseStruct2
//Structparser.exe autogenerated ParseTable for struct recurseStruct2
#define TYPE_parse_recurseStruct2 recurseStruct2
ParseTable parse_recurseStruct2[] =
{
	{ "recurseStruct2", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(recurseStruct2), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Struct1s",		TOK_STRUCT(recurseStruct2, pStruct1s, parse_recurseStruct1) },
	{ "myDirtyBit",		TOK_DIRTY_BIT | TOK_AUTOINT(recurseStruct2, myDirtyBit, 0), NULL },
	{ "Struct2s",		TOK_STRUCT(recurseStruct2, pStruct2s, parse_recurseStruct2) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_recurseStruct2()
{
	int iSize = sizeof(recurseStruct2);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_recurseStruct2, iSize, "recurseStruct2", NULL, "serverlib_structparsertests.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct unownedTest
#define TYPE_parse_unownedTest unownedTest
ParseTable parse_unownedTest[] =
{
	{ "unownedTest", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(unownedTest), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Foo",			TOK_UNOWNED | TOK_OPTIONALLATEBINDSTRUCT(unownedTest, pFoo) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_unownedTest()
{
	int iSize = sizeof(unownedTest);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_unownedTest, iSize, "unownedTest", NULL, "serverlib_structparsertests.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_unownedTest(void)
{
	DoAutoStructLateBind(parse_unownedTest, 2, "fooStruct");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InnerContainer
#define TYPE_parse_InnerContainer InnerContainer
ParseTable parse_InnerContainer[] =
{
	{ "InnerContainer", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InnerContainer), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "foo",			TOK_PERSIST | TOK_AUTOINT(InnerContainer, foo, 0), NULL },
	{ "bar",			TOK_PERSIST | TOK_AUTOINT(InnerContainer, bar, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InnerContainer()
{
	int iSize = sizeof(InnerContainer);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InnerContainer, iSize, "InnerContainer", NULL, "serverlib_structparsertests.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InnerStruct
#define TYPE_parse_InnerStruct InnerStruct
ParseTable parse_InnerStruct[] =
{
	{ "InnerStruct", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InnerStruct), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "x",				TOK_AUTOINT(InnerStruct, x, 0), NULL },
	{ "y",				TOK_AUTOINT(InnerStruct, y, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InnerStruct()
{
	int iSize = sizeof(InnerStruct);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InnerStruct, iSize, "InnerStruct", NULL, "serverlib_structparsertests.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InnerContainer[];
#define TYPE_parse_InnerContainer InnerContainer
extern ParseTable parse_InnerContainer[];
#define TYPE_parse_InnerContainer InnerContainer
extern ParseTable parse_InnerContainer[];
#define TYPE_parse_InnerContainer InnerContainer
//Structparser.exe autogenerated ParseTable for struct FakeContainer
#define TYPE_parse_FakeContainer FakeContainer
ParseTable parse_FakeContainer[] =
{
	{ "FakeContainer", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FakeContainer), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "x",						TOK_PERSIST | TOK_AUTOINT(FakeContainer, x, 0), NULL },
	{ "y",						TOK_PERSIST | TOK_AUTOINT(FakeContainer, y, 0), NULL },
	{ "z",						TOK_PERSIST | TOK_AUTOINT(FakeContainer, z, 0), NULL },
	{ "w",						TOK_PERSIST | TOK_AUTOINT(FakeContainer, w, 0), NULL },
	{ "superCrazy",				TOK_PERSIST | TOK_AUTOINT(FakeContainer, superCrazy, 0), NULL },
	{ "pMyInnerContainer",		TOK_PERSIST | TOK_OPTIONALSTRUCT(FakeContainer, pMyInnerContainer, parse_InnerContainer) },
	{ "pOtherInnerContainer",	TOK_PERSIST | TOK_OPTIONALSTRUCT(FakeContainer, pOtherInnerContainer, parse_InnerContainer) },
	{ "ppInnerContainers",		TOK_PERSIST | TOK_STRUCT(FakeContainer, ppInnerContainers, parse_InnerContainer) },
	{ "ppStrings",				TOK_PERSIST | TOK_STRINGARRAY(FakeContainer, ppStrings), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_FakeContainer()
{
	int iSize = sizeof(FakeContainer);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FakeContainer, iSize, "FakeContainer", NULL, "serverlib_structparsertests.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct FakeNonContainer
#define TYPE_parse_FakeNonContainer FakeNonContainer
ParseTable parse_FakeNonContainer[] =
{
	{ "FakeNonContainer", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FakeNonContainer), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "x",					TOK_AUTOINT(FakeNonContainer, x, 0), NULL },
	{ "f",					TOK_F32(FakeNonContainer, f, 1.5f), NULL },
	{ "foo",				TOK_SPECIAL_DEFAULT | TOK_FIXEDSTR(FakeNonContainer, foo), NULL , 0 , " SPECIAL_DEFAULT = \"test\" "},
	{ "MyWibba",			TOK_OPTIONALLATEBINDSTRUCT(FakeNonContainer, pMyWibba) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_FakeNonContainer()
{
	int iSize = sizeof(FakeNonContainer);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FakeNonContainer, iSize, "FakeNonContainer", NULL, "serverlib_structparsertests.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_FakeNonContainer[3].param = GET_INTPTR_FROM_FLOAT((float)1.5f);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_FakeNonContainer(void)
{
	DoAutoStructLateBind(parse_FakeNonContainer, 5, "wibba");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct FakeFlatEmbedTest
#define TYPE_parse_FakeFlatEmbedTest FakeFlatEmbedTest
ParseTable parse_FakeFlatEmbedTest[] =
{
	{ "FakeFlatEmbedTest", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(FakeFlatEmbedTest), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "f1",					TOK_F32(FakeFlatEmbedTest, f1, 2.5f), NULL },
	{ "nonContainer1", 		TOK_IGNORE | TOK_FLATEMBED },
	{ "Hahahahax",			TOK_AUTOINT(FakeFlatEmbedTest, nonContainer1.x, 0), NULL },
	{ "Hahahahaf",			TOK_F32(FakeFlatEmbedTest, nonContainer1.f, 1.5f), NULL },
	{ "Hahahahafoo",		TOK_SPECIAL_DEFAULT | TOK_FIXEDSTR(FakeFlatEmbedTest, nonContainer1.foo), NULL , 0 , " SPECIAL_DEFAULT = \"test\" "},
	{ "HahahahaMyWibba",	TOK_OPTIONALLATEBINDSTRUCT(FakeFlatEmbedTest, nonContainer1.pMyWibba) },
	{ "nonContainer2", 		TOK_IGNORE | TOK_FLATEMBED },
	{ "Hohohohox",			TOK_AUTOINT(FakeFlatEmbedTest, nonContainer2.x, 0), NULL },
	{ "Hohohohof",			TOK_F32(FakeFlatEmbedTest, nonContainer2.f, 1.5f), NULL },
	{ "Hohohohofoo",		TOK_SPECIAL_DEFAULT | TOK_FIXEDSTR(FakeFlatEmbedTest, nonContainer2.foo), NULL , 0 , " SPECIAL_DEFAULT = \"test\" "},
	{ "HohohohoMyWibba",	TOK_OPTIONALLATEBINDSTRUCT(FakeFlatEmbedTest, nonContainer2.pMyWibba) },
	{ "f2",					TOK_F32(FakeFlatEmbedTest, f2, 3.5f), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_FakeFlatEmbedTest()
{
	int iSize = sizeof(FakeFlatEmbedTest);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_FakeFlatEmbedTest, iSize, "FakeFlatEmbedTest", NULL, "serverlib_structparsertests.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_FakeFlatEmbedTest[2].param = GET_INTPTR_FROM_FLOAT((float)2.5f);
	parse_FakeFlatEmbedTest[5].param = GET_INTPTR_FROM_FLOAT((float)1.5f);
	parse_FakeFlatEmbedTest[10].param = GET_INTPTR_FROM_FLOAT((float)1.5f);
	parse_FakeFlatEmbedTest[13].param = GET_INTPTR_FROM_FLOAT((float)3.5f);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_FakeFlatEmbedTest(void)
{
	DoAutoStructLateBind(parse_FakeFlatEmbedTest, 7, "wibba");
	DoAutoStructLateBind(parse_FakeFlatEmbedTest, 12, "wibba");
}
//autogeneratednocheckin
extern ParseTable parse_FakeNonContainer[];
#define TYPE_parse_FakeNonContainer FakeNonContainer
//Structparser.exe autogenerated ParseTable for struct AutoIndexTest
#define TYPE_parse_AutoIndexTest AutoIndexTest
ParseTable parse_AutoIndexTest[] =
{
	{ "AutoIndexTest", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AutoIndexTest), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "testBit",		TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "foo",			TOK_AUTOINT(AutoIndexTest, foo, 0), NULL },
	{ "bar",			TOK_AUTOINT(AutoIndexTest, bar, 0), NULL },
	{ "containers_0",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[0], parse_FakeNonContainer)},
	{ "containers_1",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[1], parse_FakeNonContainer)},
	{ "containers_2",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[2], parse_FakeNonContainer)},
	{ "containers_3",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[3], parse_FakeNonContainer)},
	{ "containers_4",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[4], parse_FakeNonContainer)},
	{ "containers_5",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[5], parse_FakeNonContainer)},
	{ "containers_6",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[6], parse_FakeNonContainer)},
	{ "containers_7",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[7], parse_FakeNonContainer)},
	{ "containers_8",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[8], parse_FakeNonContainer)},
	{ "containers_9",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[9], parse_FakeNonContainer)},
	{ "containers_10",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[10], parse_FakeNonContainer)},
	{ "containers_11",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[11], parse_FakeNonContainer)},
	{ "containers_12",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[12], parse_FakeNonContainer)},
	{ "containers_13",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[13], parse_FakeNonContainer)},
	{ "containers_14",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[14], parse_FakeNonContainer)},
	{ "containers_15",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[15], parse_FakeNonContainer)},
	{ "containers_16",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[16], parse_FakeNonContainer)},
	{ "containers_17",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[17], parse_FakeNonContainer)},
	{ "containers_18",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[18], parse_FakeNonContainer)},
	{ "containers_19",	TOK_EMBEDDEDSTRUCT(AutoIndexTest, containers[19], parse_FakeNonContainer)},
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_AutoIndexTest()
{
	int iSize = sizeof(AutoIndexTest);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AutoIndexTest, iSize, "AutoIndexTest", NULL, "serverlib_structparsertests.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(AutoIndexTest) + 7) / 4;
		AutoIndexTest *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->testBit = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_AutoIndexTest[2]);
		pTemp->testBit = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct emotionStruct
#define TYPE_parse_emotionStruct emotionStruct
ParseTable parse_emotionStruct[] =
{
	{ "emotionStruct", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(emotionStruct), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "emo1",			TOK_AUTOINT(emotionStruct, emo1, HAPPY), enumEmotionsEnum },
	{ "emo2",			TOK_AUTOINT(emotionStruct, emo2, SAD), enumEmotionsEnum },
	{ "emo3",			TOK_AUTOINT(emotionStruct, emo3, CRAZY), enumEmotionsEnum },
	{ "emo4",			TOK_AUTOINT(emotionStruct, emo4, ANGRY), enumEmotionsEnum },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
typedef struct MemoryPoolImp *MemoryPool;
extern MemoryPool memPoolemotionStruct;
int autoStruct_fixup_emotionStruct()
{
	int iSize = sizeof(emotionStruct);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_emotionStruct, iSize, "emotionStruct", NULL, "serverlib_structparsertests.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	ParserSetTPIUsesSingleThreadedMemPool(parse_emotionStruct, &memPoolemotionStruct);
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct testKeyStruct
#define TYPE_parse_testKeyStruct testKeyStruct
ParseTable parse_testKeyStruct[] =
{
	{ "testKeyStruct", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(testKeyStruct), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "hi",				TOK_SELF_ONLY | TOK_REQUIRED | TOK_STRING(testKeyStruct, pName, 0), NULL },
	{ "ho",				TOK_REDUNDANTNAME | TOK_SELF_ONLY | TOK_STRING(testKeyStruct, pName, 0), NULL },
	{ "wakka",			TOK_REDUNDANTNAME | TOK_SELF_ONLY | TOK_STRING(testKeyStruct, pName, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_testKeyStruct()
{
	int iSize = sizeof(testKeyStruct);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_testKeyStruct, iSize, "testKeyStruct", NULL, "serverlib_structparsertests.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
