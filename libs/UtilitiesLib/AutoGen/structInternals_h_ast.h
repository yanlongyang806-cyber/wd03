#ifndef __STRUCTINTERNALS_H_AST_H_
#define __STRUCTINTERNALS_H_AST_H_
#pragma once
GCC_SYSTEM
#include "textparser.h"
//This file is autogenerated and contains TextParserInfo prototypes from \structInternals.h
//autogeneratednocheckin
#include "textParsercallbacks_inline.h"
static __forceinline int parse_autogen(TokenizerHandle tok, ParseTable tpi[], ParseTable *ptcc, int column, void* structptr, int index, TextParserResult *parseResult)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_parse(tok, tpi, ptcc, column, structptr, index, parseResult);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_parse(tok, tpi, ptcc, column, structptr, index, parseResult);
	}
	else
	{
		return fixedarray_parse(tok, tpi, ptcc, column, structptr, index, parseResult);
	}
}

static __forceinline bool writetext_autogen(FILE* out, ParseTable tpi[], int column, void* structptr, int index, bool showname, bool ignoreInherited, int level, WriteTextFlags iWriteTextFlags, StructTypeField iOptionFlagsToMatch, StructTypeField iOptionFlagsToExclude)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_writetext(out, tpi, column, structptr, index, showname, ignoreInherited, level, iWriteTextFlags, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_writetext(out, tpi, column, structptr, index, showname, ignoreInherited, level, iWriteTextFlags, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
	else
	{
		return fixedarray_writetext(out, tpi, column, structptr, index, showname, ignoreInherited, level, iWriteTextFlags, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
}

static __forceinline TextParserResult writebin_autogen(SimpleBufHandle file, FILE *pLayoutFile, FileList *pFileList, ParseTable tpi[], int column, void* structptr, int index, int* datasum, StructTypeField iOptionFlagsToMatch, StructTypeField iOptionFlagsToExclude)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_writebin(file, pLayoutFile, pFileList, tpi, column, structptr, index, datasum, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_writebin(file, pLayoutFile, pFileList, tpi, column, structptr, index, datasum, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
	else
	{
		return fixedarray_writebin(file, pLayoutFile, pFileList, tpi, column, structptr, index, datasum, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
}

static __forceinline TextParserResult readbin_autogen(SimpleBufHandle file, FileList *pFile, ParseTable tpi[], int column, void* structptr, int index, int* datasum, StructTypeField iOptionFlagsToMatch, StructTypeField iOptionFlagsToExclude)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_readbin(file, pFile, tpi, column, structptr, index, datasum, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_readbin(file, pFile, tpi, column, structptr, index, datasum, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
	else
	{
		return fixedarray_readbin(file, pFile, tpi, column, structptr, index, datasum, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
}

static __forceinline bool initstruct_autogen(ParseTable tpi[], int column, void* structptr, int index)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_initstruct(tpi, column, structptr, index);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_initstruct(tpi, column, structptr, index);
	}
	else
	{
		return fixedarray_initstruct(tpi, column, structptr, index);
	}
}

static __forceinline int destroystruct_autogen(ParseTable tpi[], ParseTable *ptcc, int column, void* structptr, int index)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_destroystruct(tpi, ptcc, column, structptr, index);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_destroystruct(tpi, ptcc, column, structptr, index);
	}
	else
	{
		return fixedarray_destroystruct(tpi, ptcc, column, structptr, index);
	}
}

static __forceinline void updatecrc_autogen(ParseTable tpi[], int column, void* structptr, int index)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		nonarray_updatecrc(tpi, column, structptr, index);
	}
	else if (field_type & TOK_EARRAY)
	{
		earray_updatecrc(tpi, column, structptr, index);
	}
	else
	{
		fixedarray_updatecrc(tpi, column, structptr, index);
	}
}

static __forceinline int compare_autogen(ParseTable tpi[], int column, const void* lhs, const void* rhs, int index, enumCompareFlags eFlags, StructTypeField iOptionFlagsToMatch, StructTypeField iOptionFlagsToExclude)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_compare(tpi, column, lhs, rhs, index, eFlags, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_compare(tpi, column, lhs, rhs, index, eFlags, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
	else
	{
		return fixedarray_compare(tpi, column, lhs, rhs, index, eFlags, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
}

static __forceinline size_t memusage_autogen(ParseTable tpi[], int column, void* structptr, int index, bool bAbsoluteUsage)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_memusage(tpi, column, structptr, index, bAbsoluteUsage);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_memusage(tpi, column, structptr, index, bAbsoluteUsage);
	}
	else
	{
		return fixedarray_memusage(tpi, column, structptr, index, bAbsoluteUsage);
	}
}

static __forceinline void copystruct_autogen(ParseTable tpi[], ParseTable *ptcc, int column, void* dest, void* src, int index, CustomMemoryAllocator memAllocator, void* customData)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		nonarray_copystruct(tpi, ptcc, column, dest, src, index, memAllocator, customData);
	}
	else if (field_type & TOK_EARRAY)
	{
		earray_copystruct(tpi, ptcc, column, dest, src, index, memAllocator, customData);
	}
	else
	{
		fixedarray_copystruct(tpi, ptcc, column, dest, src, index, memAllocator, customData);
	}
}

static __forceinline void copyfield_autogen(ParseTable tpi[], ParseTable *ptcc, int column, void* dest, void* src, int index, CustomMemoryAllocator memAllocator, void* customData, StructTypeField iOptionFlagsToMatch, StructTypeField iOptionFlagsToExclude)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		nonarray_copyfield(tpi, ptcc, column, dest, src, index, memAllocator, customData, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
	else if (field_type & TOK_EARRAY)
	{
		earray_copyfield(tpi, ptcc, column, dest, src, index, memAllocator, customData, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
	else
	{
		fixedarray_copyfield(tpi, ptcc, column, dest, src, index, memAllocator, customData, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
}

static __forceinline enumCopy2TpiResult copyfield2tpis_autogen(ParseTable tpi[], int column, int src_index, void *src, ParseTable dest_tpi[], int dest_column, int dest_index, void *dest,  CustomMemoryAllocator memAllocator, void* customData, StructTypeField iOptionFlagsToMatch, StructTypeField iOptionFlagsToExclude, char **ppResultString)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_copyfield2tpis(tpi, column, src_index, src, dest_tpi, dest_column, dest_index, dest, memAllocator, customData, iOptionFlagsToMatch, iOptionFlagsToExclude, ppResultString);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_copyfield2tpis(tpi, column, src_index, src, dest_tpi, dest_column, dest_index, dest, memAllocator, customData, iOptionFlagsToMatch, iOptionFlagsToExclude, ppResultString);
	}
	else
	{
		return fixedarray_copyfield2tpis(tpi, column, src_index, src, dest_tpi, dest_column, dest_index, dest, memAllocator, customData, iOptionFlagsToMatch, iOptionFlagsToExclude, ppResultString);
	}
}

static __forceinline void writehdiff_autogen(char** estr, ParseTable tpi[], int column, void* oldstruct, void* newstruct, int index, char *prefix, StructTypeField iOptionFlagsToMatch, StructTypeField iOptionFlagsToExclude, TextDiffFlags eFlags, const char *caller_fname, int line)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		nonarray_writehdiff(estr, tpi, column, oldstruct, newstruct, index, prefix, iOptionFlagsToMatch, iOptionFlagsToExclude, eFlags, caller_fname, line);
	}
	else if (field_type & TOK_EARRAY)
	{
		earray_writehdiff(estr, tpi, column, oldstruct, newstruct, index, prefix, iOptionFlagsToMatch, iOptionFlagsToExclude, eFlags, caller_fname, line);
	}
	else
	{
		fixedarray_writehdiff(estr, tpi, column, oldstruct, newstruct, index, prefix, iOptionFlagsToMatch, iOptionFlagsToExclude, eFlags, caller_fname, line);
	}
}

static __forceinline void writebdiff_autogen(StructDiff *diff, ParseTable tpi[], int column, void* oldstruct, void* newstruct, int index, ObjectPath *parentPath, StructTypeField iOptionFlagsToMatch, StructTypeField iOptionFlagsToExclude, bool invertExcludeFlags, const char *caller_fname, int line)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		nonarray_writebdiff(diff, tpi, column, oldstruct, newstruct, index, parentPath, iOptionFlagsToMatch, iOptionFlagsToExclude, invertExcludeFlags, caller_fname, line);
	}
	else if (field_type & TOK_EARRAY)
	{
		earray_writebdiff(diff, tpi, column, oldstruct, newstruct, index, parentPath, iOptionFlagsToMatch, iOptionFlagsToExclude, invertExcludeFlags, caller_fname, line);
	}
	else
	{
		fixedarray_writebdiff(diff, tpi, column, oldstruct, newstruct, index, parentPath, iOptionFlagsToMatch, iOptionFlagsToExclude, invertExcludeFlags, caller_fname, line);
	}
}

static __forceinline bool senddiff_autogen(Packet* pak, ParseTable tpi[], int column, const void* oldstruct, const void* newstruct, int index, enumSendDiffFlags eFlags, StructTypeField iOptionFlagsToMatch, StructTypeField iOptionFlagsToExclude, StructGenerateCustomIncludeExcludeFlagsCB *pGenerateFlagsCB)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_senddiff(pak, tpi, column, oldstruct, newstruct, index, eFlags, iOptionFlagsToMatch, iOptionFlagsToExclude, pGenerateFlagsCB);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_senddiff(pak, tpi, column, oldstruct, newstruct, index, eFlags, iOptionFlagsToMatch, iOptionFlagsToExclude, pGenerateFlagsCB);
	}
	else
	{
		return fixedarray_senddiff(pak, tpi, column, oldstruct, newstruct, index, eFlags, iOptionFlagsToMatch, iOptionFlagsToExclude, pGenerateFlagsCB);
	}
}

static __forceinline bool recvdiff_autogen(Packet* pak, ParseTable tpi[], int column, void* structptr, int index, enumRecvDiffFlags eFlags)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_recvdiff(pak, tpi, column, structptr, index, eFlags);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_recvdiff(pak, tpi, column, structptr, index, eFlags);
	}
	else
	{
		return fixedarray_recvdiff(pak, tpi, column, structptr, index, eFlags);
	}
}

static __forceinline bool bitpack_autogen(ParseTable tpi[], int column, const void *structptr, int index, PackedStructStream *pack)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_bitpack(tpi, column, structptr, index, pack);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_bitpack(tpi, column, structptr, index, pack);
	}
	else
	{
		return fixedarray_bitpack(tpi, column, structptr, index, pack);
	}
}

static __forceinline void unbitpack_autogen(ParseTable tpi[], int column, void *structptr, int index, PackedStructStream *pack)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		nonarray_unbitpack(tpi, column, structptr, index, pack);
	}
	else if (field_type & TOK_EARRAY)
	{
		earray_unbitpack(tpi, column, structptr, index, pack);
	}
	else
	{
		fixedarray_unbitpack(tpi, column, structptr, index, pack);
	}
}

static __forceinline void endianswap_autogen(ParseTable tpi[], int column, void* structptr, int index)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		nonarray_endianswap(tpi, column, structptr, index);
	}
	else if (field_type & TOK_EARRAY)
	{
		earray_endianswap(tpi, column, structptr, index);
	}
	else
	{
		fixedarray_endianswap(tpi, column, structptr, index);
	}
}

static __forceinline void interp_autogen(ParseTable tpi[], int column, void* structA, void* structB, void* destStruct, int index, F32 interpParam)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		nonarray_interp(tpi, column, structA, structB, destStruct, index, interpParam);
	}
	else if (field_type & TOK_EARRAY)
	{
		earray_interp(tpi, column, structA, structB, destStruct, index, interpParam);
	}
	else
	{
		fixedarray_interp(tpi, column, structA, structB, destStruct, index, interpParam);
	}
}

static __forceinline void calcrate_autogen(ParseTable tpi[], int column, void* structA, void* structB, void* destStruct, int index, F32 deltaTime)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		nonarray_calcrate(tpi, column, structA, structB, destStruct, index, deltaTime);
	}
	else if (field_type & TOK_EARRAY)
	{
		earray_calcrate(tpi, column, structA, structB, destStruct, index, deltaTime);
	}
	else
	{
		fixedarray_calcrate(tpi, column, structA, structB, destStruct, index, deltaTime);
	}
}

static __forceinline void integrate_autogen(ParseTable tpi[], int column, void* valueStruct, void* rateStruct, void* destStruct, int index, F32 deltaTime)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		nonarray_integrate(tpi, column, valueStruct, rateStruct, destStruct, index, deltaTime);
	}
	else if (field_type & TOK_EARRAY)
	{
		earray_integrate(tpi, column, valueStruct, rateStruct, destStruct, index, deltaTime);
	}
	else
	{
		fixedarray_integrate(tpi, column, valueStruct, rateStruct, destStruct, index, deltaTime);
	}
}

static __forceinline void calccyclic_autogen(ParseTable tpi[], int column, void* valueStruct, void* ampStruct, void* freqStruct, void* cycleStruct, void* destStruct, int index, F32 fStartTime, F32 deltaTime)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		nonarray_calccyclic(tpi, column, valueStruct, ampStruct, freqStruct, cycleStruct, destStruct, index, fStartTime, deltaTime);
	}
	else if (field_type & TOK_EARRAY)
	{
		earray_calccyclic(tpi, column, valueStruct, ampStruct, freqStruct, cycleStruct, destStruct, index, fStartTime, deltaTime);
	}
	else
	{
		fixedarray_calccyclic(tpi, column, valueStruct, ampStruct, freqStruct, cycleStruct, destStruct, index, fStartTime, deltaTime);
	}
}

static __forceinline void applydynop_autogen(ParseTable tpi[], int column, void* dstStruct, void* srcStruct, int index, DynOpType optype, const F32* values, U8 uiValuesSpecd, U32* seed)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		nonarray_applydynop(tpi, column, dstStruct, srcStruct, index, optype, values, uiValuesSpecd, seed);
	}
	else if (field_type & TOK_EARRAY)
	{
		earray_applydynop(tpi, column, dstStruct, srcStruct, index, optype, values, uiValuesSpecd, seed);
	}
	else
	{
		fixedarray_applydynop(tpi, column, dstStruct, srcStruct, index, optype, values, uiValuesSpecd, seed);
	}
}

static __forceinline TextParserResult writestring_autogen(ParseTable tpi[], int column, void* structptr, int index, char** estr, WriteTextFlags iWriteTextFlags, StructTypeField iOptionFlagsToMatch, StructTypeField iOptionFlagsToExclude, const char *caller_fname, int line)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_writestring(tpi, column, structptr, index, estr, iWriteTextFlags, iOptionFlagsToMatch, iOptionFlagsToExclude, caller_fname, line);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_writestring(tpi, column, structptr, index, estr, iWriteTextFlags, iOptionFlagsToMatch, iOptionFlagsToExclude, caller_fname, line);
	}
	else
	{
		return fixedarray_writestring(tpi, column, structptr, index, estr, iWriteTextFlags, iOptionFlagsToMatch, iOptionFlagsToExclude, caller_fname, line);
	}
}

static __forceinline TextParserResult readstring_autogen(ParseTable tpi[], int column, void* structptr, int index, const char* str, ReadStringFlags eFlags)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_readstring(tpi, column, structptr, index, str, eFlags);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_readstring(tpi, column, structptr, index, str, eFlags);
	}
	else
	{
		return fixedarray_readstring(tpi, column, structptr, index, str, eFlags);
	}
}

static __forceinline TextParserResult tomulti_autogen(ParseTable tpi[], int column, void* structptr, int index, MultiVal* result, bool bDuplicateData, bool dummyOnNULL)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_tomulti(tpi, column, structptr, index, result, bDuplicateData, dummyOnNULL);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_tomulti(tpi, column, structptr, index, result, bDuplicateData, dummyOnNULL);
	}
	else
	{
		return fixedarray_tomulti(tpi, column, structptr, index, result, bDuplicateData, dummyOnNULL);
	}
}

static __forceinline TextParserResult frommulti_autogen(ParseTable tpi[], int column, void* structptr, int index, const MultiVal* value)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_frommulti(tpi, column, structptr, index, value);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_frommulti(tpi, column, structptr, index, value);
	}
	else
	{
		return fixedarray_frommulti(tpi, column, structptr, index, value);
	}
}

static __forceinline void calcoffset_autogen(ParseTable tpi[], int column, size_t* size)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		nonarray_calcoffset(tpi, column, size);
	}
	else if (field_type & TOK_EARRAY)
	{
		earray_calcoffset(tpi, column, size);
	}
	else
	{
		fixedarray_calcoffset(tpi, column, size);
	}
}

static __forceinline void preparesharedmemoryforfixup_autogen(ParseTable tpi[], int column, void *structptr, int index, char **ppFixupData)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		nonarray_preparesharedmemoryforfixup(tpi, column, structptr, index, ppFixupData);
	}
	else if (field_type & TOK_EARRAY)
	{
		earray_preparesharedmemoryforfixup(tpi, column, structptr, index, ppFixupData);
	}
	else
	{
		fixedarray_preparesharedmemoryforfixup(tpi, column, structptr, index, ppFixupData);
	}
}

static __forceinline void fixupsharedmemory_autogen(ParseTable tpi[], int column, void *structptr, int index, char **ppFixupData)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		nonarray_fixupsharedmemory(tpi, column, structptr, index, ppFixupData);
	}
	else if (field_type & TOK_EARRAY)
	{
		earray_fixupsharedmemory(tpi, column, structptr, index, ppFixupData);
	}
	else
	{
		fixedarray_fixupsharedmemory(tpi, column, structptr, index, ppFixupData);
	}
}

static __forceinline TextParserResult leafFirstFixup_autogen(ParseTable tpi[], int column, void *structptr, int index, enumTextParserFixupType eFixupType, void *pExtraData)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_leafFirstFixup(tpi, column, structptr, index, eFixupType, pExtraData);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_leafFirstFixup(tpi, column, structptr, index, eFixupType, pExtraData);
	}
	else
	{
		return fixedarray_leafFirstFixup(tpi, column, structptr, index, eFixupType, pExtraData);
	}
}

static __forceinline void reapplypreparse_autogen(ParseTable tpi[], int column, void *structptr, int index, char *pCurrentFile, int iTimeStamp, int iLineNum)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		nonarray_reapplypreparse(tpi, column, structptr, index, pCurrentFile, iTimeStamp, iLineNum);
	}
	else if (field_type & TOK_EARRAY)
	{
		earray_reapplypreparse(tpi, column, structptr, index, pCurrentFile, iTimeStamp, iLineNum);
	}
	else
	{
		fixedarray_reapplypreparse(tpi, column, structptr, index, pCurrentFile, iTimeStamp, iLineNum);
	}
}

static __forceinline int checksharedmemory_autogen(ParseTable tpi[], int column, void *structptr, int index)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_checksharedmemory(tpi, column, structptr, index);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_checksharedmemory(tpi, column, structptr, index);
	}
	else
	{
		return fixedarray_checksharedmemory(tpi, column, structptr, index);
	}
}

static __forceinline enumCopy2TpiResult stringifycopy_autogen(ParseTable tpi[], int column, int src_index, void *src, ParseTable dest_tpi[], int dest_column, int dest_index, void *dest, char **ppResultString)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_stringifycopy(tpi, column, src_index, src, dest_tpi, dest_column, dest_index, dest, ppResultString);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_stringifycopy(tpi, column, src_index, src, dest_tpi, dest_column, dest_index, dest, ppResultString);
	}
	else
	{
		return fixedarray_stringifycopy(tpi, column, src_index, src, dest_tpi, dest_column, dest_index, dest, ppResultString);
	}
}

static __forceinline int recvdiff2tpis_autogen(Packet *pak, ParseTable tpi[], ParseTable dest_tpi[], int column, int index, Recv2TpiCachedInfo *pCache, void *data)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_recvdiff2tpis(pak, tpi, dest_tpi, column, index, pCache, data);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_recvdiff2tpis(pak, tpi, dest_tpi, column, index, pCache, data);
	}
	else
	{
		return fixedarray_recvdiff2tpis(pak, tpi, dest_tpi, column, index, pCache, data);
	}
}

static __forceinline int textdiffwithnull_autogen(char** estr, ParseTable tpi[], int column, void* newstruct, int index, char *prefix, int iPrefixLen, StructTypeField iOptionFlagsToMatch, StructTypeField iOptionFlagsToExclude, TextDiffFlags eFlags, const char *caller_fname, int line)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_textdiffwithnull(estr, tpi, column, newstruct, index, prefix, iPrefixLen, iOptionFlagsToMatch, iOptionFlagsToExclude, eFlags, caller_fname, line);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_textdiffwithnull(estr, tpi, column, newstruct, index, prefix, iPrefixLen, iOptionFlagsToMatch, iOptionFlagsToExclude, eFlags, caller_fname, line);
	}
	else
	{
		return fixedarray_textdiffwithnull(estr, tpi, column, newstruct, index, prefix, iPrefixLen, iOptionFlagsToMatch, iOptionFlagsToExclude, eFlags, caller_fname, line);
	}
}

static __forceinline bool writehtmlfile_autogen(ParseTable tpi[], int column, void *structptr, int index, FILE* out, WriteHTMLContext *pContext)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_writehtmlfile(tpi, column, structptr, index, out, pContext);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_writehtmlfile(tpi, column, structptr, index, out, pContext);
	}
	else
	{
		return fixedarray_writehtmlfile(tpi, column, structptr, index, out, pContext);
	}
}

static __forceinline bool writexmlfile_autogen(ParseTable tpi[], int column, void *structptr, int index, int level, FILE* out, StructFormatField iOptions)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_writexmlfile(tpi, column, structptr, index, level, out, iOptions);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_writexmlfile(tpi, column, structptr, index, level, out, iOptions);
	}
	else
	{
		return fixedarray_writexmlfile(tpi, column, structptr, index, level, out, iOptions);
	}
}

static __forceinline bool writehdf_autogen(ParseTable tpi[], int column, void *structptr, int index, HDF *hdf, char *name_override)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_writehdf(tpi, column, structptr, index, hdf, name_override);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_writehdf(tpi, column, structptr, index, hdf, name_override);
	}
	else
	{
		return fixedarray_writehdf(tpi, column, structptr, index, hdf, name_override);
	}
}

static __forceinline bool writejsonfile_autogen(ParseTable tpi[], int column, void *structptr, int index, FILE *out, WriteJsonFlags eFlags,
	StructTypeField iOptionFlagsToMatch, StructTypeField iOptionFlagsToExclude)
{
	StructTypeField field_type = tpi[column].type;
	if (!(field_type & (TOK_EARRAY | TOK_FIXED_ARRAY)))
	{
		return nonarray_writejsonfile(tpi, column, structptr, index, out, eFlags, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
	else if (field_type & TOK_EARRAY)
	{
		return earray_writejsonfile(tpi, column, structptr, index, out, eFlags, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
	else
	{
		return fixedarray_writejsonfile(tpi, column, structptr, index, out, eFlags, iOptionFlagsToMatch, iOptionFlagsToExclude);
	}
}


extern ParseTable parse_FileEntry[];
#define TYPE_parse_FileEntry FileEntry

#endif
