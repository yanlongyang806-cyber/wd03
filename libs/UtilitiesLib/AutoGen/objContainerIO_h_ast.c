#include "textparser.h"
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ContainerRepositoryTypeInfo
#define TYPE_parse_ContainerRepositoryTypeInfo ContainerRepositoryTypeInfo
ParseTable parse_ContainerRepositoryTypeInfo[] =
{
	{ "ContainerRepositoryTypeInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ContainerRepositoryTypeInfo), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "GlobalType",						TOK_KEY | TOK_AUTOINT(ContainerRepositoryTypeInfo, eGlobalType, 0), GlobalTypeEnum },
	{ "MaxContainerID",					TOK_AUTOINT(ContainerRepositoryTypeInfo, iMaxContainerID, 0), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ContainerRepositoryTypeInfo()
{
	int iSize = sizeof(ContainerRepositoryTypeInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ContainerRepositoryTypeInfo, iSize, "ContainerRepositoryTypeInfo", NULL, "objContainerIO.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ContainerRepositoryTypeInfo[];
#define TYPE_parse_ContainerRepositoryTypeInfo ContainerRepositoryTypeInfo
//Structparser.exe autogenerated ParseTable for struct ContainerRepositoryInfo
#define TYPE_parse_ContainerRepositoryInfo ContainerRepositoryInfo
ParseTable parse_ContainerRepositoryInfo[] =
{
	{ "ContainerRepositoryInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ContainerRepositoryInfo), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "LastSequenceNumber",			TOK_AUTOINT(ContainerRepositoryInfo, iLastSequenceNumber, 0), NULL },
	{ "LastTimeStamp",				TOK_AUTOINT(ContainerRepositoryInfo, iLastTimeStamp, 0), NULL },
	{ "CurrentSequenceNumber",		TOK_AUTOINT(ContainerRepositoryInfo, iCurrentSequenceNumber, 0), NULL },
	{ "CurrentTimeStamp",			TOK_AUTOINT(ContainerRepositoryInfo, iCurrentTimeStamp, 0), NULL },
	{ "BaseContainerID",			TOK_AUTOINT(ContainerRepositoryInfo, iBaseContainerID, 0), NULL },
	{ "MaxContainerID",				TOK_AUTOINT(ContainerRepositoryInfo, iMaxContainerID, 0), NULL },
	{ "RepositoryTypeInfo",			TOK_STRUCT(ContainerRepositoryInfo, ppRepositoryTypeInfo, parse_ContainerRepositoryTypeInfo) },
	{ "DeletedContainers",			TOK_IGNORE | TOK_IGNORE_STRUCT , 0 },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ContainerRepositoryInfo()
{
	int iSize = sizeof(ContainerRepositoryInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ContainerRepositoryInfo, iSize, "ContainerRepositoryInfo", NULL, "objContainerIO.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ContainerIOConfig
#define TYPE_parse_ContainerIOConfig ContainerIOConfig
ParseTable parse_ContainerIOConfig[] =
{
	{ "ContainerIOConfig", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ContainerIOConfig), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "MergerScript",			TOK_FIXEDSTR(ContainerIOConfig, MergerScript), NULL },
	{ "OfflineBackupScript",	TOK_FIXEDSTR(ContainerIOConfig, OfflineBackupScript), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ContainerIOConfig()
{
	int iSize = sizeof(ContainerIOConfig);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ContainerIOConfig, iSize, "ContainerIOConfig", NULL, "objContainerIO.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ContainerRepositoryInfo[];
#define TYPE_parse_ContainerRepositoryInfo ContainerRepositoryInfo
//Structparser.exe autogenerated ParseTable for struct ContainerSource
#define TYPE_parse_ContainerSource ContainerSource
ParseTable parse_ContainerSource[] =
{
	{ "ContainerSource", 						TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ContainerSource), 0, NULL, 0, NULL },
	{ "{",										TOK_START, 0 },
	{ "sourceInfo",								TOK_OPTIONALSTRUCT(ContainerSource, sourceInfo, parse_ContainerRepositoryInfo) },
	{ "sourcePath",								TOK_FIXEDSTR(ContainerSource, sourcePath), NULL },
	{ "incrementalPath",						TOK_FIXEDSTR(ContainerSource, incrementalPath), NULL },
	{ "offlinePath",							TOK_FIXEDSTR(ContainerSource, offlinePath), NULL },
	{ "thread_initialized",						TOK_AUTOINT(ContainerSource, thread_initialized, 0), NULL },
	{ "incrementalMinutes",						TOK_AUTOINT(ContainerSource, incrementalMinutes, 0), NULL },
	{ "incrementalHoursToKeep",					TOK_AUTOINT(ContainerSource, incrementalHoursToKeep, 0), NULL },
	{ "snapshotMinutesToKeep",					TOK_AUTOINT(ContainerSource, snapshotMinutesToKeep, 0), NULL },
	{ "snapshotHoursToKeep",					TOK_AUTOINT(ContainerSource, snapshotHoursToKeep, 0), NULL },
	{ "snapshotDaysToKeep",						TOK_AUTOINT(ContainerSource, snapshotDaysToKeep, 0), NULL },
	{ "offlineDaysToKeep",						TOK_AUTOINT(ContainerSource, offlineDaysToKeep, 0), NULL },
	{ "pendingHoursToKeep",						TOK_AUTOINT(ContainerSource, pendingHoursToKeep, 0), NULL },
	{ "journalHoursToKeep",						TOK_AUTOINT(ContainerSource, journalHoursToKeep, 0), NULL },
	{ "skipperiodiccontainersaves",				TOK_AUTOINT(ContainerSource, skipperiodiccontainersaves, 0), NULL },
	{ "savecontainerflushperiod",				TOK_AUTOINT(ContainerSource, savecontainerflushperiod, 0), NULL },
	{ "savecontainernextflush",					TOK_AUTOINT(ContainerSource, savecontainernextflush, 0), NULL },
	{ "nextRotateTime",							TOK_AUTOINT(ContainerSource, nextRotateTime, 0), NULL },
	{ "lastRotateTime",							TOK_AUTOINT(ContainerSource, lastRotateTime, 0), NULL },
	{ "scanSnapshotTime",						TOK_AUTOINT(ContainerSource, scanSnapshotTime, 0), NULL },
	{ "scanSnapshotSeq",						TOK_AUTOINT(ContainerSource, scanSnapshotSeq, 0), NULL },
	{ "validSource",							TOK_AUTOINT(ContainerSource, validSource, 0), NULL },
	{ "useHogs",								TOK_AUTOINT(ContainerSource, useHogs, 0), NULL },
	{ "ignoreContainerSource",					TOK_AUTOINT(ContainerSource, ignoreContainerSource, 0), NULL },
	{ "forceSnapshot",							TOK_AUTOINT(ContainerSource, forceSnapshot, 0), NULL },
	{ "createSnapshot",							TOK_AUTOINT(ContainerSource, createSnapshot, 0), NULL },
	{ "generateLogReport",						TOK_AUTOINT(ContainerSource, generateLogReport, 0), NULL },
	{ "strictMerge",							TOK_AUTOINT(ContainerSource, strictMerge, 0), NULL },
	{ "unloadOnHeaderCreate",					TOK_AUTOINT(ContainerSource, unloadOnHeaderCreate, 1), NULL },
	{ "dumpWebData",							TOK_STRING(ContainerSource, dumpWebData, 0), NULL },
	{ "hogUseDiskOrder",						TOK_AUTOINT(ContainerSource, hogUseDiskOrder, 0), NULL },
	{ "containerPreloadThresholdHours",			TOK_AUTOINT(ContainerSource, containerPreloadThresholdHours, 4), NULL },
	{ "containerPlayedUnloadThresholdHours",	TOK_AUTOINT(ContainerSource, containerPlayedUnloadThresholdHours, 5), NULL },
	{ "containerAccessUnloadThresholdHours",	TOK_AUTOINT(ContainerSource, containerAccessUnloadThresholdHours, 1), NULL },
	{ "enableStaleContainerCleanup",			TOK_AUTOINT(ContainerSource, enableStaleContainerCleanup, 1), NULL },
	{ "forceUnpackThreshold",					TOK_AUTOINT(ContainerSource, forceUnpackThreshold, 0), NULL },
	{ "loadThreads",							TOK_AUTOINT(ContainerSource, loadThreads, 0), NULL },
	{ "dumpload",								TOK_AUTOINT(ContainerSource, dumpload, 0), NULL },
	{ "dumpContainerType",						TOK_AUTOINT(ContainerSource, dumpContainerType, 0), GlobalTypeEnum },
	{ "purgeHogOnFailedContainer",				TOK_AUTOINT(ContainerSource, purgeHogOnFailedContainer, 0), NULL },
	{ "needsRotate",							TOK_AUTOINT(ContainerSource, needsRotate, 0), NULL },
	{ "rotateQueued",							TOK_AUTOINT(ContainerSource, rotateQueued, 0), NULL },
	{ "}",										TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ContainerSource()
{
	int iSize = sizeof(ContainerSource);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ContainerSource, iSize, "ContainerSource", NULL, "objContainerIO.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ContainerRestoreState
#define TYPE_parse_ContainerRestoreState ContainerRestoreState
ParseTable parse_ContainerRestoreState[] =
{
	{ "ContainerRestoreState", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ContainerRestoreState), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "hog_file",				TOK_ESTRING | TOK_STRING(ContainerRestoreState, hog_file, 0), NULL },
	{ "filename",				TOK_ESTRING | TOK_STRING(ContainerRestoreState, filename, 0), NULL },
	{ "isSnap",					TOK_AUTOINT(ContainerRestoreState, isSnap, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ContainerRestoreState()
{
	int iSize = sizeof(ContainerRestoreState);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ContainerRestoreState, iSize, "ContainerRestoreState", NULL, "objContainerIO.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DatabaseFileList
#define TYPE_parse_DatabaseFileList DatabaseFileList
ParseTable parse_DatabaseFileList[] =
{
	{ "DatabaseFileList", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DatabaseFileList), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "files",				TOK_STRINGARRAY(DatabaseFileList, files), NULL , 0 , "XML_UNWRAP_ARRAY = 1"},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DatabaseFileList()
{
	int iSize = sizeof(DatabaseFileList);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DatabaseFileList, iSize, "DatabaseFileList", NULL, "objContainerIO.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ContainerRefMapping
#define TYPE_parse_ContainerRefMapping ContainerRefMapping
ParseTable parse_ContainerRefMapping[] =
{
	{ "ContainerRefMapping", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ContainerRefMapping), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "type",					TOK_AUTOINT(ContainerRefMapping, type, 0), GlobalTypeEnum },
	{ "oldID",					TOK_AUTOINT(ContainerRefMapping, oldID, 0), NULL },
	{ "newID",					TOK_AUTOINT(ContainerRefMapping, newID, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ContainerRefMapping()
{
	int iSize = sizeof(ContainerRefMapping);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ContainerRefMapping, iSize, "ContainerRefMapping", NULL, "objContainerIO.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct IncrementalLogRef
#define TYPE_parse_IncrementalLogRef IncrementalLogRef
ParseTable parse_IncrementalLogRef[] =
{
	{ "IncrementalLogRef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(IncrementalLogRef), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "sequenceNum",		TOK_AUTOINT(IncrementalLogRef, sequenceNum, 0), NULL },
	{ "time_write",			TOK_AUTOINT(IncrementalLogRef, time_write, 0), NULL },
	{ "filename",			TOK_ESTRING | TOK_STRING(IncrementalLogRef, filename, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_IncrementalLogRef()
{
	int iSize = sizeof(IncrementalLogRef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_IncrementalLogRef, iSize, "IncrementalLogRef", NULL, "objContainerIO.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
