#include "textparser.h"

//auto-generated staticdefine for enum LogParserCritterRank
//autogeneratednocheckin
StaticDefineInt LogParserCritterRankEnum[] =
{
	DEFINE_INT
	{ "Henchman", kLogParserCritterRank_Henchman},
	{ "Villain", kLogParserCritterRank_Villain},
	{ "MasterVillain", kLogParserCritterRank_MasterVillain},
	{ "SuperVillain", kLogParserCritterRank_SuperVillain},
	{ "Legendary", kLogParserCritterRank_Legendary},
	{ "Cosmic", kLogParserCritterRank_Cosmic},
	DEFINE_END
};
void autoEnum_fixup_LogParserCritterRank(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(LogParserCritterRankEnum, "LogParserCritterRank");
}

//auto-generated staticdefine for enum LogParserWorldRegionType
//autogeneratednocheckin
StaticDefineInt LogParserWorldRegionTypeEnum[] =
{
	DEFINE_INT
	{ "None", LPWRT_None},
	{ "Ground", LPWRT_Ground},
	{ "Space", LPWRT_Space},
	{ "SectorSpace", LPWRT_SectorSpace},
	{ "SystemMap", LPWRT_SystemMap},
	{ "CharacterCreator", LPWRT_CharacterCreator},
	DEFINE_END
};
void autoEnum_fixup_LogParserWorldRegionType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(LogParserWorldRegionTypeEnum, "LogParserWorldRegionType");
}

//auto-generated staticdefine for enum enumLogParsingFlags
//autogeneratednocheckin
StaticDefineInt enumLogParsingFlagsEnum[] =
{
	DEFINE_INT
	{ "LOGPARSINGFLAG_COPYRAWLOGLINE", LOGPARSINGFLAG_COPYRAWLOGLINE},
	DEFINE_END
};
void autoEnum_fixup_enumLogParsingFlags(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(enumLogParsingFlagsEnum, "enumLogParsingFlags");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct KillEventParticipant
#define TYPE_parse_KillEventParticipant KillEventParticipant
ParseTable parse_KillEventParticipant[] =
{
	{ "KillEventParticipant", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(KillEventParticipant), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Rank",					TOK_POOL_STRING | TOK_STRING(KillEventParticipant, pRank, 0), NULL },
	{ "IsPlayer",				TOK_AUTOINT(KillEventParticipant, bIsPlayer, 0), NULL },
	{ "Level",					TOK_AUTOINT(KillEventParticipant, iLevel, 0), NULL },
	{ "Name",					TOK_ESTRING | TOK_STRING(KillEventParticipant, pName, 0), NULL },
	{ "GroupName",				TOK_ESTRING | TOK_STRING(KillEventParticipant, pGroupName, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_KillEventParticipant()
{
	int iSize = sizeof(KillEventParticipant);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_KillEventParticipant, iSize, "KillEventParticipant", NULL, "LogParsing.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_KillEventParticipant[];
#define TYPE_parse_KillEventParticipant KillEventParticipant
extern ParseTable parse_KillEventParticipant[];
#define TYPE_parse_KillEventParticipant KillEventParticipant
//Structparser.exe autogenerated ParseTable for struct KillEvent
#define TYPE_parse_KillEvent KillEvent
ParseTable parse_KillEvent[] =
{
	{ "KillEvent", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(KillEvent), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "Pos",		TOK_VEC3(KillEvent, pPos), NULL },
	{ "RegionType",	TOK_AUTOINT(KillEvent, eRegionType, 0), LogParserWorldRegionTypeEnum },
	{ "Sources",	TOK_STRUCT(KillEvent, ppSources, parse_KillEventParticipant) },
	{ "Targets",	TOK_STRUCT(KillEvent, ppTargets, parse_KillEventParticipant) },
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_KillEvent()
{
	int iSize = sizeof(KillEvent);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_KillEvent, iSize, "KillEvent", NULL, "LogParsing.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemGainedEvent
#define TYPE_parse_ItemGainedEvent ItemGainedEvent
ParseTable parse_ItemGainedEvent[] =
{
	{ "ItemGainedEvent", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemGainedEvent), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "ItemName",			TOK_STRING(ItemGainedEvent, pItemName, 0), NULL },
	{ "Count",				TOK_AUTOINT(ItemGainedEvent, iCount, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemGainedEvent()
{
	int iSize = sizeof(ItemGainedEvent);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemGainedEvent, iSize, "ItemGainedEvent", NULL, "LogParsing.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct TemplateMapSingleZoneInfo
#define TYPE_parse_TemplateMapSingleZoneInfo TemplateMapSingleZoneInfo
ParseTable parse_TemplateMapSingleZoneInfo[] =
{
	{ "TemplateMapSingleZoneInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(TemplateMapSingleZoneInfo), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "ZoneMinX",					TOK_AUTOINT(TemplateMapSingleZoneInfo, iZoneMinX, 0), NULL },
	{ "ZoneMaxX",					TOK_AUTOINT(TemplateMapSingleZoneInfo, iZoneMaxX, 0), NULL },
	{ "ZoneMinZ",					TOK_AUTOINT(TemplateMapSingleZoneInfo, iZoneMinZ, 0), NULL },
	{ "ZoneMaxZ",					TOK_AUTOINT(TemplateMapSingleZoneInfo, iZoneMaxZ, 0), NULL },
	{ "MapMinX",					TOK_AUTOINT(TemplateMapSingleZoneInfo, iMapMinX, 0), NULL },
	{ "MapMaxX",					TOK_AUTOINT(TemplateMapSingleZoneInfo, iMapMaxX, 0), NULL },
	{ "MapMinY",					TOK_AUTOINT(TemplateMapSingleZoneInfo, iMapMinY, 0), NULL },
	{ "MapMaxY",					TOK_AUTOINT(TemplateMapSingleZoneInfo, iMapMaxY, 0), NULL },
	{ "ZoneName",					TOK_STRING(TemplateMapSingleZoneInfo, pZoneName, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_TemplateMapSingleZoneInfo()
{
	int iSize = sizeof(TemplateMapSingleZoneInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_TemplateMapSingleZoneInfo, iSize, "TemplateMapSingleZoneInfo", NULL, "LogParsing.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_TemplateMapSingleZoneInfo[];
#define TYPE_parse_TemplateMapSingleZoneInfo TemplateMapSingleZoneInfo
//Structparser.exe autogenerated ParseTable for struct TemplateMapInfo
#define TYPE_parse_TemplateMapInfo TemplateMapInfo
ParseTable parse_TemplateMapInfo[] =
{
	{ "TemplateMapInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(TemplateMapInfo), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Zones",				TOK_STRUCT(TemplateMapInfo, ppZones, parse_TemplateMapSingleZoneInfo) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_TemplateMapInfo()
{
	int iSize = sizeof(TemplateMapInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_TemplateMapInfo, iSize, "TemplateMapInfo", NULL, "LogParsing.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct LogParsingRestrictions
#define TYPE_parse_LogParsingRestrictions LogParsingRestrictions
ParseTable parse_LogParsingRestrictions[] =
{
	{ "LogParsingRestrictions", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(LogParsingRestrictions), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "StartingTime",					TOK_AUTOINT(LogParsingRestrictions, iStartingTime, 0), NULL , 0 , "HTML_SECS = 1"},
	{ "EndingTime",						TOK_AUTOINT(LogParsingRestrictions, iEndingTime, 0), NULL , 0 , "HTML_SECS = 1"},
	{ "MapNames",						TOK_STRINGARRAY(LogParsingRestrictions, ppMapNames), NULL },
	{ "Actions",						TOK_STRINGARRAY(LogParsingRestrictions, ppActions), NULL },
	{ "ObjNames",						TOK_STRINGARRAY(LogParsingRestrictions, ppObjNames), NULL },
	{ "OwnerNames",						TOK_STRINGARRAY(LogParsingRestrictions, ppOwnerNames), NULL },
	{ "substring",						TOK_STRINGARRAY(LogParsingRestrictions, ppSubstring), NULL },
	{ "SubstringInverse",				TOK_STRINGARRAY(LogParsingRestrictions, ppSubstringInverse), NULL },
	{ "SubstringCaseSensitive",			TOK_STRINGARRAY(LogParsingRestrictions, ppSubstringCaseSensitive), NULL },
	{ "SubstringCaseSensitiveInverse",	TOK_STRINGARRAY(LogParsingRestrictions, ppSubstringCaseSensitiveInverse), NULL },
	{ "Regex",							TOK_STRING(LogParsingRestrictions, pRegex, 0), NULL },
	{ "RegexInverse",					TOK_STRING(LogParsingRestrictions, pRegexInverse, 0), NULL },
	{ "Expression",						TOK_STRING(LogParsingRestrictions, pExpression, 0), NULL },
	{ "uObjID",							TOK_AUTOINT(LogParsingRestrictions, uObjID, 0), NULL , 0 , "HTML_SKIP = 1"},
	{ "uPlayerID",						TOK_AUTOINT(LogParsingRestrictions, uPlayerID, 0), NULL , 0 , "HTML_SKIP = 1"},
	{ "uAccountID",						TOK_AUTOINT(LogParsingRestrictions, uAccountID, 0), NULL , 0 , "HTML_SKIP = 1"},
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_LogParsingRestrictions()
{
	int iSize = sizeof(LogParsingRestrictions);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_LogParsingRestrictions, iSize, "LogParsingRestrictions", NULL, "LogParsing.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ProjSpecificParsedLogObjInfo
#define TYPE_parse_ProjSpecificParsedLogObjInfo ProjSpecificParsedLogObjInfo
ParseTable parse_ProjSpecificParsedLogObjInfo[] =
{
	{ "ProjSpecificParsedLogObjInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ProjSpecificParsedLogObjInfo), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "Key",							TOK_ESTRING | TOK_KEY | TOK_STRING(ProjSpecificParsedLogObjInfo, pKey, 0), NULL },
	{ "Val",							TOK_ESTRING | TOK_STRING(ProjSpecificParsedLogObjInfo, pVal, 0), NULL },
	{ "Value",							TOK_REDUNDANTNAME | TOK_ESTRING | TOK_STRING(ProjSpecificParsedLogObjInfo, pVal, 0), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ProjSpecificParsedLogObjInfo()
{
	int iSize = sizeof(ProjSpecificParsedLogObjInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ProjSpecificParsedLogObjInfo, iSize, "ProjSpecificParsedLogObjInfo", NULL, "LogParsing.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct LoadBalancingSingleMachineInfo
#define TYPE_parse_LoadBalancingSingleMachineInfo LoadBalancingSingleMachineInfo
ParseTable parse_LoadBalancingSingleMachineInfo[] =
{
	{ "LoadBalancingSingleMachineInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(LoadBalancingSingleMachineInfo), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "MachineName",					TOK_KEY | TOK_STRING(LoadBalancingSingleMachineInfo, pMachineName, 0), NULL },
	{ "CPU",							TOK_AUTOINT(LoadBalancingSingleMachineInfo, iCPU, 0), NULL },
	{ "CPU60",							TOK_AUTOINT(LoadBalancingSingleMachineInfo, iCPU60, 0), NULL },
	{ "FreeMegs",						TOK_AUTOINT(LoadBalancingSingleMachineInfo, iFreeMegs, 0), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_LoadBalancingSingleMachineInfo()
{
	int iSize = sizeof(LoadBalancingSingleMachineInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_LoadBalancingSingleMachineInfo, iSize, "LoadBalancingSingleMachineInfo", NULL, "LogParsing.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_LoadBalancingSingleMachineInfo[];
#define TYPE_parse_LoadBalancingSingleMachineInfo LoadBalancingSingleMachineInfo
//Structparser.exe autogenerated ParseTable for struct LoadBalancingInfo
#define TYPE_parse_LoadBalancingInfo LoadBalancingInfo
ParseTable parse_LoadBalancingInfo[] =
{
	{ "LoadBalancingInfo", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(LoadBalancingInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "LaunchServerType",		TOK_AUTOINT(LoadBalancingInfo, eLaunchServerType, 0), GlobalTypeEnum },
	{ "LaunchServerCategory",	TOK_STRING(LoadBalancingInfo, pLaunchServerCategory, 0), NULL },
	{ "PickedMachine",			TOK_STRING(LoadBalancingInfo, pPickedMachine, 0), NULL },
	{ "MachineInfo",			TOK_STRUCT(LoadBalancingInfo, ppMachineInfo, parse_LoadBalancingSingleMachineInfo) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_LoadBalancingInfo()
{
	int iSize = sizeof(LoadBalancingInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_LoadBalancingInfo, iSize, "LoadBalancingInfo", NULL, "LogParsing.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct AccessLevelCommandInfo
#define TYPE_parse_AccessLevelCommandInfo AccessLevelCommandInfo
ParseTable parse_AccessLevelCommandInfo[] =
{
	{ "AccessLevelCommandInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AccessLevelCommandInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "AccessLevel",			TOK_AUTOINT(AccessLevelCommandInfo, iAccessLevel, 0), NULL },
	{ "HowCalled",				TOK_ESTRING | TOK_STRING(AccessLevelCommandInfo, pHowCalled, 0), NULL },
	{ "CmdString",				TOK_ESTRING | TOK_STRING(AccessLevelCommandInfo, pCmdString, 0), NULL },
	{ "ResultString",			TOK_ESTRING | TOK_STRING(AccessLevelCommandInfo, pResultString, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AccessLevelCommandInfo()
{
	int iSize = sizeof(AccessLevelCommandInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AccessLevelCommandInfo, iSize, "AccessLevelCommandInfo", NULL, "LogParsing.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_GenericArray[];
#define TYPE_parse_GenericArray GenericArray
//Structparser.exe autogenerated ParseTable for struct GenericArray
#define TYPE_parse_GenericArray GenericArray
ParseTable parse_GenericArray[] =
{
	{ "GenericArray", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(GenericArray), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "array",			TOK_STRUCT(GenericArray, array, parse_GenericArray) },
	{ "integer",		TOK_AUTOINT(GenericArray, integer, 0), NULL },
	{ "floating",		TOK_F32(GenericArray, floating, 0), NULL },
	{ "string",			TOK_STRING(GenericArray, string, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_GenericArray()
{
	int iSize = sizeof(GenericArray);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_GenericArray, iSize, "GenericArray", NULL, "LogParsing.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ProjSpecificParsedLogObjInfo[];
#define TYPE_parse_ProjSpecificParsedLogObjInfo ProjSpecificParsedLogObjInfo
extern ParseTable parse_LoadBalancingInfo[];
#define TYPE_parse_LoadBalancingInfo LoadBalancingInfo
extern ParseTable parse_AccessLevelCommandInfo[];
#define TYPE_parse_AccessLevelCommandInfo AccessLevelCommandInfo
extern ParseTable parse_GenericArray[];
#define TYPE_parse_GenericArray GenericArray
//Structparser.exe autogenerated ParseTable for struct ParsedLogObjInfo
#define TYPE_parse_ParsedLogObjInfo ParsedLogObjInfo
ParseTable parse_ParsedLogObjInfo[] =
{
	{ "ParsedLogObjInfo", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ParsedLogObjInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "ObjType",				TOK_AUTOINT(ParsedLogObjInfo, eObjType, 0), GlobalTypeEnum },
	{ "ObjID",					TOK_AUTOINT(ParsedLogObjInfo, iObjID, 0), NULL },
	{ "iownerID",				TOK_AUTOINT(ParsedLogObjInfo, iownerID, 0), NULL },
	{ "ObjName",				TOK_ESTRING | TOK_STRING(ParsedLogObjInfo, pObjName, 0), NULL },
	{ "Location",				TOK_VEC3(ParsedLogObjInfo, vLocation), NULL },
	{ "OwnerName",				TOK_ESTRING | TOK_STRING(ParsedLogObjInfo, pOwnerName, 0), NULL },
	{ "Action",					TOK_POOL_STRING | TOK_STRING(ParsedLogObjInfo, pAction, 0), NULL },
	{ "ForceKept",				TOK_AUTOINT(ParsedLogObjInfo, bForceKept, 0), NULL },
	{ "ProjSpecific",			TOK_STRUCT(ParsedLogObjInfo, ppProjSpecific, parse_ProjSpecificParsedLogObjInfo) },
	{ "GameEvent",				TOK_OPTIONALLATEBINDSTRUCT(ParsedLogObjInfo, pGameEvent) },
	{ "KillEvent",				TOK_OPTIONALLATEBINDSTRUCT(ParsedLogObjInfo, pKillEvent) },
	{ "ItemGainedEvent",		TOK_OPTIONALLATEBINDSTRUCT(ParsedLogObjInfo, pItemGainedEvent) },
	{ "ShardPerf",				TOK_OPTIONALLATEBINDSTRUCT(ParsedLogObjInfo, pShardPerf) },
	{ "LongTermData",			TOK_OPTIONALLATEBINDSTRUCT(ParsedLogObjInfo, pLongTermData) },
	{ "InventoryBagSummary",	TOK_OPTIONALLATEBINDSTRUCT(ParsedLogObjInfo, pInventoryBagSummary) },
	{ "InventoryBag",			TOK_OPTIONALLATEBINDSTRUCT(ParsedLogObjInfo, pInventoryBag) },
	{ "SurveyMission",			TOK_OPTIONALLATEBINDSTRUCT(ParsedLogObjInfo, pSurveyMission) },
	{ "ClientPerf",				TOK_OPTIONALLATEBINDSTRUCT(ParsedLogObjInfo, pClientPerf) },
	{ "ControllerOverview",		TOK_OPTIONALLATEBINDSTRUCT(ParsedLogObjInfo, pControllerOverview) },
	{ "StatusReport",			TOK_OPTIONALLATEBINDSTRUCT(ParsedLogObjInfo, pStatusReport) },
	{ "LoadBalancing",			TOK_OPTIONALSTRUCT(ParsedLogObjInfo, pLoadBalancing, parse_LoadBalancingInfo) },
	{ "PatchMsgPerf",			TOK_OPTIONALLATEBINDSTRUCT(ParsedLogObjInfo, pPatchMsgPerf) },
	{ "MemTrackOps",			TOK_OPTIONALLATEBINDSTRUCT(ParsedLogObjInfo, pMemTrackOps) },
	{ "AccessLevelCommand",		TOK_OPTIONALSTRUCT(ParsedLogObjInfo, pAccessLevelCommand, parse_AccessLevelCommandInfo) },
	{ "GenericArray",			TOK_EMBEDDEDSTRUCT(ParsedLogObjInfo, pGenericArray, parse_GenericArray)},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
#define PARSE_PARSEDLOGOBJINFO_GAMEEVENT_INDEX 11
#define PARSE_PARSEDLOGOBJINFO_KILLEVENT_INDEX 12
#define PARSE_PARSEDLOGOBJINFO_ITEMGAINEDEVENT_INDEX 13
#define PARSE_PARSEDLOGOBJINFO_SHARDPERF_INDEX 14
#define PARSE_PARSEDLOGOBJINFO_LONGTERMDATA_INDEX 15
#define PARSE_PARSEDLOGOBJINFO_INVENTORYBAGSUMMARY_INDEX 16
#define PARSE_PARSEDLOGOBJINFO_INVENTORYBAG_INDEX 17
#define PARSE_PARSEDLOGOBJINFO_SURVEYMISSION_INDEX 18
#define PARSE_PARSEDLOGOBJINFO_CLIENTPERF_INDEX 19
#define PARSE_PARSEDLOGOBJINFO_CONTROLLEROVERVIEW_INDEX 20
#define PARSE_PARSEDLOGOBJINFO_STATUSREPORT_INDEX 21
#define PARSE_PARSEDLOGOBJINFO_LOADBALANCING_INDEX 22
#define PARSE_PARSEDLOGOBJINFO_PATCHMSGPERF_INDEX 23
#define PARSE_PARSEDLOGOBJINFO_MEMTRACKOPS_INDEX 24
#define PARSE_PARSEDLOGOBJINFO_GENERICARRAY_INDEX 26
typedef struct MemoryPoolImp *MemoryPool;
extern MemoryPool memPoolParsedLogObjInfo;
int autoStruct_fixup_ParsedLogObjInfo()
{
	int iSize = sizeof(ParsedLogObjInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ParsedLogObjInfo, iSize, "ParsedLogObjInfo", NULL, "LogParsing.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	ParserSetTPIUsesSingleThreadedMemPool(parse_ParsedLogObjInfo, &memPoolParsedLogObjInfo);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_ParsedLogObjInfo(void)
{
	DoAutoStructLateBind(parse_ParsedLogObjInfo, 11, "GameEvent");
	DoAutoStructLateBind(parse_ParsedLogObjInfo, 12, "KillEvent");
	DoAutoStructLateBind(parse_ParsedLogObjInfo, 13, "ItemGainedEvent");
	DoAutoStructLateBind(parse_ParsedLogObjInfo, 14, "ShardInfo_Perf");
	DoAutoStructLateBind(parse_ParsedLogObjInfo, 15, "LogParserLongTermData");
	DoAutoStructLateBind(parse_ParsedLogObjInfo, 16, "InventoryBagSummary");
	DoAutoStructLateBind(parse_ParsedLogObjInfo, 17, "InventoryBag");
	DoAutoStructLateBind(parse_ParsedLogObjInfo, 18, "IndexedPairs");
	DoAutoStructLateBind(parse_ParsedLogObjInfo, 19, "FrameCountsHistReported");
	DoAutoStructLateBind(parse_ParsedLogObjInfo, 20, "ControllerOverview");
	DoAutoStructLateBind(parse_ParsedLogObjInfo, 21, "StatusReporting_Wrapper");
	DoAutoStructLateBind(parse_ParsedLogObjInfo, 23, "PatchMsgPerfInfos");
	DoAutoStructLateBind(parse_ParsedLogObjInfo, 24, "MemTrackOpsInfo");
}
//autogeneratednocheckin
extern ParseTable parse_ParsedLog[];
#define TYPE_parse_ParsedLog ParsedLog
//Structparser.exe autogenerated ParseTable for struct LogFileGroup
#define TYPE_parse_LogFileGroup LogFileGroup
ParseTable parse_LogFileGroup[] =
{
	{ "LogFileGroup", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(LogFileGroup), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "name",			TOK_STRING(LogFileGroup, name, 0), NULL },
	{ "ParsedLogs",		TOK_STRUCT(LogFileGroup, ppParsedLogs, parse_ParsedLog) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_LogFileGroup()
{
	int iSize = sizeof(LogFileGroup);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_LogFileGroup, iSize, "LogFileGroup", NULL, "LogParsing.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_LogFileGroup[];
#define TYPE_parse_LogFileGroup LogFileGroup
extern ParseTable parse_ParsedLogObjInfo[];
#define TYPE_parse_ParsedLogObjInfo ParsedLogObjInfo
extern ParseTable parse_NameValuePair[];
#define TYPE_parse_NameValuePair NameValuePair
//Structparser.exe autogenerated ParseTable for struct ParsedLog
#define TYPE_parse_ParsedLog ParsedLog
ParseTable parse_ParsedLog[] =
{
	{ "ParsedLog", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ParsedLog), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Time",				TOK_AUTOINT(ParsedLog, iTime, 0), NULL , 0 , "HTML_SECS = 1"},
	{ "LogID",				TOK_AUTOINT(ParsedLog, iLogID, 0), NULL },
	{ "ServerType",			TOK_AUTOINT(ParsedLog, eServerType, 0), GlobalTypeEnum },
	{ "ServerID",			TOK_AUTOINT(ParsedLog, iServerID, 0), NULL },
	{ "ServerIP",			TOK_AUTOINT(ParsedLog, iServerIP, 0), NULL , 0 , "HTML_IP = 1"},
	{ "ServerPID",			TOK_AUTOINT(ParsedLog, iServerPID, 0), NULL },
	{ "MapName",			TOK_ESTRING | TOK_STRING(ParsedLog, pMapName, 0), NULL },
	{ "ExtraMapInfo",		TOK_ESTRING | TOK_STRING(ParsedLog, pExtraMapInfo, 0), NULL },
	{ "ParsedLogFlags",		TOK_AUTOINT(ParsedLog, iParsedLogFlags, 0), NULL },
	{ "FileGroup",			TOK_UNOWNED | TOK_OPTIONALSTRUCT(ParsedLog, pFileGroup, parse_LogFileGroup) },
	{ "ObjInfo",			TOK_OPTIONALSTRUCT(ParsedLog, pObjInfo, parse_ParsedLogObjInfo) },
	{ "Pairs",				TOK_STRUCT(ParsedLog, ppPairs, parse_NameValuePair) },
	{ "Message",			TOK_ESTRING | TOK_STRING(ParsedLog, pMessage, 0), NULL },
	{ "ParsingCategory",	TOK_POOL_STRING | TOK_STRING(ParsedLog, pParsingCategory, 0), NULL },
	{ "serverIdString",		TOK_FIXEDSTR(ParsedLog, serverIdString), NULL },
	{ "RawLogLine",			TOK_STRING(ParsedLog, pRawLogLine, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
typedef struct MemoryPoolImp *MemoryPool;
extern MemoryPool memPoolParsedLog;
int autoStruct_fixup_ParsedLog()
{
	int iSize = sizeof(ParsedLog);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ParsedLog, iSize, "ParsedLog", NULL, "LogParsing.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	ParserSetTPIUsesSingleThreadedMemPool(parse_ParsedLog, &memPoolParsedLog);
	return 0;
};
