#pragma once
GCC_SYSTEM

#include "ExpressionMinimal.h" // for ExprStaticCheckCategory
#include "MultiVal.h"
#include "StashTable.h"
#include "stdtypes.h"

typedef struct ExprFuncDesc		ExprFuncDesc;
typedef struct ExprFuncArg		ExprFuncArg;
typedef struct ExprFuncTable	ExprFuncTable;
typedef struct StashTableImp*	StashTable;

AUTO_STRUCT;
typedef struct ExprFuncDescContainer
{
	ExprFuncDesc **funcs;
}ExprFuncDescContainer;

AUTO_STRUCT;
typedef struct ExprFuncDescString
{
	const char* str;
}ExprFuncDescString;

AUTO_STRUCT;
typedef struct ExprFuncArg
{
	MultiValType type; AST(INT)
	const char* name;

	const char* staticCheckType;
	ParseTable* ptrType;								NO_AST	
	int allowNULLPtr;
	ExprStaticCheckCategory scTypeCategory;
	const char* ptrTypeName;
}ExprFuncArg;

AUTO_ENUM;
typedef enum ExprFuncFlags
{
	EXPR_FUNC_RQ_SELFPTR	= 1 << 0,
	EXPR_FUNC_RQ_PARTITION	= 1 << 1,
}ExprFuncFlags;

AUTO_STRUCT;
typedef struct ExprFuncDesc
{
	// runtime accessed
	int argc;

	//exprCodeEnum_AutoGen, fixed up at AUTO_RUN time 
	int eExprCodeEnum;

	//pointer directly to the expression func, for use with exprCode
	void *pExprFunc; NO_AST

	PERFINFO_TYPE* perfInfo;							NO_AST

	char* funcName;

	char *comment;

	char *pSourceFile;
	int iLineNum;

	// non-runtime data
	//size is EXPR_MAX_ALLOWED_ARGS but must be a literal int
	ExprFuncArg args[12];								AST(AUTO_INDEX(args))

	ExprFuncArg returnType;

	//size is EXPR_MAX_ALLOWED_TAGS but must be a literal int
	ExprFuncDescString tags[12];						AST(AUTO_INDEX(tags))

	F32 cost;

	//autogenerated string which describes the argument types.
	char *pExprCodeName;

	//pointer to the static check func, if any
	void *pExprStaticCheckFunc;							NO_AST

	ExprFuncFlags funcFlags;

	U8* parsedTags;										NO_AST
}ExprFuncDesc;

typedef struct ExprFuncTag
{
	// statically initialized data
	const char* name;

	U32 allowSelfPtr : 1;
	U32 allowPartition : 1;

	// runtime data
	U32 tagNum;

	ExprFuncDesc** functions;

	U32 usingSelfPtr : 1;
	U32 usingPartition: 1;
}ExprFuncTag;

//AUTO_STRUCTed purely for servermonitoring purposes, do NOT structCreate/structDestroy
//
//These will show up in ServerMonitor only when BeginExpressionServerMonitoring() is called

AUTO_STRUCT AST_FORMATSTRING(HTML_DEF_FIELDS_TO_SHOW = "NumExprFuncs, Funcs, DesignerNames");
typedef struct ExprFuncTable
{
	char *pName;

	//servermon debugging only... names that designers might use to describe this
	char **ppDesignerNames;

	U8* allowedTags; NO_AST

	U32 requireSelfPtr : 1; NO_AST
	U32 requirePartition : 1; NO_AST

	// debug data
	ExprFuncTag* selfPtrTag; NO_AST
	ExprFuncTag* partitionTag; NO_AST

	//stuff used only for servermonitoring

	//note that iNumFunctions might not at all mean what you think. Particularly because on the client
	//this will count both server and client- exprFuncs, even though the server exprFuncs aren't present at all
	int iNumExprFuncs;
	char *pFuncs; AST(ESTRING FORMATSTRING(HTML=1))
}ExprFuncTable;


void exprRegisterFunction(ExprFuncDesc* desc, int checkDuplicates, bool bFunctionWontBeExecuted);
void exprRegisterFunctionTable(ExprFuncDesc* exprTable, size_t numEntries, bool bFunctionWontBeExecuted);
void exprUnregisterFunctionTable(ExprFuncDesc* exprTable, size_t numEntries);
SA_RET_NN_VALID ExprFuncDescContainer *exprGetAllFuncs(void);
bool exprTagUsingSelfPtr(const char *tagStr);
bool exprTagUsingPartition(const char *tagStr);

#define TAG_LIST_BYTES 8

extern StashTable globalFuncTable;

__forceinline static bool exprAllowedToUseFunc(ExprFuncTable* funcTable, ExprFuncDesc* funcDesc)
{
	int i;
	for(i = 0; i < TAG_LIST_BYTES; i++)
	{
		if(funcTable->allowedTags[i] & funcDesc->parsedTags[i])
			return true;
	}
	return false;
}

__forceinline static ExprFuncDesc* exprGetFuncDesc(ExprFuncTable* funcTable, const char* funcName)
{
	ExprFuncDesc* funcDesc = NULL;

	stashAddressFindPointer(globalFuncTable, funcName, &funcDesc);

	if(funcDesc && funcTable)
	{
		if(exprAllowedToUseFunc(funcTable, funcDesc))
			return funcDesc;
		else
			return NULL;
	}

	return funcDesc;
}

// Returns true if the things of type source can be passed to type dest
bool exprFuncCanArgBeConverted(ExprFuncArg *pSource, ExprFuncArg *pDest);

U32 exprFuncGetCRC(const char *pchFuncName);

typedef S64 (*S64IntFunc)(int i);
void exprSetPartitionTimeCallback(S64IntFunc cb);

//stashtable of all exprFunctAbles
extern StashTable sFuncTablesByName;