/* VindiciaStructsC.c
   Generated by gSOAP 2.7.11 from .\3.4\vindiciaStructsTemp.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "VindiciaStructsH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) VindiciaStructsC.c ver 2.7.11 2010-01-07 00:32:35 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header));
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_vin__AVSMatchType:
		return soap_in_vin__AVSMatchType(soap, NULL, NULL, "vin:AVSMatchType");
	case SOAP_TYPE_vin__TransactionStatusType:
		return soap_in_vin__TransactionStatusType(soap, NULL, NULL, "vin:TransactionStatusType");
	case SOAP_TYPE_vin__TaxRegion:
		return soap_in_vin__TaxRegion(soap, NULL, NULL, "vin:TaxRegion");
	case SOAP_TYPE_vin__ReturnCode:
		return soap_in_vin__ReturnCode(soap, NULL, NULL, "vin:ReturnCode");
	case SOAP_TYPE_vin__RefundTokenAction:
		return soap_in_vin__RefundTokenAction(soap, NULL, NULL, "vin:RefundTokenAction");
	case SOAP_TYPE_vin__TaxClassification:
		return soap_in_vin__TaxClassification(soap, NULL, NULL, "vin:TaxClassification");
	case SOAP_TYPE_vin__ProductStatus:
		return soap_in_vin__ProductStatus(soap, NULL, NULL, "vin:ProductStatus");
	case SOAP_TYPE_vin__ECPTransactionType:
		return soap_in_vin__ECPTransactionType(soap, NULL, NULL, "vin:ECPTransactionType");
	case SOAP_TYPE_vin__AccountType:
		return soap_in_vin__AccountType(soap, NULL, NULL, "vin:AccountType");
	case SOAP_TYPE_vin__HashType:
		return soap_in_vin__HashType(soap, NULL, NULL, "vin:HashType");
	case SOAP_TYPE_vin__PaymentMethodType:
		return soap_in_vin__PaymentMethodType(soap, NULL, NULL, "vin:PaymentMethodType");
	case SOAP_TYPE_vin__MetricStatusType:
		return soap_in_vin__MetricStatusType(soap, NULL, NULL, "vin:MetricStatusType");
	case SOAP_TYPE_vin__EmailTemplateType:
		return soap_in_vin__EmailTemplateType(soap, NULL, NULL, "vin:EmailTemplateType");
	case SOAP_TYPE_vin__ChargebackStatus:
		return soap_in_vin__ChargebackStatus(soap, NULL, NULL, "vin:ChargebackStatus");
	case SOAP_TYPE_vin__BillingPlanStatus:
		return soap_in_vin__BillingPlanStatus(soap, NULL, NULL, "vin:BillingPlanStatus");
	case SOAP_TYPE_vin__BillingPeriodType:
		return soap_in_vin__BillingPeriodType(soap, NULL, NULL, "vin:BillingPeriodType");
	case SOAP_TYPE_vin__DuplicateBehavior:
		return soap_in_vin__DuplicateBehavior(soap, NULL, NULL, "vin:DuplicateBehavior");
	case SOAP_TYPE_vin__AutoBillStatus:
		return soap_in_vin__AutoBillStatus(soap, NULL, NULL, "vin:AutoBillStatus");
	case SOAP_TYPE_vin__AddressType:
		return soap_in_vin__AddressType(soap, NULL, NULL, "vin:AddressType");
	case SOAP_TYPE_vin__ActivityCallType:
		return soap_in_vin__ActivityCallType(soap, NULL, NULL, "vin:ActivityCallType");
	case SOAP_TYPE_vin__ActivityType:
		return soap_in_vin__ActivityType(soap, NULL, NULL, "vin:ActivityType");
	case SOAP_TYPE_vin__ActivityCancelInitType:
		return soap_in_vin__ActivityCancelInitType(soap, NULL, NULL, "vin:ActivityCancelInitType");
	case SOAP_TYPE_vin__PaymentUpdateBehavior:
		return soap_in_vin__PaymentUpdateBehavior(soap, NULL, NULL, "vin:PaymentUpdateBehavior");
	case SOAP_TYPE_vin__EmailPreference:
		return soap_in_vin__EmailPreference(soap, NULL, NULL, "vin:EmailPreference");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_trn__score:
		return soap_in_trn__score(soap, NULL, NULL, "trn:score");
	case SOAP_TYPE_trn__scoreResponse:
		return soap_in_trn__scoreResponse(soap, NULL, NULL, "trn:scoreResponse");
	case SOAP_TYPE_trn__report:
		return soap_in_trn__report(soap, NULL, NULL, "trn:report");
	case SOAP_TYPE_trn__reportResponse:
		return soap_in_trn__reportResponse(soap, NULL, NULL, "trn:reportResponse");
	case SOAP_TYPE_trn__authCapture:
		return soap_in_trn__authCapture(soap, NULL, NULL, "trn:authCapture");
	case SOAP_TYPE_trn__authCaptureResponse:
		return soap_in_trn__authCaptureResponse(soap, NULL, NULL, "trn:authCaptureResponse");
	case SOAP_TYPE_trn__cancel:
		return soap_in_trn__cancel(soap, NULL, NULL, "trn:cancel");
	case SOAP_TYPE_trn__cancelResponse:
		return soap_in_trn__cancelResponse(soap, NULL, NULL, "trn:cancelResponse");
	case SOAP_TYPE_trn__capture:
		return soap_in_trn__capture(soap, NULL, NULL, "trn:capture");
	case SOAP_TYPE_trn__captureResponse:
		return soap_in_trn__captureResponse(soap, NULL, NULL, "trn:captureResponse");
	case SOAP_TYPE_trn__calculateSalesTax:
		return soap_in_trn__calculateSalesTax(soap, NULL, NULL, "trn:calculateSalesTax");
	case SOAP_TYPE_trn__calculateSalesTaxResponse:
		return soap_in_trn__calculateSalesTaxResponse(soap, NULL, NULL, "trn:calculateSalesTaxResponse");
	case SOAP_TYPE_trn__auth:
		return soap_in_trn__auth(soap, NULL, NULL, "trn:auth");
	case SOAP_TYPE_trn__authResponse:
		return soap_in_trn__authResponse(soap, NULL, NULL, "trn:authResponse");
	case SOAP_TYPE_trn__fetchByPaymentMethod:
		return soap_in_trn__fetchByPaymentMethod(soap, NULL, NULL, "trn:fetchByPaymentMethod");
	case SOAP_TYPE_trn__fetchByPaymentMethodResponse:
		return soap_in_trn__fetchByPaymentMethodResponse(soap, NULL, NULL, "trn:fetchByPaymentMethodResponse");
	case SOAP_TYPE_trn__fetchSearchPage:
		return soap_in_trn__fetchSearchPage(soap, NULL, NULL, "trn:fetchSearchPage");
	case SOAP_TYPE_trn__fetchSearchPageResponse:
		return soap_in_trn__fetchSearchPageResponse(soap, NULL, NULL, "trn:fetchSearchPageResponse");
	case SOAP_TYPE_trn__fetchByAutobill:
		return soap_in_trn__fetchByAutobill(soap, NULL, NULL, "trn:fetchByAutobill");
	case SOAP_TYPE_trn__fetchByAutobillResponse:
		return soap_in_trn__fetchByAutobillResponse(soap, NULL, NULL, "trn:fetchByAutobillResponse");
	case SOAP_TYPE_trn__fetchDelta:
		return soap_in_trn__fetchDelta(soap, NULL, NULL, "trn:fetchDelta");
	case SOAP_TYPE_trn__fetchDeltaResponse:
		return soap_in_trn__fetchDeltaResponse(soap, NULL, NULL, "trn:fetchDeltaResponse");
	case SOAP_TYPE_trn__fetchDeltaSince:
		return soap_in_trn__fetchDeltaSince(soap, NULL, NULL, "trn:fetchDeltaSince");
	case SOAP_TYPE_trn__fetchDeltaSinceResponse:
		return soap_in_trn__fetchDeltaSinceResponse(soap, NULL, NULL, "trn:fetchDeltaSinceResponse");
	case SOAP_TYPE_trn__fetchByMerchantTransactionId:
		return soap_in_trn__fetchByMerchantTransactionId(soap, NULL, NULL, "trn:fetchByMerchantTransactionId");
	case SOAP_TYPE_trn__fetchByMerchantTransactionIdResponse:
		return soap_in_trn__fetchByMerchantTransactionIdResponse(soap, NULL, NULL, "trn:fetchByMerchantTransactionIdResponse");
	case SOAP_TYPE_trn__fetchByAccount:
		return soap_in_trn__fetchByAccount(soap, NULL, NULL, "trn:fetchByAccount");
	case SOAP_TYPE_trn__fetchByAccountResponse:
		return soap_in_trn__fetchByAccountResponse(soap, NULL, NULL, "trn:fetchByAccountResponse");
	case SOAP_TYPE_trn__fetchByVid:
		return soap_in_trn__fetchByVid(soap, NULL, NULL, "trn:fetchByVid");
	case SOAP_TYPE_trn__fetchByVidResponse:
		return soap_in_trn__fetchByVidResponse(soap, NULL, NULL, "trn:fetchByVidResponse");
	case SOAP_TYPE_rfd__perform:
		return soap_in_rfd__perform(soap, NULL, NULL, "rfd:perform");
	case SOAP_TYPE_rfd__performResponse:
		return soap_in_rfd__performResponse(soap, NULL, NULL, "rfd:performResponse");
	case SOAP_TYPE_rfd__report:
		return soap_in_rfd__report(soap, NULL, NULL, "rfd:report");
	case SOAP_TYPE_rfd__reportResponse:
		return soap_in_rfd__reportResponse(soap, NULL, NULL, "rfd:reportResponse");
	case SOAP_TYPE_rfd__fetchDeltaSince:
		return soap_in_rfd__fetchDeltaSince(soap, NULL, NULL, "rfd:fetchDeltaSince");
	case SOAP_TYPE_rfd__fetchDeltaSinceResponse:
		return soap_in_rfd__fetchDeltaSinceResponse(soap, NULL, NULL, "rfd:fetchDeltaSinceResponse");
	case SOAP_TYPE_rfd__fetchByTransaction:
		return soap_in_rfd__fetchByTransaction(soap, NULL, NULL, "rfd:fetchByTransaction");
	case SOAP_TYPE_rfd__fetchByTransactionResponse:
		return soap_in_rfd__fetchByTransactionResponse(soap, NULL, NULL, "rfd:fetchByTransactionResponse");
	case SOAP_TYPE_rfd__fetchByAccount:
		return soap_in_rfd__fetchByAccount(soap, NULL, NULL, "rfd:fetchByAccount");
	case SOAP_TYPE_rfd__fetchByAccountResponse:
		return soap_in_rfd__fetchByAccountResponse(soap, NULL, NULL, "rfd:fetchByAccountResponse");
	case SOAP_TYPE_rfd__fetchByVid:
		return soap_in_rfd__fetchByVid(soap, NULL, NULL, "rfd:fetchByVid");
	case SOAP_TYPE_rfd__fetchByVidResponse:
		return soap_in_rfd__fetchByVidResponse(soap, NULL, NULL, "rfd:fetchByVidResponse");
	case SOAP_TYPE_pyp__fetchByVid:
		return soap_in_pyp__fetchByVid(soap, NULL, NULL, "pyp:fetchByVid");
	case SOAP_TYPE_pyp__fetchByVidResponse:
		return soap_in_pyp__fetchByVidResponse(soap, NULL, NULL, "pyp:fetchByVidResponse");
	case SOAP_TYPE_pyp__update:
		return soap_in_pyp__update(soap, NULL, NULL, "pyp:update");
	case SOAP_TYPE_pyp__updateResponse:
		return soap_in_pyp__updateResponse(soap, NULL, NULL, "pyp:updateResponse");
	case SOAP_TYPE_pym__validate:
		return soap_in_pym__validate(soap, NULL, NULL, "pym:validate");
	case SOAP_TYPE_pym__validateResponse:
		return soap_in_pym__validateResponse(soap, NULL, NULL, "pym:validateResponse");
	case SOAP_TYPE_pym__fetchByMerchantPaymentMethodId:
		return soap_in_pym__fetchByMerchantPaymentMethodId(soap, NULL, NULL, "pym:fetchByMerchantPaymentMethodId");
	case SOAP_TYPE_pym__fetchByMerchantPaymentMethodIdResponse:
		return soap_in_pym__fetchByMerchantPaymentMethodIdResponse(soap, NULL, NULL, "pym:fetchByMerchantPaymentMethodIdResponse");
	case SOAP_TYPE_pym__fetchByAccount:
		return soap_in_pym__fetchByAccount(soap, NULL, NULL, "pym:fetchByAccount");
	case SOAP_TYPE_pym__fetchByAccountResponse:
		return soap_in_pym__fetchByAccountResponse(soap, NULL, NULL, "pym:fetchByAccountResponse");
	case SOAP_TYPE_pym__fetchByVid:
		return soap_in_pym__fetchByVid(soap, NULL, NULL, "pym:fetchByVid");
	case SOAP_TYPE_pym__fetchByVidResponse:
		return soap_in_pym__fetchByVidResponse(soap, NULL, NULL, "pym:fetchByVidResponse");
	case SOAP_TYPE_pym__update:
		return soap_in_pym__update(soap, NULL, NULL, "pym:update");
	case SOAP_TYPE_pym__updateResponse:
		return soap_in_pym__updateResponse(soap, NULL, NULL, "pym:updateResponse");
	case SOAP_TYPE_prd__fetchByMerchantEntitlementId:
		return soap_in_prd__fetchByMerchantEntitlementId(soap, NULL, NULL, "prd:fetchByMerchantEntitlementId");
	case SOAP_TYPE_prd__fetchByMerchantEntitlementIdResponse:
		return soap_in_prd__fetchByMerchantEntitlementIdResponse(soap, NULL, NULL, "prd:fetchByMerchantEntitlementIdResponse");
	case SOAP_TYPE_prd__fetchAll:
		return soap_in_prd__fetchAll(soap, NULL, NULL, "prd:fetchAll");
	case SOAP_TYPE_prd__fetchAllResponse:
		return soap_in_prd__fetchAllResponse(soap, NULL, NULL, "prd:fetchAllResponse");
	case SOAP_TYPE_prd__fetchByAccount:
		return soap_in_prd__fetchByAccount(soap, NULL, NULL, "prd:fetchByAccount");
	case SOAP_TYPE_prd__fetchByAccountResponse:
		return soap_in_prd__fetchByAccountResponse(soap, NULL, NULL, "prd:fetchByAccountResponse");
	case SOAP_TYPE_prd__fetchByMerchantProductId:
		return soap_in_prd__fetchByMerchantProductId(soap, NULL, NULL, "prd:fetchByMerchantProductId");
	case SOAP_TYPE_prd__fetchByMerchantProductIdResponse:
		return soap_in_prd__fetchByMerchantProductIdResponse(soap, NULL, NULL, "prd:fetchByMerchantProductIdResponse");
	case SOAP_TYPE_prd__fetchByVid:
		return soap_in_prd__fetchByVid(soap, NULL, NULL, "prd:fetchByVid");
	case SOAP_TYPE_prd__fetchByVidResponse:
		return soap_in_prd__fetchByVidResponse(soap, NULL, NULL, "prd:fetchByVidResponse");
	case SOAP_TYPE_prd__update:
		return soap_in_prd__update(soap, NULL, NULL, "prd:update");
	case SOAP_TYPE_prd__updateResponse:
		return soap_in_prd__updateResponse(soap, NULL, NULL, "prd:updateResponse");
	case SOAP_TYPE_met__report:
		return soap_in_met__report(soap, NULL, NULL, "met:report");
	case SOAP_TYPE_met__reportResponse:
		return soap_in_met__reportResponse(soap, NULL, NULL, "met:reportResponse");
	case SOAP_TYPE_etp__fetchByTypeAndVersion:
		return soap_in_etp__fetchByTypeAndVersion(soap, NULL, NULL, "etp:fetchByTypeAndVersion");
	case SOAP_TYPE_etp__fetchByTypeAndVersionResponse:
		return soap_in_etp__fetchByTypeAndVersionResponse(soap, NULL, NULL, "etp:fetchByTypeAndVersionResponse");
	case SOAP_TYPE_etp__fetchByType:
		return soap_in_etp__fetchByType(soap, NULL, NULL, "etp:fetchByType");
	case SOAP_TYPE_etp__fetchByTypeResponse:
		return soap_in_etp__fetchByTypeResponse(soap, NULL, NULL, "etp:fetchByTypeResponse");
	case SOAP_TYPE_etp__fetchByProduct:
		return soap_in_etp__fetchByProduct(soap, NULL, NULL, "etp:fetchByProduct");
	case SOAP_TYPE_etp__fetchByProductResponse:
		return soap_in_etp__fetchByProductResponse(soap, NULL, NULL, "etp:fetchByProductResponse");
	case SOAP_TYPE_etp__fetchByVid:
		return soap_in_etp__fetchByVid(soap, NULL, NULL, "etp:fetchByVid");
	case SOAP_TYPE_etp__fetchByVidResponse:
		return soap_in_etp__fetchByVidResponse(soap, NULL, NULL, "etp:fetchByVidResponse");
	case SOAP_TYPE_etp__update:
		return soap_in_etp__update(soap, NULL, NULL, "etp:update");
	case SOAP_TYPE_etp__updateResponse:
		return soap_in_etp__updateResponse(soap, NULL, NULL, "etp:updateResponse");
	case SOAP_TYPE_ent__fetchDeltaSince:
		return soap_in_ent__fetchDeltaSince(soap, NULL, NULL, "ent:fetchDeltaSince");
	case SOAP_TYPE_ent__fetchDeltaSinceResponse:
		return soap_in_ent__fetchDeltaSinceResponse(soap, NULL, NULL, "ent:fetchDeltaSinceResponse");
	case SOAP_TYPE_ent__fetchByAccount:
		return soap_in_ent__fetchByAccount(soap, NULL, NULL, "ent:fetchByAccount");
	case SOAP_TYPE_ent__fetchByAccountResponse:
		return soap_in_ent__fetchByAccountResponse(soap, NULL, NULL, "ent:fetchByAccountResponse");
	case SOAP_TYPE_ent__fetchByEntitlementIdAndAccount:
		return soap_in_ent__fetchByEntitlementIdAndAccount(soap, NULL, NULL, "ent:fetchByEntitlementIdAndAccount");
	case SOAP_TYPE_ent__fetchByEntitlementIdAndAccountResponse:
		return soap_in_ent__fetchByEntitlementIdAndAccountResponse(soap, NULL, NULL, "ent:fetchByEntitlementIdAndAccountResponse");
	case SOAP_TYPE_ecs__getSignatureBlock:
		return soap_in_ecs__getSignatureBlock(soap, NULL, NULL, "ecs:getSignatureBlock");
	case SOAP_TYPE_ecs__getSignatureBlockResponse:
		return soap_in_ecs__getSignatureBlockResponse(soap, NULL, NULL, "ecs:getSignatureBlockResponse");
	case SOAP_TYPE_ecs__sign:
		return soap_in_ecs__sign(soap, NULL, NULL, "ecs:sign");
	case SOAP_TYPE_ecs__signResponse:
		return soap_in_ecs__signResponse(soap, NULL, NULL, "ecs:signResponse");
	case SOAP_TYPE_cgb__report:
		return soap_in_cgb__report(soap, NULL, NULL, "cgb:report");
	case SOAP_TYPE_cgb__reportResponse:
		return soap_in_cgb__reportResponse(soap, NULL, NULL, "cgb:reportResponse");
	case SOAP_TYPE_cgb__fetchDelta:
		return soap_in_cgb__fetchDelta(soap, NULL, NULL, "cgb:fetchDelta");
	case SOAP_TYPE_cgb__fetchDeltaResponse:
		return soap_in_cgb__fetchDeltaResponse(soap, NULL, NULL, "cgb:fetchDeltaResponse");
	case SOAP_TYPE_cgb__fetchDeltaSince:
		return soap_in_cgb__fetchDeltaSince(soap, NULL, NULL, "cgb:fetchDeltaSince");
	case SOAP_TYPE_cgb__fetchDeltaSinceResponse:
		return soap_in_cgb__fetchDeltaSinceResponse(soap, NULL, NULL, "cgb:fetchDeltaSinceResponse");
	case SOAP_TYPE_cgb__fetchByMerchantTransactionId:
		return soap_in_cgb__fetchByMerchantTransactionId(soap, NULL, NULL, "cgb:fetchByMerchantTransactionId");
	case SOAP_TYPE_cgb__fetchByMerchantTransactionIdResponse:
		return soap_in_cgb__fetchByMerchantTransactionIdResponse(soap, NULL, NULL, "cgb:fetchByMerchantTransactionIdResponse");
	case SOAP_TYPE_cgb__fetchByStatusSince:
		return soap_in_cgb__fetchByStatusSince(soap, NULL, NULL, "cgb:fetchByStatusSince");
	case SOAP_TYPE_cgb__fetchByStatusSinceResponse:
		return soap_in_cgb__fetchByStatusSinceResponse(soap, NULL, NULL, "cgb:fetchByStatusSinceResponse");
	case SOAP_TYPE_cgb__fetchByStatus:
		return soap_in_cgb__fetchByStatus(soap, NULL, NULL, "cgb:fetchByStatus");
	case SOAP_TYPE_cgb__fetchByStatusResponse:
		return soap_in_cgb__fetchByStatusResponse(soap, NULL, NULL, "cgb:fetchByStatusResponse");
	case SOAP_TYPE_cgb__fetchByReferenceNumber:
		return soap_in_cgb__fetchByReferenceNumber(soap, NULL, NULL, "cgb:fetchByReferenceNumber");
	case SOAP_TYPE_cgb__fetchByReferenceNumberResponse:
		return soap_in_cgb__fetchByReferenceNumberResponse(soap, NULL, NULL, "cgb:fetchByReferenceNumberResponse");
	case SOAP_TYPE_cgb__fetchByCaseNumber:
		return soap_in_cgb__fetchByCaseNumber(soap, NULL, NULL, "cgb:fetchByCaseNumber");
	case SOAP_TYPE_cgb__fetchByCaseNumberResponse:
		return soap_in_cgb__fetchByCaseNumberResponse(soap, NULL, NULL, "cgb:fetchByCaseNumberResponse");
	case SOAP_TYPE_cgb__fetchByAccount:
		return soap_in_cgb__fetchByAccount(soap, NULL, NULL, "cgb:fetchByAccount");
	case SOAP_TYPE_cgb__fetchByAccountResponse:
		return soap_in_cgb__fetchByAccountResponse(soap, NULL, NULL, "cgb:fetchByAccountResponse");
	case SOAP_TYPE_cgb__fetchByVid:
		return soap_in_cgb__fetchByVid(soap, NULL, NULL, "cgb:fetchByVid");
	case SOAP_TYPE_cgb__fetchByVidResponse:
		return soap_in_cgb__fetchByVidResponse(soap, NULL, NULL, "cgb:fetchByVidResponse");
	case SOAP_TYPE_cgb__update:
		return soap_in_cgb__update(soap, NULL, NULL, "cgb:update");
	case SOAP_TYPE_cgb__updateResponse:
		return soap_in_cgb__updateResponse(soap, NULL, NULL, "cgb:updateResponse");
	case SOAP_TYPE_bpl__fetchByMerchantEntitlementId:
		return soap_in_bpl__fetchByMerchantEntitlementId(soap, NULL, NULL, "bpl:fetchByMerchantEntitlementId");
	case SOAP_TYPE_bpl__fetchByMerchantEntitlementIdResponse:
		return soap_in_bpl__fetchByMerchantEntitlementIdResponse(soap, NULL, NULL, "bpl:fetchByMerchantEntitlementIdResponse");
	case SOAP_TYPE_bpl__fetchAll:
		return soap_in_bpl__fetchAll(soap, NULL, NULL, "bpl:fetchAll");
	case SOAP_TYPE_bpl__fetchAllResponse:
		return soap_in_bpl__fetchAllResponse(soap, NULL, NULL, "bpl:fetchAllResponse");
	case SOAP_TYPE_bpl__fetchByBillingPlanStatus:
		return soap_in_bpl__fetchByBillingPlanStatus(soap, NULL, NULL, "bpl:fetchByBillingPlanStatus");
	case SOAP_TYPE_bpl__fetchByBillingPlanStatusResponse:
		return soap_in_bpl__fetchByBillingPlanStatusResponse(soap, NULL, NULL, "bpl:fetchByBillingPlanStatusResponse");
	case SOAP_TYPE_bpl__fetchByMerchantBillingPlanId:
		return soap_in_bpl__fetchByMerchantBillingPlanId(soap, NULL, NULL, "bpl:fetchByMerchantBillingPlanId");
	case SOAP_TYPE_bpl__fetchByMerchantBillingPlanIdResponse:
		return soap_in_bpl__fetchByMerchantBillingPlanIdResponse(soap, NULL, NULL, "bpl:fetchByMerchantBillingPlanIdResponse");
	case SOAP_TYPE_bpl__fetchByVid:
		return soap_in_bpl__fetchByVid(soap, NULL, NULL, "bpl:fetchByVid");
	case SOAP_TYPE_bpl__fetchByVidResponse:
		return soap_in_bpl__fetchByVidResponse(soap, NULL, NULL, "bpl:fetchByVidResponse");
	case SOAP_TYPE_bpl__update:
		return soap_in_bpl__update(soap, NULL, NULL, "bpl:update");
	case SOAP_TYPE_bpl__updateResponse:
		return soap_in_bpl__updateResponse(soap, NULL, NULL, "bpl:updateResponse");
	case SOAP_TYPE_add__fetchByVid:
		return soap_in_add__fetchByVid(soap, NULL, NULL, "add:fetchByVid");
	case SOAP_TYPE_add__fetchByVidResponse:
		return soap_in_add__fetchByVidResponse(soap, NULL, NULL, "add:fetchByVidResponse");
	case SOAP_TYPE_add__update:
		return soap_in_add__update(soap, NULL, NULL, "add:update");
	case SOAP_TYPE_add__updateResponse:
		return soap_in_add__updateResponse(soap, NULL, NULL, "add:updateResponse");
	case SOAP_TYPE_act__record:
		return soap_in_act__record(soap, NULL, NULL, "act:record");
	case SOAP_TYPE_act__recordResponse:
		return soap_in_act__recordResponse(soap, NULL, NULL, "act:recordResponse");
	case SOAP_TYPE_acc__transfer:
		return soap_in_acc__transfer(soap, NULL, NULL, "acc:transfer");
	case SOAP_TYPE_acc__transferResponse:
		return soap_in_acc__transferResponse(soap, NULL, NULL, "acc:transferResponse");
	case SOAP_TYPE_acc__decrementTokens:
		return soap_in_acc__decrementTokens(soap, NULL, NULL, "acc:decrementTokens");
	case SOAP_TYPE_acc__decrementTokensResponse:
		return soap_in_acc__decrementTokensResponse(soap, NULL, NULL, "acc:decrementTokensResponse");
	case SOAP_TYPE_acc__incrementTokens:
		return soap_in_acc__incrementTokens(soap, NULL, NULL, "acc:incrementTokens");
	case SOAP_TYPE_acc__incrementTokensResponse:
		return soap_in_acc__incrementTokensResponse(soap, NULL, NULL, "acc:incrementTokensResponse");
	case SOAP_TYPE_acc__tokenTransaction:
		return soap_in_acc__tokenTransaction(soap, NULL, NULL, "acc:tokenTransaction");
	case SOAP_TYPE_acc__tokenTransactionResponse:
		return soap_in_acc__tokenTransactionResponse(soap, NULL, NULL, "acc:tokenTransactionResponse");
	case SOAP_TYPE_acc__tokenBalance:
		return soap_in_acc__tokenBalance(soap, NULL, NULL, "acc:tokenBalance");
	case SOAP_TYPE_acc__tokenBalanceResponse:
		return soap_in_acc__tokenBalanceResponse(soap, NULL, NULL, "acc:tokenBalanceResponse");
	case SOAP_TYPE_acc__fetchByPaymentMethod:
		return soap_in_acc__fetchByPaymentMethod(soap, NULL, NULL, "acc:fetchByPaymentMethod");
	case SOAP_TYPE_acc__fetchByPaymentMethodResponse:
		return soap_in_acc__fetchByPaymentMethodResponse(soap, NULL, NULL, "acc:fetchByPaymentMethodResponse");
	case SOAP_TYPE_acc__fetchByEmail:
		return soap_in_acc__fetchByEmail(soap, NULL, NULL, "acc:fetchByEmail");
	case SOAP_TYPE_acc__fetchByEmailResponse:
		return soap_in_acc__fetchByEmailResponse(soap, NULL, NULL, "acc:fetchByEmailResponse");
	case SOAP_TYPE_acc__fetchByVid:
		return soap_in_acc__fetchByVid(soap, NULL, NULL, "acc:fetchByVid");
	case SOAP_TYPE_acc__fetchByVidResponse:
		return soap_in_acc__fetchByVidResponse(soap, NULL, NULL, "acc:fetchByVidResponse");
	case SOAP_TYPE_acc__fetchByMerchantAccountId:
		return soap_in_acc__fetchByMerchantAccountId(soap, NULL, NULL, "acc:fetchByMerchantAccountId");
	case SOAP_TYPE_acc__fetchByMerchantAccountIdResponse:
		return soap_in_acc__fetchByMerchantAccountIdResponse(soap, NULL, NULL, "acc:fetchByMerchantAccountIdResponse");
	case SOAP_TYPE_acc__updatePaymentMethod:
		return soap_in_acc__updatePaymentMethod(soap, NULL, NULL, "acc:updatePaymentMethod");
	case SOAP_TYPE_acc__updatePaymentMethodResponse:
		return soap_in_acc__updatePaymentMethodResponse(soap, NULL, NULL, "acc:updatePaymentMethodResponse");
	case SOAP_TYPE_acc__stopAutoBilling:
		return soap_in_acc__stopAutoBilling(soap, NULL, NULL, "acc:stopAutoBilling");
	case SOAP_TYPE_acc__stopAutoBillingResponse:
		return soap_in_acc__stopAutoBillingResponse(soap, NULL, NULL, "acc:stopAutoBillingResponse");
	case SOAP_TYPE_acc__update:
		return soap_in_acc__update(soap, NULL, NULL, "acc:update");
	case SOAP_TYPE_acc__updateResponse:
		return soap_in_acc__updateResponse(soap, NULL, NULL, "acc:updateResponse");
	case SOAP_TYPE_abl__fetchDeltaSince:
		return soap_in_abl__fetchDeltaSince(soap, NULL, NULL, "abl:fetchDeltaSince");
	case SOAP_TYPE_abl__fetchDeltaSinceResponse:
		return soap_in_abl__fetchDeltaSinceResponse(soap, NULL, NULL, "abl:fetchDeltaSinceResponse");
	case SOAP_TYPE_abl__futureRebills:
		return soap_in_abl__futureRebills(soap, NULL, NULL, "abl:futureRebills");
	case SOAP_TYPE_abl__futureRebillsResponse:
		return soap_in_abl__futureRebillsResponse(soap, NULL, NULL, "abl:futureRebillsResponse");
	case SOAP_TYPE_abl__fetchByAccount:
		return soap_in_abl__fetchByAccount(soap, NULL, NULL, "abl:fetchByAccount");
	case SOAP_TYPE_abl__fetchByAccountResponse:
		return soap_in_abl__fetchByAccountResponse(soap, NULL, NULL, "abl:fetchByAccountResponse");
	case SOAP_TYPE_abl__fetchByEmail:
		return soap_in_abl__fetchByEmail(soap, NULL, NULL, "abl:fetchByEmail");
	case SOAP_TYPE_abl__fetchByEmailResponse:
		return soap_in_abl__fetchByEmailResponse(soap, NULL, NULL, "abl:fetchByEmailResponse");
	case SOAP_TYPE_abl__fetchByVid:
		return soap_in_abl__fetchByVid(soap, NULL, NULL, "abl:fetchByVid");
	case SOAP_TYPE_abl__fetchByVidResponse:
		return soap_in_abl__fetchByVidResponse(soap, NULL, NULL, "abl:fetchByVidResponse");
	case SOAP_TYPE_abl__fetchByMerchantAutoBillId:
		return soap_in_abl__fetchByMerchantAutoBillId(soap, NULL, NULL, "abl:fetchByMerchantAutoBillId");
	case SOAP_TYPE_abl__fetchByMerchantAutoBillIdResponse:
		return soap_in_abl__fetchByMerchantAutoBillIdResponse(soap, NULL, NULL, "abl:fetchByMerchantAutoBillIdResponse");
	case SOAP_TYPE_abl__fetchByAccountAndProduct:
		return soap_in_abl__fetchByAccountAndProduct(soap, NULL, NULL, "abl:fetchByAccountAndProduct");
	case SOAP_TYPE_abl__fetchByAccountAndProductResponse:
		return soap_in_abl__fetchByAccountAndProductResponse(soap, NULL, NULL, "abl:fetchByAccountAndProductResponse");
	case SOAP_TYPE_abl__changeBillingDayOfMonth:
		return soap_in_abl__changeBillingDayOfMonth(soap, NULL, NULL, "abl:changeBillingDayOfMonth");
	case SOAP_TYPE_abl__changeBillingDayOfMonthResponse:
		return soap_in_abl__changeBillingDayOfMonthResponse(soap, NULL, NULL, "abl:changeBillingDayOfMonthResponse");
	case SOAP_TYPE_abl__delayBillingByDays:
		return soap_in_abl__delayBillingByDays(soap, NULL, NULL, "abl:delayBillingByDays");
	case SOAP_TYPE_abl__delayBillingByDaysResponse:
		return soap_in_abl__delayBillingByDaysResponse(soap, NULL, NULL, "abl:delayBillingByDaysResponse");
	case SOAP_TYPE_abl__delayBillingToDate:
		return soap_in_abl__delayBillingToDate(soap, NULL, NULL, "abl:delayBillingToDate");
	case SOAP_TYPE_abl__delayBillingToDateResponse:
		return soap_in_abl__delayBillingToDateResponse(soap, NULL, NULL, "abl:delayBillingToDateResponse");
	case SOAP_TYPE_abl__cancel:
		return soap_in_abl__cancel(soap, NULL, NULL, "abl:cancel");
	case SOAP_TYPE_abl__cancelResponse:
		return soap_in_abl__cancelResponse(soap, NULL, NULL, "abl:cancelResponse");
	case SOAP_TYPE_abl__update:
		return soap_in_abl__update(soap, NULL, NULL, "abl:update");
	case SOAP_TYPE_abl__updateResponse:
		return soap_in_abl__updateResponse(soap, NULL, NULL, "abl:updateResponse");
	case SOAP_TYPE_ArrayOfScoreCodes:
		return soap_in_ArrayOfScoreCodes(soap, NULL, NULL, "vin:ScoreCode");
	case SOAP_TYPE_ArrayOfCancelResults:
		return soap_in_ArrayOfCancelResults(soap, NULL, NULL, "vin:CancelResult");
	case SOAP_TYPE_ArrayOfCaptureResults:
		return soap_in_ArrayOfCaptureResults(soap, NULL, NULL, "vin:CaptureResult");
	case SOAP_TYPE_ArrayOfTokenTransactions:
		return soap_in_ArrayOfTokenTransactions(soap, NULL, NULL, "vin:TokenTransaction");
	case SOAP_TYPE_ArrayOfTokens:
		return soap_in_ArrayOfTokens(soap, NULL, NULL, "vin:Token");
	case SOAP_TYPE_ArrayOfTaxExemption:
		return soap_in_ArrayOfTaxExemption(soap, NULL, NULL, "vin:TaxExemption");
	case SOAP_TYPE_ArrayOfSalesTaxes:
		return soap_in_ArrayOfSalesTaxes(soap, NULL, NULL, "vin:SalesTax");
	case SOAP_TYPE_ArrayOfRefunds:
		return soap_in_ArrayOfRefunds(soap, NULL, NULL, "vin:Refund");
	case SOAP_TYPE_ArrayOfProducts:
		return soap_in_ArrayOfProducts(soap, NULL, NULL, "vin:Product");
	case SOAP_TYPE_ArrayOfMetricStats:
		return soap_in_ArrayOfMetricStats(soap, NULL, NULL, "vin:MetricStatistics");
	case SOAP_TYPE_ArrayOfEntitlements:
		return soap_in_ArrayOfEntitlements(soap, NULL, NULL, "vin:Entitlement");
	case SOAP_TYPE_ArrayOfEmailTemplates:
		return soap_in_ArrayOfEmailTemplates(soap, NULL, NULL, "vin:EmailTemplate");
	case SOAP_TYPE_ArrayOfChargebacks:
		return soap_in_ArrayOfChargebacks(soap, NULL, NULL, "vin:Chargeback");
	case SOAP_TYPE_ArrayOfBillingPlans:
		return soap_in_ArrayOfBillingPlans(soap, NULL, NULL, "vin:BillingPlan");
	case SOAP_TYPE_ArrayOfAutoBills:
		return soap_in_ArrayOfAutoBills(soap, NULL, NULL, "vin:AutoBill");
	case SOAP_TYPE_ArrayOfActivities:
		return soap_in_ArrayOfActivities(soap, NULL, NULL, "vin:Activity");
	case SOAP_TYPE_ArrayOfAccounts:
		return soap_in_ArrayOfAccounts(soap, NULL, NULL, "vin:Account");
	case SOAP_TYPE_ArrayOfTransactionItems:
		return soap_in_ArrayOfTransactionItems(soap, NULL, NULL, "vin:TransactionItem");
	case SOAP_TYPE_ArrayOfTransactionStatuses:
		return soap_in_ArrayOfTransactionStatuses(soap, NULL, NULL, "vin:TransactionStatus");
	case SOAP_TYPE_vin__TransactionStatusDirectDebit:
		return soap_in_vin__TransactionStatusDirectDebit(soap, NULL, NULL, "vin:TransactionStatusDirectDebit");
	case SOAP_TYPE_vin__TransactionStatusPayPal:
		return soap_in_vin__TransactionStatusPayPal(soap, NULL, NULL, "vin:TransactionStatusPayPal");
	case SOAP_TYPE_vin__TransactionStatusBoleto:
		return soap_in_vin__TransactionStatusBoleto(soap, NULL, NULL, "vin:TransactionStatusBoleto");
	case SOAP_TYPE_vin__TransactionStatusECP:
		return soap_in_vin__TransactionStatusECP(soap, NULL, NULL, "vin:TransactionStatusECP");
	case SOAP_TYPE_vin__TransactionStatusCreditCard:
		return soap_in_vin__TransactionStatusCreditCard(soap, NULL, NULL, "vin:TransactionStatusCreditCard");
	case SOAP_TYPE_vin__TransactionStatus:
		return soap_in_vin__TransactionStatus(soap, NULL, NULL, "vin:TransactionStatus");
	case SOAP_TYPE_vin__TransactionItem:
		return soap_in_vin__TransactionItem(soap, NULL, NULL, "vin:TransactionItem");
	case SOAP_TYPE_vin__ScoreCode:
		return soap_in_vin__ScoreCode(soap, NULL, NULL, "vin:ScoreCode");
	case SOAP_TYPE_vin__CancelResult:
		return soap_in_vin__CancelResult(soap, NULL, NULL, "vin:CancelResult");
	case SOAP_TYPE_vin__CaptureResult:
		return soap_in_vin__CaptureResult(soap, NULL, NULL, "vin:CaptureResult");
	case SOAP_TYPE_vin__TokenTransaction:
		return soap_in_vin__TokenTransaction(soap, NULL, NULL, "vin:TokenTransaction");
	case SOAP_TYPE_vin__SalesTax:
		return soap_in_vin__SalesTax(soap, NULL, NULL, "vin:SalesTax");
	case SOAP_TYPE_vin__TaxExemption:
		return soap_in_vin__TaxExemption(soap, NULL, NULL, "vin:TaxExemption");
	case SOAP_TYPE_vin__Return:
		return soap_in_vin__Return(soap, NULL, NULL, "vin:Return");
	case SOAP_TYPE_vin__Refund:
		return soap_in_vin__Refund(soap, NULL, NULL, "vin:Refund");
	case SOAP_TYPE_vin__NameValuePair:
		return soap_in_vin__NameValuePair(soap, NULL, NULL, "vin:NameValuePair");
	case SOAP_TYPE_vin__MerchantEntitlementId:
		return soap_in_vin__MerchantEntitlementId(soap, NULL, NULL, "vin:MerchantEntitlementId");
	case SOAP_TYPE_vin__PaymentProvider:
		return soap_in_vin__PaymentProvider(soap, NULL, NULL, "vin:PaymentProvider");
	case SOAP_TYPE_vin__Token:
		return soap_in_vin__Token(soap, NULL, NULL, "vin:Token");
	case SOAP_TYPE_vin__Boleto:
		return soap_in_vin__Boleto(soap, NULL, NULL, "vin:Boleto");
	case SOAP_TYPE_vin__PayPal:
		return soap_in_vin__PayPal(soap, NULL, NULL, "vin:PayPal");
	case SOAP_TYPE_vin__DirectDebit:
		return soap_in_vin__DirectDebit(soap, NULL, NULL, "vin:DirectDebit");
	case SOAP_TYPE_vin__ECP:
		return soap_in_vin__ECP(soap, NULL, NULL, "vin:ECP");
	case SOAP_TYPE_vin__CreditCard:
		return soap_in_vin__CreditCard(soap, NULL, NULL, "vin:CreditCard");
	case SOAP_TYPE_vin__MetricStatistics:
		return soap_in_vin__MetricStatistics(soap, NULL, NULL, "vin:MetricStatistics");
	case SOAP_TYPE_vin__Entitlement:
		return soap_in_vin__Entitlement(soap, NULL, NULL, "vin:Entitlement");
	case SOAP_TYPE_vin__EmailTemplate:
		return soap_in_vin__EmailTemplate(soap, NULL, NULL, "vin:EmailTemplate");
	case SOAP_TYPE_vin__Transaction:
		return soap_in_vin__Transaction(soap, NULL, NULL, "vin:Transaction");
	case SOAP_TYPE_vin__ElectronicSignature:
		return soap_in_vin__ElectronicSignature(soap, NULL, NULL, "vin:ElectronicSignature");
	case SOAP_TYPE_vin__Chargeback:
		return soap_in_vin__Chargeback(soap, NULL, NULL, "vin:Chargeback");
	case SOAP_TYPE_ArrayOfMerchantEntitlementIds:
		return soap_in_ArrayOfMerchantEntitlementIds(soap, NULL, NULL, "vin:MerchantEntitlementId");
	case SOAP_TYPE_ArrayOfBillingPlanPeriods:
		return soap_in_ArrayOfBillingPlanPeriods(soap, NULL, NULL, "vin:BillingPlanPeriod");
	case SOAP_TYPE_ArrayOfBillingPlanPrices:
		return soap_in_ArrayOfBillingPlanPrices(soap, NULL, NULL, "vin:BillingPlanPrice");
	case SOAP_TYPE_vin__BillingPlanPeriod:
		return soap_in_vin__BillingPlanPeriod(soap, NULL, NULL, "vin:BillingPlanPeriod");
	case SOAP_TYPE_vin__TokenAmount:
		return soap_in_vin__TokenAmount(soap, NULL, NULL, "vin:TokenAmount");
	case SOAP_TYPE_vin__BillingPlanPrice:
		return soap_in_vin__BillingPlanPrice(soap, NULL, NULL, "vin:BillingPlanPrice");
	case SOAP_TYPE_ArrayOfTransactions:
		return soap_in_ArrayOfTransactions(soap, NULL, NULL, "vin:Transaction");
	case SOAP_TYPE_vin__PaymentMethod:
		return soap_in_vin__PaymentMethod(soap, NULL, NULL, "vin:PaymentMethod");
	case SOAP_TYPE_vin__BillingPlan:
		return soap_in_vin__BillingPlan(soap, NULL, NULL, "vin:BillingPlan");
	case SOAP_TYPE_vin__Product:
		return soap_in_vin__Product(soap, NULL, NULL, "vin:Product");
	case SOAP_TYPE_vin__AutoBill:
		return soap_in_vin__AutoBill(soap, NULL, NULL, "vin:AutoBill");
	case SOAP_TYPE_vin__Authentication:
		return soap_in_vin__Authentication(soap, NULL, NULL, "vin:Authentication");
	case SOAP_TYPE_vin__Activity:
		return soap_in_vin__Activity(soap, NULL, NULL, "vin:Activity");
	case SOAP_TYPE_vin__ActivityNote:
		return soap_in_vin__ActivityNote(soap, NULL, NULL, "vin:ActivityNote");
	case SOAP_TYPE_vin__ActivityCancellation:
		return soap_in_vin__ActivityCancellation(soap, NULL, NULL, "vin:ActivityCancellation");
	case SOAP_TYPE_vin__ActivityNamedValue:
		return soap_in_vin__ActivityNamedValue(soap, NULL, NULL, "vin:ActivityNamedValue");
	case SOAP_TYPE_vin__ActivityUsage:
		return soap_in_vin__ActivityUsage(soap, NULL, NULL, "vin:ActivityUsage");
	case SOAP_TYPE_vin__ActivityFulfillment:
		return soap_in_vin__ActivityFulfillment(soap, NULL, NULL, "vin:ActivityFulfillment");
	case SOAP_TYPE_vin__ActivityEmailContact:
		return soap_in_vin__ActivityEmailContact(soap, NULL, NULL, "vin:ActivityEmailContact");
	case SOAP_TYPE_vin__ActivityPhoneContact:
		return soap_in_vin__ActivityPhoneContact(soap, NULL, NULL, "vin:ActivityPhoneContact");
	case SOAP_TYPE_vin__ActivityURIView:
		return soap_in_vin__ActivityURIView(soap, NULL, NULL, "vin:ActivityURIView");
	case SOAP_TYPE_vin__ActivityLogout:
		return soap_in_vin__ActivityLogout(soap, NULL, NULL, "vin:ActivityLogout");
	case SOAP_TYPE_vin__ActivityLogin:
		return soap_in_vin__ActivityLogin(soap, NULL, NULL, "vin:ActivityLogin");
	case SOAP_TYPE_vin__ActivityTypeArg:
		return soap_in_vin__ActivityTypeArg(soap, NULL, NULL, "vin:ActivityTypeArg");
	case SOAP_TYPE_ArrayOfTokenAmounts:
		return soap_in_ArrayOfTokenAmounts(soap, NULL, NULL, "vin:TokenAmount");
	case SOAP_TYPE_ArrayOfTaxExemptions:
		return soap_in_ArrayOfTaxExemptions(soap, NULL, NULL, "vin:TaxExemption");
	case SOAP_TYPE_ArrayOfNameValuePairs:
		return soap_in_ArrayOfNameValuePairs(soap, NULL, NULL, "vin:NameValuePair");
	case SOAP_TYPE_ArrayOfPaymentMethods:
		return soap_in_ArrayOfPaymentMethods(soap, NULL, NULL, "vin:PaymentMethod");
	case SOAP_TYPE_vin__Address:
		return soap_in_vin__Address(soap, NULL, NULL, "vin:Address");
	case SOAP_TYPE_vin__Account:
		return soap_in_vin__Account(soap, NULL, NULL, "vin:Account");
	case SOAP_TYPE_PointerTotrn__scoreResponse:
		return soap_in_PointerTotrn__scoreResponse(soap, NULL, NULL, "trn:scoreResponse");
	case SOAP_TYPE_PointerToArrayOfScoreCodes:
		return soap_in_PointerToArrayOfScoreCodes(soap, NULL, NULL, "vin:ScoreCode");
	case SOAP_TYPE_PointerTotrn__reportResponse:
		return soap_in_PointerTotrn__reportResponse(soap, NULL, NULL, "trn:reportResponse");
	case SOAP_TYPE_PointerTotrn__authCaptureResponse:
		return soap_in_PointerTotrn__authCaptureResponse(soap, NULL, NULL, "trn:authCaptureResponse");
	case SOAP_TYPE_PointerTotrn__cancelResponse:
		return soap_in_PointerTotrn__cancelResponse(soap, NULL, NULL, "trn:cancelResponse");
	case SOAP_TYPE_PointerToArrayOfCancelResults:
		return soap_in_PointerToArrayOfCancelResults(soap, NULL, NULL, "vin:CancelResult");
	case SOAP_TYPE_PointerTotrn__captureResponse:
		return soap_in_PointerTotrn__captureResponse(soap, NULL, NULL, "trn:captureResponse");
	case SOAP_TYPE_PointerToArrayOfCaptureResults:
		return soap_in_PointerToArrayOfCaptureResults(soap, NULL, NULL, "vin:CaptureResult");
	case SOAP_TYPE_PointerTotrn__calculateSalesTaxResponse:
		return soap_in_PointerTotrn__calculateSalesTaxResponse(soap, NULL, NULL, "trn:calculateSalesTaxResponse");
	case SOAP_TYPE_PointerToArrayOfSalesTaxes:
		return soap_in_PointerToArrayOfSalesTaxes(soap, NULL, NULL, "vin:SalesTax");
	case SOAP_TYPE_PointerTotrn__authResponse:
		return soap_in_PointerTotrn__authResponse(soap, NULL, NULL, "trn:authResponse");
	case SOAP_TYPE_PointerTotrn__fetchByPaymentMethodResponse:
		return soap_in_PointerTotrn__fetchByPaymentMethodResponse(soap, NULL, NULL, "trn:fetchByPaymentMethodResponse");
	case SOAP_TYPE_PointerTotrn__fetchSearchPageResponse:
		return soap_in_PointerTotrn__fetchSearchPageResponse(soap, NULL, NULL, "trn:fetchSearchPageResponse");
	case SOAP_TYPE_PointerTotrn__fetchByAutobillResponse:
		return soap_in_PointerTotrn__fetchByAutobillResponse(soap, NULL, NULL, "trn:fetchByAutobillResponse");
	case SOAP_TYPE_PointerTotrn__fetchDeltaResponse:
		return soap_in_PointerTotrn__fetchDeltaResponse(soap, NULL, NULL, "trn:fetchDeltaResponse");
	case SOAP_TYPE_PointerTotrn__fetchDeltaSinceResponse:
		return soap_in_PointerTotrn__fetchDeltaSinceResponse(soap, NULL, NULL, "trn:fetchDeltaSinceResponse");
	case SOAP_TYPE_PointerTotrn__fetchByMerchantTransactionIdResponse:
		return soap_in_PointerTotrn__fetchByMerchantTransactionIdResponse(soap, NULL, NULL, "trn:fetchByMerchantTransactionIdResponse");
	case SOAP_TYPE_PointerTotrn__fetchByAccountResponse:
		return soap_in_PointerTotrn__fetchByAccountResponse(soap, NULL, NULL, "trn:fetchByAccountResponse");
	case SOAP_TYPE_PointerTotrn__fetchByVidResponse:
		return soap_in_PointerTotrn__fetchByVidResponse(soap, NULL, NULL, "trn:fetchByVidResponse");
	case SOAP_TYPE_PointerTorfd__performResponse:
		return soap_in_PointerTorfd__performResponse(soap, NULL, NULL, "rfd:performResponse");
	case SOAP_TYPE_PointerTorfd__reportResponse:
		return soap_in_PointerTorfd__reportResponse(soap, NULL, NULL, "rfd:reportResponse");
	case SOAP_TYPE_PointerTorfd__fetchDeltaSinceResponse:
		return soap_in_PointerTorfd__fetchDeltaSinceResponse(soap, NULL, NULL, "rfd:fetchDeltaSinceResponse");
	case SOAP_TYPE_PointerTorfd__fetchByTransactionResponse:
		return soap_in_PointerTorfd__fetchByTransactionResponse(soap, NULL, NULL, "rfd:fetchByTransactionResponse");
	case SOAP_TYPE_PointerTorfd__fetchByAccountResponse:
		return soap_in_PointerTorfd__fetchByAccountResponse(soap, NULL, NULL, "rfd:fetchByAccountResponse");
	case SOAP_TYPE_PointerToArrayOfRefunds:
		return soap_in_PointerToArrayOfRefunds(soap, NULL, NULL, "vin:Refund");
	case SOAP_TYPE_PointerTorfd__fetchByVidResponse:
		return soap_in_PointerTorfd__fetchByVidResponse(soap, NULL, NULL, "rfd:fetchByVidResponse");
	case SOAP_TYPE_PointerTopyp__fetchByVidResponse:
		return soap_in_PointerTopyp__fetchByVidResponse(soap, NULL, NULL, "pyp:fetchByVidResponse");
	case SOAP_TYPE_PointerTopyp__updateResponse:
		return soap_in_PointerTopyp__updateResponse(soap, NULL, NULL, "pyp:updateResponse");
	case SOAP_TYPE_PointerTovin__PaymentProvider:
		return soap_in_PointerTovin__PaymentProvider(soap, NULL, NULL, "vin:PaymentProvider");
	case SOAP_TYPE_PointerTopym__validateResponse:
		return soap_in_PointerTopym__validateResponse(soap, NULL, NULL, "pym:validateResponse");
	case SOAP_TYPE_PointerTopym__fetchByMerchantPaymentMethodIdResponse:
		return soap_in_PointerTopym__fetchByMerchantPaymentMethodIdResponse(soap, NULL, NULL, "pym:fetchByMerchantPaymentMethodIdResponse");
	case SOAP_TYPE_PointerTopym__fetchByAccountResponse:
		return soap_in_PointerTopym__fetchByAccountResponse(soap, NULL, NULL, "pym:fetchByAccountResponse");
	case SOAP_TYPE_PointerTopym__fetchByVidResponse:
		return soap_in_PointerTopym__fetchByVidResponse(soap, NULL, NULL, "pym:fetchByVidResponse");
	case SOAP_TYPE_PointerTopym__updateResponse:
		return soap_in_PointerTopym__updateResponse(soap, NULL, NULL, "pym:updateResponse");
	case SOAP_TYPE_PointerToprd__fetchByMerchantEntitlementIdResponse:
		return soap_in_PointerToprd__fetchByMerchantEntitlementIdResponse(soap, NULL, NULL, "prd:fetchByMerchantEntitlementIdResponse");
	case SOAP_TYPE_PointerToprd__fetchAllResponse:
		return soap_in_PointerToprd__fetchAllResponse(soap, NULL, NULL, "prd:fetchAllResponse");
	case SOAP_TYPE_PointerToprd__fetchByAccountResponse:
		return soap_in_PointerToprd__fetchByAccountResponse(soap, NULL, NULL, "prd:fetchByAccountResponse");
	case SOAP_TYPE_PointerToArrayOfProducts:
		return soap_in_PointerToArrayOfProducts(soap, NULL, NULL, "vin:Product");
	case SOAP_TYPE_PointerToprd__fetchByMerchantProductIdResponse:
		return soap_in_PointerToprd__fetchByMerchantProductIdResponse(soap, NULL, NULL, "prd:fetchByMerchantProductIdResponse");
	case SOAP_TYPE_PointerToprd__fetchByVidResponse:
		return soap_in_PointerToprd__fetchByVidResponse(soap, NULL, NULL, "prd:fetchByVidResponse");
	case SOAP_TYPE_PointerToprd__updateResponse:
		return soap_in_PointerToprd__updateResponse(soap, NULL, NULL, "prd:updateResponse");
	case SOAP_TYPE_PointerTomet__reportResponse:
		return soap_in_PointerTomet__reportResponse(soap, NULL, NULL, "met:reportResponse");
	case SOAP_TYPE_PointerToArrayOfMetricStats:
		return soap_in_PointerToArrayOfMetricStats(soap, NULL, NULL, "vin:MetricStatistics");
	case SOAP_TYPE_PointerToetp__fetchByTypeAndVersionResponse:
		return soap_in_PointerToetp__fetchByTypeAndVersionResponse(soap, NULL, NULL, "etp:fetchByTypeAndVersionResponse");
	case SOAP_TYPE_PointerToetp__fetchByTypeResponse:
		return soap_in_PointerToetp__fetchByTypeResponse(soap, NULL, NULL, "etp:fetchByTypeResponse");
	case SOAP_TYPE_PointerToetp__fetchByProductResponse:
		return soap_in_PointerToetp__fetchByProductResponse(soap, NULL, NULL, "etp:fetchByProductResponse");
	case SOAP_TYPE_PointerToArrayOfEmailTemplates:
		return soap_in_PointerToArrayOfEmailTemplates(soap, NULL, NULL, "vin:EmailTemplate");
	case SOAP_TYPE_PointerToetp__fetchByVidResponse:
		return soap_in_PointerToetp__fetchByVidResponse(soap, NULL, NULL, "etp:fetchByVidResponse");
	case SOAP_TYPE_PointerToetp__updateResponse:
		return soap_in_PointerToetp__updateResponse(soap, NULL, NULL, "etp:updateResponse");
	case SOAP_TYPE_PointerToent__fetchDeltaSinceResponse:
		return soap_in_PointerToent__fetchDeltaSinceResponse(soap, NULL, NULL, "ent:fetchDeltaSinceResponse");
	case SOAP_TYPE_PointerToent__fetchByAccountResponse:
		return soap_in_PointerToent__fetchByAccountResponse(soap, NULL, NULL, "ent:fetchByAccountResponse");
	case SOAP_TYPE_PointerToArrayOfEntitlements:
		return soap_in_PointerToArrayOfEntitlements(soap, NULL, NULL, "vin:Entitlement");
	case SOAP_TYPE_PointerToent__fetchByEntitlementIdAndAccountResponse:
		return soap_in_PointerToent__fetchByEntitlementIdAndAccountResponse(soap, NULL, NULL, "ent:fetchByEntitlementIdAndAccountResponse");
	case SOAP_TYPE_PointerToecs__getSignatureBlockResponse:
		return soap_in_PointerToecs__getSignatureBlockResponse(soap, NULL, NULL, "ecs:getSignatureBlockResponse");
	case SOAP_TYPE_PointerToecs__signResponse:
		return soap_in_PointerToecs__signResponse(soap, NULL, NULL, "ecs:signResponse");
	case SOAP_TYPE_PointerTovin__ElectronicSignature:
		return soap_in_PointerTovin__ElectronicSignature(soap, NULL, NULL, "vin:ElectronicSignature");
	case SOAP_TYPE_PointerTocgb__reportResponse:
		return soap_in_PointerTocgb__reportResponse(soap, NULL, NULL, "cgb:reportResponse");
	case SOAP_TYPE_PointerTocgb__fetchDeltaResponse:
		return soap_in_PointerTocgb__fetchDeltaResponse(soap, NULL, NULL, "cgb:fetchDeltaResponse");
	case SOAP_TYPE_PointerTocgb__fetchDeltaSinceResponse:
		return soap_in_PointerTocgb__fetchDeltaSinceResponse(soap, NULL, NULL, "cgb:fetchDeltaSinceResponse");
	case SOAP_TYPE_PointerTocgb__fetchByMerchantTransactionIdResponse:
		return soap_in_PointerTocgb__fetchByMerchantTransactionIdResponse(soap, NULL, NULL, "cgb:fetchByMerchantTransactionIdResponse");
	case SOAP_TYPE_PointerTocgb__fetchByStatusSinceResponse:
		return soap_in_PointerTocgb__fetchByStatusSinceResponse(soap, NULL, NULL, "cgb:fetchByStatusSinceResponse");
	case SOAP_TYPE_PointerTocgb__fetchByStatusResponse:
		return soap_in_PointerTocgb__fetchByStatusResponse(soap, NULL, NULL, "cgb:fetchByStatusResponse");
	case SOAP_TYPE_PointerTocgb__fetchByReferenceNumberResponse:
		return soap_in_PointerTocgb__fetchByReferenceNumberResponse(soap, NULL, NULL, "cgb:fetchByReferenceNumberResponse");
	case SOAP_TYPE_PointerTocgb__fetchByCaseNumberResponse:
		return soap_in_PointerTocgb__fetchByCaseNumberResponse(soap, NULL, NULL, "cgb:fetchByCaseNumberResponse");
	case SOAP_TYPE_PointerTocgb__fetchByAccountResponse:
		return soap_in_PointerTocgb__fetchByAccountResponse(soap, NULL, NULL, "cgb:fetchByAccountResponse");
	case SOAP_TYPE_PointerToArrayOfChargebacks:
		return soap_in_PointerToArrayOfChargebacks(soap, NULL, NULL, "vin:Chargeback");
	case SOAP_TYPE_PointerTocgb__fetchByVidResponse:
		return soap_in_PointerTocgb__fetchByVidResponse(soap, NULL, NULL, "cgb:fetchByVidResponse");
	case SOAP_TYPE_PointerTocgb__updateResponse:
		return soap_in_PointerTocgb__updateResponse(soap, NULL, NULL, "cgb:updateResponse");
	case SOAP_TYPE_PointerTobpl__fetchByMerchantEntitlementIdResponse:
		return soap_in_PointerTobpl__fetchByMerchantEntitlementIdResponse(soap, NULL, NULL, "bpl:fetchByMerchantEntitlementIdResponse");
	case SOAP_TYPE_PointerTobpl__fetchAllResponse:
		return soap_in_PointerTobpl__fetchAllResponse(soap, NULL, NULL, "bpl:fetchAllResponse");
	case SOAP_TYPE_PointerTobpl__fetchByBillingPlanStatusResponse:
		return soap_in_PointerTobpl__fetchByBillingPlanStatusResponse(soap, NULL, NULL, "bpl:fetchByBillingPlanStatusResponse");
	case SOAP_TYPE_PointerToArrayOfBillingPlans:
		return soap_in_PointerToArrayOfBillingPlans(soap, NULL, NULL, "vin:BillingPlan");
	case SOAP_TYPE_PointerTobpl__fetchByMerchantBillingPlanIdResponse:
		return soap_in_PointerTobpl__fetchByMerchantBillingPlanIdResponse(soap, NULL, NULL, "bpl:fetchByMerchantBillingPlanIdResponse");
	case SOAP_TYPE_PointerTobpl__fetchByVidResponse:
		return soap_in_PointerTobpl__fetchByVidResponse(soap, NULL, NULL, "bpl:fetchByVidResponse");
	case SOAP_TYPE_PointerTobpl__updateResponse:
		return soap_in_PointerTobpl__updateResponse(soap, NULL, NULL, "bpl:updateResponse");
	case SOAP_TYPE_PointerToadd__fetchByVidResponse:
		return soap_in_PointerToadd__fetchByVidResponse(soap, NULL, NULL, "add:fetchByVidResponse");
	case SOAP_TYPE_PointerToadd__updateResponse:
		return soap_in_PointerToadd__updateResponse(soap, NULL, NULL, "add:updateResponse");
	case SOAP_TYPE_PointerToact__recordResponse:
		return soap_in_PointerToact__recordResponse(soap, NULL, NULL, "act:recordResponse");
	case SOAP_TYPE_PointerToArrayOfActivities:
		return soap_in_PointerToArrayOfActivities(soap, NULL, NULL, "vin:Activity");
	case SOAP_TYPE_PointerToacc__transferResponse:
		return soap_in_PointerToacc__transferResponse(soap, NULL, NULL, "acc:transferResponse");
	case SOAP_TYPE_PointerToacc__decrementTokensResponse:
		return soap_in_PointerToacc__decrementTokensResponse(soap, NULL, NULL, "acc:decrementTokensResponse");
	case SOAP_TYPE_PointerToacc__incrementTokensResponse:
		return soap_in_PointerToacc__incrementTokensResponse(soap, NULL, NULL, "acc:incrementTokensResponse");
	case SOAP_TYPE_PointerToacc__tokenTransactionResponse:
		return soap_in_PointerToacc__tokenTransactionResponse(soap, NULL, NULL, "acc:tokenTransactionResponse");
	case SOAP_TYPE_PointerToArrayOfTokenTransactions:
		return soap_in_PointerToArrayOfTokenTransactions(soap, NULL, NULL, "vin:TokenTransaction");
	case SOAP_TYPE_PointerToacc__tokenBalanceResponse:
		return soap_in_PointerToacc__tokenBalanceResponse(soap, NULL, NULL, "acc:tokenBalanceResponse");
	case SOAP_TYPE_PointerToArrayOfTokens:
		return soap_in_PointerToArrayOfTokens(soap, NULL, NULL, "vin:Token");
	case SOAP_TYPE_PointerToacc__fetchByPaymentMethodResponse:
		return soap_in_PointerToacc__fetchByPaymentMethodResponse(soap, NULL, NULL, "acc:fetchByPaymentMethodResponse");
	case SOAP_TYPE_PointerToacc__fetchByEmailResponse:
		return soap_in_PointerToacc__fetchByEmailResponse(soap, NULL, NULL, "acc:fetchByEmailResponse");
	case SOAP_TYPE_PointerToArrayOfAccounts:
		return soap_in_PointerToArrayOfAccounts(soap, NULL, NULL, "vin:Account");
	case SOAP_TYPE_PointerToacc__fetchByVidResponse:
		return soap_in_PointerToacc__fetchByVidResponse(soap, NULL, NULL, "acc:fetchByVidResponse");
	case SOAP_TYPE_PointerToacc__fetchByMerchantAccountIdResponse:
		return soap_in_PointerToacc__fetchByMerchantAccountIdResponse(soap, NULL, NULL, "acc:fetchByMerchantAccountIdResponse");
	case SOAP_TYPE_PointerToacc__updatePaymentMethodResponse:
		return soap_in_PointerToacc__updatePaymentMethodResponse(soap, NULL, NULL, "acc:updatePaymentMethodResponse");
	case SOAP_TYPE_PointerToacc__stopAutoBillingResponse:
		return soap_in_PointerToacc__stopAutoBillingResponse(soap, NULL, NULL, "acc:stopAutoBillingResponse");
	case SOAP_TYPE_PointerToacc__updateResponse:
		return soap_in_PointerToacc__updateResponse(soap, NULL, NULL, "acc:updateResponse");
	case SOAP_TYPE_PointerToabl__fetchDeltaSinceResponse:
		return soap_in_PointerToabl__fetchDeltaSinceResponse(soap, NULL, NULL, "abl:fetchDeltaSinceResponse");
	case SOAP_TYPE_PointerToabl__futureRebillsResponse:
		return soap_in_PointerToabl__futureRebillsResponse(soap, NULL, NULL, "abl:futureRebillsResponse");
	case SOAP_TYPE_PointerToabl__fetchByAccountResponse:
		return soap_in_PointerToabl__fetchByAccountResponse(soap, NULL, NULL, "abl:fetchByAccountResponse");
	case SOAP_TYPE_PointerToabl__fetchByEmailResponse:
		return soap_in_PointerToabl__fetchByEmailResponse(soap, NULL, NULL, "abl:fetchByEmailResponse");
	case SOAP_TYPE_PointerToabl__fetchByVidResponse:
		return soap_in_PointerToabl__fetchByVidResponse(soap, NULL, NULL, "abl:fetchByVidResponse");
	case SOAP_TYPE_PointerToabl__fetchByMerchantAutoBillIdResponse:
		return soap_in_PointerToabl__fetchByMerchantAutoBillIdResponse(soap, NULL, NULL, "abl:fetchByMerchantAutoBillIdResponse");
	case SOAP_TYPE_PointerToabl__fetchByAccountAndProductResponse:
		return soap_in_PointerToabl__fetchByAccountAndProductResponse(soap, NULL, NULL, "abl:fetchByAccountAndProductResponse");
	case SOAP_TYPE_PointerToArrayOfAutoBills:
		return soap_in_PointerToArrayOfAutoBills(soap, NULL, NULL, "vin:AutoBill");
	case SOAP_TYPE_PointerToabl__changeBillingDayOfMonthResponse:
		return soap_in_PointerToabl__changeBillingDayOfMonthResponse(soap, NULL, NULL, "abl:changeBillingDayOfMonthResponse");
	case SOAP_TYPE_PointerToabl__delayBillingByDaysResponse:
		return soap_in_PointerToabl__delayBillingByDaysResponse(soap, NULL, NULL, "abl:delayBillingByDaysResponse");
	case SOAP_TYPE_PointerToabl__delayBillingToDateResponse:
		return soap_in_PointerToabl__delayBillingToDateResponse(soap, NULL, NULL, "abl:delayBillingToDateResponse");
	case SOAP_TYPE_PointerToabl__cancelResponse:
		return soap_in_PointerToabl__cancelResponse(soap, NULL, NULL, "abl:cancelResponse");
	case SOAP_TYPE_PointerToabl__updateResponse:
		return soap_in_PointerToabl__updateResponse(soap, NULL, NULL, "abl:updateResponse");
	case SOAP_TYPE_PointerTovin__Authentication:
		return soap_in_PointerTovin__Authentication(soap, NULL, NULL, "vin:Authentication");
	case SOAP_TYPE_PointerTovin__Return:
		return soap_in_PointerTovin__Return(soap, NULL, NULL, "vin:Return");
	case SOAP_TYPE_PointerToPointerTovin__Transaction:
		return soap_in_PointerToPointerTovin__Transaction(soap, NULL, NULL, "vin:Transaction");
	case SOAP_TYPE_PointerToPointerTovin__TransactionStatus:
		return soap_in_PointerToPointerTovin__TransactionStatus(soap, NULL, NULL, "vin:TransactionStatus");
	case SOAP_TYPE_PointerTovin__TransactionStatus:
		return soap_in_PointerTovin__TransactionStatus(soap, NULL, NULL, "vin:TransactionStatus");
	case SOAP_TYPE_PointerToPointerTovin__TransactionItem:
		return soap_in_PointerToPointerTovin__TransactionItem(soap, NULL, NULL, "vin:TransactionItem");
	case SOAP_TYPE_PointerTovin__TransactionItem:
		return soap_in_PointerTovin__TransactionItem(soap, NULL, NULL, "vin:TransactionItem");
	case SOAP_TYPE_PointerToPointerTovin__ScoreCode:
		return soap_in_PointerToPointerTovin__ScoreCode(soap, NULL, NULL, "vin:ScoreCode");
	case SOAP_TYPE_PointerTovin__ScoreCode:
		return soap_in_PointerTovin__ScoreCode(soap, NULL, NULL, "vin:ScoreCode");
	case SOAP_TYPE_PointerToPointerTovin__CancelResult:
		return soap_in_PointerToPointerTovin__CancelResult(soap, NULL, NULL, "vin:CancelResult");
	case SOAP_TYPE_PointerTovin__CancelResult:
		return soap_in_PointerTovin__CancelResult(soap, NULL, NULL, "vin:CancelResult");
	case SOAP_TYPE_PointerToPointerTovin__CaptureResult:
		return soap_in_PointerToPointerTovin__CaptureResult(soap, NULL, NULL, "vin:CaptureResult");
	case SOAP_TYPE_PointerTovin__CaptureResult:
		return soap_in_PointerTovin__CaptureResult(soap, NULL, NULL, "vin:CaptureResult");
	case SOAP_TYPE_PointerToPointerTovin__TokenTransaction:
		return soap_in_PointerToPointerTovin__TokenTransaction(soap, NULL, NULL, "vin:TokenTransaction");
	case SOAP_TYPE_PointerTovin__TokenTransaction:
		return soap_in_PointerTovin__TokenTransaction(soap, NULL, NULL, "vin:TokenTransaction");
	case SOAP_TYPE_PointerToPointerTovin__TokenAmount:
		return soap_in_PointerToPointerTovin__TokenAmount(soap, NULL, NULL, "vin:TokenAmount");
	case SOAP_TYPE_PointerToPointerTovin__Token:
		return soap_in_PointerToPointerTovin__Token(soap, NULL, NULL, "vin:Token");
	case SOAP_TYPE_PointerToPointerTovin__SalesTax:
		return soap_in_PointerToPointerTovin__SalesTax(soap, NULL, NULL, "vin:SalesTax");
	case SOAP_TYPE_PointerTovin__SalesTax:
		return soap_in_PointerTovin__SalesTax(soap, NULL, NULL, "vin:SalesTax");
	case SOAP_TYPE_PointerToPointerTovin__TaxExemption:
		return soap_in_PointerToPointerTovin__TaxExemption(soap, NULL, NULL, "vin:TaxExemption");
	case SOAP_TYPE_PointerTovin__TaxExemption:
		return soap_in_PointerTovin__TaxExemption(soap, NULL, NULL, "vin:TaxExemption");
	case SOAP_TYPE_PointerToPointerTovin__Refund:
		return soap_in_PointerToPointerTovin__Refund(soap, NULL, NULL, "vin:Refund");
	case SOAP_TYPE_PointerTovin__Refund:
		return soap_in_PointerTovin__Refund(soap, NULL, NULL, "vin:Refund");
	case SOAP_TYPE_PointerToPointerTovin__Product:
		return soap_in_PointerToPointerTovin__Product(soap, NULL, NULL, "vin:Product");
	case SOAP_TYPE_PointerToPointerTovin__NameValuePair:
		return soap_in_PointerToPointerTovin__NameValuePair(soap, NULL, NULL, "vin:NameValuePair");
	case SOAP_TYPE_PointerTovin__NameValuePair:
		return soap_in_PointerTovin__NameValuePair(soap, NULL, NULL, "vin:NameValuePair");
	case SOAP_TYPE_PointerToPointerTovin__MerchantEntitlementId:
		return soap_in_PointerToPointerTovin__MerchantEntitlementId(soap, NULL, NULL, "vin:MerchantEntitlementId");
	case SOAP_TYPE_PointerTovin__MerchantEntitlementId:
		return soap_in_PointerTovin__MerchantEntitlementId(soap, NULL, NULL, "vin:MerchantEntitlementId");
	case SOAP_TYPE_PointerToPointerTovin__PaymentMethod:
		return soap_in_PointerToPointerTovin__PaymentMethod(soap, NULL, NULL, "vin:PaymentMethod");
	case SOAP_TYPE_PointerToPointerTovin__MetricStatistics:
		return soap_in_PointerToPointerTovin__MetricStatistics(soap, NULL, NULL, "vin:MetricStatistics");
	case SOAP_TYPE_PointerTovin__MetricStatistics:
		return soap_in_PointerTovin__MetricStatistics(soap, NULL, NULL, "vin:MetricStatistics");
	case SOAP_TYPE_PointerToPointerTovin__Entitlement:
		return soap_in_PointerToPointerTovin__Entitlement(soap, NULL, NULL, "vin:Entitlement");
	case SOAP_TYPE_PointerTovin__Entitlement:
		return soap_in_PointerTovin__Entitlement(soap, NULL, NULL, "vin:Entitlement");
	case SOAP_TYPE_PointerToPointerTovin__EmailTemplate:
		return soap_in_PointerToPointerTovin__EmailTemplate(soap, NULL, NULL, "vin:EmailTemplate");
	case SOAP_TYPE_PointerTovin__EmailTemplate:
		return soap_in_PointerTovin__EmailTemplate(soap, NULL, NULL, "vin:EmailTemplate");
	case SOAP_TYPE_PointerToPointerTovin__Chargeback:
		return soap_in_PointerToPointerTovin__Chargeback(soap, NULL, NULL, "vin:Chargeback");
	case SOAP_TYPE_PointerTovin__Chargeback:
		return soap_in_PointerTovin__Chargeback(soap, NULL, NULL, "vin:Chargeback");
	case SOAP_TYPE_PointerToPointerTovin__BillingPlan:
		return soap_in_PointerToPointerTovin__BillingPlan(soap, NULL, NULL, "vin:BillingPlan");
	case SOAP_TYPE_PointerToPointerTovin__BillingPlanPeriod:
		return soap_in_PointerToPointerTovin__BillingPlanPeriod(soap, NULL, NULL, "vin:BillingPlanPeriod");
	case SOAP_TYPE_PointerTovin__BillingPlanPeriod:
		return soap_in_PointerTovin__BillingPlanPeriod(soap, NULL, NULL, "vin:BillingPlanPeriod");
	case SOAP_TYPE_PointerToPointerTovin__BillingPlanPrice:
		return soap_in_PointerToPointerTovin__BillingPlanPrice(soap, NULL, NULL, "vin:BillingPlanPrice");
	case SOAP_TYPE_PointerTovin__BillingPlanPrice:
		return soap_in_PointerTovin__BillingPlanPrice(soap, NULL, NULL, "vin:BillingPlanPrice");
	case SOAP_TYPE_PointerToPointerTovin__AutoBill:
		return soap_in_PointerToPointerTovin__AutoBill(soap, NULL, NULL, "vin:AutoBill");
	case SOAP_TYPE_PointerTovin__AutoBill:
		return soap_in_PointerTovin__AutoBill(soap, NULL, NULL, "vin:AutoBill");
	case SOAP_TYPE_PointerToPointerTovin__Activity:
		return soap_in_PointerToPointerTovin__Activity(soap, NULL, NULL, "vin:Activity");
	case SOAP_TYPE_PointerTovin__Activity:
		return soap_in_PointerTovin__Activity(soap, NULL, NULL, "vin:Activity");
	case SOAP_TYPE_PointerToPointerTovin__Account:
		return soap_in_PointerToPointerTovin__Account(soap, NULL, NULL, "vin:Account");
	case SOAP_TYPE_PointerToArrayOfTransactionItems:
		return soap_in_PointerToArrayOfTransactionItems(soap, NULL, NULL, "vin:TransactionItem");
	case SOAP_TYPE_PointerToArrayOfTransactionStatuses:
		return soap_in_PointerToArrayOfTransactionStatuses(soap, NULL, NULL, "vin:TransactionStatus");
	case SOAP_TYPE_PointerTovin__AVSMatchType:
		return soap_in_PointerTovin__AVSMatchType(soap, NULL, NULL, "vin:AVSMatchType");
	case SOAP_TYPE_PointerTovin__TransactionStatusDirectDebit:
		return soap_in_PointerTovin__TransactionStatusDirectDebit(soap, NULL, NULL, "vin:TransactionStatusDirectDebit");
	case SOAP_TYPE_PointerTovin__TransactionStatusPayPal:
		return soap_in_PointerTovin__TransactionStatusPayPal(soap, NULL, NULL, "vin:TransactionStatusPayPal");
	case SOAP_TYPE_PointerTovin__TransactionStatusBoleto:
		return soap_in_PointerTovin__TransactionStatusBoleto(soap, NULL, NULL, "vin:TransactionStatusBoleto");
	case SOAP_TYPE_PointerTovin__TransactionStatusECP:
		return soap_in_PointerTovin__TransactionStatusECP(soap, NULL, NULL, "vin:TransactionStatusECP");
	case SOAP_TYPE_PointerTovin__TransactionStatusCreditCard:
		return soap_in_PointerTovin__TransactionStatusCreditCard(soap, NULL, NULL, "vin:TransactionStatusCreditCard");
	case SOAP_TYPE_PointerTovin__TaxRegion:
		return soap_in_PointerTovin__TaxRegion(soap, NULL, NULL, "vin:TaxRegion");
	case SOAP_TYPE_PointerTovin__RefundTokenAction:
		return soap_in_PointerTovin__RefundTokenAction(soap, NULL, NULL, "vin:RefundTokenAction");
	case SOAP_TYPE_PointerTovin__TaxClassification:
		return soap_in_PointerTovin__TaxClassification(soap, NULL, NULL, "vin:TaxClassification");
	case SOAP_TYPE_PointerTovin__ProductStatus:
		return soap_in_PointerTovin__ProductStatus(soap, NULL, NULL, "vin:ProductStatus");
	case SOAP_TYPE_PointerTovin__Token:
		return soap_in_PointerTovin__Token(soap, NULL, NULL, "vin:Token");
	case SOAP_TYPE_PointerTovin__Boleto:
		return soap_in_PointerTovin__Boleto(soap, NULL, NULL, "vin:Boleto");
	case SOAP_TYPE_PointerTovin__PayPal:
		return soap_in_PointerTovin__PayPal(soap, NULL, NULL, "vin:PayPal");
	case SOAP_TYPE_PointerTovin__DirectDebit:
		return soap_in_PointerTovin__DirectDebit(soap, NULL, NULL, "vin:DirectDebit");
	case SOAP_TYPE_PointerTovin__ECP:
		return soap_in_PointerTovin__ECP(soap, NULL, NULL, "vin:ECP");
	case SOAP_TYPE_PointerTovin__CreditCard:
		return soap_in_PointerTovin__CreditCard(soap, NULL, NULL, "vin:CreditCard");
	case SOAP_TYPE_PointerTovin__PaymentMethodType:
		return soap_in_PointerTovin__PaymentMethodType(soap, NULL, NULL, "vin:PaymentMethodType");
	case SOAP_TYPE_PointerTovin__ECPTransactionType:
		return soap_in_PointerTovin__ECPTransactionType(soap, NULL, NULL, "vin:ECPTransactionType");
	case SOAP_TYPE_PointerTovin__AccountType:
		return soap_in_PointerTovin__AccountType(soap, NULL, NULL, "vin:AccountType");
	case SOAP_TYPE_PointerTovin__HashType:
		return soap_in_PointerTovin__HashType(soap, NULL, NULL, "vin:HashType");
	case SOAP_TYPE_PointerTovin__EmailTemplateType:
		return soap_in_PointerTovin__EmailTemplateType(soap, NULL, NULL, "vin:EmailTemplateType");
	case SOAP_TYPE_PointerTovin__Transaction:
		return soap_in_PointerTovin__Transaction(soap, NULL, NULL, "vin:Transaction");
	case SOAP_TYPE_PointerToArrayOfMerchantEntitlementIds:
		return soap_in_PointerToArrayOfMerchantEntitlementIds(soap, NULL, NULL, "vin:MerchantEntitlementId");
	case SOAP_TYPE_PointerToArrayOfBillingPlanPeriods:
		return soap_in_PointerToArrayOfBillingPlanPeriods(soap, NULL, NULL, "vin:BillingPlanPeriod");
	case SOAP_TYPE_PointerTovin__BillingPlanStatus:
		return soap_in_PointerTovin__BillingPlanStatus(soap, NULL, NULL, "vin:BillingPlanStatus");
	case SOAP_TYPE_PointerToArrayOfBillingPlanPrices:
		return soap_in_PointerToArrayOfBillingPlanPrices(soap, NULL, NULL, "vin:BillingPlanPrice");
	case SOAP_TYPE_PointerTovin__BillingPeriodType:
		return soap_in_PointerTovin__BillingPeriodType(soap, NULL, NULL, "vin:BillingPeriodType");
	case SOAP_TYPE_PointerTovin__TokenAmount:
		return soap_in_PointerTovin__TokenAmount(soap, NULL, NULL, "vin:TokenAmount");
	case SOAP_TYPE_PointerToArrayOfTransactions:
		return soap_in_PointerToArrayOfTransactions(soap, NULL, NULL, "vin:Transaction");
	case SOAP_TYPE_PointerTovin__AutoBillStatus:
		return soap_in_PointerTovin__AutoBillStatus(soap, NULL, NULL, "vin:AutoBillStatus");
	case SOAP_TYPE_PointerTovin__PaymentMethod:
		return soap_in_PointerTovin__PaymentMethod(soap, NULL, NULL, "vin:PaymentMethod");
	case SOAP_TYPE_PointerTovin__BillingPlan:
		return soap_in_PointerTovin__BillingPlan(soap, NULL, NULL, "vin:BillingPlan");
	case SOAP_TYPE_PointerTovin__Product:
		return soap_in_PointerTovin__Product(soap, NULL, NULL, "vin:Product");
	case SOAP_TYPE_PointerTovin__ActivityTypeArg:
		return soap_in_PointerTovin__ActivityTypeArg(soap, NULL, NULL, "vin:ActivityTypeArg");
	case SOAP_TYPE_PointerTovin__Account:
		return soap_in_PointerTovin__Account(soap, NULL, NULL, "vin:Account");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTovin__ActivityNote:
		return soap_in_PointerTovin__ActivityNote(soap, NULL, NULL, "vin:ActivityNote");
	case SOAP_TYPE_PointerTovin__ActivityCancellation:
		return soap_in_PointerTovin__ActivityCancellation(soap, NULL, NULL, "vin:ActivityCancellation");
	case SOAP_TYPE_PointerTovin__ActivityNamedValue:
		return soap_in_PointerTovin__ActivityNamedValue(soap, NULL, NULL, "vin:ActivityNamedValue");
	case SOAP_TYPE_PointerTovin__ActivityUsage:
		return soap_in_PointerTovin__ActivityUsage(soap, NULL, NULL, "vin:ActivityUsage");
	case SOAP_TYPE_PointerTovin__ActivityFulfillment:
		return soap_in_PointerTovin__ActivityFulfillment(soap, NULL, NULL, "vin:ActivityFulfillment");
	case SOAP_TYPE_PointerTovin__ActivityEmailContact:
		return soap_in_PointerTovin__ActivityEmailContact(soap, NULL, NULL, "vin:ActivityEmailContact");
	case SOAP_TYPE_PointerTovin__ActivityPhoneContact:
		return soap_in_PointerTovin__ActivityPhoneContact(soap, NULL, NULL, "vin:ActivityPhoneContact");
	case SOAP_TYPE_PointerTovin__ActivityURIView:
		return soap_in_PointerTovin__ActivityURIView(soap, NULL, NULL, "vin:ActivityURIView");
	case SOAP_TYPE_PointerTovin__ActivityLogout:
		return soap_in_PointerTovin__ActivityLogout(soap, NULL, NULL, "vin:ActivityLogout");
	case SOAP_TYPE_PointerTovin__ActivityLogin:
		return soap_in_PointerTovin__ActivityLogin(soap, NULL, NULL, "vin:ActivityLogin");
	case SOAP_TYPE_PointerToArrayOfTokenAmounts:
		return soap_in_PointerToArrayOfTokenAmounts(soap, NULL, NULL, "vin:TokenAmount");
	case SOAP_TYPE_PointerToArrayOfTaxExemptions:
		return soap_in_PointerToArrayOfTaxExemptions(soap, NULL, NULL, "vin:TaxExemption");
	case SOAP_TYPE_PointerToArrayOfNameValuePairs:
		return soap_in_PointerToArrayOfNameValuePairs(soap, NULL, NULL, "vin:NameValuePair");
	case SOAP_TYPE_PointerToArrayOfPaymentMethods:
		return soap_in_PointerToArrayOfPaymentMethods(soap, NULL, NULL, "vin:PaymentMethod");
	case SOAP_TYPE_PointerTovin__Address:
		return soap_in_PointerTovin__Address(soap, NULL, NULL, "vin:Address");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_in_PointerToxsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTovin__EmailPreference:
		return soap_in_PointerTovin__EmailPreference(soap, NULL, NULL, "vin:EmailPreference");
	case SOAP_TYPE_xsd__decimal:
	{	char **s;
		s = soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__date:
	{	char **s;
		s = soap_in_xsd__date(soap, NULL, NULL, "xsd:date");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__anyURI:
	{	char **s;
		s = soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:AVSMatchType"))
		{	*type = SOAP_TYPE_vin__AVSMatchType;
			return soap_in_vin__AVSMatchType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:TransactionStatusType"))
		{	*type = SOAP_TYPE_vin__TransactionStatusType;
			return soap_in_vin__TransactionStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:TaxRegion"))
		{	*type = SOAP_TYPE_vin__TaxRegion;
			return soap_in_vin__TaxRegion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ReturnCode"))
		{	*type = SOAP_TYPE_vin__ReturnCode;
			return soap_in_vin__ReturnCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:RefundTokenAction"))
		{	*type = SOAP_TYPE_vin__RefundTokenAction;
			return soap_in_vin__RefundTokenAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:TaxClassification"))
		{	*type = SOAP_TYPE_vin__TaxClassification;
			return soap_in_vin__TaxClassification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ProductStatus"))
		{	*type = SOAP_TYPE_vin__ProductStatus;
			return soap_in_vin__ProductStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ECPTransactionType"))
		{	*type = SOAP_TYPE_vin__ECPTransactionType;
			return soap_in_vin__ECPTransactionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:AccountType"))
		{	*type = SOAP_TYPE_vin__AccountType;
			return soap_in_vin__AccountType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:HashType"))
		{	*type = SOAP_TYPE_vin__HashType;
			return soap_in_vin__HashType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:PaymentMethodType"))
		{	*type = SOAP_TYPE_vin__PaymentMethodType;
			return soap_in_vin__PaymentMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:MetricStatusType"))
		{	*type = SOAP_TYPE_vin__MetricStatusType;
			return soap_in_vin__MetricStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:EmailTemplateType"))
		{	*type = SOAP_TYPE_vin__EmailTemplateType;
			return soap_in_vin__EmailTemplateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ChargebackStatus"))
		{	*type = SOAP_TYPE_vin__ChargebackStatus;
			return soap_in_vin__ChargebackStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:BillingPlanStatus"))
		{	*type = SOAP_TYPE_vin__BillingPlanStatus;
			return soap_in_vin__BillingPlanStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:BillingPeriodType"))
		{	*type = SOAP_TYPE_vin__BillingPeriodType;
			return soap_in_vin__BillingPeriodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:DuplicateBehavior"))
		{	*type = SOAP_TYPE_vin__DuplicateBehavior;
			return soap_in_vin__DuplicateBehavior(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:AutoBillStatus"))
		{	*type = SOAP_TYPE_vin__AutoBillStatus;
			return soap_in_vin__AutoBillStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:AddressType"))
		{	*type = SOAP_TYPE_vin__AddressType;
			return soap_in_vin__AddressType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ActivityCallType"))
		{	*type = SOAP_TYPE_vin__ActivityCallType;
			return soap_in_vin__ActivityCallType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ActivityType"))
		{	*type = SOAP_TYPE_vin__ActivityType;
			return soap_in_vin__ActivityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ActivityCancelInitType"))
		{	*type = SOAP_TYPE_vin__ActivityCancelInitType;
			return soap_in_vin__ActivityCancelInitType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:PaymentUpdateBehavior"))
		{	*type = SOAP_TYPE_vin__PaymentUpdateBehavior;
			return soap_in_vin__PaymentUpdateBehavior(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:EmailPreference"))
		{	*type = SOAP_TYPE_vin__EmailPreference;
			return soap_in_vin__EmailPreference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:score"))
		{	*type = SOAP_TYPE_trn__score;
			return soap_in_trn__score(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:scoreResponse"))
		{	*type = SOAP_TYPE_trn__scoreResponse;
			return soap_in_trn__scoreResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:report"))
		{	*type = SOAP_TYPE_trn__report;
			return soap_in_trn__report(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:reportResponse"))
		{	*type = SOAP_TYPE_trn__reportResponse;
			return soap_in_trn__reportResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:authCapture"))
		{	*type = SOAP_TYPE_trn__authCapture;
			return soap_in_trn__authCapture(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:authCaptureResponse"))
		{	*type = SOAP_TYPE_trn__authCaptureResponse;
			return soap_in_trn__authCaptureResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:cancel"))
		{	*type = SOAP_TYPE_trn__cancel;
			return soap_in_trn__cancel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:cancelResponse"))
		{	*type = SOAP_TYPE_trn__cancelResponse;
			return soap_in_trn__cancelResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:capture"))
		{	*type = SOAP_TYPE_trn__capture;
			return soap_in_trn__capture(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:captureResponse"))
		{	*type = SOAP_TYPE_trn__captureResponse;
			return soap_in_trn__captureResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:calculateSalesTax"))
		{	*type = SOAP_TYPE_trn__calculateSalesTax;
			return soap_in_trn__calculateSalesTax(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:calculateSalesTaxResponse"))
		{	*type = SOAP_TYPE_trn__calculateSalesTaxResponse;
			return soap_in_trn__calculateSalesTaxResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:auth"))
		{	*type = SOAP_TYPE_trn__auth;
			return soap_in_trn__auth(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:authResponse"))
		{	*type = SOAP_TYPE_trn__authResponse;
			return soap_in_trn__authResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:fetchByPaymentMethod"))
		{	*type = SOAP_TYPE_trn__fetchByPaymentMethod;
			return soap_in_trn__fetchByPaymentMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:fetchByPaymentMethodResponse"))
		{	*type = SOAP_TYPE_trn__fetchByPaymentMethodResponse;
			return soap_in_trn__fetchByPaymentMethodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:fetchSearchPage"))
		{	*type = SOAP_TYPE_trn__fetchSearchPage;
			return soap_in_trn__fetchSearchPage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:fetchSearchPageResponse"))
		{	*type = SOAP_TYPE_trn__fetchSearchPageResponse;
			return soap_in_trn__fetchSearchPageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:fetchByAutobill"))
		{	*type = SOAP_TYPE_trn__fetchByAutobill;
			return soap_in_trn__fetchByAutobill(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:fetchByAutobillResponse"))
		{	*type = SOAP_TYPE_trn__fetchByAutobillResponse;
			return soap_in_trn__fetchByAutobillResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:fetchDelta"))
		{	*type = SOAP_TYPE_trn__fetchDelta;
			return soap_in_trn__fetchDelta(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:fetchDeltaResponse"))
		{	*type = SOAP_TYPE_trn__fetchDeltaResponse;
			return soap_in_trn__fetchDeltaResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:fetchDeltaSince"))
		{	*type = SOAP_TYPE_trn__fetchDeltaSince;
			return soap_in_trn__fetchDeltaSince(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:fetchDeltaSinceResponse"))
		{	*type = SOAP_TYPE_trn__fetchDeltaSinceResponse;
			return soap_in_trn__fetchDeltaSinceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:fetchByMerchantTransactionId"))
		{	*type = SOAP_TYPE_trn__fetchByMerchantTransactionId;
			return soap_in_trn__fetchByMerchantTransactionId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:fetchByMerchantTransactionIdResponse"))
		{	*type = SOAP_TYPE_trn__fetchByMerchantTransactionIdResponse;
			return soap_in_trn__fetchByMerchantTransactionIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:fetchByAccount"))
		{	*type = SOAP_TYPE_trn__fetchByAccount;
			return soap_in_trn__fetchByAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:fetchByAccountResponse"))
		{	*type = SOAP_TYPE_trn__fetchByAccountResponse;
			return soap_in_trn__fetchByAccountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:fetchByVid"))
		{	*type = SOAP_TYPE_trn__fetchByVid;
			return soap_in_trn__fetchByVid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trn:fetchByVidResponse"))
		{	*type = SOAP_TYPE_trn__fetchByVidResponse;
			return soap_in_trn__fetchByVidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rfd:perform"))
		{	*type = SOAP_TYPE_rfd__perform;
			return soap_in_rfd__perform(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rfd:performResponse"))
		{	*type = SOAP_TYPE_rfd__performResponse;
			return soap_in_rfd__performResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rfd:report"))
		{	*type = SOAP_TYPE_rfd__report;
			return soap_in_rfd__report(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rfd:reportResponse"))
		{	*type = SOAP_TYPE_rfd__reportResponse;
			return soap_in_rfd__reportResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rfd:fetchDeltaSince"))
		{	*type = SOAP_TYPE_rfd__fetchDeltaSince;
			return soap_in_rfd__fetchDeltaSince(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rfd:fetchDeltaSinceResponse"))
		{	*type = SOAP_TYPE_rfd__fetchDeltaSinceResponse;
			return soap_in_rfd__fetchDeltaSinceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rfd:fetchByTransaction"))
		{	*type = SOAP_TYPE_rfd__fetchByTransaction;
			return soap_in_rfd__fetchByTransaction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rfd:fetchByTransactionResponse"))
		{	*type = SOAP_TYPE_rfd__fetchByTransactionResponse;
			return soap_in_rfd__fetchByTransactionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rfd:fetchByAccount"))
		{	*type = SOAP_TYPE_rfd__fetchByAccount;
			return soap_in_rfd__fetchByAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rfd:fetchByAccountResponse"))
		{	*type = SOAP_TYPE_rfd__fetchByAccountResponse;
			return soap_in_rfd__fetchByAccountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rfd:fetchByVid"))
		{	*type = SOAP_TYPE_rfd__fetchByVid;
			return soap_in_rfd__fetchByVid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "rfd:fetchByVidResponse"))
		{	*type = SOAP_TYPE_rfd__fetchByVidResponse;
			return soap_in_rfd__fetchByVidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pyp:fetchByVid"))
		{	*type = SOAP_TYPE_pyp__fetchByVid;
			return soap_in_pyp__fetchByVid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pyp:fetchByVidResponse"))
		{	*type = SOAP_TYPE_pyp__fetchByVidResponse;
			return soap_in_pyp__fetchByVidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pyp:update"))
		{	*type = SOAP_TYPE_pyp__update;
			return soap_in_pyp__update(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pyp:updateResponse"))
		{	*type = SOAP_TYPE_pyp__updateResponse;
			return soap_in_pyp__updateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pym:validate"))
		{	*type = SOAP_TYPE_pym__validate;
			return soap_in_pym__validate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pym:validateResponse"))
		{	*type = SOAP_TYPE_pym__validateResponse;
			return soap_in_pym__validateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pym:fetchByMerchantPaymentMethodId"))
		{	*type = SOAP_TYPE_pym__fetchByMerchantPaymentMethodId;
			return soap_in_pym__fetchByMerchantPaymentMethodId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pym:fetchByMerchantPaymentMethodIdResponse"))
		{	*type = SOAP_TYPE_pym__fetchByMerchantPaymentMethodIdResponse;
			return soap_in_pym__fetchByMerchantPaymentMethodIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pym:fetchByAccount"))
		{	*type = SOAP_TYPE_pym__fetchByAccount;
			return soap_in_pym__fetchByAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pym:fetchByAccountResponse"))
		{	*type = SOAP_TYPE_pym__fetchByAccountResponse;
			return soap_in_pym__fetchByAccountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pym:fetchByVid"))
		{	*type = SOAP_TYPE_pym__fetchByVid;
			return soap_in_pym__fetchByVid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pym:fetchByVidResponse"))
		{	*type = SOAP_TYPE_pym__fetchByVidResponse;
			return soap_in_pym__fetchByVidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pym:update"))
		{	*type = SOAP_TYPE_pym__update;
			return soap_in_pym__update(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pym:updateResponse"))
		{	*type = SOAP_TYPE_pym__updateResponse;
			return soap_in_pym__updateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "prd:fetchByMerchantEntitlementId"))
		{	*type = SOAP_TYPE_prd__fetchByMerchantEntitlementId;
			return soap_in_prd__fetchByMerchantEntitlementId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "prd:fetchByMerchantEntitlementIdResponse"))
		{	*type = SOAP_TYPE_prd__fetchByMerchantEntitlementIdResponse;
			return soap_in_prd__fetchByMerchantEntitlementIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "prd:fetchAll"))
		{	*type = SOAP_TYPE_prd__fetchAll;
			return soap_in_prd__fetchAll(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "prd:fetchAllResponse"))
		{	*type = SOAP_TYPE_prd__fetchAllResponse;
			return soap_in_prd__fetchAllResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "prd:fetchByAccount"))
		{	*type = SOAP_TYPE_prd__fetchByAccount;
			return soap_in_prd__fetchByAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "prd:fetchByAccountResponse"))
		{	*type = SOAP_TYPE_prd__fetchByAccountResponse;
			return soap_in_prd__fetchByAccountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "prd:fetchByMerchantProductId"))
		{	*type = SOAP_TYPE_prd__fetchByMerchantProductId;
			return soap_in_prd__fetchByMerchantProductId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "prd:fetchByMerchantProductIdResponse"))
		{	*type = SOAP_TYPE_prd__fetchByMerchantProductIdResponse;
			return soap_in_prd__fetchByMerchantProductIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "prd:fetchByVid"))
		{	*type = SOAP_TYPE_prd__fetchByVid;
			return soap_in_prd__fetchByVid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "prd:fetchByVidResponse"))
		{	*type = SOAP_TYPE_prd__fetchByVidResponse;
			return soap_in_prd__fetchByVidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "prd:update"))
		{	*type = SOAP_TYPE_prd__update;
			return soap_in_prd__update(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "prd:updateResponse"))
		{	*type = SOAP_TYPE_prd__updateResponse;
			return soap_in_prd__updateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "met:report"))
		{	*type = SOAP_TYPE_met__report;
			return soap_in_met__report(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "met:reportResponse"))
		{	*type = SOAP_TYPE_met__reportResponse;
			return soap_in_met__reportResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "etp:fetchByTypeAndVersion"))
		{	*type = SOAP_TYPE_etp__fetchByTypeAndVersion;
			return soap_in_etp__fetchByTypeAndVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "etp:fetchByTypeAndVersionResponse"))
		{	*type = SOAP_TYPE_etp__fetchByTypeAndVersionResponse;
			return soap_in_etp__fetchByTypeAndVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "etp:fetchByType"))
		{	*type = SOAP_TYPE_etp__fetchByType;
			return soap_in_etp__fetchByType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "etp:fetchByTypeResponse"))
		{	*type = SOAP_TYPE_etp__fetchByTypeResponse;
			return soap_in_etp__fetchByTypeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "etp:fetchByProduct"))
		{	*type = SOAP_TYPE_etp__fetchByProduct;
			return soap_in_etp__fetchByProduct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "etp:fetchByProductResponse"))
		{	*type = SOAP_TYPE_etp__fetchByProductResponse;
			return soap_in_etp__fetchByProductResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "etp:fetchByVid"))
		{	*type = SOAP_TYPE_etp__fetchByVid;
			return soap_in_etp__fetchByVid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "etp:fetchByVidResponse"))
		{	*type = SOAP_TYPE_etp__fetchByVidResponse;
			return soap_in_etp__fetchByVidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "etp:update"))
		{	*type = SOAP_TYPE_etp__update;
			return soap_in_etp__update(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "etp:updateResponse"))
		{	*type = SOAP_TYPE_etp__updateResponse;
			return soap_in_etp__updateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ent:fetchDeltaSince"))
		{	*type = SOAP_TYPE_ent__fetchDeltaSince;
			return soap_in_ent__fetchDeltaSince(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ent:fetchDeltaSinceResponse"))
		{	*type = SOAP_TYPE_ent__fetchDeltaSinceResponse;
			return soap_in_ent__fetchDeltaSinceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ent:fetchByAccount"))
		{	*type = SOAP_TYPE_ent__fetchByAccount;
			return soap_in_ent__fetchByAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ent:fetchByAccountResponse"))
		{	*type = SOAP_TYPE_ent__fetchByAccountResponse;
			return soap_in_ent__fetchByAccountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ent:fetchByEntitlementIdAndAccount"))
		{	*type = SOAP_TYPE_ent__fetchByEntitlementIdAndAccount;
			return soap_in_ent__fetchByEntitlementIdAndAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ent:fetchByEntitlementIdAndAccountResponse"))
		{	*type = SOAP_TYPE_ent__fetchByEntitlementIdAndAccountResponse;
			return soap_in_ent__fetchByEntitlementIdAndAccountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ecs:getSignatureBlock"))
		{	*type = SOAP_TYPE_ecs__getSignatureBlock;
			return soap_in_ecs__getSignatureBlock(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ecs:getSignatureBlockResponse"))
		{	*type = SOAP_TYPE_ecs__getSignatureBlockResponse;
			return soap_in_ecs__getSignatureBlockResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ecs:sign"))
		{	*type = SOAP_TYPE_ecs__sign;
			return soap_in_ecs__sign(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ecs:signResponse"))
		{	*type = SOAP_TYPE_ecs__signResponse;
			return soap_in_ecs__signResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:report"))
		{	*type = SOAP_TYPE_cgb__report;
			return soap_in_cgb__report(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:reportResponse"))
		{	*type = SOAP_TYPE_cgb__reportResponse;
			return soap_in_cgb__reportResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchDelta"))
		{	*type = SOAP_TYPE_cgb__fetchDelta;
			return soap_in_cgb__fetchDelta(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchDeltaResponse"))
		{	*type = SOAP_TYPE_cgb__fetchDeltaResponse;
			return soap_in_cgb__fetchDeltaResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchDeltaSince"))
		{	*type = SOAP_TYPE_cgb__fetchDeltaSince;
			return soap_in_cgb__fetchDeltaSince(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchDeltaSinceResponse"))
		{	*type = SOAP_TYPE_cgb__fetchDeltaSinceResponse;
			return soap_in_cgb__fetchDeltaSinceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchByMerchantTransactionId"))
		{	*type = SOAP_TYPE_cgb__fetchByMerchantTransactionId;
			return soap_in_cgb__fetchByMerchantTransactionId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchByMerchantTransactionIdResponse"))
		{	*type = SOAP_TYPE_cgb__fetchByMerchantTransactionIdResponse;
			return soap_in_cgb__fetchByMerchantTransactionIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchByStatusSince"))
		{	*type = SOAP_TYPE_cgb__fetchByStatusSince;
			return soap_in_cgb__fetchByStatusSince(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchByStatusSinceResponse"))
		{	*type = SOAP_TYPE_cgb__fetchByStatusSinceResponse;
			return soap_in_cgb__fetchByStatusSinceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchByStatus"))
		{	*type = SOAP_TYPE_cgb__fetchByStatus;
			return soap_in_cgb__fetchByStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchByStatusResponse"))
		{	*type = SOAP_TYPE_cgb__fetchByStatusResponse;
			return soap_in_cgb__fetchByStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchByReferenceNumber"))
		{	*type = SOAP_TYPE_cgb__fetchByReferenceNumber;
			return soap_in_cgb__fetchByReferenceNumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchByReferenceNumberResponse"))
		{	*type = SOAP_TYPE_cgb__fetchByReferenceNumberResponse;
			return soap_in_cgb__fetchByReferenceNumberResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchByCaseNumber"))
		{	*type = SOAP_TYPE_cgb__fetchByCaseNumber;
			return soap_in_cgb__fetchByCaseNumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchByCaseNumberResponse"))
		{	*type = SOAP_TYPE_cgb__fetchByCaseNumberResponse;
			return soap_in_cgb__fetchByCaseNumberResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchByAccount"))
		{	*type = SOAP_TYPE_cgb__fetchByAccount;
			return soap_in_cgb__fetchByAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchByAccountResponse"))
		{	*type = SOAP_TYPE_cgb__fetchByAccountResponse;
			return soap_in_cgb__fetchByAccountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchByVid"))
		{	*type = SOAP_TYPE_cgb__fetchByVid;
			return soap_in_cgb__fetchByVid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:fetchByVidResponse"))
		{	*type = SOAP_TYPE_cgb__fetchByVidResponse;
			return soap_in_cgb__fetchByVidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:update"))
		{	*type = SOAP_TYPE_cgb__update;
			return soap_in_cgb__update(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cgb:updateResponse"))
		{	*type = SOAP_TYPE_cgb__updateResponse;
			return soap_in_cgb__updateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bpl:fetchByMerchantEntitlementId"))
		{	*type = SOAP_TYPE_bpl__fetchByMerchantEntitlementId;
			return soap_in_bpl__fetchByMerchantEntitlementId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bpl:fetchByMerchantEntitlementIdResponse"))
		{	*type = SOAP_TYPE_bpl__fetchByMerchantEntitlementIdResponse;
			return soap_in_bpl__fetchByMerchantEntitlementIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bpl:fetchAll"))
		{	*type = SOAP_TYPE_bpl__fetchAll;
			return soap_in_bpl__fetchAll(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bpl:fetchAllResponse"))
		{	*type = SOAP_TYPE_bpl__fetchAllResponse;
			return soap_in_bpl__fetchAllResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bpl:fetchByBillingPlanStatus"))
		{	*type = SOAP_TYPE_bpl__fetchByBillingPlanStatus;
			return soap_in_bpl__fetchByBillingPlanStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bpl:fetchByBillingPlanStatusResponse"))
		{	*type = SOAP_TYPE_bpl__fetchByBillingPlanStatusResponse;
			return soap_in_bpl__fetchByBillingPlanStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bpl:fetchByMerchantBillingPlanId"))
		{	*type = SOAP_TYPE_bpl__fetchByMerchantBillingPlanId;
			return soap_in_bpl__fetchByMerchantBillingPlanId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bpl:fetchByMerchantBillingPlanIdResponse"))
		{	*type = SOAP_TYPE_bpl__fetchByMerchantBillingPlanIdResponse;
			return soap_in_bpl__fetchByMerchantBillingPlanIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bpl:fetchByVid"))
		{	*type = SOAP_TYPE_bpl__fetchByVid;
			return soap_in_bpl__fetchByVid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bpl:fetchByVidResponse"))
		{	*type = SOAP_TYPE_bpl__fetchByVidResponse;
			return soap_in_bpl__fetchByVidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bpl:update"))
		{	*type = SOAP_TYPE_bpl__update;
			return soap_in_bpl__update(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bpl:updateResponse"))
		{	*type = SOAP_TYPE_bpl__updateResponse;
			return soap_in_bpl__updateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "add:fetchByVid"))
		{	*type = SOAP_TYPE_add__fetchByVid;
			return soap_in_add__fetchByVid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "add:fetchByVidResponse"))
		{	*type = SOAP_TYPE_add__fetchByVidResponse;
			return soap_in_add__fetchByVidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "add:update"))
		{	*type = SOAP_TYPE_add__update;
			return soap_in_add__update(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "add:updateResponse"))
		{	*type = SOAP_TYPE_add__updateResponse;
			return soap_in_add__updateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "act:record"))
		{	*type = SOAP_TYPE_act__record;
			return soap_in_act__record(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "act:recordResponse"))
		{	*type = SOAP_TYPE_act__recordResponse;
			return soap_in_act__recordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:transfer"))
		{	*type = SOAP_TYPE_acc__transfer;
			return soap_in_acc__transfer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:transferResponse"))
		{	*type = SOAP_TYPE_acc__transferResponse;
			return soap_in_acc__transferResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:decrementTokens"))
		{	*type = SOAP_TYPE_acc__decrementTokens;
			return soap_in_acc__decrementTokens(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:decrementTokensResponse"))
		{	*type = SOAP_TYPE_acc__decrementTokensResponse;
			return soap_in_acc__decrementTokensResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:incrementTokens"))
		{	*type = SOAP_TYPE_acc__incrementTokens;
			return soap_in_acc__incrementTokens(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:incrementTokensResponse"))
		{	*type = SOAP_TYPE_acc__incrementTokensResponse;
			return soap_in_acc__incrementTokensResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:tokenTransaction"))
		{	*type = SOAP_TYPE_acc__tokenTransaction;
			return soap_in_acc__tokenTransaction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:tokenTransactionResponse"))
		{	*type = SOAP_TYPE_acc__tokenTransactionResponse;
			return soap_in_acc__tokenTransactionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:tokenBalance"))
		{	*type = SOAP_TYPE_acc__tokenBalance;
			return soap_in_acc__tokenBalance(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:tokenBalanceResponse"))
		{	*type = SOAP_TYPE_acc__tokenBalanceResponse;
			return soap_in_acc__tokenBalanceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:fetchByPaymentMethod"))
		{	*type = SOAP_TYPE_acc__fetchByPaymentMethod;
			return soap_in_acc__fetchByPaymentMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:fetchByPaymentMethodResponse"))
		{	*type = SOAP_TYPE_acc__fetchByPaymentMethodResponse;
			return soap_in_acc__fetchByPaymentMethodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:fetchByEmail"))
		{	*type = SOAP_TYPE_acc__fetchByEmail;
			return soap_in_acc__fetchByEmail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:fetchByEmailResponse"))
		{	*type = SOAP_TYPE_acc__fetchByEmailResponse;
			return soap_in_acc__fetchByEmailResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:fetchByVid"))
		{	*type = SOAP_TYPE_acc__fetchByVid;
			return soap_in_acc__fetchByVid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:fetchByVidResponse"))
		{	*type = SOAP_TYPE_acc__fetchByVidResponse;
			return soap_in_acc__fetchByVidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:fetchByMerchantAccountId"))
		{	*type = SOAP_TYPE_acc__fetchByMerchantAccountId;
			return soap_in_acc__fetchByMerchantAccountId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:fetchByMerchantAccountIdResponse"))
		{	*type = SOAP_TYPE_acc__fetchByMerchantAccountIdResponse;
			return soap_in_acc__fetchByMerchantAccountIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:updatePaymentMethod"))
		{	*type = SOAP_TYPE_acc__updatePaymentMethod;
			return soap_in_acc__updatePaymentMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:updatePaymentMethodResponse"))
		{	*type = SOAP_TYPE_acc__updatePaymentMethodResponse;
			return soap_in_acc__updatePaymentMethodResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:stopAutoBilling"))
		{	*type = SOAP_TYPE_acc__stopAutoBilling;
			return soap_in_acc__stopAutoBilling(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:stopAutoBillingResponse"))
		{	*type = SOAP_TYPE_acc__stopAutoBillingResponse;
			return soap_in_acc__stopAutoBillingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:update"))
		{	*type = SOAP_TYPE_acc__update;
			return soap_in_acc__update(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "acc:updateResponse"))
		{	*type = SOAP_TYPE_acc__updateResponse;
			return soap_in_acc__updateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:fetchDeltaSince"))
		{	*type = SOAP_TYPE_abl__fetchDeltaSince;
			return soap_in_abl__fetchDeltaSince(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:fetchDeltaSinceResponse"))
		{	*type = SOAP_TYPE_abl__fetchDeltaSinceResponse;
			return soap_in_abl__fetchDeltaSinceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:futureRebills"))
		{	*type = SOAP_TYPE_abl__futureRebills;
			return soap_in_abl__futureRebills(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:futureRebillsResponse"))
		{	*type = SOAP_TYPE_abl__futureRebillsResponse;
			return soap_in_abl__futureRebillsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:fetchByAccount"))
		{	*type = SOAP_TYPE_abl__fetchByAccount;
			return soap_in_abl__fetchByAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:fetchByAccountResponse"))
		{	*type = SOAP_TYPE_abl__fetchByAccountResponse;
			return soap_in_abl__fetchByAccountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:fetchByEmail"))
		{	*type = SOAP_TYPE_abl__fetchByEmail;
			return soap_in_abl__fetchByEmail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:fetchByEmailResponse"))
		{	*type = SOAP_TYPE_abl__fetchByEmailResponse;
			return soap_in_abl__fetchByEmailResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:fetchByVid"))
		{	*type = SOAP_TYPE_abl__fetchByVid;
			return soap_in_abl__fetchByVid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:fetchByVidResponse"))
		{	*type = SOAP_TYPE_abl__fetchByVidResponse;
			return soap_in_abl__fetchByVidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:fetchByMerchantAutoBillId"))
		{	*type = SOAP_TYPE_abl__fetchByMerchantAutoBillId;
			return soap_in_abl__fetchByMerchantAutoBillId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:fetchByMerchantAutoBillIdResponse"))
		{	*type = SOAP_TYPE_abl__fetchByMerchantAutoBillIdResponse;
			return soap_in_abl__fetchByMerchantAutoBillIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:fetchByAccountAndProduct"))
		{	*type = SOAP_TYPE_abl__fetchByAccountAndProduct;
			return soap_in_abl__fetchByAccountAndProduct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:fetchByAccountAndProductResponse"))
		{	*type = SOAP_TYPE_abl__fetchByAccountAndProductResponse;
			return soap_in_abl__fetchByAccountAndProductResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:changeBillingDayOfMonth"))
		{	*type = SOAP_TYPE_abl__changeBillingDayOfMonth;
			return soap_in_abl__changeBillingDayOfMonth(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:changeBillingDayOfMonthResponse"))
		{	*type = SOAP_TYPE_abl__changeBillingDayOfMonthResponse;
			return soap_in_abl__changeBillingDayOfMonthResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:delayBillingByDays"))
		{	*type = SOAP_TYPE_abl__delayBillingByDays;
			return soap_in_abl__delayBillingByDays(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:delayBillingByDaysResponse"))
		{	*type = SOAP_TYPE_abl__delayBillingByDaysResponse;
			return soap_in_abl__delayBillingByDaysResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:delayBillingToDate"))
		{	*type = SOAP_TYPE_abl__delayBillingToDate;
			return soap_in_abl__delayBillingToDate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:delayBillingToDateResponse"))
		{	*type = SOAP_TYPE_abl__delayBillingToDateResponse;
			return soap_in_abl__delayBillingToDateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:cancel"))
		{	*type = SOAP_TYPE_abl__cancel;
			return soap_in_abl__cancel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:cancelResponse"))
		{	*type = SOAP_TYPE_abl__cancelResponse;
			return soap_in_abl__cancelResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:update"))
		{	*type = SOAP_TYPE_abl__update;
			return soap_in_abl__update(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "abl:updateResponse"))
		{	*type = SOAP_TYPE_abl__updateResponse;
			return soap_in_abl__updateResponse(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:ScoreCode"))
		{	*type = SOAP_TYPE_ArrayOfScoreCodes;
			return soap_in_ArrayOfScoreCodes(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:CancelResult"))
		{	*type = SOAP_TYPE_ArrayOfCancelResults;
			return soap_in_ArrayOfCancelResults(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:CaptureResult"))
		{	*type = SOAP_TYPE_ArrayOfCaptureResults;
			return soap_in_ArrayOfCaptureResults(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:TokenTransaction"))
		{	*type = SOAP_TYPE_ArrayOfTokenTransactions;
			return soap_in_ArrayOfTokenTransactions(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:Token"))
		{	*type = SOAP_TYPE_ArrayOfTokens;
			return soap_in_ArrayOfTokens(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:TaxExemption"))
		{	*type = SOAP_TYPE_ArrayOfTaxExemption;
			return soap_in_ArrayOfTaxExemption(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:SalesTax"))
		{	*type = SOAP_TYPE_ArrayOfSalesTaxes;
			return soap_in_ArrayOfSalesTaxes(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:Refund"))
		{	*type = SOAP_TYPE_ArrayOfRefunds;
			return soap_in_ArrayOfRefunds(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:Product"))
		{	*type = SOAP_TYPE_ArrayOfProducts;
			return soap_in_ArrayOfProducts(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:MetricStatistics"))
		{	*type = SOAP_TYPE_ArrayOfMetricStats;
			return soap_in_ArrayOfMetricStats(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:Entitlement"))
		{	*type = SOAP_TYPE_ArrayOfEntitlements;
			return soap_in_ArrayOfEntitlements(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:EmailTemplate"))
		{	*type = SOAP_TYPE_ArrayOfEmailTemplates;
			return soap_in_ArrayOfEmailTemplates(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:Chargeback"))
		{	*type = SOAP_TYPE_ArrayOfChargebacks;
			return soap_in_ArrayOfChargebacks(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:BillingPlan"))
		{	*type = SOAP_TYPE_ArrayOfBillingPlans;
			return soap_in_ArrayOfBillingPlans(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:AutoBill"))
		{	*type = SOAP_TYPE_ArrayOfAutoBills;
			return soap_in_ArrayOfAutoBills(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:Activity"))
		{	*type = SOAP_TYPE_ArrayOfActivities;
			return soap_in_ArrayOfActivities(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:Account"))
		{	*type = SOAP_TYPE_ArrayOfAccounts;
			return soap_in_ArrayOfAccounts(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:TransactionItem"))
		{	*type = SOAP_TYPE_ArrayOfTransactionItems;
			return soap_in_ArrayOfTransactionItems(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:TransactionStatus"))
		{	*type = SOAP_TYPE_ArrayOfTransactionStatuses;
			return soap_in_ArrayOfTransactionStatuses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:TransactionStatusDirectDebit"))
		{	*type = SOAP_TYPE_vin__TransactionStatusDirectDebit;
			return soap_in_vin__TransactionStatusDirectDebit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:TransactionStatusPayPal"))
		{	*type = SOAP_TYPE_vin__TransactionStatusPayPal;
			return soap_in_vin__TransactionStatusPayPal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:TransactionStatusBoleto"))
		{	*type = SOAP_TYPE_vin__TransactionStatusBoleto;
			return soap_in_vin__TransactionStatusBoleto(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:TransactionStatusECP"))
		{	*type = SOAP_TYPE_vin__TransactionStatusECP;
			return soap_in_vin__TransactionStatusECP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:TransactionStatusCreditCard"))
		{	*type = SOAP_TYPE_vin__TransactionStatusCreditCard;
			return soap_in_vin__TransactionStatusCreditCard(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:TransactionStatus"))
		{	*type = SOAP_TYPE_vin__TransactionStatus;
			return soap_in_vin__TransactionStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:TransactionItem"))
		{	*type = SOAP_TYPE_vin__TransactionItem;
			return soap_in_vin__TransactionItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ScoreCode"))
		{	*type = SOAP_TYPE_vin__ScoreCode;
			return soap_in_vin__ScoreCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:CancelResult"))
		{	*type = SOAP_TYPE_vin__CancelResult;
			return soap_in_vin__CancelResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:CaptureResult"))
		{	*type = SOAP_TYPE_vin__CaptureResult;
			return soap_in_vin__CaptureResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:TokenTransaction"))
		{	*type = SOAP_TYPE_vin__TokenTransaction;
			return soap_in_vin__TokenTransaction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:SalesTax"))
		{	*type = SOAP_TYPE_vin__SalesTax;
			return soap_in_vin__SalesTax(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:TaxExemption"))
		{	*type = SOAP_TYPE_vin__TaxExemption;
			return soap_in_vin__TaxExemption(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:Return"))
		{	*type = SOAP_TYPE_vin__Return;
			return soap_in_vin__Return(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:Refund"))
		{	*type = SOAP_TYPE_vin__Refund;
			return soap_in_vin__Refund(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:NameValuePair"))
		{	*type = SOAP_TYPE_vin__NameValuePair;
			return soap_in_vin__NameValuePair(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:MerchantEntitlementId"))
		{	*type = SOAP_TYPE_vin__MerchantEntitlementId;
			return soap_in_vin__MerchantEntitlementId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:PaymentProvider"))
		{	*type = SOAP_TYPE_vin__PaymentProvider;
			return soap_in_vin__PaymentProvider(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:Token"))
		{	*type = SOAP_TYPE_vin__Token;
			return soap_in_vin__Token(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:Boleto"))
		{	*type = SOAP_TYPE_vin__Boleto;
			return soap_in_vin__Boleto(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:PayPal"))
		{	*type = SOAP_TYPE_vin__PayPal;
			return soap_in_vin__PayPal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:DirectDebit"))
		{	*type = SOAP_TYPE_vin__DirectDebit;
			return soap_in_vin__DirectDebit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ECP"))
		{	*type = SOAP_TYPE_vin__ECP;
			return soap_in_vin__ECP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:CreditCard"))
		{	*type = SOAP_TYPE_vin__CreditCard;
			return soap_in_vin__CreditCard(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:MetricStatistics"))
		{	*type = SOAP_TYPE_vin__MetricStatistics;
			return soap_in_vin__MetricStatistics(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:Entitlement"))
		{	*type = SOAP_TYPE_vin__Entitlement;
			return soap_in_vin__Entitlement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:EmailTemplate"))
		{	*type = SOAP_TYPE_vin__EmailTemplate;
			return soap_in_vin__EmailTemplate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:Transaction"))
		{	*type = SOAP_TYPE_vin__Transaction;
			return soap_in_vin__Transaction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ElectronicSignature"))
		{	*type = SOAP_TYPE_vin__ElectronicSignature;
			return soap_in_vin__ElectronicSignature(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:Chargeback"))
		{	*type = SOAP_TYPE_vin__Chargeback;
			return soap_in_vin__Chargeback(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:MerchantEntitlementId"))
		{	*type = SOAP_TYPE_ArrayOfMerchantEntitlementIds;
			return soap_in_ArrayOfMerchantEntitlementIds(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:BillingPlanPeriod"))
		{	*type = SOAP_TYPE_ArrayOfBillingPlanPeriods;
			return soap_in_ArrayOfBillingPlanPeriods(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:BillingPlanPrice"))
		{	*type = SOAP_TYPE_ArrayOfBillingPlanPrices;
			return soap_in_ArrayOfBillingPlanPrices(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:BillingPlanPeriod"))
		{	*type = SOAP_TYPE_vin__BillingPlanPeriod;
			return soap_in_vin__BillingPlanPeriod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:TokenAmount"))
		{	*type = SOAP_TYPE_vin__TokenAmount;
			return soap_in_vin__TokenAmount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:BillingPlanPrice"))
		{	*type = SOAP_TYPE_vin__BillingPlanPrice;
			return soap_in_vin__BillingPlanPrice(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:Transaction"))
		{	*type = SOAP_TYPE_ArrayOfTransactions;
			return soap_in_ArrayOfTransactions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:PaymentMethod"))
		{	*type = SOAP_TYPE_vin__PaymentMethod;
			return soap_in_vin__PaymentMethod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:BillingPlan"))
		{	*type = SOAP_TYPE_vin__BillingPlan;
			return soap_in_vin__BillingPlan(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:Product"))
		{	*type = SOAP_TYPE_vin__Product;
			return soap_in_vin__Product(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:AutoBill"))
		{	*type = SOAP_TYPE_vin__AutoBill;
			return soap_in_vin__AutoBill(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:Authentication"))
		{	*type = SOAP_TYPE_vin__Authentication;
			return soap_in_vin__Authentication(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:Activity"))
		{	*type = SOAP_TYPE_vin__Activity;
			return soap_in_vin__Activity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ActivityNote"))
		{	*type = SOAP_TYPE_vin__ActivityNote;
			return soap_in_vin__ActivityNote(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ActivityCancellation"))
		{	*type = SOAP_TYPE_vin__ActivityCancellation;
			return soap_in_vin__ActivityCancellation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ActivityNamedValue"))
		{	*type = SOAP_TYPE_vin__ActivityNamedValue;
			return soap_in_vin__ActivityNamedValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ActivityUsage"))
		{	*type = SOAP_TYPE_vin__ActivityUsage;
			return soap_in_vin__ActivityUsage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ActivityFulfillment"))
		{	*type = SOAP_TYPE_vin__ActivityFulfillment;
			return soap_in_vin__ActivityFulfillment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ActivityEmailContact"))
		{	*type = SOAP_TYPE_vin__ActivityEmailContact;
			return soap_in_vin__ActivityEmailContact(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ActivityPhoneContact"))
		{	*type = SOAP_TYPE_vin__ActivityPhoneContact;
			return soap_in_vin__ActivityPhoneContact(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ActivityURIView"))
		{	*type = SOAP_TYPE_vin__ActivityURIView;
			return soap_in_vin__ActivityURIView(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ActivityLogout"))
		{	*type = SOAP_TYPE_vin__ActivityLogout;
			return soap_in_vin__ActivityLogout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ActivityLogin"))
		{	*type = SOAP_TYPE_vin__ActivityLogin;
			return soap_in_vin__ActivityLogin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:ActivityTypeArg"))
		{	*type = SOAP_TYPE_vin__ActivityTypeArg;
			return soap_in_vin__ActivityTypeArg(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:TokenAmount"))
		{	*type = SOAP_TYPE_ArrayOfTokenAmounts;
			return soap_in_ArrayOfTokenAmounts(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:TaxExemption"))
		{	*type = SOAP_TYPE_ArrayOfTaxExemptions;
			return soap_in_ArrayOfTaxExemptions(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:NameValuePair"))
		{	*type = SOAP_TYPE_ArrayOfNameValuePairs;
			return soap_in_ArrayOfNameValuePairs(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "vin:PaymentMethod"))
		{	*type = SOAP_TYPE_ArrayOfPaymentMethods;
			return soap_in_ArrayOfPaymentMethods(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:Address"))
		{	*type = SOAP_TYPE_vin__Address;
			return soap_in_vin__Address(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "vin:Account"))
		{	*type = SOAP_TYPE_vin__Account;
			return soap_in_vin__Account(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	char **s;
			*type = SOAP_TYPE_xsd__decimal;
			s = soap_in_xsd__decimal(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	char **s;
			*type = SOAP_TYPE_xsd__date;
			s = soap_in_xsd__date(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anyURI;
			s = soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_vin__AVSMatchType:
		return soap_out_vin__AVSMatchType(soap, tag, id, (const enum vin__AVSMatchType *)ptr, "vin:AVSMatchType");
	case SOAP_TYPE_vin__TransactionStatusType:
		return soap_out_vin__TransactionStatusType(soap, tag, id, (const enum vin__TransactionStatusType *)ptr, "vin:TransactionStatusType");
	case SOAP_TYPE_vin__TaxRegion:
		return soap_out_vin__TaxRegion(soap, tag, id, (const enum vin__TaxRegion *)ptr, "vin:TaxRegion");
	case SOAP_TYPE_vin__ReturnCode:
		return soap_out_vin__ReturnCode(soap, tag, id, (const enum vin__ReturnCode *)ptr, "vin:ReturnCode");
	case SOAP_TYPE_vin__RefundTokenAction:
		return soap_out_vin__RefundTokenAction(soap, tag, id, (const enum vin__RefundTokenAction *)ptr, "vin:RefundTokenAction");
	case SOAP_TYPE_vin__TaxClassification:
		return soap_out_vin__TaxClassification(soap, tag, id, (const enum vin__TaxClassification *)ptr, "vin:TaxClassification");
	case SOAP_TYPE_vin__ProductStatus:
		return soap_out_vin__ProductStatus(soap, tag, id, (const enum vin__ProductStatus *)ptr, "vin:ProductStatus");
	case SOAP_TYPE_vin__ECPTransactionType:
		return soap_out_vin__ECPTransactionType(soap, tag, id, (const enum vin__ECPTransactionType *)ptr, "vin:ECPTransactionType");
	case SOAP_TYPE_vin__AccountType:
		return soap_out_vin__AccountType(soap, tag, id, (const enum vin__AccountType *)ptr, "vin:AccountType");
	case SOAP_TYPE_vin__HashType:
		return soap_out_vin__HashType(soap, tag, id, (const enum vin__HashType *)ptr, "vin:HashType");
	case SOAP_TYPE_vin__PaymentMethodType:
		return soap_out_vin__PaymentMethodType(soap, tag, id, (const enum vin__PaymentMethodType *)ptr, "vin:PaymentMethodType");
	case SOAP_TYPE_vin__MetricStatusType:
		return soap_out_vin__MetricStatusType(soap, tag, id, (const enum vin__MetricStatusType *)ptr, "vin:MetricStatusType");
	case SOAP_TYPE_vin__EmailTemplateType:
		return soap_out_vin__EmailTemplateType(soap, tag, id, (const enum vin__EmailTemplateType *)ptr, "vin:EmailTemplateType");
	case SOAP_TYPE_vin__ChargebackStatus:
		return soap_out_vin__ChargebackStatus(soap, tag, id, (const enum vin__ChargebackStatus *)ptr, "vin:ChargebackStatus");
	case SOAP_TYPE_vin__BillingPlanStatus:
		return soap_out_vin__BillingPlanStatus(soap, tag, id, (const enum vin__BillingPlanStatus *)ptr, "vin:BillingPlanStatus");
	case SOAP_TYPE_vin__BillingPeriodType:
		return soap_out_vin__BillingPeriodType(soap, tag, id, (const enum vin__BillingPeriodType *)ptr, "vin:BillingPeriodType");
	case SOAP_TYPE_vin__DuplicateBehavior:
		return soap_out_vin__DuplicateBehavior(soap, tag, id, (const enum vin__DuplicateBehavior *)ptr, "vin:DuplicateBehavior");
	case SOAP_TYPE_vin__AutoBillStatus:
		return soap_out_vin__AutoBillStatus(soap, tag, id, (const enum vin__AutoBillStatus *)ptr, "vin:AutoBillStatus");
	case SOAP_TYPE_vin__AddressType:
		return soap_out_vin__AddressType(soap, tag, id, (const enum vin__AddressType *)ptr, "vin:AddressType");
	case SOAP_TYPE_vin__ActivityCallType:
		return soap_out_vin__ActivityCallType(soap, tag, id, (const enum vin__ActivityCallType *)ptr, "vin:ActivityCallType");
	case SOAP_TYPE_vin__ActivityType:
		return soap_out_vin__ActivityType(soap, tag, id, (const enum vin__ActivityType *)ptr, "vin:ActivityType");
	case SOAP_TYPE_vin__ActivityCancelInitType:
		return soap_out_vin__ActivityCancelInitType(soap, tag, id, (const enum vin__ActivityCancelInitType *)ptr, "vin:ActivityCancelInitType");
	case SOAP_TYPE_vin__PaymentUpdateBehavior:
		return soap_out_vin__PaymentUpdateBehavior(soap, tag, id, (const enum vin__PaymentUpdateBehavior *)ptr, "vin:PaymentUpdateBehavior");
	case SOAP_TYPE_vin__EmailPreference:
		return soap_out_vin__EmailPreference(soap, tag, id, (const enum vin__EmailPreference *)ptr, "vin:EmailPreference");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE_trn__score:
		return soap_out_trn__score(soap, tag, id, (const struct trn__score *)ptr, "trn:score");
	case SOAP_TYPE_trn__scoreResponse:
		return soap_out_trn__scoreResponse(soap, tag, id, (const struct trn__scoreResponse *)ptr, "trn:scoreResponse");
	case SOAP_TYPE_trn__report:
		return soap_out_trn__report(soap, tag, id, (const struct trn__report *)ptr, "trn:report");
	case SOAP_TYPE_trn__reportResponse:
		return soap_out_trn__reportResponse(soap, tag, id, (const struct trn__reportResponse *)ptr, "trn:reportResponse");
	case SOAP_TYPE_trn__authCapture:
		return soap_out_trn__authCapture(soap, tag, id, (const struct trn__authCapture *)ptr, "trn:authCapture");
	case SOAP_TYPE_trn__authCaptureResponse:
		return soap_out_trn__authCaptureResponse(soap, tag, id, (const struct trn__authCaptureResponse *)ptr, "trn:authCaptureResponse");
	case SOAP_TYPE_trn__cancel:
		return soap_out_trn__cancel(soap, tag, id, (const struct trn__cancel *)ptr, "trn:cancel");
	case SOAP_TYPE_trn__cancelResponse:
		return soap_out_trn__cancelResponse(soap, tag, id, (const struct trn__cancelResponse *)ptr, "trn:cancelResponse");
	case SOAP_TYPE_trn__capture:
		return soap_out_trn__capture(soap, tag, id, (const struct trn__capture *)ptr, "trn:capture");
	case SOAP_TYPE_trn__captureResponse:
		return soap_out_trn__captureResponse(soap, tag, id, (const struct trn__captureResponse *)ptr, "trn:captureResponse");
	case SOAP_TYPE_trn__calculateSalesTax:
		return soap_out_trn__calculateSalesTax(soap, tag, id, (const struct trn__calculateSalesTax *)ptr, "trn:calculateSalesTax");
	case SOAP_TYPE_trn__calculateSalesTaxResponse:
		return soap_out_trn__calculateSalesTaxResponse(soap, tag, id, (const struct trn__calculateSalesTaxResponse *)ptr, "trn:calculateSalesTaxResponse");
	case SOAP_TYPE_trn__auth:
		return soap_out_trn__auth(soap, tag, id, (const struct trn__auth *)ptr, "trn:auth");
	case SOAP_TYPE_trn__authResponse:
		return soap_out_trn__authResponse(soap, tag, id, (const struct trn__authResponse *)ptr, "trn:authResponse");
	case SOAP_TYPE_trn__fetchByPaymentMethod:
		return soap_out_trn__fetchByPaymentMethod(soap, tag, id, (const struct trn__fetchByPaymentMethod *)ptr, "trn:fetchByPaymentMethod");
	case SOAP_TYPE_trn__fetchByPaymentMethodResponse:
		return soap_out_trn__fetchByPaymentMethodResponse(soap, tag, id, (const struct trn__fetchByPaymentMethodResponse *)ptr, "trn:fetchByPaymentMethodResponse");
	case SOAP_TYPE_trn__fetchSearchPage:
		return soap_out_trn__fetchSearchPage(soap, tag, id, (const struct trn__fetchSearchPage *)ptr, "trn:fetchSearchPage");
	case SOAP_TYPE_trn__fetchSearchPageResponse:
		return soap_out_trn__fetchSearchPageResponse(soap, tag, id, (const struct trn__fetchSearchPageResponse *)ptr, "trn:fetchSearchPageResponse");
	case SOAP_TYPE_trn__fetchByAutobill:
		return soap_out_trn__fetchByAutobill(soap, tag, id, (const struct trn__fetchByAutobill *)ptr, "trn:fetchByAutobill");
	case SOAP_TYPE_trn__fetchByAutobillResponse:
		return soap_out_trn__fetchByAutobillResponse(soap, tag, id, (const struct trn__fetchByAutobillResponse *)ptr, "trn:fetchByAutobillResponse");
	case SOAP_TYPE_trn__fetchDelta:
		return soap_out_trn__fetchDelta(soap, tag, id, (const struct trn__fetchDelta *)ptr, "trn:fetchDelta");
	case SOAP_TYPE_trn__fetchDeltaResponse:
		return soap_out_trn__fetchDeltaResponse(soap, tag, id, (const struct trn__fetchDeltaResponse *)ptr, "trn:fetchDeltaResponse");
	case SOAP_TYPE_trn__fetchDeltaSince:
		return soap_out_trn__fetchDeltaSince(soap, tag, id, (const struct trn__fetchDeltaSince *)ptr, "trn:fetchDeltaSince");
	case SOAP_TYPE_trn__fetchDeltaSinceResponse:
		return soap_out_trn__fetchDeltaSinceResponse(soap, tag, id, (const struct trn__fetchDeltaSinceResponse *)ptr, "trn:fetchDeltaSinceResponse");
	case SOAP_TYPE_trn__fetchByMerchantTransactionId:
		return soap_out_trn__fetchByMerchantTransactionId(soap, tag, id, (const struct trn__fetchByMerchantTransactionId *)ptr, "trn:fetchByMerchantTransactionId");
	case SOAP_TYPE_trn__fetchByMerchantTransactionIdResponse:
		return soap_out_trn__fetchByMerchantTransactionIdResponse(soap, tag, id, (const struct trn__fetchByMerchantTransactionIdResponse *)ptr, "trn:fetchByMerchantTransactionIdResponse");
	case SOAP_TYPE_trn__fetchByAccount:
		return soap_out_trn__fetchByAccount(soap, tag, id, (const struct trn__fetchByAccount *)ptr, "trn:fetchByAccount");
	case SOAP_TYPE_trn__fetchByAccountResponse:
		return soap_out_trn__fetchByAccountResponse(soap, tag, id, (const struct trn__fetchByAccountResponse *)ptr, "trn:fetchByAccountResponse");
	case SOAP_TYPE_trn__fetchByVid:
		return soap_out_trn__fetchByVid(soap, tag, id, (const struct trn__fetchByVid *)ptr, "trn:fetchByVid");
	case SOAP_TYPE_trn__fetchByVidResponse:
		return soap_out_trn__fetchByVidResponse(soap, tag, id, (const struct trn__fetchByVidResponse *)ptr, "trn:fetchByVidResponse");
	case SOAP_TYPE_rfd__perform:
		return soap_out_rfd__perform(soap, tag, id, (const struct rfd__perform *)ptr, "rfd:perform");
	case SOAP_TYPE_rfd__performResponse:
		return soap_out_rfd__performResponse(soap, tag, id, (const struct rfd__performResponse *)ptr, "rfd:performResponse");
	case SOAP_TYPE_rfd__report:
		return soap_out_rfd__report(soap, tag, id, (const struct rfd__report *)ptr, "rfd:report");
	case SOAP_TYPE_rfd__reportResponse:
		return soap_out_rfd__reportResponse(soap, tag, id, (const struct rfd__reportResponse *)ptr, "rfd:reportResponse");
	case SOAP_TYPE_rfd__fetchDeltaSince:
		return soap_out_rfd__fetchDeltaSince(soap, tag, id, (const struct rfd__fetchDeltaSince *)ptr, "rfd:fetchDeltaSince");
	case SOAP_TYPE_rfd__fetchDeltaSinceResponse:
		return soap_out_rfd__fetchDeltaSinceResponse(soap, tag, id, (const struct rfd__fetchDeltaSinceResponse *)ptr, "rfd:fetchDeltaSinceResponse");
	case SOAP_TYPE_rfd__fetchByTransaction:
		return soap_out_rfd__fetchByTransaction(soap, tag, id, (const struct rfd__fetchByTransaction *)ptr, "rfd:fetchByTransaction");
	case SOAP_TYPE_rfd__fetchByTransactionResponse:
		return soap_out_rfd__fetchByTransactionResponse(soap, tag, id, (const struct rfd__fetchByTransactionResponse *)ptr, "rfd:fetchByTransactionResponse");
	case SOAP_TYPE_rfd__fetchByAccount:
		return soap_out_rfd__fetchByAccount(soap, tag, id, (const struct rfd__fetchByAccount *)ptr, "rfd:fetchByAccount");
	case SOAP_TYPE_rfd__fetchByAccountResponse:
		return soap_out_rfd__fetchByAccountResponse(soap, tag, id, (const struct rfd__fetchByAccountResponse *)ptr, "rfd:fetchByAccountResponse");
	case SOAP_TYPE_rfd__fetchByVid:
		return soap_out_rfd__fetchByVid(soap, tag, id, (const struct rfd__fetchByVid *)ptr, "rfd:fetchByVid");
	case SOAP_TYPE_rfd__fetchByVidResponse:
		return soap_out_rfd__fetchByVidResponse(soap, tag, id, (const struct rfd__fetchByVidResponse *)ptr, "rfd:fetchByVidResponse");
	case SOAP_TYPE_pyp__fetchByVid:
		return soap_out_pyp__fetchByVid(soap, tag, id, (const struct pyp__fetchByVid *)ptr, "pyp:fetchByVid");
	case SOAP_TYPE_pyp__fetchByVidResponse:
		return soap_out_pyp__fetchByVidResponse(soap, tag, id, (const struct pyp__fetchByVidResponse *)ptr, "pyp:fetchByVidResponse");
	case SOAP_TYPE_pyp__update:
		return soap_out_pyp__update(soap, tag, id, (const struct pyp__update *)ptr, "pyp:update");
	case SOAP_TYPE_pyp__updateResponse:
		return soap_out_pyp__updateResponse(soap, tag, id, (const struct pyp__updateResponse *)ptr, "pyp:updateResponse");
	case SOAP_TYPE_pym__validate:
		return soap_out_pym__validate(soap, tag, id, (const struct pym__validate *)ptr, "pym:validate");
	case SOAP_TYPE_pym__validateResponse:
		return soap_out_pym__validateResponse(soap, tag, id, (const struct pym__validateResponse *)ptr, "pym:validateResponse");
	case SOAP_TYPE_pym__fetchByMerchantPaymentMethodId:
		return soap_out_pym__fetchByMerchantPaymentMethodId(soap, tag, id, (const struct pym__fetchByMerchantPaymentMethodId *)ptr, "pym:fetchByMerchantPaymentMethodId");
	case SOAP_TYPE_pym__fetchByMerchantPaymentMethodIdResponse:
		return soap_out_pym__fetchByMerchantPaymentMethodIdResponse(soap, tag, id, (const struct pym__fetchByMerchantPaymentMethodIdResponse *)ptr, "pym:fetchByMerchantPaymentMethodIdResponse");
	case SOAP_TYPE_pym__fetchByAccount:
		return soap_out_pym__fetchByAccount(soap, tag, id, (const struct pym__fetchByAccount *)ptr, "pym:fetchByAccount");
	case SOAP_TYPE_pym__fetchByAccountResponse:
		return soap_out_pym__fetchByAccountResponse(soap, tag, id, (const struct pym__fetchByAccountResponse *)ptr, "pym:fetchByAccountResponse");
	case SOAP_TYPE_pym__fetchByVid:
		return soap_out_pym__fetchByVid(soap, tag, id, (const struct pym__fetchByVid *)ptr, "pym:fetchByVid");
	case SOAP_TYPE_pym__fetchByVidResponse:
		return soap_out_pym__fetchByVidResponse(soap, tag, id, (const struct pym__fetchByVidResponse *)ptr, "pym:fetchByVidResponse");
	case SOAP_TYPE_pym__update:
		return soap_out_pym__update(soap, tag, id, (const struct pym__update *)ptr, "pym:update");
	case SOAP_TYPE_pym__updateResponse:
		return soap_out_pym__updateResponse(soap, tag, id, (const struct pym__updateResponse *)ptr, "pym:updateResponse");
	case SOAP_TYPE_prd__fetchByMerchantEntitlementId:
		return soap_out_prd__fetchByMerchantEntitlementId(soap, tag, id, (const struct prd__fetchByMerchantEntitlementId *)ptr, "prd:fetchByMerchantEntitlementId");
	case SOAP_TYPE_prd__fetchByMerchantEntitlementIdResponse:
		return soap_out_prd__fetchByMerchantEntitlementIdResponse(soap, tag, id, (const struct prd__fetchByMerchantEntitlementIdResponse *)ptr, "prd:fetchByMerchantEntitlementIdResponse");
	case SOAP_TYPE_prd__fetchAll:
		return soap_out_prd__fetchAll(soap, tag, id, (const struct prd__fetchAll *)ptr, "prd:fetchAll");
	case SOAP_TYPE_prd__fetchAllResponse:
		return soap_out_prd__fetchAllResponse(soap, tag, id, (const struct prd__fetchAllResponse *)ptr, "prd:fetchAllResponse");
	case SOAP_TYPE_prd__fetchByAccount:
		return soap_out_prd__fetchByAccount(soap, tag, id, (const struct prd__fetchByAccount *)ptr, "prd:fetchByAccount");
	case SOAP_TYPE_prd__fetchByAccountResponse:
		return soap_out_prd__fetchByAccountResponse(soap, tag, id, (const struct prd__fetchByAccountResponse *)ptr, "prd:fetchByAccountResponse");
	case SOAP_TYPE_prd__fetchByMerchantProductId:
		return soap_out_prd__fetchByMerchantProductId(soap, tag, id, (const struct prd__fetchByMerchantProductId *)ptr, "prd:fetchByMerchantProductId");
	case SOAP_TYPE_prd__fetchByMerchantProductIdResponse:
		return soap_out_prd__fetchByMerchantProductIdResponse(soap, tag, id, (const struct prd__fetchByMerchantProductIdResponse *)ptr, "prd:fetchByMerchantProductIdResponse");
	case SOAP_TYPE_prd__fetchByVid:
		return soap_out_prd__fetchByVid(soap, tag, id, (const struct prd__fetchByVid *)ptr, "prd:fetchByVid");
	case SOAP_TYPE_prd__fetchByVidResponse:
		return soap_out_prd__fetchByVidResponse(soap, tag, id, (const struct prd__fetchByVidResponse *)ptr, "prd:fetchByVidResponse");
	case SOAP_TYPE_prd__update:
		return soap_out_prd__update(soap, tag, id, (const struct prd__update *)ptr, "prd:update");
	case SOAP_TYPE_prd__updateResponse:
		return soap_out_prd__updateResponse(soap, tag, id, (const struct prd__updateResponse *)ptr, "prd:updateResponse");
	case SOAP_TYPE_met__report:
		return soap_out_met__report(soap, tag, id, (const struct met__report *)ptr, "met:report");
	case SOAP_TYPE_met__reportResponse:
		return soap_out_met__reportResponse(soap, tag, id, (const struct met__reportResponse *)ptr, "met:reportResponse");
	case SOAP_TYPE_etp__fetchByTypeAndVersion:
		return soap_out_etp__fetchByTypeAndVersion(soap, tag, id, (const struct etp__fetchByTypeAndVersion *)ptr, "etp:fetchByTypeAndVersion");
	case SOAP_TYPE_etp__fetchByTypeAndVersionResponse:
		return soap_out_etp__fetchByTypeAndVersionResponse(soap, tag, id, (const struct etp__fetchByTypeAndVersionResponse *)ptr, "etp:fetchByTypeAndVersionResponse");
	case SOAP_TYPE_etp__fetchByType:
		return soap_out_etp__fetchByType(soap, tag, id, (const struct etp__fetchByType *)ptr, "etp:fetchByType");
	case SOAP_TYPE_etp__fetchByTypeResponse:
		return soap_out_etp__fetchByTypeResponse(soap, tag, id, (const struct etp__fetchByTypeResponse *)ptr, "etp:fetchByTypeResponse");
	case SOAP_TYPE_etp__fetchByProduct:
		return soap_out_etp__fetchByProduct(soap, tag, id, (const struct etp__fetchByProduct *)ptr, "etp:fetchByProduct");
	case SOAP_TYPE_etp__fetchByProductResponse:
		return soap_out_etp__fetchByProductResponse(soap, tag, id, (const struct etp__fetchByProductResponse *)ptr, "etp:fetchByProductResponse");
	case SOAP_TYPE_etp__fetchByVid:
		return soap_out_etp__fetchByVid(soap, tag, id, (const struct etp__fetchByVid *)ptr, "etp:fetchByVid");
	case SOAP_TYPE_etp__fetchByVidResponse:
		return soap_out_etp__fetchByVidResponse(soap, tag, id, (const struct etp__fetchByVidResponse *)ptr, "etp:fetchByVidResponse");
	case SOAP_TYPE_etp__update:
		return soap_out_etp__update(soap, tag, id, (const struct etp__update *)ptr, "etp:update");
	case SOAP_TYPE_etp__updateResponse:
		return soap_out_etp__updateResponse(soap, tag, id, (const struct etp__updateResponse *)ptr, "etp:updateResponse");
	case SOAP_TYPE_ent__fetchDeltaSince:
		return soap_out_ent__fetchDeltaSince(soap, tag, id, (const struct ent__fetchDeltaSince *)ptr, "ent:fetchDeltaSince");
	case SOAP_TYPE_ent__fetchDeltaSinceResponse:
		return soap_out_ent__fetchDeltaSinceResponse(soap, tag, id, (const struct ent__fetchDeltaSinceResponse *)ptr, "ent:fetchDeltaSinceResponse");
	case SOAP_TYPE_ent__fetchByAccount:
		return soap_out_ent__fetchByAccount(soap, tag, id, (const struct ent__fetchByAccount *)ptr, "ent:fetchByAccount");
	case SOAP_TYPE_ent__fetchByAccountResponse:
		return soap_out_ent__fetchByAccountResponse(soap, tag, id, (const struct ent__fetchByAccountResponse *)ptr, "ent:fetchByAccountResponse");
	case SOAP_TYPE_ent__fetchByEntitlementIdAndAccount:
		return soap_out_ent__fetchByEntitlementIdAndAccount(soap, tag, id, (const struct ent__fetchByEntitlementIdAndAccount *)ptr, "ent:fetchByEntitlementIdAndAccount");
	case SOAP_TYPE_ent__fetchByEntitlementIdAndAccountResponse:
		return soap_out_ent__fetchByEntitlementIdAndAccountResponse(soap, tag, id, (const struct ent__fetchByEntitlementIdAndAccountResponse *)ptr, "ent:fetchByEntitlementIdAndAccountResponse");
	case SOAP_TYPE_ecs__getSignatureBlock:
		return soap_out_ecs__getSignatureBlock(soap, tag, id, (const struct ecs__getSignatureBlock *)ptr, "ecs:getSignatureBlock");
	case SOAP_TYPE_ecs__getSignatureBlockResponse:
		return soap_out_ecs__getSignatureBlockResponse(soap, tag, id, (const struct ecs__getSignatureBlockResponse *)ptr, "ecs:getSignatureBlockResponse");
	case SOAP_TYPE_ecs__sign:
		return soap_out_ecs__sign(soap, tag, id, (const struct ecs__sign *)ptr, "ecs:sign");
	case SOAP_TYPE_ecs__signResponse:
		return soap_out_ecs__signResponse(soap, tag, id, (const struct ecs__signResponse *)ptr, "ecs:signResponse");
	case SOAP_TYPE_cgb__report:
		return soap_out_cgb__report(soap, tag, id, (const struct cgb__report *)ptr, "cgb:report");
	case SOAP_TYPE_cgb__reportResponse:
		return soap_out_cgb__reportResponse(soap, tag, id, (const struct cgb__reportResponse *)ptr, "cgb:reportResponse");
	case SOAP_TYPE_cgb__fetchDelta:
		return soap_out_cgb__fetchDelta(soap, tag, id, (const struct cgb__fetchDelta *)ptr, "cgb:fetchDelta");
	case SOAP_TYPE_cgb__fetchDeltaResponse:
		return soap_out_cgb__fetchDeltaResponse(soap, tag, id, (const struct cgb__fetchDeltaResponse *)ptr, "cgb:fetchDeltaResponse");
	case SOAP_TYPE_cgb__fetchDeltaSince:
		return soap_out_cgb__fetchDeltaSince(soap, tag, id, (const struct cgb__fetchDeltaSince *)ptr, "cgb:fetchDeltaSince");
	case SOAP_TYPE_cgb__fetchDeltaSinceResponse:
		return soap_out_cgb__fetchDeltaSinceResponse(soap, tag, id, (const struct cgb__fetchDeltaSinceResponse *)ptr, "cgb:fetchDeltaSinceResponse");
	case SOAP_TYPE_cgb__fetchByMerchantTransactionId:
		return soap_out_cgb__fetchByMerchantTransactionId(soap, tag, id, (const struct cgb__fetchByMerchantTransactionId *)ptr, "cgb:fetchByMerchantTransactionId");
	case SOAP_TYPE_cgb__fetchByMerchantTransactionIdResponse:
		return soap_out_cgb__fetchByMerchantTransactionIdResponse(soap, tag, id, (const struct cgb__fetchByMerchantTransactionIdResponse *)ptr, "cgb:fetchByMerchantTransactionIdResponse");
	case SOAP_TYPE_cgb__fetchByStatusSince:
		return soap_out_cgb__fetchByStatusSince(soap, tag, id, (const struct cgb__fetchByStatusSince *)ptr, "cgb:fetchByStatusSince");
	case SOAP_TYPE_cgb__fetchByStatusSinceResponse:
		return soap_out_cgb__fetchByStatusSinceResponse(soap, tag, id, (const struct cgb__fetchByStatusSinceResponse *)ptr, "cgb:fetchByStatusSinceResponse");
	case SOAP_TYPE_cgb__fetchByStatus:
		return soap_out_cgb__fetchByStatus(soap, tag, id, (const struct cgb__fetchByStatus *)ptr, "cgb:fetchByStatus");
	case SOAP_TYPE_cgb__fetchByStatusResponse:
		return soap_out_cgb__fetchByStatusResponse(soap, tag, id, (const struct cgb__fetchByStatusResponse *)ptr, "cgb:fetchByStatusResponse");
	case SOAP_TYPE_cgb__fetchByReferenceNumber:
		return soap_out_cgb__fetchByReferenceNumber(soap, tag, id, (const struct cgb__fetchByReferenceNumber *)ptr, "cgb:fetchByReferenceNumber");
	case SOAP_TYPE_cgb__fetchByReferenceNumberResponse:
		return soap_out_cgb__fetchByReferenceNumberResponse(soap, tag, id, (const struct cgb__fetchByReferenceNumberResponse *)ptr, "cgb:fetchByReferenceNumberResponse");
	case SOAP_TYPE_cgb__fetchByCaseNumber:
		return soap_out_cgb__fetchByCaseNumber(soap, tag, id, (const struct cgb__fetchByCaseNumber *)ptr, "cgb:fetchByCaseNumber");
	case SOAP_TYPE_cgb__fetchByCaseNumberResponse:
		return soap_out_cgb__fetchByCaseNumberResponse(soap, tag, id, (const struct cgb__fetchByCaseNumberResponse *)ptr, "cgb:fetchByCaseNumberResponse");
	case SOAP_TYPE_cgb__fetchByAccount:
		return soap_out_cgb__fetchByAccount(soap, tag, id, (const struct cgb__fetchByAccount *)ptr, "cgb:fetchByAccount");
	case SOAP_TYPE_cgb__fetchByAccountResponse:
		return soap_out_cgb__fetchByAccountResponse(soap, tag, id, (const struct cgb__fetchByAccountResponse *)ptr, "cgb:fetchByAccountResponse");
	case SOAP_TYPE_cgb__fetchByVid:
		return soap_out_cgb__fetchByVid(soap, tag, id, (const struct cgb__fetchByVid *)ptr, "cgb:fetchByVid");
	case SOAP_TYPE_cgb__fetchByVidResponse:
		return soap_out_cgb__fetchByVidResponse(soap, tag, id, (const struct cgb__fetchByVidResponse *)ptr, "cgb:fetchByVidResponse");
	case SOAP_TYPE_cgb__update:
		return soap_out_cgb__update(soap, tag, id, (const struct cgb__update *)ptr, "cgb:update");
	case SOAP_TYPE_cgb__updateResponse:
		return soap_out_cgb__updateResponse(soap, tag, id, (const struct cgb__updateResponse *)ptr, "cgb:updateResponse");
	case SOAP_TYPE_bpl__fetchByMerchantEntitlementId:
		return soap_out_bpl__fetchByMerchantEntitlementId(soap, tag, id, (const struct bpl__fetchByMerchantEntitlementId *)ptr, "bpl:fetchByMerchantEntitlementId");
	case SOAP_TYPE_bpl__fetchByMerchantEntitlementIdResponse:
		return soap_out_bpl__fetchByMerchantEntitlementIdResponse(soap, tag, id, (const struct bpl__fetchByMerchantEntitlementIdResponse *)ptr, "bpl:fetchByMerchantEntitlementIdResponse");
	case SOAP_TYPE_bpl__fetchAll:
		return soap_out_bpl__fetchAll(soap, tag, id, (const struct bpl__fetchAll *)ptr, "bpl:fetchAll");
	case SOAP_TYPE_bpl__fetchAllResponse:
		return soap_out_bpl__fetchAllResponse(soap, tag, id, (const struct bpl__fetchAllResponse *)ptr, "bpl:fetchAllResponse");
	case SOAP_TYPE_bpl__fetchByBillingPlanStatus:
		return soap_out_bpl__fetchByBillingPlanStatus(soap, tag, id, (const struct bpl__fetchByBillingPlanStatus *)ptr, "bpl:fetchByBillingPlanStatus");
	case SOAP_TYPE_bpl__fetchByBillingPlanStatusResponse:
		return soap_out_bpl__fetchByBillingPlanStatusResponse(soap, tag, id, (const struct bpl__fetchByBillingPlanStatusResponse *)ptr, "bpl:fetchByBillingPlanStatusResponse");
	case SOAP_TYPE_bpl__fetchByMerchantBillingPlanId:
		return soap_out_bpl__fetchByMerchantBillingPlanId(soap, tag, id, (const struct bpl__fetchByMerchantBillingPlanId *)ptr, "bpl:fetchByMerchantBillingPlanId");
	case SOAP_TYPE_bpl__fetchByMerchantBillingPlanIdResponse:
		return soap_out_bpl__fetchByMerchantBillingPlanIdResponse(soap, tag, id, (const struct bpl__fetchByMerchantBillingPlanIdResponse *)ptr, "bpl:fetchByMerchantBillingPlanIdResponse");
	case SOAP_TYPE_bpl__fetchByVid:
		return soap_out_bpl__fetchByVid(soap, tag, id, (const struct bpl__fetchByVid *)ptr, "bpl:fetchByVid");
	case SOAP_TYPE_bpl__fetchByVidResponse:
		return soap_out_bpl__fetchByVidResponse(soap, tag, id, (const struct bpl__fetchByVidResponse *)ptr, "bpl:fetchByVidResponse");
	case SOAP_TYPE_bpl__update:
		return soap_out_bpl__update(soap, tag, id, (const struct bpl__update *)ptr, "bpl:update");
	case SOAP_TYPE_bpl__updateResponse:
		return soap_out_bpl__updateResponse(soap, tag, id, (const struct bpl__updateResponse *)ptr, "bpl:updateResponse");
	case SOAP_TYPE_add__fetchByVid:
		return soap_out_add__fetchByVid(soap, tag, id, (const struct add__fetchByVid *)ptr, "add:fetchByVid");
	case SOAP_TYPE_add__fetchByVidResponse:
		return soap_out_add__fetchByVidResponse(soap, tag, id, (const struct add__fetchByVidResponse *)ptr, "add:fetchByVidResponse");
	case SOAP_TYPE_add__update:
		return soap_out_add__update(soap, tag, id, (const struct add__update *)ptr, "add:update");
	case SOAP_TYPE_add__updateResponse:
		return soap_out_add__updateResponse(soap, tag, id, (const struct add__updateResponse *)ptr, "add:updateResponse");
	case SOAP_TYPE_act__record:
		return soap_out_act__record(soap, tag, id, (const struct act__record *)ptr, "act:record");
	case SOAP_TYPE_act__recordResponse:
		return soap_out_act__recordResponse(soap, tag, id, (const struct act__recordResponse *)ptr, "act:recordResponse");
	case SOAP_TYPE_acc__transfer:
		return soap_out_acc__transfer(soap, tag, id, (const struct acc__transfer *)ptr, "acc:transfer");
	case SOAP_TYPE_acc__transferResponse:
		return soap_out_acc__transferResponse(soap, tag, id, (const struct acc__transferResponse *)ptr, "acc:transferResponse");
	case SOAP_TYPE_acc__decrementTokens:
		return soap_out_acc__decrementTokens(soap, tag, id, (const struct acc__decrementTokens *)ptr, "acc:decrementTokens");
	case SOAP_TYPE_acc__decrementTokensResponse:
		return soap_out_acc__decrementTokensResponse(soap, tag, id, (const struct acc__decrementTokensResponse *)ptr, "acc:decrementTokensResponse");
	case SOAP_TYPE_acc__incrementTokens:
		return soap_out_acc__incrementTokens(soap, tag, id, (const struct acc__incrementTokens *)ptr, "acc:incrementTokens");
	case SOAP_TYPE_acc__incrementTokensResponse:
		return soap_out_acc__incrementTokensResponse(soap, tag, id, (const struct acc__incrementTokensResponse *)ptr, "acc:incrementTokensResponse");
	case SOAP_TYPE_acc__tokenTransaction:
		return soap_out_acc__tokenTransaction(soap, tag, id, (const struct acc__tokenTransaction *)ptr, "acc:tokenTransaction");
	case SOAP_TYPE_acc__tokenTransactionResponse:
		return soap_out_acc__tokenTransactionResponse(soap, tag, id, (const struct acc__tokenTransactionResponse *)ptr, "acc:tokenTransactionResponse");
	case SOAP_TYPE_acc__tokenBalance:
		return soap_out_acc__tokenBalance(soap, tag, id, (const struct acc__tokenBalance *)ptr, "acc:tokenBalance");
	case SOAP_TYPE_acc__tokenBalanceResponse:
		return soap_out_acc__tokenBalanceResponse(soap, tag, id, (const struct acc__tokenBalanceResponse *)ptr, "acc:tokenBalanceResponse");
	case SOAP_TYPE_acc__fetchByPaymentMethod:
		return soap_out_acc__fetchByPaymentMethod(soap, tag, id, (const struct acc__fetchByPaymentMethod *)ptr, "acc:fetchByPaymentMethod");
	case SOAP_TYPE_acc__fetchByPaymentMethodResponse:
		return soap_out_acc__fetchByPaymentMethodResponse(soap, tag, id, (const struct acc__fetchByPaymentMethodResponse *)ptr, "acc:fetchByPaymentMethodResponse");
	case SOAP_TYPE_acc__fetchByEmail:
		return soap_out_acc__fetchByEmail(soap, tag, id, (const struct acc__fetchByEmail *)ptr, "acc:fetchByEmail");
	case SOAP_TYPE_acc__fetchByEmailResponse:
		return soap_out_acc__fetchByEmailResponse(soap, tag, id, (const struct acc__fetchByEmailResponse *)ptr, "acc:fetchByEmailResponse");
	case SOAP_TYPE_acc__fetchByVid:
		return soap_out_acc__fetchByVid(soap, tag, id, (const struct acc__fetchByVid *)ptr, "acc:fetchByVid");
	case SOAP_TYPE_acc__fetchByVidResponse:
		return soap_out_acc__fetchByVidResponse(soap, tag, id, (const struct acc__fetchByVidResponse *)ptr, "acc:fetchByVidResponse");
	case SOAP_TYPE_acc__fetchByMerchantAccountId:
		return soap_out_acc__fetchByMerchantAccountId(soap, tag, id, (const struct acc__fetchByMerchantAccountId *)ptr, "acc:fetchByMerchantAccountId");
	case SOAP_TYPE_acc__fetchByMerchantAccountIdResponse:
		return soap_out_acc__fetchByMerchantAccountIdResponse(soap, tag, id, (const struct acc__fetchByMerchantAccountIdResponse *)ptr, "acc:fetchByMerchantAccountIdResponse");
	case SOAP_TYPE_acc__updatePaymentMethod:
		return soap_out_acc__updatePaymentMethod(soap, tag, id, (const struct acc__updatePaymentMethod *)ptr, "acc:updatePaymentMethod");
	case SOAP_TYPE_acc__updatePaymentMethodResponse:
		return soap_out_acc__updatePaymentMethodResponse(soap, tag, id, (const struct acc__updatePaymentMethodResponse *)ptr, "acc:updatePaymentMethodResponse");
	case SOAP_TYPE_acc__stopAutoBilling:
		return soap_out_acc__stopAutoBilling(soap, tag, id, (const struct acc__stopAutoBilling *)ptr, "acc:stopAutoBilling");
	case SOAP_TYPE_acc__stopAutoBillingResponse:
		return soap_out_acc__stopAutoBillingResponse(soap, tag, id, (const struct acc__stopAutoBillingResponse *)ptr, "acc:stopAutoBillingResponse");
	case SOAP_TYPE_acc__update:
		return soap_out_acc__update(soap, tag, id, (const struct acc__update *)ptr, "acc:update");
	case SOAP_TYPE_acc__updateResponse:
		return soap_out_acc__updateResponse(soap, tag, id, (const struct acc__updateResponse *)ptr, "acc:updateResponse");
	case SOAP_TYPE_abl__fetchDeltaSince:
		return soap_out_abl__fetchDeltaSince(soap, tag, id, (const struct abl__fetchDeltaSince *)ptr, "abl:fetchDeltaSince");
	case SOAP_TYPE_abl__fetchDeltaSinceResponse:
		return soap_out_abl__fetchDeltaSinceResponse(soap, tag, id, (const struct abl__fetchDeltaSinceResponse *)ptr, "abl:fetchDeltaSinceResponse");
	case SOAP_TYPE_abl__futureRebills:
		return soap_out_abl__futureRebills(soap, tag, id, (const struct abl__futureRebills *)ptr, "abl:futureRebills");
	case SOAP_TYPE_abl__futureRebillsResponse:
		return soap_out_abl__futureRebillsResponse(soap, tag, id, (const struct abl__futureRebillsResponse *)ptr, "abl:futureRebillsResponse");
	case SOAP_TYPE_abl__fetchByAccount:
		return soap_out_abl__fetchByAccount(soap, tag, id, (const struct abl__fetchByAccount *)ptr, "abl:fetchByAccount");
	case SOAP_TYPE_abl__fetchByAccountResponse:
		return soap_out_abl__fetchByAccountResponse(soap, tag, id, (const struct abl__fetchByAccountResponse *)ptr, "abl:fetchByAccountResponse");
	case SOAP_TYPE_abl__fetchByEmail:
		return soap_out_abl__fetchByEmail(soap, tag, id, (const struct abl__fetchByEmail *)ptr, "abl:fetchByEmail");
	case SOAP_TYPE_abl__fetchByEmailResponse:
		return soap_out_abl__fetchByEmailResponse(soap, tag, id, (const struct abl__fetchByEmailResponse *)ptr, "abl:fetchByEmailResponse");
	case SOAP_TYPE_abl__fetchByVid:
		return soap_out_abl__fetchByVid(soap, tag, id, (const struct abl__fetchByVid *)ptr, "abl:fetchByVid");
	case SOAP_TYPE_abl__fetchByVidResponse:
		return soap_out_abl__fetchByVidResponse(soap, tag, id, (const struct abl__fetchByVidResponse *)ptr, "abl:fetchByVidResponse");
	case SOAP_TYPE_abl__fetchByMerchantAutoBillId:
		return soap_out_abl__fetchByMerchantAutoBillId(soap, tag, id, (const struct abl__fetchByMerchantAutoBillId *)ptr, "abl:fetchByMerchantAutoBillId");
	case SOAP_TYPE_abl__fetchByMerchantAutoBillIdResponse:
		return soap_out_abl__fetchByMerchantAutoBillIdResponse(soap, tag, id, (const struct abl__fetchByMerchantAutoBillIdResponse *)ptr, "abl:fetchByMerchantAutoBillIdResponse");
	case SOAP_TYPE_abl__fetchByAccountAndProduct:
		return soap_out_abl__fetchByAccountAndProduct(soap, tag, id, (const struct abl__fetchByAccountAndProduct *)ptr, "abl:fetchByAccountAndProduct");
	case SOAP_TYPE_abl__fetchByAccountAndProductResponse:
		return soap_out_abl__fetchByAccountAndProductResponse(soap, tag, id, (const struct abl__fetchByAccountAndProductResponse *)ptr, "abl:fetchByAccountAndProductResponse");
	case SOAP_TYPE_abl__changeBillingDayOfMonth:
		return soap_out_abl__changeBillingDayOfMonth(soap, tag, id, (const struct abl__changeBillingDayOfMonth *)ptr, "abl:changeBillingDayOfMonth");
	case SOAP_TYPE_abl__changeBillingDayOfMonthResponse:
		return soap_out_abl__changeBillingDayOfMonthResponse(soap, tag, id, (const struct abl__changeBillingDayOfMonthResponse *)ptr, "abl:changeBillingDayOfMonthResponse");
	case SOAP_TYPE_abl__delayBillingByDays:
		return soap_out_abl__delayBillingByDays(soap, tag, id, (const struct abl__delayBillingByDays *)ptr, "abl:delayBillingByDays");
	case SOAP_TYPE_abl__delayBillingByDaysResponse:
		return soap_out_abl__delayBillingByDaysResponse(soap, tag, id, (const struct abl__delayBillingByDaysResponse *)ptr, "abl:delayBillingByDaysResponse");
	case SOAP_TYPE_abl__delayBillingToDate:
		return soap_out_abl__delayBillingToDate(soap, tag, id, (const struct abl__delayBillingToDate *)ptr, "abl:delayBillingToDate");
	case SOAP_TYPE_abl__delayBillingToDateResponse:
		return soap_out_abl__delayBillingToDateResponse(soap, tag, id, (const struct abl__delayBillingToDateResponse *)ptr, "abl:delayBillingToDateResponse");
	case SOAP_TYPE_abl__cancel:
		return soap_out_abl__cancel(soap, tag, id, (const struct abl__cancel *)ptr, "abl:cancel");
	case SOAP_TYPE_abl__cancelResponse:
		return soap_out_abl__cancelResponse(soap, tag, id, (const struct abl__cancelResponse *)ptr, "abl:cancelResponse");
	case SOAP_TYPE_abl__update:
		return soap_out_abl__update(soap, tag, id, (const struct abl__update *)ptr, "abl:update");
	case SOAP_TYPE_abl__updateResponse:
		return soap_out_abl__updateResponse(soap, tag, id, (const struct abl__updateResponse *)ptr, "abl:updateResponse");
	case SOAP_TYPE_ArrayOfScoreCodes:
		return soap_out_ArrayOfScoreCodes(soap, tag, id, (const struct ArrayOfScoreCodes *)ptr, "vin:ScoreCode");
	case SOAP_TYPE_ArrayOfCancelResults:
		return soap_out_ArrayOfCancelResults(soap, tag, id, (const struct ArrayOfCancelResults *)ptr, "vin:CancelResult");
	case SOAP_TYPE_ArrayOfCaptureResults:
		return soap_out_ArrayOfCaptureResults(soap, tag, id, (const struct ArrayOfCaptureResults *)ptr, "vin:CaptureResult");
	case SOAP_TYPE_ArrayOfTokenTransactions:
		return soap_out_ArrayOfTokenTransactions(soap, tag, id, (const struct ArrayOfTokenTransactions *)ptr, "vin:TokenTransaction");
	case SOAP_TYPE_ArrayOfTokens:
		return soap_out_ArrayOfTokens(soap, tag, id, (const struct ArrayOfTokens *)ptr, "vin:Token");
	case SOAP_TYPE_ArrayOfTaxExemption:
		return soap_out_ArrayOfTaxExemption(soap, tag, id, (const struct ArrayOfTaxExemption *)ptr, "vin:TaxExemption");
	case SOAP_TYPE_ArrayOfSalesTaxes:
		return soap_out_ArrayOfSalesTaxes(soap, tag, id, (const struct ArrayOfSalesTaxes *)ptr, "vin:SalesTax");
	case SOAP_TYPE_ArrayOfRefunds:
		return soap_out_ArrayOfRefunds(soap, tag, id, (const struct ArrayOfRefunds *)ptr, "vin:Refund");
	case SOAP_TYPE_ArrayOfProducts:
		return soap_out_ArrayOfProducts(soap, tag, id, (const struct ArrayOfProducts *)ptr, "vin:Product");
	case SOAP_TYPE_ArrayOfMetricStats:
		return soap_out_ArrayOfMetricStats(soap, tag, id, (const struct ArrayOfMetricStats *)ptr, "vin:MetricStatistics");
	case SOAP_TYPE_ArrayOfEntitlements:
		return soap_out_ArrayOfEntitlements(soap, tag, id, (const struct ArrayOfEntitlements *)ptr, "vin:Entitlement");
	case SOAP_TYPE_ArrayOfEmailTemplates:
		return soap_out_ArrayOfEmailTemplates(soap, tag, id, (const struct ArrayOfEmailTemplates *)ptr, "vin:EmailTemplate");
	case SOAP_TYPE_ArrayOfChargebacks:
		return soap_out_ArrayOfChargebacks(soap, tag, id, (const struct ArrayOfChargebacks *)ptr, "vin:Chargeback");
	case SOAP_TYPE_ArrayOfBillingPlans:
		return soap_out_ArrayOfBillingPlans(soap, tag, id, (const struct ArrayOfBillingPlans *)ptr, "vin:BillingPlan");
	case SOAP_TYPE_ArrayOfAutoBills:
		return soap_out_ArrayOfAutoBills(soap, tag, id, (const struct ArrayOfAutoBills *)ptr, "vin:AutoBill");
	case SOAP_TYPE_ArrayOfActivities:
		return soap_out_ArrayOfActivities(soap, tag, id, (const struct ArrayOfActivities *)ptr, "vin:Activity");
	case SOAP_TYPE_ArrayOfAccounts:
		return soap_out_ArrayOfAccounts(soap, tag, id, (const struct ArrayOfAccounts *)ptr, "vin:Account");
	case SOAP_TYPE_ArrayOfTransactionItems:
		return soap_out_ArrayOfTransactionItems(soap, tag, id, (const struct ArrayOfTransactionItems *)ptr, "vin:TransactionItem");
	case SOAP_TYPE_ArrayOfTransactionStatuses:
		return soap_out_ArrayOfTransactionStatuses(soap, tag, id, (const struct ArrayOfTransactionStatuses *)ptr, "vin:TransactionStatus");
	case SOAP_TYPE_vin__TransactionStatusDirectDebit:
		return soap_out_vin__TransactionStatusDirectDebit(soap, tag, id, (const struct vin__TransactionStatusDirectDebit *)ptr, "vin:TransactionStatusDirectDebit");
	case SOAP_TYPE_vin__TransactionStatusPayPal:
		return soap_out_vin__TransactionStatusPayPal(soap, tag, id, (const struct vin__TransactionStatusPayPal *)ptr, "vin:TransactionStatusPayPal");
	case SOAP_TYPE_vin__TransactionStatusBoleto:
		return soap_out_vin__TransactionStatusBoleto(soap, tag, id, (const struct vin__TransactionStatusBoleto *)ptr, "vin:TransactionStatusBoleto");
	case SOAP_TYPE_vin__TransactionStatusECP:
		return soap_out_vin__TransactionStatusECP(soap, tag, id, (const struct vin__TransactionStatusECP *)ptr, "vin:TransactionStatusECP");
	case SOAP_TYPE_vin__TransactionStatusCreditCard:
		return soap_out_vin__TransactionStatusCreditCard(soap, tag, id, (const struct vin__TransactionStatusCreditCard *)ptr, "vin:TransactionStatusCreditCard");
	case SOAP_TYPE_vin__TransactionStatus:
		return soap_out_vin__TransactionStatus(soap, tag, id, (const struct vin__TransactionStatus *)ptr, "vin:TransactionStatus");
	case SOAP_TYPE_vin__TransactionItem:
		return soap_out_vin__TransactionItem(soap, tag, id, (const struct vin__TransactionItem *)ptr, "vin:TransactionItem");
	case SOAP_TYPE_vin__ScoreCode:
		return soap_out_vin__ScoreCode(soap, tag, id, (const struct vin__ScoreCode *)ptr, "vin:ScoreCode");
	case SOAP_TYPE_vin__CancelResult:
		return soap_out_vin__CancelResult(soap, tag, id, (const struct vin__CancelResult *)ptr, "vin:CancelResult");
	case SOAP_TYPE_vin__CaptureResult:
		return soap_out_vin__CaptureResult(soap, tag, id, (const struct vin__CaptureResult *)ptr, "vin:CaptureResult");
	case SOAP_TYPE_vin__TokenTransaction:
		return soap_out_vin__TokenTransaction(soap, tag, id, (const struct vin__TokenTransaction *)ptr, "vin:TokenTransaction");
	case SOAP_TYPE_vin__SalesTax:
		return soap_out_vin__SalesTax(soap, tag, id, (const struct vin__SalesTax *)ptr, "vin:SalesTax");
	case SOAP_TYPE_vin__TaxExemption:
		return soap_out_vin__TaxExemption(soap, tag, id, (const struct vin__TaxExemption *)ptr, "vin:TaxExemption");
	case SOAP_TYPE_vin__Return:
		return soap_out_vin__Return(soap, tag, id, (const struct vin__Return *)ptr, "vin:Return");
	case SOAP_TYPE_vin__Refund:
		return soap_out_vin__Refund(soap, tag, id, (const struct vin__Refund *)ptr, "vin:Refund");
	case SOAP_TYPE_vin__NameValuePair:
		return soap_out_vin__NameValuePair(soap, tag, id, (const struct vin__NameValuePair *)ptr, "vin:NameValuePair");
	case SOAP_TYPE_vin__MerchantEntitlementId:
		return soap_out_vin__MerchantEntitlementId(soap, tag, id, (const struct vin__MerchantEntitlementId *)ptr, "vin:MerchantEntitlementId");
	case SOAP_TYPE_vin__PaymentProvider:
		return soap_out_vin__PaymentProvider(soap, tag, id, (const struct vin__PaymentProvider *)ptr, "vin:PaymentProvider");
	case SOAP_TYPE_vin__Token:
		return soap_out_vin__Token(soap, tag, id, (const struct vin__Token *)ptr, "vin:Token");
	case SOAP_TYPE_vin__Boleto:
		return soap_out_vin__Boleto(soap, tag, id, (const struct vin__Boleto *)ptr, "vin:Boleto");
	case SOAP_TYPE_vin__PayPal:
		return soap_out_vin__PayPal(soap, tag, id, (const struct vin__PayPal *)ptr, "vin:PayPal");
	case SOAP_TYPE_vin__DirectDebit:
		return soap_out_vin__DirectDebit(soap, tag, id, (const struct vin__DirectDebit *)ptr, "vin:DirectDebit");
	case SOAP_TYPE_vin__ECP:
		return soap_out_vin__ECP(soap, tag, id, (const struct vin__ECP *)ptr, "vin:ECP");
	case SOAP_TYPE_vin__CreditCard:
		return soap_out_vin__CreditCard(soap, tag, id, (const struct vin__CreditCard *)ptr, "vin:CreditCard");
	case SOAP_TYPE_vin__MetricStatistics:
		return soap_out_vin__MetricStatistics(soap, tag, id, (const struct vin__MetricStatistics *)ptr, "vin:MetricStatistics");
	case SOAP_TYPE_vin__Entitlement:
		return soap_out_vin__Entitlement(soap, tag, id, (const struct vin__Entitlement *)ptr, "vin:Entitlement");
	case SOAP_TYPE_vin__EmailTemplate:
		return soap_out_vin__EmailTemplate(soap, tag, id, (const struct vin__EmailTemplate *)ptr, "vin:EmailTemplate");
	case SOAP_TYPE_vin__Transaction:
		return soap_out_vin__Transaction(soap, tag, id, (const struct vin__Transaction *)ptr, "vin:Transaction");
	case SOAP_TYPE_vin__ElectronicSignature:
		return soap_out_vin__ElectronicSignature(soap, tag, id, (const struct vin__ElectronicSignature *)ptr, "vin:ElectronicSignature");
	case SOAP_TYPE_vin__Chargeback:
		return soap_out_vin__Chargeback(soap, tag, id, (const struct vin__Chargeback *)ptr, "vin:Chargeback");
	case SOAP_TYPE_ArrayOfMerchantEntitlementIds:
		return soap_out_ArrayOfMerchantEntitlementIds(soap, tag, id, (const struct ArrayOfMerchantEntitlementIds *)ptr, "vin:MerchantEntitlementId");
	case SOAP_TYPE_ArrayOfBillingPlanPeriods:
		return soap_out_ArrayOfBillingPlanPeriods(soap, tag, id, (const struct ArrayOfBillingPlanPeriods *)ptr, "vin:BillingPlanPeriod");
	case SOAP_TYPE_ArrayOfBillingPlanPrices:
		return soap_out_ArrayOfBillingPlanPrices(soap, tag, id, (const struct ArrayOfBillingPlanPrices *)ptr, "vin:BillingPlanPrice");
	case SOAP_TYPE_vin__BillingPlanPeriod:
		return soap_out_vin__BillingPlanPeriod(soap, tag, id, (const struct vin__BillingPlanPeriod *)ptr, "vin:BillingPlanPeriod");
	case SOAP_TYPE_vin__TokenAmount:
		return soap_out_vin__TokenAmount(soap, tag, id, (const struct vin__TokenAmount *)ptr, "vin:TokenAmount");
	case SOAP_TYPE_vin__BillingPlanPrice:
		return soap_out_vin__BillingPlanPrice(soap, tag, id, (const struct vin__BillingPlanPrice *)ptr, "vin:BillingPlanPrice");
	case SOAP_TYPE_ArrayOfTransactions:
		return soap_out_ArrayOfTransactions(soap, tag, id, (const struct ArrayOfTransactions *)ptr, "vin:Transaction");
	case SOAP_TYPE_vin__PaymentMethod:
		return soap_out_vin__PaymentMethod(soap, tag, id, (const struct vin__PaymentMethod *)ptr, "vin:PaymentMethod");
	case SOAP_TYPE_vin__BillingPlan:
		return soap_out_vin__BillingPlan(soap, tag, id, (const struct vin__BillingPlan *)ptr, "vin:BillingPlan");
	case SOAP_TYPE_vin__Product:
		return soap_out_vin__Product(soap, tag, id, (const struct vin__Product *)ptr, "vin:Product");
	case SOAP_TYPE_vin__AutoBill:
		return soap_out_vin__AutoBill(soap, tag, id, (const struct vin__AutoBill *)ptr, "vin:AutoBill");
	case SOAP_TYPE_vin__Authentication:
		return soap_out_vin__Authentication(soap, tag, id, (const struct vin__Authentication *)ptr, "vin:Authentication");
	case SOAP_TYPE_vin__Activity:
		return soap_out_vin__Activity(soap, tag, id, (const struct vin__Activity *)ptr, "vin:Activity");
	case SOAP_TYPE_vin__ActivityNote:
		return soap_out_vin__ActivityNote(soap, tag, id, (const struct vin__ActivityNote *)ptr, "vin:ActivityNote");
	case SOAP_TYPE_vin__ActivityCancellation:
		return soap_out_vin__ActivityCancellation(soap, tag, id, (const struct vin__ActivityCancellation *)ptr, "vin:ActivityCancellation");
	case SOAP_TYPE_vin__ActivityNamedValue:
		return soap_out_vin__ActivityNamedValue(soap, tag, id, (const struct vin__ActivityNamedValue *)ptr, "vin:ActivityNamedValue");
	case SOAP_TYPE_vin__ActivityUsage:
		return soap_out_vin__ActivityUsage(soap, tag, id, (const struct vin__ActivityUsage *)ptr, "vin:ActivityUsage");
	case SOAP_TYPE_vin__ActivityFulfillment:
		return soap_out_vin__ActivityFulfillment(soap, tag, id, (const struct vin__ActivityFulfillment *)ptr, "vin:ActivityFulfillment");
	case SOAP_TYPE_vin__ActivityEmailContact:
		return soap_out_vin__ActivityEmailContact(soap, tag, id, (const struct vin__ActivityEmailContact *)ptr, "vin:ActivityEmailContact");
	case SOAP_TYPE_vin__ActivityPhoneContact:
		return soap_out_vin__ActivityPhoneContact(soap, tag, id, (const struct vin__ActivityPhoneContact *)ptr, "vin:ActivityPhoneContact");
	case SOAP_TYPE_vin__ActivityURIView:
		return soap_out_vin__ActivityURIView(soap, tag, id, (const struct vin__ActivityURIView *)ptr, "vin:ActivityURIView");
	case SOAP_TYPE_vin__ActivityLogout:
		return soap_out_vin__ActivityLogout(soap, tag, id, (const struct vin__ActivityLogout *)ptr, "vin:ActivityLogout");
	case SOAP_TYPE_vin__ActivityLogin:
		return soap_out_vin__ActivityLogin(soap, tag, id, (const struct vin__ActivityLogin *)ptr, "vin:ActivityLogin");
	case SOAP_TYPE_vin__ActivityTypeArg:
		return soap_out_vin__ActivityTypeArg(soap, tag, id, (const struct vin__ActivityTypeArg *)ptr, "vin:ActivityTypeArg");
	case SOAP_TYPE_ArrayOfTokenAmounts:
		return soap_out_ArrayOfTokenAmounts(soap, tag, id, (const struct ArrayOfTokenAmounts *)ptr, "vin:TokenAmount");
	case SOAP_TYPE_ArrayOfTaxExemptions:
		return soap_out_ArrayOfTaxExemptions(soap, tag, id, (const struct ArrayOfTaxExemptions *)ptr, "vin:TaxExemption");
	case SOAP_TYPE_ArrayOfNameValuePairs:
		return soap_out_ArrayOfNameValuePairs(soap, tag, id, (const struct ArrayOfNameValuePairs *)ptr, "vin:NameValuePair");
	case SOAP_TYPE_ArrayOfPaymentMethods:
		return soap_out_ArrayOfPaymentMethods(soap, tag, id, (const struct ArrayOfPaymentMethods *)ptr, "vin:PaymentMethod");
	case SOAP_TYPE_vin__Address:
		return soap_out_vin__Address(soap, tag, id, (const struct vin__Address *)ptr, "vin:Address");
	case SOAP_TYPE_vin__Account:
		return soap_out_vin__Account(soap, tag, id, (const struct vin__Account *)ptr, "vin:Account");
	case SOAP_TYPE_PointerTotrn__scoreResponse:
		return soap_out_PointerTotrn__scoreResponse(soap, tag, id, (struct trn__scoreResponse *const*)ptr, "trn:scoreResponse");
	case SOAP_TYPE_PointerToArrayOfScoreCodes:
		return soap_out_PointerToArrayOfScoreCodes(soap, tag, id, (struct ArrayOfScoreCodes *const*)ptr, "vin:ScoreCode");
	case SOAP_TYPE_PointerTotrn__reportResponse:
		return soap_out_PointerTotrn__reportResponse(soap, tag, id, (struct trn__reportResponse *const*)ptr, "trn:reportResponse");
	case SOAP_TYPE_PointerTotrn__authCaptureResponse:
		return soap_out_PointerTotrn__authCaptureResponse(soap, tag, id, (struct trn__authCaptureResponse *const*)ptr, "trn:authCaptureResponse");
	case SOAP_TYPE_PointerTotrn__cancelResponse:
		return soap_out_PointerTotrn__cancelResponse(soap, tag, id, (struct trn__cancelResponse *const*)ptr, "trn:cancelResponse");
	case SOAP_TYPE_PointerToArrayOfCancelResults:
		return soap_out_PointerToArrayOfCancelResults(soap, tag, id, (struct ArrayOfCancelResults *const*)ptr, "vin:CancelResult");
	case SOAP_TYPE_PointerTotrn__captureResponse:
		return soap_out_PointerTotrn__captureResponse(soap, tag, id, (struct trn__captureResponse *const*)ptr, "trn:captureResponse");
	case SOAP_TYPE_PointerToArrayOfCaptureResults:
		return soap_out_PointerToArrayOfCaptureResults(soap, tag, id, (struct ArrayOfCaptureResults *const*)ptr, "vin:CaptureResult");
	case SOAP_TYPE_PointerTotrn__calculateSalesTaxResponse:
		return soap_out_PointerTotrn__calculateSalesTaxResponse(soap, tag, id, (struct trn__calculateSalesTaxResponse *const*)ptr, "trn:calculateSalesTaxResponse");
	case SOAP_TYPE_PointerToArrayOfSalesTaxes:
		return soap_out_PointerToArrayOfSalesTaxes(soap, tag, id, (struct ArrayOfSalesTaxes *const*)ptr, "vin:SalesTax");
	case SOAP_TYPE_PointerTotrn__authResponse:
		return soap_out_PointerTotrn__authResponse(soap, tag, id, (struct trn__authResponse *const*)ptr, "trn:authResponse");
	case SOAP_TYPE_PointerTotrn__fetchByPaymentMethodResponse:
		return soap_out_PointerTotrn__fetchByPaymentMethodResponse(soap, tag, id, (struct trn__fetchByPaymentMethodResponse *const*)ptr, "trn:fetchByPaymentMethodResponse");
	case SOAP_TYPE_PointerTotrn__fetchSearchPageResponse:
		return soap_out_PointerTotrn__fetchSearchPageResponse(soap, tag, id, (struct trn__fetchSearchPageResponse *const*)ptr, "trn:fetchSearchPageResponse");
	case SOAP_TYPE_PointerTotrn__fetchByAutobillResponse:
		return soap_out_PointerTotrn__fetchByAutobillResponse(soap, tag, id, (struct trn__fetchByAutobillResponse *const*)ptr, "trn:fetchByAutobillResponse");
	case SOAP_TYPE_PointerTotrn__fetchDeltaResponse:
		return soap_out_PointerTotrn__fetchDeltaResponse(soap, tag, id, (struct trn__fetchDeltaResponse *const*)ptr, "trn:fetchDeltaResponse");
	case SOAP_TYPE_PointerTotrn__fetchDeltaSinceResponse:
		return soap_out_PointerTotrn__fetchDeltaSinceResponse(soap, tag, id, (struct trn__fetchDeltaSinceResponse *const*)ptr, "trn:fetchDeltaSinceResponse");
	case SOAP_TYPE_PointerTotrn__fetchByMerchantTransactionIdResponse:
		return soap_out_PointerTotrn__fetchByMerchantTransactionIdResponse(soap, tag, id, (struct trn__fetchByMerchantTransactionIdResponse *const*)ptr, "trn:fetchByMerchantTransactionIdResponse");
	case SOAP_TYPE_PointerTotrn__fetchByAccountResponse:
		return soap_out_PointerTotrn__fetchByAccountResponse(soap, tag, id, (struct trn__fetchByAccountResponse *const*)ptr, "trn:fetchByAccountResponse");
	case SOAP_TYPE_PointerTotrn__fetchByVidResponse:
		return soap_out_PointerTotrn__fetchByVidResponse(soap, tag, id, (struct trn__fetchByVidResponse *const*)ptr, "trn:fetchByVidResponse");
	case SOAP_TYPE_PointerTorfd__performResponse:
		return soap_out_PointerTorfd__performResponse(soap, tag, id, (struct rfd__performResponse *const*)ptr, "rfd:performResponse");
	case SOAP_TYPE_PointerTorfd__reportResponse:
		return soap_out_PointerTorfd__reportResponse(soap, tag, id, (struct rfd__reportResponse *const*)ptr, "rfd:reportResponse");
	case SOAP_TYPE_PointerTorfd__fetchDeltaSinceResponse:
		return soap_out_PointerTorfd__fetchDeltaSinceResponse(soap, tag, id, (struct rfd__fetchDeltaSinceResponse *const*)ptr, "rfd:fetchDeltaSinceResponse");
	case SOAP_TYPE_PointerTorfd__fetchByTransactionResponse:
		return soap_out_PointerTorfd__fetchByTransactionResponse(soap, tag, id, (struct rfd__fetchByTransactionResponse *const*)ptr, "rfd:fetchByTransactionResponse");
	case SOAP_TYPE_PointerTorfd__fetchByAccountResponse:
		return soap_out_PointerTorfd__fetchByAccountResponse(soap, tag, id, (struct rfd__fetchByAccountResponse *const*)ptr, "rfd:fetchByAccountResponse");
	case SOAP_TYPE_PointerToArrayOfRefunds:
		return soap_out_PointerToArrayOfRefunds(soap, tag, id, (struct ArrayOfRefunds *const*)ptr, "vin:Refund");
	case SOAP_TYPE_PointerTorfd__fetchByVidResponse:
		return soap_out_PointerTorfd__fetchByVidResponse(soap, tag, id, (struct rfd__fetchByVidResponse *const*)ptr, "rfd:fetchByVidResponse");
	case SOAP_TYPE_PointerTopyp__fetchByVidResponse:
		return soap_out_PointerTopyp__fetchByVidResponse(soap, tag, id, (struct pyp__fetchByVidResponse *const*)ptr, "pyp:fetchByVidResponse");
	case SOAP_TYPE_PointerTopyp__updateResponse:
		return soap_out_PointerTopyp__updateResponse(soap, tag, id, (struct pyp__updateResponse *const*)ptr, "pyp:updateResponse");
	case SOAP_TYPE_PointerTovin__PaymentProvider:
		return soap_out_PointerTovin__PaymentProvider(soap, tag, id, (struct vin__PaymentProvider *const*)ptr, "vin:PaymentProvider");
	case SOAP_TYPE_PointerTopym__validateResponse:
		return soap_out_PointerTopym__validateResponse(soap, tag, id, (struct pym__validateResponse *const*)ptr, "pym:validateResponse");
	case SOAP_TYPE_PointerTopym__fetchByMerchantPaymentMethodIdResponse:
		return soap_out_PointerTopym__fetchByMerchantPaymentMethodIdResponse(soap, tag, id, (struct pym__fetchByMerchantPaymentMethodIdResponse *const*)ptr, "pym:fetchByMerchantPaymentMethodIdResponse");
	case SOAP_TYPE_PointerTopym__fetchByAccountResponse:
		return soap_out_PointerTopym__fetchByAccountResponse(soap, tag, id, (struct pym__fetchByAccountResponse *const*)ptr, "pym:fetchByAccountResponse");
	case SOAP_TYPE_PointerTopym__fetchByVidResponse:
		return soap_out_PointerTopym__fetchByVidResponse(soap, tag, id, (struct pym__fetchByVidResponse *const*)ptr, "pym:fetchByVidResponse");
	case SOAP_TYPE_PointerTopym__updateResponse:
		return soap_out_PointerTopym__updateResponse(soap, tag, id, (struct pym__updateResponse *const*)ptr, "pym:updateResponse");
	case SOAP_TYPE_PointerToprd__fetchByMerchantEntitlementIdResponse:
		return soap_out_PointerToprd__fetchByMerchantEntitlementIdResponse(soap, tag, id, (struct prd__fetchByMerchantEntitlementIdResponse *const*)ptr, "prd:fetchByMerchantEntitlementIdResponse");
	case SOAP_TYPE_PointerToprd__fetchAllResponse:
		return soap_out_PointerToprd__fetchAllResponse(soap, tag, id, (struct prd__fetchAllResponse *const*)ptr, "prd:fetchAllResponse");
	case SOAP_TYPE_PointerToprd__fetchByAccountResponse:
		return soap_out_PointerToprd__fetchByAccountResponse(soap, tag, id, (struct prd__fetchByAccountResponse *const*)ptr, "prd:fetchByAccountResponse");
	case SOAP_TYPE_PointerToArrayOfProducts:
		return soap_out_PointerToArrayOfProducts(soap, tag, id, (struct ArrayOfProducts *const*)ptr, "vin:Product");
	case SOAP_TYPE_PointerToprd__fetchByMerchantProductIdResponse:
		return soap_out_PointerToprd__fetchByMerchantProductIdResponse(soap, tag, id, (struct prd__fetchByMerchantProductIdResponse *const*)ptr, "prd:fetchByMerchantProductIdResponse");
	case SOAP_TYPE_PointerToprd__fetchByVidResponse:
		return soap_out_PointerToprd__fetchByVidResponse(soap, tag, id, (struct prd__fetchByVidResponse *const*)ptr, "prd:fetchByVidResponse");
	case SOAP_TYPE_PointerToprd__updateResponse:
		return soap_out_PointerToprd__updateResponse(soap, tag, id, (struct prd__updateResponse *const*)ptr, "prd:updateResponse");
	case SOAP_TYPE_PointerTomet__reportResponse:
		return soap_out_PointerTomet__reportResponse(soap, tag, id, (struct met__reportResponse *const*)ptr, "met:reportResponse");
	case SOAP_TYPE_PointerToArrayOfMetricStats:
		return soap_out_PointerToArrayOfMetricStats(soap, tag, id, (struct ArrayOfMetricStats *const*)ptr, "vin:MetricStatistics");
	case SOAP_TYPE_PointerToetp__fetchByTypeAndVersionResponse:
		return soap_out_PointerToetp__fetchByTypeAndVersionResponse(soap, tag, id, (struct etp__fetchByTypeAndVersionResponse *const*)ptr, "etp:fetchByTypeAndVersionResponse");
	case SOAP_TYPE_PointerToetp__fetchByTypeResponse:
		return soap_out_PointerToetp__fetchByTypeResponse(soap, tag, id, (struct etp__fetchByTypeResponse *const*)ptr, "etp:fetchByTypeResponse");
	case SOAP_TYPE_PointerToetp__fetchByProductResponse:
		return soap_out_PointerToetp__fetchByProductResponse(soap, tag, id, (struct etp__fetchByProductResponse *const*)ptr, "etp:fetchByProductResponse");
	case SOAP_TYPE_PointerToArrayOfEmailTemplates:
		return soap_out_PointerToArrayOfEmailTemplates(soap, tag, id, (struct ArrayOfEmailTemplates *const*)ptr, "vin:EmailTemplate");
	case SOAP_TYPE_PointerToetp__fetchByVidResponse:
		return soap_out_PointerToetp__fetchByVidResponse(soap, tag, id, (struct etp__fetchByVidResponse *const*)ptr, "etp:fetchByVidResponse");
	case SOAP_TYPE_PointerToetp__updateResponse:
		return soap_out_PointerToetp__updateResponse(soap, tag, id, (struct etp__updateResponse *const*)ptr, "etp:updateResponse");
	case SOAP_TYPE_PointerToent__fetchDeltaSinceResponse:
		return soap_out_PointerToent__fetchDeltaSinceResponse(soap, tag, id, (struct ent__fetchDeltaSinceResponse *const*)ptr, "ent:fetchDeltaSinceResponse");
	case SOAP_TYPE_PointerToent__fetchByAccountResponse:
		return soap_out_PointerToent__fetchByAccountResponse(soap, tag, id, (struct ent__fetchByAccountResponse *const*)ptr, "ent:fetchByAccountResponse");
	case SOAP_TYPE_PointerToArrayOfEntitlements:
		return soap_out_PointerToArrayOfEntitlements(soap, tag, id, (struct ArrayOfEntitlements *const*)ptr, "vin:Entitlement");
	case SOAP_TYPE_PointerToent__fetchByEntitlementIdAndAccountResponse:
		return soap_out_PointerToent__fetchByEntitlementIdAndAccountResponse(soap, tag, id, (struct ent__fetchByEntitlementIdAndAccountResponse *const*)ptr, "ent:fetchByEntitlementIdAndAccountResponse");
	case SOAP_TYPE_PointerToecs__getSignatureBlockResponse:
		return soap_out_PointerToecs__getSignatureBlockResponse(soap, tag, id, (struct ecs__getSignatureBlockResponse *const*)ptr, "ecs:getSignatureBlockResponse");
	case SOAP_TYPE_PointerToecs__signResponse:
		return soap_out_PointerToecs__signResponse(soap, tag, id, (struct ecs__signResponse *const*)ptr, "ecs:signResponse");
	case SOAP_TYPE_PointerTovin__ElectronicSignature:
		return soap_out_PointerTovin__ElectronicSignature(soap, tag, id, (struct vin__ElectronicSignature *const*)ptr, "vin:ElectronicSignature");
	case SOAP_TYPE_PointerTocgb__reportResponse:
		return soap_out_PointerTocgb__reportResponse(soap, tag, id, (struct cgb__reportResponse *const*)ptr, "cgb:reportResponse");
	case SOAP_TYPE_PointerTocgb__fetchDeltaResponse:
		return soap_out_PointerTocgb__fetchDeltaResponse(soap, tag, id, (struct cgb__fetchDeltaResponse *const*)ptr, "cgb:fetchDeltaResponse");
	case SOAP_TYPE_PointerTocgb__fetchDeltaSinceResponse:
		return soap_out_PointerTocgb__fetchDeltaSinceResponse(soap, tag, id, (struct cgb__fetchDeltaSinceResponse *const*)ptr, "cgb:fetchDeltaSinceResponse");
	case SOAP_TYPE_PointerTocgb__fetchByMerchantTransactionIdResponse:
		return soap_out_PointerTocgb__fetchByMerchantTransactionIdResponse(soap, tag, id, (struct cgb__fetchByMerchantTransactionIdResponse *const*)ptr, "cgb:fetchByMerchantTransactionIdResponse");
	case SOAP_TYPE_PointerTocgb__fetchByStatusSinceResponse:
		return soap_out_PointerTocgb__fetchByStatusSinceResponse(soap, tag, id, (struct cgb__fetchByStatusSinceResponse *const*)ptr, "cgb:fetchByStatusSinceResponse");
	case SOAP_TYPE_PointerTocgb__fetchByStatusResponse:
		return soap_out_PointerTocgb__fetchByStatusResponse(soap, tag, id, (struct cgb__fetchByStatusResponse *const*)ptr, "cgb:fetchByStatusResponse");
	case SOAP_TYPE_PointerTocgb__fetchByReferenceNumberResponse:
		return soap_out_PointerTocgb__fetchByReferenceNumberResponse(soap, tag, id, (struct cgb__fetchByReferenceNumberResponse *const*)ptr, "cgb:fetchByReferenceNumberResponse");
	case SOAP_TYPE_PointerTocgb__fetchByCaseNumberResponse:
		return soap_out_PointerTocgb__fetchByCaseNumberResponse(soap, tag, id, (struct cgb__fetchByCaseNumberResponse *const*)ptr, "cgb:fetchByCaseNumberResponse");
	case SOAP_TYPE_PointerTocgb__fetchByAccountResponse:
		return soap_out_PointerTocgb__fetchByAccountResponse(soap, tag, id, (struct cgb__fetchByAccountResponse *const*)ptr, "cgb:fetchByAccountResponse");
	case SOAP_TYPE_PointerToArrayOfChargebacks:
		return soap_out_PointerToArrayOfChargebacks(soap, tag, id, (struct ArrayOfChargebacks *const*)ptr, "vin:Chargeback");
	case SOAP_TYPE_PointerTocgb__fetchByVidResponse:
		return soap_out_PointerTocgb__fetchByVidResponse(soap, tag, id, (struct cgb__fetchByVidResponse *const*)ptr, "cgb:fetchByVidResponse");
	case SOAP_TYPE_PointerTocgb__updateResponse:
		return soap_out_PointerTocgb__updateResponse(soap, tag, id, (struct cgb__updateResponse *const*)ptr, "cgb:updateResponse");
	case SOAP_TYPE_PointerTobpl__fetchByMerchantEntitlementIdResponse:
		return soap_out_PointerTobpl__fetchByMerchantEntitlementIdResponse(soap, tag, id, (struct bpl__fetchByMerchantEntitlementIdResponse *const*)ptr, "bpl:fetchByMerchantEntitlementIdResponse");
	case SOAP_TYPE_PointerTobpl__fetchAllResponse:
		return soap_out_PointerTobpl__fetchAllResponse(soap, tag, id, (struct bpl__fetchAllResponse *const*)ptr, "bpl:fetchAllResponse");
	case SOAP_TYPE_PointerTobpl__fetchByBillingPlanStatusResponse:
		return soap_out_PointerTobpl__fetchByBillingPlanStatusResponse(soap, tag, id, (struct bpl__fetchByBillingPlanStatusResponse *const*)ptr, "bpl:fetchByBillingPlanStatusResponse");
	case SOAP_TYPE_PointerToArrayOfBillingPlans:
		return soap_out_PointerToArrayOfBillingPlans(soap, tag, id, (struct ArrayOfBillingPlans *const*)ptr, "vin:BillingPlan");
	case SOAP_TYPE_PointerTobpl__fetchByMerchantBillingPlanIdResponse:
		return soap_out_PointerTobpl__fetchByMerchantBillingPlanIdResponse(soap, tag, id, (struct bpl__fetchByMerchantBillingPlanIdResponse *const*)ptr, "bpl:fetchByMerchantBillingPlanIdResponse");
	case SOAP_TYPE_PointerTobpl__fetchByVidResponse:
		return soap_out_PointerTobpl__fetchByVidResponse(soap, tag, id, (struct bpl__fetchByVidResponse *const*)ptr, "bpl:fetchByVidResponse");
	case SOAP_TYPE_PointerTobpl__updateResponse:
		return soap_out_PointerTobpl__updateResponse(soap, tag, id, (struct bpl__updateResponse *const*)ptr, "bpl:updateResponse");
	case SOAP_TYPE_PointerToadd__fetchByVidResponse:
		return soap_out_PointerToadd__fetchByVidResponse(soap, tag, id, (struct add__fetchByVidResponse *const*)ptr, "add:fetchByVidResponse");
	case SOAP_TYPE_PointerToadd__updateResponse:
		return soap_out_PointerToadd__updateResponse(soap, tag, id, (struct add__updateResponse *const*)ptr, "add:updateResponse");
	case SOAP_TYPE_PointerToact__recordResponse:
		return soap_out_PointerToact__recordResponse(soap, tag, id, (struct act__recordResponse *const*)ptr, "act:recordResponse");
	case SOAP_TYPE_PointerToArrayOfActivities:
		return soap_out_PointerToArrayOfActivities(soap, tag, id, (struct ArrayOfActivities *const*)ptr, "vin:Activity");
	case SOAP_TYPE_PointerToacc__transferResponse:
		return soap_out_PointerToacc__transferResponse(soap, tag, id, (struct acc__transferResponse *const*)ptr, "acc:transferResponse");
	case SOAP_TYPE_PointerToacc__decrementTokensResponse:
		return soap_out_PointerToacc__decrementTokensResponse(soap, tag, id, (struct acc__decrementTokensResponse *const*)ptr, "acc:decrementTokensResponse");
	case SOAP_TYPE_PointerToacc__incrementTokensResponse:
		return soap_out_PointerToacc__incrementTokensResponse(soap, tag, id, (struct acc__incrementTokensResponse *const*)ptr, "acc:incrementTokensResponse");
	case SOAP_TYPE_PointerToacc__tokenTransactionResponse:
		return soap_out_PointerToacc__tokenTransactionResponse(soap, tag, id, (struct acc__tokenTransactionResponse *const*)ptr, "acc:tokenTransactionResponse");
	case SOAP_TYPE_PointerToArrayOfTokenTransactions:
		return soap_out_PointerToArrayOfTokenTransactions(soap, tag, id, (struct ArrayOfTokenTransactions *const*)ptr, "vin:TokenTransaction");
	case SOAP_TYPE_PointerToacc__tokenBalanceResponse:
		return soap_out_PointerToacc__tokenBalanceResponse(soap, tag, id, (struct acc__tokenBalanceResponse *const*)ptr, "acc:tokenBalanceResponse");
	case SOAP_TYPE_PointerToArrayOfTokens:
		return soap_out_PointerToArrayOfTokens(soap, tag, id, (struct ArrayOfTokens *const*)ptr, "vin:Token");
	case SOAP_TYPE_PointerToacc__fetchByPaymentMethodResponse:
		return soap_out_PointerToacc__fetchByPaymentMethodResponse(soap, tag, id, (struct acc__fetchByPaymentMethodResponse *const*)ptr, "acc:fetchByPaymentMethodResponse");
	case SOAP_TYPE_PointerToacc__fetchByEmailResponse:
		return soap_out_PointerToacc__fetchByEmailResponse(soap, tag, id, (struct acc__fetchByEmailResponse *const*)ptr, "acc:fetchByEmailResponse");
	case SOAP_TYPE_PointerToArrayOfAccounts:
		return soap_out_PointerToArrayOfAccounts(soap, tag, id, (struct ArrayOfAccounts *const*)ptr, "vin:Account");
	case SOAP_TYPE_PointerToacc__fetchByVidResponse:
		return soap_out_PointerToacc__fetchByVidResponse(soap, tag, id, (struct acc__fetchByVidResponse *const*)ptr, "acc:fetchByVidResponse");
	case SOAP_TYPE_PointerToacc__fetchByMerchantAccountIdResponse:
		return soap_out_PointerToacc__fetchByMerchantAccountIdResponse(soap, tag, id, (struct acc__fetchByMerchantAccountIdResponse *const*)ptr, "acc:fetchByMerchantAccountIdResponse");
	case SOAP_TYPE_PointerToacc__updatePaymentMethodResponse:
		return soap_out_PointerToacc__updatePaymentMethodResponse(soap, tag, id, (struct acc__updatePaymentMethodResponse *const*)ptr, "acc:updatePaymentMethodResponse");
	case SOAP_TYPE_PointerToacc__stopAutoBillingResponse:
		return soap_out_PointerToacc__stopAutoBillingResponse(soap, tag, id, (struct acc__stopAutoBillingResponse *const*)ptr, "acc:stopAutoBillingResponse");
	case SOAP_TYPE_PointerToacc__updateResponse:
		return soap_out_PointerToacc__updateResponse(soap, tag, id, (struct acc__updateResponse *const*)ptr, "acc:updateResponse");
	case SOAP_TYPE_PointerToabl__fetchDeltaSinceResponse:
		return soap_out_PointerToabl__fetchDeltaSinceResponse(soap, tag, id, (struct abl__fetchDeltaSinceResponse *const*)ptr, "abl:fetchDeltaSinceResponse");
	case SOAP_TYPE_PointerToabl__futureRebillsResponse:
		return soap_out_PointerToabl__futureRebillsResponse(soap, tag, id, (struct abl__futureRebillsResponse *const*)ptr, "abl:futureRebillsResponse");
	case SOAP_TYPE_PointerToabl__fetchByAccountResponse:
		return soap_out_PointerToabl__fetchByAccountResponse(soap, tag, id, (struct abl__fetchByAccountResponse *const*)ptr, "abl:fetchByAccountResponse");
	case SOAP_TYPE_PointerToabl__fetchByEmailResponse:
		return soap_out_PointerToabl__fetchByEmailResponse(soap, tag, id, (struct abl__fetchByEmailResponse *const*)ptr, "abl:fetchByEmailResponse");
	case SOAP_TYPE_PointerToabl__fetchByVidResponse:
		return soap_out_PointerToabl__fetchByVidResponse(soap, tag, id, (struct abl__fetchByVidResponse *const*)ptr, "abl:fetchByVidResponse");
	case SOAP_TYPE_PointerToabl__fetchByMerchantAutoBillIdResponse:
		return soap_out_PointerToabl__fetchByMerchantAutoBillIdResponse(soap, tag, id, (struct abl__fetchByMerchantAutoBillIdResponse *const*)ptr, "abl:fetchByMerchantAutoBillIdResponse");
	case SOAP_TYPE_PointerToabl__fetchByAccountAndProductResponse:
		return soap_out_PointerToabl__fetchByAccountAndProductResponse(soap, tag, id, (struct abl__fetchByAccountAndProductResponse *const*)ptr, "abl:fetchByAccountAndProductResponse");
	case SOAP_TYPE_PointerToArrayOfAutoBills:
		return soap_out_PointerToArrayOfAutoBills(soap, tag, id, (struct ArrayOfAutoBills *const*)ptr, "vin:AutoBill");
	case SOAP_TYPE_PointerToabl__changeBillingDayOfMonthResponse:
		return soap_out_PointerToabl__changeBillingDayOfMonthResponse(soap, tag, id, (struct abl__changeBillingDayOfMonthResponse *const*)ptr, "abl:changeBillingDayOfMonthResponse");
	case SOAP_TYPE_PointerToabl__delayBillingByDaysResponse:
		return soap_out_PointerToabl__delayBillingByDaysResponse(soap, tag, id, (struct abl__delayBillingByDaysResponse *const*)ptr, "abl:delayBillingByDaysResponse");
	case SOAP_TYPE_PointerToabl__delayBillingToDateResponse:
		return soap_out_PointerToabl__delayBillingToDateResponse(soap, tag, id, (struct abl__delayBillingToDateResponse *const*)ptr, "abl:delayBillingToDateResponse");
	case SOAP_TYPE_PointerToabl__cancelResponse:
		return soap_out_PointerToabl__cancelResponse(soap, tag, id, (struct abl__cancelResponse *const*)ptr, "abl:cancelResponse");
	case SOAP_TYPE_PointerToabl__updateResponse:
		return soap_out_PointerToabl__updateResponse(soap, tag, id, (struct abl__updateResponse *const*)ptr, "abl:updateResponse");
	case SOAP_TYPE_PointerTovin__Authentication:
		return soap_out_PointerTovin__Authentication(soap, tag, id, (struct vin__Authentication *const*)ptr, "vin:Authentication");
	case SOAP_TYPE_PointerTovin__Return:
		return soap_out_PointerTovin__Return(soap, tag, id, (struct vin__Return *const*)ptr, "vin:Return");
	case SOAP_TYPE_PointerToPointerTovin__Transaction:
		return soap_out_PointerToPointerTovin__Transaction(soap, tag, id, (struct vin__Transaction **const*)ptr, "vin:Transaction");
	case SOAP_TYPE_PointerToPointerTovin__TransactionStatus:
		return soap_out_PointerToPointerTovin__TransactionStatus(soap, tag, id, (struct vin__TransactionStatus **const*)ptr, "vin:TransactionStatus");
	case SOAP_TYPE_PointerTovin__TransactionStatus:
		return soap_out_PointerTovin__TransactionStatus(soap, tag, id, (struct vin__TransactionStatus *const*)ptr, "vin:TransactionStatus");
	case SOAP_TYPE_PointerToPointerTovin__TransactionItem:
		return soap_out_PointerToPointerTovin__TransactionItem(soap, tag, id, (struct vin__TransactionItem **const*)ptr, "vin:TransactionItem");
	case SOAP_TYPE_PointerTovin__TransactionItem:
		return soap_out_PointerTovin__TransactionItem(soap, tag, id, (struct vin__TransactionItem *const*)ptr, "vin:TransactionItem");
	case SOAP_TYPE_PointerToPointerTovin__ScoreCode:
		return soap_out_PointerToPointerTovin__ScoreCode(soap, tag, id, (struct vin__ScoreCode **const*)ptr, "vin:ScoreCode");
	case SOAP_TYPE_PointerTovin__ScoreCode:
		return soap_out_PointerTovin__ScoreCode(soap, tag, id, (struct vin__ScoreCode *const*)ptr, "vin:ScoreCode");
	case SOAP_TYPE_PointerToPointerTovin__CancelResult:
		return soap_out_PointerToPointerTovin__CancelResult(soap, tag, id, (struct vin__CancelResult **const*)ptr, "vin:CancelResult");
	case SOAP_TYPE_PointerTovin__CancelResult:
		return soap_out_PointerTovin__CancelResult(soap, tag, id, (struct vin__CancelResult *const*)ptr, "vin:CancelResult");
	case SOAP_TYPE_PointerToPointerTovin__CaptureResult:
		return soap_out_PointerToPointerTovin__CaptureResult(soap, tag, id, (struct vin__CaptureResult **const*)ptr, "vin:CaptureResult");
	case SOAP_TYPE_PointerTovin__CaptureResult:
		return soap_out_PointerTovin__CaptureResult(soap, tag, id, (struct vin__CaptureResult *const*)ptr, "vin:CaptureResult");
	case SOAP_TYPE_PointerToPointerTovin__TokenTransaction:
		return soap_out_PointerToPointerTovin__TokenTransaction(soap, tag, id, (struct vin__TokenTransaction **const*)ptr, "vin:TokenTransaction");
	case SOAP_TYPE_PointerTovin__TokenTransaction:
		return soap_out_PointerTovin__TokenTransaction(soap, tag, id, (struct vin__TokenTransaction *const*)ptr, "vin:TokenTransaction");
	case SOAP_TYPE_PointerToPointerTovin__TokenAmount:
		return soap_out_PointerToPointerTovin__TokenAmount(soap, tag, id, (struct vin__TokenAmount **const*)ptr, "vin:TokenAmount");
	case SOAP_TYPE_PointerToPointerTovin__Token:
		return soap_out_PointerToPointerTovin__Token(soap, tag, id, (struct vin__Token **const*)ptr, "vin:Token");
	case SOAP_TYPE_PointerToPointerTovin__SalesTax:
		return soap_out_PointerToPointerTovin__SalesTax(soap, tag, id, (struct vin__SalesTax **const*)ptr, "vin:SalesTax");
	case SOAP_TYPE_PointerTovin__SalesTax:
		return soap_out_PointerTovin__SalesTax(soap, tag, id, (struct vin__SalesTax *const*)ptr, "vin:SalesTax");
	case SOAP_TYPE_PointerToPointerTovin__TaxExemption:
		return soap_out_PointerToPointerTovin__TaxExemption(soap, tag, id, (struct vin__TaxExemption **const*)ptr, "vin:TaxExemption");
	case SOAP_TYPE_PointerTovin__TaxExemption:
		return soap_out_PointerTovin__TaxExemption(soap, tag, id, (struct vin__TaxExemption *const*)ptr, "vin:TaxExemption");
	case SOAP_TYPE_PointerToPointerTovin__Refund:
		return soap_out_PointerToPointerTovin__Refund(soap, tag, id, (struct vin__Refund **const*)ptr, "vin:Refund");
	case SOAP_TYPE_PointerTovin__Refund:
		return soap_out_PointerTovin__Refund(soap, tag, id, (struct vin__Refund *const*)ptr, "vin:Refund");
	case SOAP_TYPE_PointerToPointerTovin__Product:
		return soap_out_PointerToPointerTovin__Product(soap, tag, id, (struct vin__Product **const*)ptr, "vin:Product");
	case SOAP_TYPE_PointerToPointerTovin__NameValuePair:
		return soap_out_PointerToPointerTovin__NameValuePair(soap, tag, id, (struct vin__NameValuePair **const*)ptr, "vin:NameValuePair");
	case SOAP_TYPE_PointerTovin__NameValuePair:
		return soap_out_PointerTovin__NameValuePair(soap, tag, id, (struct vin__NameValuePair *const*)ptr, "vin:NameValuePair");
	case SOAP_TYPE_PointerToPointerTovin__MerchantEntitlementId:
		return soap_out_PointerToPointerTovin__MerchantEntitlementId(soap, tag, id, (struct vin__MerchantEntitlementId **const*)ptr, "vin:MerchantEntitlementId");
	case SOAP_TYPE_PointerTovin__MerchantEntitlementId:
		return soap_out_PointerTovin__MerchantEntitlementId(soap, tag, id, (struct vin__MerchantEntitlementId *const*)ptr, "vin:MerchantEntitlementId");
	case SOAP_TYPE_PointerToPointerTovin__PaymentMethod:
		return soap_out_PointerToPointerTovin__PaymentMethod(soap, tag, id, (struct vin__PaymentMethod **const*)ptr, "vin:PaymentMethod");
	case SOAP_TYPE_PointerToPointerTovin__MetricStatistics:
		return soap_out_PointerToPointerTovin__MetricStatistics(soap, tag, id, (struct vin__MetricStatistics **const*)ptr, "vin:MetricStatistics");
	case SOAP_TYPE_PointerTovin__MetricStatistics:
		return soap_out_PointerTovin__MetricStatistics(soap, tag, id, (struct vin__MetricStatistics *const*)ptr, "vin:MetricStatistics");
	case SOAP_TYPE_PointerToPointerTovin__Entitlement:
		return soap_out_PointerToPointerTovin__Entitlement(soap, tag, id, (struct vin__Entitlement **const*)ptr, "vin:Entitlement");
	case SOAP_TYPE_PointerTovin__Entitlement:
		return soap_out_PointerTovin__Entitlement(soap, tag, id, (struct vin__Entitlement *const*)ptr, "vin:Entitlement");
	case SOAP_TYPE_PointerToPointerTovin__EmailTemplate:
		return soap_out_PointerToPointerTovin__EmailTemplate(soap, tag, id, (struct vin__EmailTemplate **const*)ptr, "vin:EmailTemplate");
	case SOAP_TYPE_PointerTovin__EmailTemplate:
		return soap_out_PointerTovin__EmailTemplate(soap, tag, id, (struct vin__EmailTemplate *const*)ptr, "vin:EmailTemplate");
	case SOAP_TYPE_PointerToPointerTovin__Chargeback:
		return soap_out_PointerToPointerTovin__Chargeback(soap, tag, id, (struct vin__Chargeback **const*)ptr, "vin:Chargeback");
	case SOAP_TYPE_PointerTovin__Chargeback:
		return soap_out_PointerTovin__Chargeback(soap, tag, id, (struct vin__Chargeback *const*)ptr, "vin:Chargeback");
	case SOAP_TYPE_PointerToPointerTovin__BillingPlan:
		return soap_out_PointerToPointerTovin__BillingPlan(soap, tag, id, (struct vin__BillingPlan **const*)ptr, "vin:BillingPlan");
	case SOAP_TYPE_PointerToPointerTovin__BillingPlanPeriod:
		return soap_out_PointerToPointerTovin__BillingPlanPeriod(soap, tag, id, (struct vin__BillingPlanPeriod **const*)ptr, "vin:BillingPlanPeriod");
	case SOAP_TYPE_PointerTovin__BillingPlanPeriod:
		return soap_out_PointerTovin__BillingPlanPeriod(soap, tag, id, (struct vin__BillingPlanPeriod *const*)ptr, "vin:BillingPlanPeriod");
	case SOAP_TYPE_PointerToPointerTovin__BillingPlanPrice:
		return soap_out_PointerToPointerTovin__BillingPlanPrice(soap, tag, id, (struct vin__BillingPlanPrice **const*)ptr, "vin:BillingPlanPrice");
	case SOAP_TYPE_PointerTovin__BillingPlanPrice:
		return soap_out_PointerTovin__BillingPlanPrice(soap, tag, id, (struct vin__BillingPlanPrice *const*)ptr, "vin:BillingPlanPrice");
	case SOAP_TYPE_PointerToPointerTovin__AutoBill:
		return soap_out_PointerToPointerTovin__AutoBill(soap, tag, id, (struct vin__AutoBill **const*)ptr, "vin:AutoBill");
	case SOAP_TYPE_PointerTovin__AutoBill:
		return soap_out_PointerTovin__AutoBill(soap, tag, id, (struct vin__AutoBill *const*)ptr, "vin:AutoBill");
	case SOAP_TYPE_PointerToPointerTovin__Activity:
		return soap_out_PointerToPointerTovin__Activity(soap, tag, id, (struct vin__Activity **const*)ptr, "vin:Activity");
	case SOAP_TYPE_PointerTovin__Activity:
		return soap_out_PointerTovin__Activity(soap, tag, id, (struct vin__Activity *const*)ptr, "vin:Activity");
	case SOAP_TYPE_PointerToPointerTovin__Account:
		return soap_out_PointerToPointerTovin__Account(soap, tag, id, (struct vin__Account **const*)ptr, "vin:Account");
	case SOAP_TYPE_PointerToArrayOfTransactionItems:
		return soap_out_PointerToArrayOfTransactionItems(soap, tag, id, (struct ArrayOfTransactionItems *const*)ptr, "vin:TransactionItem");
	case SOAP_TYPE_PointerToArrayOfTransactionStatuses:
		return soap_out_PointerToArrayOfTransactionStatuses(soap, tag, id, (struct ArrayOfTransactionStatuses *const*)ptr, "vin:TransactionStatus");
	case SOAP_TYPE_PointerTovin__AVSMatchType:
		return soap_out_PointerTovin__AVSMatchType(soap, tag, id, (enum vin__AVSMatchType *const*)ptr, "vin:AVSMatchType");
	case SOAP_TYPE_PointerTovin__TransactionStatusDirectDebit:
		return soap_out_PointerTovin__TransactionStatusDirectDebit(soap, tag, id, (struct vin__TransactionStatusDirectDebit *const*)ptr, "vin:TransactionStatusDirectDebit");
	case SOAP_TYPE_PointerTovin__TransactionStatusPayPal:
		return soap_out_PointerTovin__TransactionStatusPayPal(soap, tag, id, (struct vin__TransactionStatusPayPal *const*)ptr, "vin:TransactionStatusPayPal");
	case SOAP_TYPE_PointerTovin__TransactionStatusBoleto:
		return soap_out_PointerTovin__TransactionStatusBoleto(soap, tag, id, (struct vin__TransactionStatusBoleto *const*)ptr, "vin:TransactionStatusBoleto");
	case SOAP_TYPE_PointerTovin__TransactionStatusECP:
		return soap_out_PointerTovin__TransactionStatusECP(soap, tag, id, (struct vin__TransactionStatusECP *const*)ptr, "vin:TransactionStatusECP");
	case SOAP_TYPE_PointerTovin__TransactionStatusCreditCard:
		return soap_out_PointerTovin__TransactionStatusCreditCard(soap, tag, id, (struct vin__TransactionStatusCreditCard *const*)ptr, "vin:TransactionStatusCreditCard");
	case SOAP_TYPE_PointerTovin__TaxRegion:
		return soap_out_PointerTovin__TaxRegion(soap, tag, id, (enum vin__TaxRegion *const*)ptr, "vin:TaxRegion");
	case SOAP_TYPE_PointerTovin__RefundTokenAction:
		return soap_out_PointerTovin__RefundTokenAction(soap, tag, id, (enum vin__RefundTokenAction *const*)ptr, "vin:RefundTokenAction");
	case SOAP_TYPE_PointerTovin__TaxClassification:
		return soap_out_PointerTovin__TaxClassification(soap, tag, id, (enum vin__TaxClassification *const*)ptr, "vin:TaxClassification");
	case SOAP_TYPE_PointerTovin__ProductStatus:
		return soap_out_PointerTovin__ProductStatus(soap, tag, id, (enum vin__ProductStatus *const*)ptr, "vin:ProductStatus");
	case SOAP_TYPE_PointerTovin__Token:
		return soap_out_PointerTovin__Token(soap, tag, id, (struct vin__Token *const*)ptr, "vin:Token");
	case SOAP_TYPE_PointerTovin__Boleto:
		return soap_out_PointerTovin__Boleto(soap, tag, id, (struct vin__Boleto *const*)ptr, "vin:Boleto");
	case SOAP_TYPE_PointerTovin__PayPal:
		return soap_out_PointerTovin__PayPal(soap, tag, id, (struct vin__PayPal *const*)ptr, "vin:PayPal");
	case SOAP_TYPE_PointerTovin__DirectDebit:
		return soap_out_PointerTovin__DirectDebit(soap, tag, id, (struct vin__DirectDebit *const*)ptr, "vin:DirectDebit");
	case SOAP_TYPE_PointerTovin__ECP:
		return soap_out_PointerTovin__ECP(soap, tag, id, (struct vin__ECP *const*)ptr, "vin:ECP");
	case SOAP_TYPE_PointerTovin__CreditCard:
		return soap_out_PointerTovin__CreditCard(soap, tag, id, (struct vin__CreditCard *const*)ptr, "vin:CreditCard");
	case SOAP_TYPE_PointerTovin__PaymentMethodType:
		return soap_out_PointerTovin__PaymentMethodType(soap, tag, id, (enum vin__PaymentMethodType *const*)ptr, "vin:PaymentMethodType");
	case SOAP_TYPE_PointerTovin__ECPTransactionType:
		return soap_out_PointerTovin__ECPTransactionType(soap, tag, id, (enum vin__ECPTransactionType *const*)ptr, "vin:ECPTransactionType");
	case SOAP_TYPE_PointerTovin__AccountType:
		return soap_out_PointerTovin__AccountType(soap, tag, id, (enum vin__AccountType *const*)ptr, "vin:AccountType");
	case SOAP_TYPE_PointerTovin__HashType:
		return soap_out_PointerTovin__HashType(soap, tag, id, (enum vin__HashType *const*)ptr, "vin:HashType");
	case SOAP_TYPE_PointerTovin__EmailTemplateType:
		return soap_out_PointerTovin__EmailTemplateType(soap, tag, id, (enum vin__EmailTemplateType *const*)ptr, "vin:EmailTemplateType");
	case SOAP_TYPE_PointerTovin__Transaction:
		return soap_out_PointerTovin__Transaction(soap, tag, id, (struct vin__Transaction *const*)ptr, "vin:Transaction");
	case SOAP_TYPE_PointerToArrayOfMerchantEntitlementIds:
		return soap_out_PointerToArrayOfMerchantEntitlementIds(soap, tag, id, (struct ArrayOfMerchantEntitlementIds *const*)ptr, "vin:MerchantEntitlementId");
	case SOAP_TYPE_PointerToArrayOfBillingPlanPeriods:
		return soap_out_PointerToArrayOfBillingPlanPeriods(soap, tag, id, (struct ArrayOfBillingPlanPeriods *const*)ptr, "vin:BillingPlanPeriod");
	case SOAP_TYPE_PointerTovin__BillingPlanStatus:
		return soap_out_PointerTovin__BillingPlanStatus(soap, tag, id, (enum vin__BillingPlanStatus *const*)ptr, "vin:BillingPlanStatus");
	case SOAP_TYPE_PointerToArrayOfBillingPlanPrices:
		return soap_out_PointerToArrayOfBillingPlanPrices(soap, tag, id, (struct ArrayOfBillingPlanPrices *const*)ptr, "vin:BillingPlanPrice");
	case SOAP_TYPE_PointerTovin__BillingPeriodType:
		return soap_out_PointerTovin__BillingPeriodType(soap, tag, id, (enum vin__BillingPeriodType *const*)ptr, "vin:BillingPeriodType");
	case SOAP_TYPE_PointerTovin__TokenAmount:
		return soap_out_PointerTovin__TokenAmount(soap, tag, id, (struct vin__TokenAmount *const*)ptr, "vin:TokenAmount");
	case SOAP_TYPE_PointerToArrayOfTransactions:
		return soap_out_PointerToArrayOfTransactions(soap, tag, id, (struct ArrayOfTransactions *const*)ptr, "vin:Transaction");
	case SOAP_TYPE_PointerTovin__AutoBillStatus:
		return soap_out_PointerTovin__AutoBillStatus(soap, tag, id, (enum vin__AutoBillStatus *const*)ptr, "vin:AutoBillStatus");
	case SOAP_TYPE_PointerTovin__PaymentMethod:
		return soap_out_PointerTovin__PaymentMethod(soap, tag, id, (struct vin__PaymentMethod *const*)ptr, "vin:PaymentMethod");
	case SOAP_TYPE_PointerTovin__BillingPlan:
		return soap_out_PointerTovin__BillingPlan(soap, tag, id, (struct vin__BillingPlan *const*)ptr, "vin:BillingPlan");
	case SOAP_TYPE_PointerTovin__Product:
		return soap_out_PointerTovin__Product(soap, tag, id, (struct vin__Product *const*)ptr, "vin:Product");
	case SOAP_TYPE_PointerTovin__ActivityTypeArg:
		return soap_out_PointerTovin__ActivityTypeArg(soap, tag, id, (struct vin__ActivityTypeArg *const*)ptr, "vin:ActivityTypeArg");
	case SOAP_TYPE_PointerTovin__Account:
		return soap_out_PointerTovin__Account(soap, tag, id, (struct vin__Account *const*)ptr, "vin:Account");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTovin__ActivityNote:
		return soap_out_PointerTovin__ActivityNote(soap, tag, id, (struct vin__ActivityNote *const*)ptr, "vin:ActivityNote");
	case SOAP_TYPE_PointerTovin__ActivityCancellation:
		return soap_out_PointerTovin__ActivityCancellation(soap, tag, id, (struct vin__ActivityCancellation *const*)ptr, "vin:ActivityCancellation");
	case SOAP_TYPE_PointerTovin__ActivityNamedValue:
		return soap_out_PointerTovin__ActivityNamedValue(soap, tag, id, (struct vin__ActivityNamedValue *const*)ptr, "vin:ActivityNamedValue");
	case SOAP_TYPE_PointerTovin__ActivityUsage:
		return soap_out_PointerTovin__ActivityUsage(soap, tag, id, (struct vin__ActivityUsage *const*)ptr, "vin:ActivityUsage");
	case SOAP_TYPE_PointerTovin__ActivityFulfillment:
		return soap_out_PointerTovin__ActivityFulfillment(soap, tag, id, (struct vin__ActivityFulfillment *const*)ptr, "vin:ActivityFulfillment");
	case SOAP_TYPE_PointerTovin__ActivityEmailContact:
		return soap_out_PointerTovin__ActivityEmailContact(soap, tag, id, (struct vin__ActivityEmailContact *const*)ptr, "vin:ActivityEmailContact");
	case SOAP_TYPE_PointerTovin__ActivityPhoneContact:
		return soap_out_PointerTovin__ActivityPhoneContact(soap, tag, id, (struct vin__ActivityPhoneContact *const*)ptr, "vin:ActivityPhoneContact");
	case SOAP_TYPE_PointerTovin__ActivityURIView:
		return soap_out_PointerTovin__ActivityURIView(soap, tag, id, (struct vin__ActivityURIView *const*)ptr, "vin:ActivityURIView");
	case SOAP_TYPE_PointerTovin__ActivityLogout:
		return soap_out_PointerTovin__ActivityLogout(soap, tag, id, (struct vin__ActivityLogout *const*)ptr, "vin:ActivityLogout");
	case SOAP_TYPE_PointerTovin__ActivityLogin:
		return soap_out_PointerTovin__ActivityLogin(soap, tag, id, (struct vin__ActivityLogin *const*)ptr, "vin:ActivityLogin");
	case SOAP_TYPE_PointerToArrayOfTokenAmounts:
		return soap_out_PointerToArrayOfTokenAmounts(soap, tag, id, (struct ArrayOfTokenAmounts *const*)ptr, "vin:TokenAmount");
	case SOAP_TYPE_PointerToArrayOfTaxExemptions:
		return soap_out_PointerToArrayOfTaxExemptions(soap, tag, id, (struct ArrayOfTaxExemptions *const*)ptr, "vin:TaxExemption");
	case SOAP_TYPE_PointerToArrayOfNameValuePairs:
		return soap_out_PointerToArrayOfNameValuePairs(soap, tag, id, (struct ArrayOfNameValuePairs *const*)ptr, "vin:NameValuePair");
	case SOAP_TYPE_PointerToArrayOfPaymentMethods:
		return soap_out_PointerToArrayOfPaymentMethods(soap, tag, id, (struct ArrayOfPaymentMethods *const*)ptr, "vin:PaymentMethod");
	case SOAP_TYPE_PointerTovin__Address:
		return soap_out_PointerTovin__Address(soap, tag, id, (struct vin__Address *const*)ptr, "vin:Address");
	case SOAP_TYPE_PointerToxsd__boolean:
		return soap_out_PointerToxsd__boolean(soap, tag, id, (enum xsd__boolean *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTovin__EmailPreference:
		return soap_out_PointerTovin__EmailPreference(soap, tag, id, (enum vin__EmailPreference *const*)ptr, "vin:EmailPreference");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__date:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:date");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:anyURI");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_trn__score:
		soap_serialize_trn__score(soap, (const struct trn__score *)ptr);
		break;
	case SOAP_TYPE_trn__scoreResponse:
		soap_serialize_trn__scoreResponse(soap, (const struct trn__scoreResponse *)ptr);
		break;
	case SOAP_TYPE_trn__report:
		soap_serialize_trn__report(soap, (const struct trn__report *)ptr);
		break;
	case SOAP_TYPE_trn__reportResponse:
		soap_serialize_trn__reportResponse(soap, (const struct trn__reportResponse *)ptr);
		break;
	case SOAP_TYPE_trn__authCapture:
		soap_serialize_trn__authCapture(soap, (const struct trn__authCapture *)ptr);
		break;
	case SOAP_TYPE_trn__authCaptureResponse:
		soap_serialize_trn__authCaptureResponse(soap, (const struct trn__authCaptureResponse *)ptr);
		break;
	case SOAP_TYPE_trn__cancel:
		soap_serialize_trn__cancel(soap, (const struct trn__cancel *)ptr);
		break;
	case SOAP_TYPE_trn__cancelResponse:
		soap_serialize_trn__cancelResponse(soap, (const struct trn__cancelResponse *)ptr);
		break;
	case SOAP_TYPE_trn__capture:
		soap_serialize_trn__capture(soap, (const struct trn__capture *)ptr);
		break;
	case SOAP_TYPE_trn__captureResponse:
		soap_serialize_trn__captureResponse(soap, (const struct trn__captureResponse *)ptr);
		break;
	case SOAP_TYPE_trn__calculateSalesTax:
		soap_serialize_trn__calculateSalesTax(soap, (const struct trn__calculateSalesTax *)ptr);
		break;
	case SOAP_TYPE_trn__calculateSalesTaxResponse:
		soap_serialize_trn__calculateSalesTaxResponse(soap, (const struct trn__calculateSalesTaxResponse *)ptr);
		break;
	case SOAP_TYPE_trn__auth:
		soap_serialize_trn__auth(soap, (const struct trn__auth *)ptr);
		break;
	case SOAP_TYPE_trn__authResponse:
		soap_serialize_trn__authResponse(soap, (const struct trn__authResponse *)ptr);
		break;
	case SOAP_TYPE_trn__fetchByPaymentMethod:
		soap_serialize_trn__fetchByPaymentMethod(soap, (const struct trn__fetchByPaymentMethod *)ptr);
		break;
	case SOAP_TYPE_trn__fetchByPaymentMethodResponse:
		soap_serialize_trn__fetchByPaymentMethodResponse(soap, (const struct trn__fetchByPaymentMethodResponse *)ptr);
		break;
	case SOAP_TYPE_trn__fetchSearchPage:
		soap_serialize_trn__fetchSearchPage(soap, (const struct trn__fetchSearchPage *)ptr);
		break;
	case SOAP_TYPE_trn__fetchSearchPageResponse:
		soap_serialize_trn__fetchSearchPageResponse(soap, (const struct trn__fetchSearchPageResponse *)ptr);
		break;
	case SOAP_TYPE_trn__fetchByAutobill:
		soap_serialize_trn__fetchByAutobill(soap, (const struct trn__fetchByAutobill *)ptr);
		break;
	case SOAP_TYPE_trn__fetchByAutobillResponse:
		soap_serialize_trn__fetchByAutobillResponse(soap, (const struct trn__fetchByAutobillResponse *)ptr);
		break;
	case SOAP_TYPE_trn__fetchDelta:
		soap_serialize_trn__fetchDelta(soap, (const struct trn__fetchDelta *)ptr);
		break;
	case SOAP_TYPE_trn__fetchDeltaResponse:
		soap_serialize_trn__fetchDeltaResponse(soap, (const struct trn__fetchDeltaResponse *)ptr);
		break;
	case SOAP_TYPE_trn__fetchDeltaSince:
		soap_serialize_trn__fetchDeltaSince(soap, (const struct trn__fetchDeltaSince *)ptr);
		break;
	case SOAP_TYPE_trn__fetchDeltaSinceResponse:
		soap_serialize_trn__fetchDeltaSinceResponse(soap, (const struct trn__fetchDeltaSinceResponse *)ptr);
		break;
	case SOAP_TYPE_trn__fetchByMerchantTransactionId:
		soap_serialize_trn__fetchByMerchantTransactionId(soap, (const struct trn__fetchByMerchantTransactionId *)ptr);
		break;
	case SOAP_TYPE_trn__fetchByMerchantTransactionIdResponse:
		soap_serialize_trn__fetchByMerchantTransactionIdResponse(soap, (const struct trn__fetchByMerchantTransactionIdResponse *)ptr);
		break;
	case SOAP_TYPE_trn__fetchByAccount:
		soap_serialize_trn__fetchByAccount(soap, (const struct trn__fetchByAccount *)ptr);
		break;
	case SOAP_TYPE_trn__fetchByAccountResponse:
		soap_serialize_trn__fetchByAccountResponse(soap, (const struct trn__fetchByAccountResponse *)ptr);
		break;
	case SOAP_TYPE_trn__fetchByVid:
		soap_serialize_trn__fetchByVid(soap, (const struct trn__fetchByVid *)ptr);
		break;
	case SOAP_TYPE_trn__fetchByVidResponse:
		soap_serialize_trn__fetchByVidResponse(soap, (const struct trn__fetchByVidResponse *)ptr);
		break;
	case SOAP_TYPE_rfd__perform:
		soap_serialize_rfd__perform(soap, (const struct rfd__perform *)ptr);
		break;
	case SOAP_TYPE_rfd__performResponse:
		soap_serialize_rfd__performResponse(soap, (const struct rfd__performResponse *)ptr);
		break;
	case SOAP_TYPE_rfd__report:
		soap_serialize_rfd__report(soap, (const struct rfd__report *)ptr);
		break;
	case SOAP_TYPE_rfd__reportResponse:
		soap_serialize_rfd__reportResponse(soap, (const struct rfd__reportResponse *)ptr);
		break;
	case SOAP_TYPE_rfd__fetchDeltaSince:
		soap_serialize_rfd__fetchDeltaSince(soap, (const struct rfd__fetchDeltaSince *)ptr);
		break;
	case SOAP_TYPE_rfd__fetchDeltaSinceResponse:
		soap_serialize_rfd__fetchDeltaSinceResponse(soap, (const struct rfd__fetchDeltaSinceResponse *)ptr);
		break;
	case SOAP_TYPE_rfd__fetchByTransaction:
		soap_serialize_rfd__fetchByTransaction(soap, (const struct rfd__fetchByTransaction *)ptr);
		break;
	case SOAP_TYPE_rfd__fetchByTransactionResponse:
		soap_serialize_rfd__fetchByTransactionResponse(soap, (const struct rfd__fetchByTransactionResponse *)ptr);
		break;
	case SOAP_TYPE_rfd__fetchByAccount:
		soap_serialize_rfd__fetchByAccount(soap, (const struct rfd__fetchByAccount *)ptr);
		break;
	case SOAP_TYPE_rfd__fetchByAccountResponse:
		soap_serialize_rfd__fetchByAccountResponse(soap, (const struct rfd__fetchByAccountResponse *)ptr);
		break;
	case SOAP_TYPE_rfd__fetchByVid:
		soap_serialize_rfd__fetchByVid(soap, (const struct rfd__fetchByVid *)ptr);
		break;
	case SOAP_TYPE_rfd__fetchByVidResponse:
		soap_serialize_rfd__fetchByVidResponse(soap, (const struct rfd__fetchByVidResponse *)ptr);
		break;
	case SOAP_TYPE_pyp__fetchByVid:
		soap_serialize_pyp__fetchByVid(soap, (const struct pyp__fetchByVid *)ptr);
		break;
	case SOAP_TYPE_pyp__fetchByVidResponse:
		soap_serialize_pyp__fetchByVidResponse(soap, (const struct pyp__fetchByVidResponse *)ptr);
		break;
	case SOAP_TYPE_pyp__update:
		soap_serialize_pyp__update(soap, (const struct pyp__update *)ptr);
		break;
	case SOAP_TYPE_pyp__updateResponse:
		soap_serialize_pyp__updateResponse(soap, (const struct pyp__updateResponse *)ptr);
		break;
	case SOAP_TYPE_pym__validate:
		soap_serialize_pym__validate(soap, (const struct pym__validate *)ptr);
		break;
	case SOAP_TYPE_pym__validateResponse:
		soap_serialize_pym__validateResponse(soap, (const struct pym__validateResponse *)ptr);
		break;
	case SOAP_TYPE_pym__fetchByMerchantPaymentMethodId:
		soap_serialize_pym__fetchByMerchantPaymentMethodId(soap, (const struct pym__fetchByMerchantPaymentMethodId *)ptr);
		break;
	case SOAP_TYPE_pym__fetchByMerchantPaymentMethodIdResponse:
		soap_serialize_pym__fetchByMerchantPaymentMethodIdResponse(soap, (const struct pym__fetchByMerchantPaymentMethodIdResponse *)ptr);
		break;
	case SOAP_TYPE_pym__fetchByAccount:
		soap_serialize_pym__fetchByAccount(soap, (const struct pym__fetchByAccount *)ptr);
		break;
	case SOAP_TYPE_pym__fetchByAccountResponse:
		soap_serialize_pym__fetchByAccountResponse(soap, (const struct pym__fetchByAccountResponse *)ptr);
		break;
	case SOAP_TYPE_pym__fetchByVid:
		soap_serialize_pym__fetchByVid(soap, (const struct pym__fetchByVid *)ptr);
		break;
	case SOAP_TYPE_pym__fetchByVidResponse:
		soap_serialize_pym__fetchByVidResponse(soap, (const struct pym__fetchByVidResponse *)ptr);
		break;
	case SOAP_TYPE_pym__update:
		soap_serialize_pym__update(soap, (const struct pym__update *)ptr);
		break;
	case SOAP_TYPE_pym__updateResponse:
		soap_serialize_pym__updateResponse(soap, (const struct pym__updateResponse *)ptr);
		break;
	case SOAP_TYPE_prd__fetchByMerchantEntitlementId:
		soap_serialize_prd__fetchByMerchantEntitlementId(soap, (const struct prd__fetchByMerchantEntitlementId *)ptr);
		break;
	case SOAP_TYPE_prd__fetchByMerchantEntitlementIdResponse:
		soap_serialize_prd__fetchByMerchantEntitlementIdResponse(soap, (const struct prd__fetchByMerchantEntitlementIdResponse *)ptr);
		break;
	case SOAP_TYPE_prd__fetchAll:
		soap_serialize_prd__fetchAll(soap, (const struct prd__fetchAll *)ptr);
		break;
	case SOAP_TYPE_prd__fetchAllResponse:
		soap_serialize_prd__fetchAllResponse(soap, (const struct prd__fetchAllResponse *)ptr);
		break;
	case SOAP_TYPE_prd__fetchByAccount:
		soap_serialize_prd__fetchByAccount(soap, (const struct prd__fetchByAccount *)ptr);
		break;
	case SOAP_TYPE_prd__fetchByAccountResponse:
		soap_serialize_prd__fetchByAccountResponse(soap, (const struct prd__fetchByAccountResponse *)ptr);
		break;
	case SOAP_TYPE_prd__fetchByMerchantProductId:
		soap_serialize_prd__fetchByMerchantProductId(soap, (const struct prd__fetchByMerchantProductId *)ptr);
		break;
	case SOAP_TYPE_prd__fetchByMerchantProductIdResponse:
		soap_serialize_prd__fetchByMerchantProductIdResponse(soap, (const struct prd__fetchByMerchantProductIdResponse *)ptr);
		break;
	case SOAP_TYPE_prd__fetchByVid:
		soap_serialize_prd__fetchByVid(soap, (const struct prd__fetchByVid *)ptr);
		break;
	case SOAP_TYPE_prd__fetchByVidResponse:
		soap_serialize_prd__fetchByVidResponse(soap, (const struct prd__fetchByVidResponse *)ptr);
		break;
	case SOAP_TYPE_prd__update:
		soap_serialize_prd__update(soap, (const struct prd__update *)ptr);
		break;
	case SOAP_TYPE_prd__updateResponse:
		soap_serialize_prd__updateResponse(soap, (const struct prd__updateResponse *)ptr);
		break;
	case SOAP_TYPE_met__report:
		soap_serialize_met__report(soap, (const struct met__report *)ptr);
		break;
	case SOAP_TYPE_met__reportResponse:
		soap_serialize_met__reportResponse(soap, (const struct met__reportResponse *)ptr);
		break;
	case SOAP_TYPE_etp__fetchByTypeAndVersion:
		soap_serialize_etp__fetchByTypeAndVersion(soap, (const struct etp__fetchByTypeAndVersion *)ptr);
		break;
	case SOAP_TYPE_etp__fetchByTypeAndVersionResponse:
		soap_serialize_etp__fetchByTypeAndVersionResponse(soap, (const struct etp__fetchByTypeAndVersionResponse *)ptr);
		break;
	case SOAP_TYPE_etp__fetchByType:
		soap_serialize_etp__fetchByType(soap, (const struct etp__fetchByType *)ptr);
		break;
	case SOAP_TYPE_etp__fetchByTypeResponse:
		soap_serialize_etp__fetchByTypeResponse(soap, (const struct etp__fetchByTypeResponse *)ptr);
		break;
	case SOAP_TYPE_etp__fetchByProduct:
		soap_serialize_etp__fetchByProduct(soap, (const struct etp__fetchByProduct *)ptr);
		break;
	case SOAP_TYPE_etp__fetchByProductResponse:
		soap_serialize_etp__fetchByProductResponse(soap, (const struct etp__fetchByProductResponse *)ptr);
		break;
	case SOAP_TYPE_etp__fetchByVid:
		soap_serialize_etp__fetchByVid(soap, (const struct etp__fetchByVid *)ptr);
		break;
	case SOAP_TYPE_etp__fetchByVidResponse:
		soap_serialize_etp__fetchByVidResponse(soap, (const struct etp__fetchByVidResponse *)ptr);
		break;
	case SOAP_TYPE_etp__update:
		soap_serialize_etp__update(soap, (const struct etp__update *)ptr);
		break;
	case SOAP_TYPE_etp__updateResponse:
		soap_serialize_etp__updateResponse(soap, (const struct etp__updateResponse *)ptr);
		break;
	case SOAP_TYPE_ent__fetchDeltaSince:
		soap_serialize_ent__fetchDeltaSince(soap, (const struct ent__fetchDeltaSince *)ptr);
		break;
	case SOAP_TYPE_ent__fetchDeltaSinceResponse:
		soap_serialize_ent__fetchDeltaSinceResponse(soap, (const struct ent__fetchDeltaSinceResponse *)ptr);
		break;
	case SOAP_TYPE_ent__fetchByAccount:
		soap_serialize_ent__fetchByAccount(soap, (const struct ent__fetchByAccount *)ptr);
		break;
	case SOAP_TYPE_ent__fetchByAccountResponse:
		soap_serialize_ent__fetchByAccountResponse(soap, (const struct ent__fetchByAccountResponse *)ptr);
		break;
	case SOAP_TYPE_ent__fetchByEntitlementIdAndAccount:
		soap_serialize_ent__fetchByEntitlementIdAndAccount(soap, (const struct ent__fetchByEntitlementIdAndAccount *)ptr);
		break;
	case SOAP_TYPE_ent__fetchByEntitlementIdAndAccountResponse:
		soap_serialize_ent__fetchByEntitlementIdAndAccountResponse(soap, (const struct ent__fetchByEntitlementIdAndAccountResponse *)ptr);
		break;
	case SOAP_TYPE_ecs__getSignatureBlock:
		soap_serialize_ecs__getSignatureBlock(soap, (const struct ecs__getSignatureBlock *)ptr);
		break;
	case SOAP_TYPE_ecs__getSignatureBlockResponse:
		soap_serialize_ecs__getSignatureBlockResponse(soap, (const struct ecs__getSignatureBlockResponse *)ptr);
		break;
	case SOAP_TYPE_ecs__sign:
		soap_serialize_ecs__sign(soap, (const struct ecs__sign *)ptr);
		break;
	case SOAP_TYPE_ecs__signResponse:
		soap_serialize_ecs__signResponse(soap, (const struct ecs__signResponse *)ptr);
		break;
	case SOAP_TYPE_cgb__report:
		soap_serialize_cgb__report(soap, (const struct cgb__report *)ptr);
		break;
	case SOAP_TYPE_cgb__reportResponse:
		soap_serialize_cgb__reportResponse(soap, (const struct cgb__reportResponse *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchDelta:
		soap_serialize_cgb__fetchDelta(soap, (const struct cgb__fetchDelta *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchDeltaResponse:
		soap_serialize_cgb__fetchDeltaResponse(soap, (const struct cgb__fetchDeltaResponse *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchDeltaSince:
		soap_serialize_cgb__fetchDeltaSince(soap, (const struct cgb__fetchDeltaSince *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchDeltaSinceResponse:
		soap_serialize_cgb__fetchDeltaSinceResponse(soap, (const struct cgb__fetchDeltaSinceResponse *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchByMerchantTransactionId:
		soap_serialize_cgb__fetchByMerchantTransactionId(soap, (const struct cgb__fetchByMerchantTransactionId *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchByMerchantTransactionIdResponse:
		soap_serialize_cgb__fetchByMerchantTransactionIdResponse(soap, (const struct cgb__fetchByMerchantTransactionIdResponse *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchByStatusSince:
		soap_serialize_cgb__fetchByStatusSince(soap, (const struct cgb__fetchByStatusSince *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchByStatusSinceResponse:
		soap_serialize_cgb__fetchByStatusSinceResponse(soap, (const struct cgb__fetchByStatusSinceResponse *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchByStatus:
		soap_serialize_cgb__fetchByStatus(soap, (const struct cgb__fetchByStatus *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchByStatusResponse:
		soap_serialize_cgb__fetchByStatusResponse(soap, (const struct cgb__fetchByStatusResponse *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchByReferenceNumber:
		soap_serialize_cgb__fetchByReferenceNumber(soap, (const struct cgb__fetchByReferenceNumber *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchByReferenceNumberResponse:
		soap_serialize_cgb__fetchByReferenceNumberResponse(soap, (const struct cgb__fetchByReferenceNumberResponse *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchByCaseNumber:
		soap_serialize_cgb__fetchByCaseNumber(soap, (const struct cgb__fetchByCaseNumber *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchByCaseNumberResponse:
		soap_serialize_cgb__fetchByCaseNumberResponse(soap, (const struct cgb__fetchByCaseNumberResponse *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchByAccount:
		soap_serialize_cgb__fetchByAccount(soap, (const struct cgb__fetchByAccount *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchByAccountResponse:
		soap_serialize_cgb__fetchByAccountResponse(soap, (const struct cgb__fetchByAccountResponse *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchByVid:
		soap_serialize_cgb__fetchByVid(soap, (const struct cgb__fetchByVid *)ptr);
		break;
	case SOAP_TYPE_cgb__fetchByVidResponse:
		soap_serialize_cgb__fetchByVidResponse(soap, (const struct cgb__fetchByVidResponse *)ptr);
		break;
	case SOAP_TYPE_cgb__update:
		soap_serialize_cgb__update(soap, (const struct cgb__update *)ptr);
		break;
	case SOAP_TYPE_cgb__updateResponse:
		soap_serialize_cgb__updateResponse(soap, (const struct cgb__updateResponse *)ptr);
		break;
	case SOAP_TYPE_bpl__fetchByMerchantEntitlementId:
		soap_serialize_bpl__fetchByMerchantEntitlementId(soap, (const struct bpl__fetchByMerchantEntitlementId *)ptr);
		break;
	case SOAP_TYPE_bpl__fetchByMerchantEntitlementIdResponse:
		soap_serialize_bpl__fetchByMerchantEntitlementIdResponse(soap, (const struct bpl__fetchByMerchantEntitlementIdResponse *)ptr);
		break;
	case SOAP_TYPE_bpl__fetchAll:
		soap_serialize_bpl__fetchAll(soap, (const struct bpl__fetchAll *)ptr);
		break;
	case SOAP_TYPE_bpl__fetchAllResponse:
		soap_serialize_bpl__fetchAllResponse(soap, (const struct bpl__fetchAllResponse *)ptr);
		break;
	case SOAP_TYPE_bpl__fetchByBillingPlanStatus:
		soap_serialize_bpl__fetchByBillingPlanStatus(soap, (const struct bpl__fetchByBillingPlanStatus *)ptr);
		break;
	case SOAP_TYPE_bpl__fetchByBillingPlanStatusResponse:
		soap_serialize_bpl__fetchByBillingPlanStatusResponse(soap, (const struct bpl__fetchByBillingPlanStatusResponse *)ptr);
		break;
	case SOAP_TYPE_bpl__fetchByMerchantBillingPlanId:
		soap_serialize_bpl__fetchByMerchantBillingPlanId(soap, (const struct bpl__fetchByMerchantBillingPlanId *)ptr);
		break;
	case SOAP_TYPE_bpl__fetchByMerchantBillingPlanIdResponse:
		soap_serialize_bpl__fetchByMerchantBillingPlanIdResponse(soap, (const struct bpl__fetchByMerchantBillingPlanIdResponse *)ptr);
		break;
	case SOAP_TYPE_bpl__fetchByVid:
		soap_serialize_bpl__fetchByVid(soap, (const struct bpl__fetchByVid *)ptr);
		break;
	case SOAP_TYPE_bpl__fetchByVidResponse:
		soap_serialize_bpl__fetchByVidResponse(soap, (const struct bpl__fetchByVidResponse *)ptr);
		break;
	case SOAP_TYPE_bpl__update:
		soap_serialize_bpl__update(soap, (const struct bpl__update *)ptr);
		break;
	case SOAP_TYPE_bpl__updateResponse:
		soap_serialize_bpl__updateResponse(soap, (const struct bpl__updateResponse *)ptr);
		break;
	case SOAP_TYPE_add__fetchByVid:
		soap_serialize_add__fetchByVid(soap, (const struct add__fetchByVid *)ptr);
		break;
	case SOAP_TYPE_add__fetchByVidResponse:
		soap_serialize_add__fetchByVidResponse(soap, (const struct add__fetchByVidResponse *)ptr);
		break;
	case SOAP_TYPE_add__update:
		soap_serialize_add__update(soap, (const struct add__update *)ptr);
		break;
	case SOAP_TYPE_add__updateResponse:
		soap_serialize_add__updateResponse(soap, (const struct add__updateResponse *)ptr);
		break;
	case SOAP_TYPE_act__record:
		soap_serialize_act__record(soap, (const struct act__record *)ptr);
		break;
	case SOAP_TYPE_act__recordResponse:
		soap_serialize_act__recordResponse(soap, (const struct act__recordResponse *)ptr);
		break;
	case SOAP_TYPE_acc__transfer:
		soap_serialize_acc__transfer(soap, (const struct acc__transfer *)ptr);
		break;
	case SOAP_TYPE_acc__transferResponse:
		soap_serialize_acc__transferResponse(soap, (const struct acc__transferResponse *)ptr);
		break;
	case SOAP_TYPE_acc__decrementTokens:
		soap_serialize_acc__decrementTokens(soap, (const struct acc__decrementTokens *)ptr);
		break;
	case SOAP_TYPE_acc__decrementTokensResponse:
		soap_serialize_acc__decrementTokensResponse(soap, (const struct acc__decrementTokensResponse *)ptr);
		break;
	case SOAP_TYPE_acc__incrementTokens:
		soap_serialize_acc__incrementTokens(soap, (const struct acc__incrementTokens *)ptr);
		break;
	case SOAP_TYPE_acc__incrementTokensResponse:
		soap_serialize_acc__incrementTokensResponse(soap, (const struct acc__incrementTokensResponse *)ptr);
		break;
	case SOAP_TYPE_acc__tokenTransaction:
		soap_serialize_acc__tokenTransaction(soap, (const struct acc__tokenTransaction *)ptr);
		break;
	case SOAP_TYPE_acc__tokenTransactionResponse:
		soap_serialize_acc__tokenTransactionResponse(soap, (const struct acc__tokenTransactionResponse *)ptr);
		break;
	case SOAP_TYPE_acc__tokenBalance:
		soap_serialize_acc__tokenBalance(soap, (const struct acc__tokenBalance *)ptr);
		break;
	case SOAP_TYPE_acc__tokenBalanceResponse:
		soap_serialize_acc__tokenBalanceResponse(soap, (const struct acc__tokenBalanceResponse *)ptr);
		break;
	case SOAP_TYPE_acc__fetchByPaymentMethod:
		soap_serialize_acc__fetchByPaymentMethod(soap, (const struct acc__fetchByPaymentMethod *)ptr);
		break;
	case SOAP_TYPE_acc__fetchByPaymentMethodResponse:
		soap_serialize_acc__fetchByPaymentMethodResponse(soap, (const struct acc__fetchByPaymentMethodResponse *)ptr);
		break;
	case SOAP_TYPE_acc__fetchByEmail:
		soap_serialize_acc__fetchByEmail(soap, (const struct acc__fetchByEmail *)ptr);
		break;
	case SOAP_TYPE_acc__fetchByEmailResponse:
		soap_serialize_acc__fetchByEmailResponse(soap, (const struct acc__fetchByEmailResponse *)ptr);
		break;
	case SOAP_TYPE_acc__fetchByVid:
		soap_serialize_acc__fetchByVid(soap, (const struct acc__fetchByVid *)ptr);
		break;
	case SOAP_TYPE_acc__fetchByVidResponse:
		soap_serialize_acc__fetchByVidResponse(soap, (const struct acc__fetchByVidResponse *)ptr);
		break;
	case SOAP_TYPE_acc__fetchByMerchantAccountId:
		soap_serialize_acc__fetchByMerchantAccountId(soap, (const struct acc__fetchByMerchantAccountId *)ptr);
		break;
	case SOAP_TYPE_acc__fetchByMerchantAccountIdResponse:
		soap_serialize_acc__fetchByMerchantAccountIdResponse(soap, (const struct acc__fetchByMerchantAccountIdResponse *)ptr);
		break;
	case SOAP_TYPE_acc__updatePaymentMethod:
		soap_serialize_acc__updatePaymentMethod(soap, (const struct acc__updatePaymentMethod *)ptr);
		break;
	case SOAP_TYPE_acc__updatePaymentMethodResponse:
		soap_serialize_acc__updatePaymentMethodResponse(soap, (const struct acc__updatePaymentMethodResponse *)ptr);
		break;
	case SOAP_TYPE_acc__stopAutoBilling:
		soap_serialize_acc__stopAutoBilling(soap, (const struct acc__stopAutoBilling *)ptr);
		break;
	case SOAP_TYPE_acc__stopAutoBillingResponse:
		soap_serialize_acc__stopAutoBillingResponse(soap, (const struct acc__stopAutoBillingResponse *)ptr);
		break;
	case SOAP_TYPE_acc__update:
		soap_serialize_acc__update(soap, (const struct acc__update *)ptr);
		break;
	case SOAP_TYPE_acc__updateResponse:
		soap_serialize_acc__updateResponse(soap, (const struct acc__updateResponse *)ptr);
		break;
	case SOAP_TYPE_abl__fetchDeltaSince:
		soap_serialize_abl__fetchDeltaSince(soap, (const struct abl__fetchDeltaSince *)ptr);
		break;
	case SOAP_TYPE_abl__fetchDeltaSinceResponse:
		soap_serialize_abl__fetchDeltaSinceResponse(soap, (const struct abl__fetchDeltaSinceResponse *)ptr);
		break;
	case SOAP_TYPE_abl__futureRebills:
		soap_serialize_abl__futureRebills(soap, (const struct abl__futureRebills *)ptr);
		break;
	case SOAP_TYPE_abl__futureRebillsResponse:
		soap_serialize_abl__futureRebillsResponse(soap, (const struct abl__futureRebillsResponse *)ptr);
		break;
	case SOAP_TYPE_abl__fetchByAccount:
		soap_serialize_abl__fetchByAccount(soap, (const struct abl__fetchByAccount *)ptr);
		break;
	case SOAP_TYPE_abl__fetchByAccountResponse:
		soap_serialize_abl__fetchByAccountResponse(soap, (const struct abl__fetchByAccountResponse *)ptr);
		break;
	case SOAP_TYPE_abl__fetchByEmail:
		soap_serialize_abl__fetchByEmail(soap, (const struct abl__fetchByEmail *)ptr);
		break;
	case SOAP_TYPE_abl__fetchByEmailResponse:
		soap_serialize_abl__fetchByEmailResponse(soap, (const struct abl__fetchByEmailResponse *)ptr);
		break;
	case SOAP_TYPE_abl__fetchByVid:
		soap_serialize_abl__fetchByVid(soap, (const struct abl__fetchByVid *)ptr);
		break;
	case SOAP_TYPE_abl__fetchByVidResponse:
		soap_serialize_abl__fetchByVidResponse(soap, (const struct abl__fetchByVidResponse *)ptr);
		break;
	case SOAP_TYPE_abl__fetchByMerchantAutoBillId:
		soap_serialize_abl__fetchByMerchantAutoBillId(soap, (const struct abl__fetchByMerchantAutoBillId *)ptr);
		break;
	case SOAP_TYPE_abl__fetchByMerchantAutoBillIdResponse:
		soap_serialize_abl__fetchByMerchantAutoBillIdResponse(soap, (const struct abl__fetchByMerchantAutoBillIdResponse *)ptr);
		break;
	case SOAP_TYPE_abl__fetchByAccountAndProduct:
		soap_serialize_abl__fetchByAccountAndProduct(soap, (const struct abl__fetchByAccountAndProduct *)ptr);
		break;
	case SOAP_TYPE_abl__fetchByAccountAndProductResponse:
		soap_serialize_abl__fetchByAccountAndProductResponse(soap, (const struct abl__fetchByAccountAndProductResponse *)ptr);
		break;
	case SOAP_TYPE_abl__changeBillingDayOfMonth:
		soap_serialize_abl__changeBillingDayOfMonth(soap, (const struct abl__changeBillingDayOfMonth *)ptr);
		break;
	case SOAP_TYPE_abl__changeBillingDayOfMonthResponse:
		soap_serialize_abl__changeBillingDayOfMonthResponse(soap, (const struct abl__changeBillingDayOfMonthResponse *)ptr);
		break;
	case SOAP_TYPE_abl__delayBillingByDays:
		soap_serialize_abl__delayBillingByDays(soap, (const struct abl__delayBillingByDays *)ptr);
		break;
	case SOAP_TYPE_abl__delayBillingByDaysResponse:
		soap_serialize_abl__delayBillingByDaysResponse(soap, (const struct abl__delayBillingByDaysResponse *)ptr);
		break;
	case SOAP_TYPE_abl__delayBillingToDate:
		soap_serialize_abl__delayBillingToDate(soap, (const struct abl__delayBillingToDate *)ptr);
		break;
	case SOAP_TYPE_abl__delayBillingToDateResponse:
		soap_serialize_abl__delayBillingToDateResponse(soap, (const struct abl__delayBillingToDateResponse *)ptr);
		break;
	case SOAP_TYPE_abl__cancel:
		soap_serialize_abl__cancel(soap, (const struct abl__cancel *)ptr);
		break;
	case SOAP_TYPE_abl__cancelResponse:
		soap_serialize_abl__cancelResponse(soap, (const struct abl__cancelResponse *)ptr);
		break;
	case SOAP_TYPE_abl__update:
		soap_serialize_abl__update(soap, (const struct abl__update *)ptr);
		break;
	case SOAP_TYPE_abl__updateResponse:
		soap_serialize_abl__updateResponse(soap, (const struct abl__updateResponse *)ptr);
		break;
	case SOAP_TYPE_ArrayOfScoreCodes:
		soap_serialize_ArrayOfScoreCodes(soap, (const struct ArrayOfScoreCodes *)ptr);
		break;
	case SOAP_TYPE_ArrayOfCancelResults:
		soap_serialize_ArrayOfCancelResults(soap, (const struct ArrayOfCancelResults *)ptr);
		break;
	case SOAP_TYPE_ArrayOfCaptureResults:
		soap_serialize_ArrayOfCaptureResults(soap, (const struct ArrayOfCaptureResults *)ptr);
		break;
	case SOAP_TYPE_ArrayOfTokenTransactions:
		soap_serialize_ArrayOfTokenTransactions(soap, (const struct ArrayOfTokenTransactions *)ptr);
		break;
	case SOAP_TYPE_ArrayOfTokens:
		soap_serialize_ArrayOfTokens(soap, (const struct ArrayOfTokens *)ptr);
		break;
	case SOAP_TYPE_ArrayOfTaxExemption:
		soap_serialize_ArrayOfTaxExemption(soap, (const struct ArrayOfTaxExemption *)ptr);
		break;
	case SOAP_TYPE_ArrayOfSalesTaxes:
		soap_serialize_ArrayOfSalesTaxes(soap, (const struct ArrayOfSalesTaxes *)ptr);
		break;
	case SOAP_TYPE_ArrayOfRefunds:
		soap_serialize_ArrayOfRefunds(soap, (const struct ArrayOfRefunds *)ptr);
		break;
	case SOAP_TYPE_ArrayOfProducts:
		soap_serialize_ArrayOfProducts(soap, (const struct ArrayOfProducts *)ptr);
		break;
	case SOAP_TYPE_ArrayOfMetricStats:
		soap_serialize_ArrayOfMetricStats(soap, (const struct ArrayOfMetricStats *)ptr);
		break;
	case SOAP_TYPE_ArrayOfEntitlements:
		soap_serialize_ArrayOfEntitlements(soap, (const struct ArrayOfEntitlements *)ptr);
		break;
	case SOAP_TYPE_ArrayOfEmailTemplates:
		soap_serialize_ArrayOfEmailTemplates(soap, (const struct ArrayOfEmailTemplates *)ptr);
		break;
	case SOAP_TYPE_ArrayOfChargebacks:
		soap_serialize_ArrayOfChargebacks(soap, (const struct ArrayOfChargebacks *)ptr);
		break;
	case SOAP_TYPE_ArrayOfBillingPlans:
		soap_serialize_ArrayOfBillingPlans(soap, (const struct ArrayOfBillingPlans *)ptr);
		break;
	case SOAP_TYPE_ArrayOfAutoBills:
		soap_serialize_ArrayOfAutoBills(soap, (const struct ArrayOfAutoBills *)ptr);
		break;
	case SOAP_TYPE_ArrayOfActivities:
		soap_serialize_ArrayOfActivities(soap, (const struct ArrayOfActivities *)ptr);
		break;
	case SOAP_TYPE_ArrayOfAccounts:
		soap_serialize_ArrayOfAccounts(soap, (const struct ArrayOfAccounts *)ptr);
		break;
	case SOAP_TYPE_ArrayOfTransactionItems:
		soap_serialize_ArrayOfTransactionItems(soap, (const struct ArrayOfTransactionItems *)ptr);
		break;
	case SOAP_TYPE_ArrayOfTransactionStatuses:
		soap_serialize_ArrayOfTransactionStatuses(soap, (const struct ArrayOfTransactionStatuses *)ptr);
		break;
	case SOAP_TYPE_vin__TransactionStatusDirectDebit:
		soap_serialize_vin__TransactionStatusDirectDebit(soap, (const struct vin__TransactionStatusDirectDebit *)ptr);
		break;
	case SOAP_TYPE_vin__TransactionStatusPayPal:
		soap_serialize_vin__TransactionStatusPayPal(soap, (const struct vin__TransactionStatusPayPal *)ptr);
		break;
	case SOAP_TYPE_vin__TransactionStatusBoleto:
		soap_serialize_vin__TransactionStatusBoleto(soap, (const struct vin__TransactionStatusBoleto *)ptr);
		break;
	case SOAP_TYPE_vin__TransactionStatusECP:
		soap_serialize_vin__TransactionStatusECP(soap, (const struct vin__TransactionStatusECP *)ptr);
		break;
	case SOAP_TYPE_vin__TransactionStatusCreditCard:
		soap_serialize_vin__TransactionStatusCreditCard(soap, (const struct vin__TransactionStatusCreditCard *)ptr);
		break;
	case SOAP_TYPE_vin__TransactionStatus:
		soap_serialize_vin__TransactionStatus(soap, (const struct vin__TransactionStatus *)ptr);
		break;
	case SOAP_TYPE_vin__TransactionItem:
		soap_serialize_vin__TransactionItem(soap, (const struct vin__TransactionItem *)ptr);
		break;
	case SOAP_TYPE_vin__ScoreCode:
		soap_serialize_vin__ScoreCode(soap, (const struct vin__ScoreCode *)ptr);
		break;
	case SOAP_TYPE_vin__CancelResult:
		soap_serialize_vin__CancelResult(soap, (const struct vin__CancelResult *)ptr);
		break;
	case SOAP_TYPE_vin__CaptureResult:
		soap_serialize_vin__CaptureResult(soap, (const struct vin__CaptureResult *)ptr);
		break;
	case SOAP_TYPE_vin__TokenTransaction:
		soap_serialize_vin__TokenTransaction(soap, (const struct vin__TokenTransaction *)ptr);
		break;
	case SOAP_TYPE_vin__SalesTax:
		soap_serialize_vin__SalesTax(soap, (const struct vin__SalesTax *)ptr);
		break;
	case SOAP_TYPE_vin__TaxExemption:
		soap_serialize_vin__TaxExemption(soap, (const struct vin__TaxExemption *)ptr);
		break;
	case SOAP_TYPE_vin__Return:
		soap_serialize_vin__Return(soap, (const struct vin__Return *)ptr);
		break;
	case SOAP_TYPE_vin__Refund:
		soap_serialize_vin__Refund(soap, (const struct vin__Refund *)ptr);
		break;
	case SOAP_TYPE_vin__NameValuePair:
		soap_serialize_vin__NameValuePair(soap, (const struct vin__NameValuePair *)ptr);
		break;
	case SOAP_TYPE_vin__MerchantEntitlementId:
		soap_serialize_vin__MerchantEntitlementId(soap, (const struct vin__MerchantEntitlementId *)ptr);
		break;
	case SOAP_TYPE_vin__PaymentProvider:
		soap_serialize_vin__PaymentProvider(soap, (const struct vin__PaymentProvider *)ptr);
		break;
	case SOAP_TYPE_vin__Token:
		soap_serialize_vin__Token(soap, (const struct vin__Token *)ptr);
		break;
	case SOAP_TYPE_vin__Boleto:
		soap_serialize_vin__Boleto(soap, (const struct vin__Boleto *)ptr);
		break;
	case SOAP_TYPE_vin__PayPal:
		soap_serialize_vin__PayPal(soap, (const struct vin__PayPal *)ptr);
		break;
	case SOAP_TYPE_vin__DirectDebit:
		soap_serialize_vin__DirectDebit(soap, (const struct vin__DirectDebit *)ptr);
		break;
	case SOAP_TYPE_vin__ECP:
		soap_serialize_vin__ECP(soap, (const struct vin__ECP *)ptr);
		break;
	case SOAP_TYPE_vin__CreditCard:
		soap_serialize_vin__CreditCard(soap, (const struct vin__CreditCard *)ptr);
		break;
	case SOAP_TYPE_vin__MetricStatistics:
		soap_serialize_vin__MetricStatistics(soap, (const struct vin__MetricStatistics *)ptr);
		break;
	case SOAP_TYPE_vin__Entitlement:
		soap_serialize_vin__Entitlement(soap, (const struct vin__Entitlement *)ptr);
		break;
	case SOAP_TYPE_vin__EmailTemplate:
		soap_serialize_vin__EmailTemplate(soap, (const struct vin__EmailTemplate *)ptr);
		break;
	case SOAP_TYPE_vin__Transaction:
		soap_serialize_vin__Transaction(soap, (const struct vin__Transaction *)ptr);
		break;
	case SOAP_TYPE_vin__ElectronicSignature:
		soap_serialize_vin__ElectronicSignature(soap, (const struct vin__ElectronicSignature *)ptr);
		break;
	case SOAP_TYPE_vin__Chargeback:
		soap_serialize_vin__Chargeback(soap, (const struct vin__Chargeback *)ptr);
		break;
	case SOAP_TYPE_ArrayOfMerchantEntitlementIds:
		soap_serialize_ArrayOfMerchantEntitlementIds(soap, (const struct ArrayOfMerchantEntitlementIds *)ptr);
		break;
	case SOAP_TYPE_ArrayOfBillingPlanPeriods:
		soap_serialize_ArrayOfBillingPlanPeriods(soap, (const struct ArrayOfBillingPlanPeriods *)ptr);
		break;
	case SOAP_TYPE_ArrayOfBillingPlanPrices:
		soap_serialize_ArrayOfBillingPlanPrices(soap, (const struct ArrayOfBillingPlanPrices *)ptr);
		break;
	case SOAP_TYPE_vin__BillingPlanPeriod:
		soap_serialize_vin__BillingPlanPeriod(soap, (const struct vin__BillingPlanPeriod *)ptr);
		break;
	case SOAP_TYPE_vin__TokenAmount:
		soap_serialize_vin__TokenAmount(soap, (const struct vin__TokenAmount *)ptr);
		break;
	case SOAP_TYPE_vin__BillingPlanPrice:
		soap_serialize_vin__BillingPlanPrice(soap, (const struct vin__BillingPlanPrice *)ptr);
		break;
	case SOAP_TYPE_ArrayOfTransactions:
		soap_serialize_ArrayOfTransactions(soap, (const struct ArrayOfTransactions *)ptr);
		break;
	case SOAP_TYPE_vin__PaymentMethod:
		soap_serialize_vin__PaymentMethod(soap, (const struct vin__PaymentMethod *)ptr);
		break;
	case SOAP_TYPE_vin__BillingPlan:
		soap_serialize_vin__BillingPlan(soap, (const struct vin__BillingPlan *)ptr);
		break;
	case SOAP_TYPE_vin__Product:
		soap_serialize_vin__Product(soap, (const struct vin__Product *)ptr);
		break;
	case SOAP_TYPE_vin__AutoBill:
		soap_serialize_vin__AutoBill(soap, (const struct vin__AutoBill *)ptr);
		break;
	case SOAP_TYPE_vin__Authentication:
		soap_serialize_vin__Authentication(soap, (const struct vin__Authentication *)ptr);
		break;
	case SOAP_TYPE_vin__Activity:
		soap_serialize_vin__Activity(soap, (const struct vin__Activity *)ptr);
		break;
	case SOAP_TYPE_vin__ActivityNote:
		soap_serialize_vin__ActivityNote(soap, (const struct vin__ActivityNote *)ptr);
		break;
	case SOAP_TYPE_vin__ActivityCancellation:
		soap_serialize_vin__ActivityCancellation(soap, (const struct vin__ActivityCancellation *)ptr);
		break;
	case SOAP_TYPE_vin__ActivityNamedValue:
		soap_serialize_vin__ActivityNamedValue(soap, (const struct vin__ActivityNamedValue *)ptr);
		break;
	case SOAP_TYPE_vin__ActivityUsage:
		soap_serialize_vin__ActivityUsage(soap, (const struct vin__ActivityUsage *)ptr);
		break;
	case SOAP_TYPE_vin__ActivityFulfillment:
		soap_serialize_vin__ActivityFulfillment(soap, (const struct vin__ActivityFulfillment *)ptr);
		break;
	case SOAP_TYPE_vin__ActivityEmailContact:
		soap_serialize_vin__ActivityEmailContact(soap, (const struct vin__ActivityEmailContact *)ptr);
		break;
	case SOAP_TYPE_vin__ActivityPhoneContact:
		soap_serialize_vin__ActivityPhoneContact(soap, (const struct vin__ActivityPhoneContact *)ptr);
		break;
	case SOAP_TYPE_vin__ActivityURIView:
		soap_serialize_vin__ActivityURIView(soap, (const struct vin__ActivityURIView *)ptr);
		break;
	case SOAP_TYPE_vin__ActivityLogout:
		soap_serialize_vin__ActivityLogout(soap, (const struct vin__ActivityLogout *)ptr);
		break;
	case SOAP_TYPE_vin__ActivityLogin:
		soap_serialize_vin__ActivityLogin(soap, (const struct vin__ActivityLogin *)ptr);
		break;
	case SOAP_TYPE_vin__ActivityTypeArg:
		soap_serialize_vin__ActivityTypeArg(soap, (const struct vin__ActivityTypeArg *)ptr);
		break;
	case SOAP_TYPE_ArrayOfTokenAmounts:
		soap_serialize_ArrayOfTokenAmounts(soap, (const struct ArrayOfTokenAmounts *)ptr);
		break;
	case SOAP_TYPE_ArrayOfTaxExemptions:
		soap_serialize_ArrayOfTaxExemptions(soap, (const struct ArrayOfTaxExemptions *)ptr);
		break;
	case SOAP_TYPE_ArrayOfNameValuePairs:
		soap_serialize_ArrayOfNameValuePairs(soap, (const struct ArrayOfNameValuePairs *)ptr);
		break;
	case SOAP_TYPE_ArrayOfPaymentMethods:
		soap_serialize_ArrayOfPaymentMethods(soap, (const struct ArrayOfPaymentMethods *)ptr);
		break;
	case SOAP_TYPE_vin__Address:
		soap_serialize_vin__Address(soap, (const struct vin__Address *)ptr);
		break;
	case SOAP_TYPE_vin__Account:
		soap_serialize_vin__Account(soap, (const struct vin__Account *)ptr);
		break;
	case SOAP_TYPE_PointerTotrn__scoreResponse:
		soap_serialize_PointerTotrn__scoreResponse(soap, (struct trn__scoreResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfScoreCodes:
		soap_serialize_PointerToArrayOfScoreCodes(soap, (struct ArrayOfScoreCodes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotrn__reportResponse:
		soap_serialize_PointerTotrn__reportResponse(soap, (struct trn__reportResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotrn__authCaptureResponse:
		soap_serialize_PointerTotrn__authCaptureResponse(soap, (struct trn__authCaptureResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotrn__cancelResponse:
		soap_serialize_PointerTotrn__cancelResponse(soap, (struct trn__cancelResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCancelResults:
		soap_serialize_PointerToArrayOfCancelResults(soap, (struct ArrayOfCancelResults *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotrn__captureResponse:
		soap_serialize_PointerTotrn__captureResponse(soap, (struct trn__captureResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCaptureResults:
		soap_serialize_PointerToArrayOfCaptureResults(soap, (struct ArrayOfCaptureResults *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotrn__calculateSalesTaxResponse:
		soap_serialize_PointerTotrn__calculateSalesTaxResponse(soap, (struct trn__calculateSalesTaxResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfSalesTaxes:
		soap_serialize_PointerToArrayOfSalesTaxes(soap, (struct ArrayOfSalesTaxes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotrn__authResponse:
		soap_serialize_PointerTotrn__authResponse(soap, (struct trn__authResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotrn__fetchByPaymentMethodResponse:
		soap_serialize_PointerTotrn__fetchByPaymentMethodResponse(soap, (struct trn__fetchByPaymentMethodResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotrn__fetchSearchPageResponse:
		soap_serialize_PointerTotrn__fetchSearchPageResponse(soap, (struct trn__fetchSearchPageResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotrn__fetchByAutobillResponse:
		soap_serialize_PointerTotrn__fetchByAutobillResponse(soap, (struct trn__fetchByAutobillResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotrn__fetchDeltaResponse:
		soap_serialize_PointerTotrn__fetchDeltaResponse(soap, (struct trn__fetchDeltaResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotrn__fetchDeltaSinceResponse:
		soap_serialize_PointerTotrn__fetchDeltaSinceResponse(soap, (struct trn__fetchDeltaSinceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotrn__fetchByMerchantTransactionIdResponse:
		soap_serialize_PointerTotrn__fetchByMerchantTransactionIdResponse(soap, (struct trn__fetchByMerchantTransactionIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotrn__fetchByAccountResponse:
		soap_serialize_PointerTotrn__fetchByAccountResponse(soap, (struct trn__fetchByAccountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotrn__fetchByVidResponse:
		soap_serialize_PointerTotrn__fetchByVidResponse(soap, (struct trn__fetchByVidResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorfd__performResponse:
		soap_serialize_PointerTorfd__performResponse(soap, (struct rfd__performResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorfd__reportResponse:
		soap_serialize_PointerTorfd__reportResponse(soap, (struct rfd__reportResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorfd__fetchDeltaSinceResponse:
		soap_serialize_PointerTorfd__fetchDeltaSinceResponse(soap, (struct rfd__fetchDeltaSinceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorfd__fetchByTransactionResponse:
		soap_serialize_PointerTorfd__fetchByTransactionResponse(soap, (struct rfd__fetchByTransactionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorfd__fetchByAccountResponse:
		soap_serialize_PointerTorfd__fetchByAccountResponse(soap, (struct rfd__fetchByAccountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfRefunds:
		soap_serialize_PointerToArrayOfRefunds(soap, (struct ArrayOfRefunds *const*)ptr);
		break;
	case SOAP_TYPE_PointerTorfd__fetchByVidResponse:
		soap_serialize_PointerTorfd__fetchByVidResponse(soap, (struct rfd__fetchByVidResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTopyp__fetchByVidResponse:
		soap_serialize_PointerTopyp__fetchByVidResponse(soap, (struct pyp__fetchByVidResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTopyp__updateResponse:
		soap_serialize_PointerTopyp__updateResponse(soap, (struct pyp__updateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__PaymentProvider:
		soap_serialize_PointerTovin__PaymentProvider(soap, (struct vin__PaymentProvider *const*)ptr);
		break;
	case SOAP_TYPE_PointerTopym__validateResponse:
		soap_serialize_PointerTopym__validateResponse(soap, (struct pym__validateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTopym__fetchByMerchantPaymentMethodIdResponse:
		soap_serialize_PointerTopym__fetchByMerchantPaymentMethodIdResponse(soap, (struct pym__fetchByMerchantPaymentMethodIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTopym__fetchByAccountResponse:
		soap_serialize_PointerTopym__fetchByAccountResponse(soap, (struct pym__fetchByAccountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTopym__fetchByVidResponse:
		soap_serialize_PointerTopym__fetchByVidResponse(soap, (struct pym__fetchByVidResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTopym__updateResponse:
		soap_serialize_PointerTopym__updateResponse(soap, (struct pym__updateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToprd__fetchByMerchantEntitlementIdResponse:
		soap_serialize_PointerToprd__fetchByMerchantEntitlementIdResponse(soap, (struct prd__fetchByMerchantEntitlementIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToprd__fetchAllResponse:
		soap_serialize_PointerToprd__fetchAllResponse(soap, (struct prd__fetchAllResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToprd__fetchByAccountResponse:
		soap_serialize_PointerToprd__fetchByAccountResponse(soap, (struct prd__fetchByAccountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfProducts:
		soap_serialize_PointerToArrayOfProducts(soap, (struct ArrayOfProducts *const*)ptr);
		break;
	case SOAP_TYPE_PointerToprd__fetchByMerchantProductIdResponse:
		soap_serialize_PointerToprd__fetchByMerchantProductIdResponse(soap, (struct prd__fetchByMerchantProductIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToprd__fetchByVidResponse:
		soap_serialize_PointerToprd__fetchByVidResponse(soap, (struct prd__fetchByVidResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToprd__updateResponse:
		soap_serialize_PointerToprd__updateResponse(soap, (struct prd__updateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomet__reportResponse:
		soap_serialize_PointerTomet__reportResponse(soap, (struct met__reportResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfMetricStats:
		soap_serialize_PointerToArrayOfMetricStats(soap, (struct ArrayOfMetricStats *const*)ptr);
		break;
	case SOAP_TYPE_PointerToetp__fetchByTypeAndVersionResponse:
		soap_serialize_PointerToetp__fetchByTypeAndVersionResponse(soap, (struct etp__fetchByTypeAndVersionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToetp__fetchByTypeResponse:
		soap_serialize_PointerToetp__fetchByTypeResponse(soap, (struct etp__fetchByTypeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToetp__fetchByProductResponse:
		soap_serialize_PointerToetp__fetchByProductResponse(soap, (struct etp__fetchByProductResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfEmailTemplates:
		soap_serialize_PointerToArrayOfEmailTemplates(soap, (struct ArrayOfEmailTemplates *const*)ptr);
		break;
	case SOAP_TYPE_PointerToetp__fetchByVidResponse:
		soap_serialize_PointerToetp__fetchByVidResponse(soap, (struct etp__fetchByVidResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToetp__updateResponse:
		soap_serialize_PointerToetp__updateResponse(soap, (struct etp__updateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToent__fetchDeltaSinceResponse:
		soap_serialize_PointerToent__fetchDeltaSinceResponse(soap, (struct ent__fetchDeltaSinceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToent__fetchByAccountResponse:
		soap_serialize_PointerToent__fetchByAccountResponse(soap, (struct ent__fetchByAccountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfEntitlements:
		soap_serialize_PointerToArrayOfEntitlements(soap, (struct ArrayOfEntitlements *const*)ptr);
		break;
	case SOAP_TYPE_PointerToent__fetchByEntitlementIdAndAccountResponse:
		soap_serialize_PointerToent__fetchByEntitlementIdAndAccountResponse(soap, (struct ent__fetchByEntitlementIdAndAccountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToecs__getSignatureBlockResponse:
		soap_serialize_PointerToecs__getSignatureBlockResponse(soap, (struct ecs__getSignatureBlockResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToecs__signResponse:
		soap_serialize_PointerToecs__signResponse(soap, (struct ecs__signResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__ElectronicSignature:
		soap_serialize_PointerTovin__ElectronicSignature(soap, (struct vin__ElectronicSignature *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocgb__reportResponse:
		soap_serialize_PointerTocgb__reportResponse(soap, (struct cgb__reportResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocgb__fetchDeltaResponse:
		soap_serialize_PointerTocgb__fetchDeltaResponse(soap, (struct cgb__fetchDeltaResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocgb__fetchDeltaSinceResponse:
		soap_serialize_PointerTocgb__fetchDeltaSinceResponse(soap, (struct cgb__fetchDeltaSinceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocgb__fetchByMerchantTransactionIdResponse:
		soap_serialize_PointerTocgb__fetchByMerchantTransactionIdResponse(soap, (struct cgb__fetchByMerchantTransactionIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocgb__fetchByStatusSinceResponse:
		soap_serialize_PointerTocgb__fetchByStatusSinceResponse(soap, (struct cgb__fetchByStatusSinceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocgb__fetchByStatusResponse:
		soap_serialize_PointerTocgb__fetchByStatusResponse(soap, (struct cgb__fetchByStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocgb__fetchByReferenceNumberResponse:
		soap_serialize_PointerTocgb__fetchByReferenceNumberResponse(soap, (struct cgb__fetchByReferenceNumberResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocgb__fetchByCaseNumberResponse:
		soap_serialize_PointerTocgb__fetchByCaseNumberResponse(soap, (struct cgb__fetchByCaseNumberResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocgb__fetchByAccountResponse:
		soap_serialize_PointerTocgb__fetchByAccountResponse(soap, (struct cgb__fetchByAccountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfChargebacks:
		soap_serialize_PointerToArrayOfChargebacks(soap, (struct ArrayOfChargebacks *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocgb__fetchByVidResponse:
		soap_serialize_PointerTocgb__fetchByVidResponse(soap, (struct cgb__fetchByVidResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocgb__updateResponse:
		soap_serialize_PointerTocgb__updateResponse(soap, (struct cgb__updateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobpl__fetchByMerchantEntitlementIdResponse:
		soap_serialize_PointerTobpl__fetchByMerchantEntitlementIdResponse(soap, (struct bpl__fetchByMerchantEntitlementIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobpl__fetchAllResponse:
		soap_serialize_PointerTobpl__fetchAllResponse(soap, (struct bpl__fetchAllResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobpl__fetchByBillingPlanStatusResponse:
		soap_serialize_PointerTobpl__fetchByBillingPlanStatusResponse(soap, (struct bpl__fetchByBillingPlanStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfBillingPlans:
		soap_serialize_PointerToArrayOfBillingPlans(soap, (struct ArrayOfBillingPlans *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobpl__fetchByMerchantBillingPlanIdResponse:
		soap_serialize_PointerTobpl__fetchByMerchantBillingPlanIdResponse(soap, (struct bpl__fetchByMerchantBillingPlanIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobpl__fetchByVidResponse:
		soap_serialize_PointerTobpl__fetchByVidResponse(soap, (struct bpl__fetchByVidResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobpl__updateResponse:
		soap_serialize_PointerTobpl__updateResponse(soap, (struct bpl__updateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToadd__fetchByVidResponse:
		soap_serialize_PointerToadd__fetchByVidResponse(soap, (struct add__fetchByVidResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToadd__updateResponse:
		soap_serialize_PointerToadd__updateResponse(soap, (struct add__updateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToact__recordResponse:
		soap_serialize_PointerToact__recordResponse(soap, (struct act__recordResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfActivities:
		soap_serialize_PointerToArrayOfActivities(soap, (struct ArrayOfActivities *const*)ptr);
		break;
	case SOAP_TYPE_PointerToacc__transferResponse:
		soap_serialize_PointerToacc__transferResponse(soap, (struct acc__transferResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToacc__decrementTokensResponse:
		soap_serialize_PointerToacc__decrementTokensResponse(soap, (struct acc__decrementTokensResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToacc__incrementTokensResponse:
		soap_serialize_PointerToacc__incrementTokensResponse(soap, (struct acc__incrementTokensResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToacc__tokenTransactionResponse:
		soap_serialize_PointerToacc__tokenTransactionResponse(soap, (struct acc__tokenTransactionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfTokenTransactions:
		soap_serialize_PointerToArrayOfTokenTransactions(soap, (struct ArrayOfTokenTransactions *const*)ptr);
		break;
	case SOAP_TYPE_PointerToacc__tokenBalanceResponse:
		soap_serialize_PointerToacc__tokenBalanceResponse(soap, (struct acc__tokenBalanceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfTokens:
		soap_serialize_PointerToArrayOfTokens(soap, (struct ArrayOfTokens *const*)ptr);
		break;
	case SOAP_TYPE_PointerToacc__fetchByPaymentMethodResponse:
		soap_serialize_PointerToacc__fetchByPaymentMethodResponse(soap, (struct acc__fetchByPaymentMethodResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToacc__fetchByEmailResponse:
		soap_serialize_PointerToacc__fetchByEmailResponse(soap, (struct acc__fetchByEmailResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfAccounts:
		soap_serialize_PointerToArrayOfAccounts(soap, (struct ArrayOfAccounts *const*)ptr);
		break;
	case SOAP_TYPE_PointerToacc__fetchByVidResponse:
		soap_serialize_PointerToacc__fetchByVidResponse(soap, (struct acc__fetchByVidResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToacc__fetchByMerchantAccountIdResponse:
		soap_serialize_PointerToacc__fetchByMerchantAccountIdResponse(soap, (struct acc__fetchByMerchantAccountIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToacc__updatePaymentMethodResponse:
		soap_serialize_PointerToacc__updatePaymentMethodResponse(soap, (struct acc__updatePaymentMethodResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToacc__stopAutoBillingResponse:
		soap_serialize_PointerToacc__stopAutoBillingResponse(soap, (struct acc__stopAutoBillingResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToacc__updateResponse:
		soap_serialize_PointerToacc__updateResponse(soap, (struct acc__updateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToabl__fetchDeltaSinceResponse:
		soap_serialize_PointerToabl__fetchDeltaSinceResponse(soap, (struct abl__fetchDeltaSinceResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToabl__futureRebillsResponse:
		soap_serialize_PointerToabl__futureRebillsResponse(soap, (struct abl__futureRebillsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToabl__fetchByAccountResponse:
		soap_serialize_PointerToabl__fetchByAccountResponse(soap, (struct abl__fetchByAccountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToabl__fetchByEmailResponse:
		soap_serialize_PointerToabl__fetchByEmailResponse(soap, (struct abl__fetchByEmailResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToabl__fetchByVidResponse:
		soap_serialize_PointerToabl__fetchByVidResponse(soap, (struct abl__fetchByVidResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToabl__fetchByMerchantAutoBillIdResponse:
		soap_serialize_PointerToabl__fetchByMerchantAutoBillIdResponse(soap, (struct abl__fetchByMerchantAutoBillIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToabl__fetchByAccountAndProductResponse:
		soap_serialize_PointerToabl__fetchByAccountAndProductResponse(soap, (struct abl__fetchByAccountAndProductResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfAutoBills:
		soap_serialize_PointerToArrayOfAutoBills(soap, (struct ArrayOfAutoBills *const*)ptr);
		break;
	case SOAP_TYPE_PointerToabl__changeBillingDayOfMonthResponse:
		soap_serialize_PointerToabl__changeBillingDayOfMonthResponse(soap, (struct abl__changeBillingDayOfMonthResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToabl__delayBillingByDaysResponse:
		soap_serialize_PointerToabl__delayBillingByDaysResponse(soap, (struct abl__delayBillingByDaysResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToabl__delayBillingToDateResponse:
		soap_serialize_PointerToabl__delayBillingToDateResponse(soap, (struct abl__delayBillingToDateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToabl__cancelResponse:
		soap_serialize_PointerToabl__cancelResponse(soap, (struct abl__cancelResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToabl__updateResponse:
		soap_serialize_PointerToabl__updateResponse(soap, (struct abl__updateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__Authentication:
		soap_serialize_PointerTovin__Authentication(soap, (struct vin__Authentication *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__Return:
		soap_serialize_PointerTovin__Return(soap, (struct vin__Return *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__Transaction:
		soap_serialize_PointerToPointerTovin__Transaction(soap, (struct vin__Transaction **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__TransactionStatus:
		soap_serialize_PointerToPointerTovin__TransactionStatus(soap, (struct vin__TransactionStatus **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__TransactionStatus:
		soap_serialize_PointerTovin__TransactionStatus(soap, (struct vin__TransactionStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__TransactionItem:
		soap_serialize_PointerToPointerTovin__TransactionItem(soap, (struct vin__TransactionItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__TransactionItem:
		soap_serialize_PointerTovin__TransactionItem(soap, (struct vin__TransactionItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__ScoreCode:
		soap_serialize_PointerToPointerTovin__ScoreCode(soap, (struct vin__ScoreCode **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__ScoreCode:
		soap_serialize_PointerTovin__ScoreCode(soap, (struct vin__ScoreCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__CancelResult:
		soap_serialize_PointerToPointerTovin__CancelResult(soap, (struct vin__CancelResult **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__CancelResult:
		soap_serialize_PointerTovin__CancelResult(soap, (struct vin__CancelResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__CaptureResult:
		soap_serialize_PointerToPointerTovin__CaptureResult(soap, (struct vin__CaptureResult **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__CaptureResult:
		soap_serialize_PointerTovin__CaptureResult(soap, (struct vin__CaptureResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__TokenTransaction:
		soap_serialize_PointerToPointerTovin__TokenTransaction(soap, (struct vin__TokenTransaction **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__TokenTransaction:
		soap_serialize_PointerTovin__TokenTransaction(soap, (struct vin__TokenTransaction *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__TokenAmount:
		soap_serialize_PointerToPointerTovin__TokenAmount(soap, (struct vin__TokenAmount **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__Token:
		soap_serialize_PointerToPointerTovin__Token(soap, (struct vin__Token **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__SalesTax:
		soap_serialize_PointerToPointerTovin__SalesTax(soap, (struct vin__SalesTax **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__SalesTax:
		soap_serialize_PointerTovin__SalesTax(soap, (struct vin__SalesTax *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__TaxExemption:
		soap_serialize_PointerToPointerTovin__TaxExemption(soap, (struct vin__TaxExemption **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__TaxExemption:
		soap_serialize_PointerTovin__TaxExemption(soap, (struct vin__TaxExemption *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__Refund:
		soap_serialize_PointerToPointerTovin__Refund(soap, (struct vin__Refund **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__Refund:
		soap_serialize_PointerTovin__Refund(soap, (struct vin__Refund *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__Product:
		soap_serialize_PointerToPointerTovin__Product(soap, (struct vin__Product **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__NameValuePair:
		soap_serialize_PointerToPointerTovin__NameValuePair(soap, (struct vin__NameValuePair **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__NameValuePair:
		soap_serialize_PointerTovin__NameValuePair(soap, (struct vin__NameValuePair *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__MerchantEntitlementId:
		soap_serialize_PointerToPointerTovin__MerchantEntitlementId(soap, (struct vin__MerchantEntitlementId **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__MerchantEntitlementId:
		soap_serialize_PointerTovin__MerchantEntitlementId(soap, (struct vin__MerchantEntitlementId *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__PaymentMethod:
		soap_serialize_PointerToPointerTovin__PaymentMethod(soap, (struct vin__PaymentMethod **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__MetricStatistics:
		soap_serialize_PointerToPointerTovin__MetricStatistics(soap, (struct vin__MetricStatistics **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__MetricStatistics:
		soap_serialize_PointerTovin__MetricStatistics(soap, (struct vin__MetricStatistics *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__Entitlement:
		soap_serialize_PointerToPointerTovin__Entitlement(soap, (struct vin__Entitlement **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__Entitlement:
		soap_serialize_PointerTovin__Entitlement(soap, (struct vin__Entitlement *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__EmailTemplate:
		soap_serialize_PointerToPointerTovin__EmailTemplate(soap, (struct vin__EmailTemplate **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__EmailTemplate:
		soap_serialize_PointerTovin__EmailTemplate(soap, (struct vin__EmailTemplate *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__Chargeback:
		soap_serialize_PointerToPointerTovin__Chargeback(soap, (struct vin__Chargeback **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__Chargeback:
		soap_serialize_PointerTovin__Chargeback(soap, (struct vin__Chargeback *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__BillingPlan:
		soap_serialize_PointerToPointerTovin__BillingPlan(soap, (struct vin__BillingPlan **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__BillingPlanPeriod:
		soap_serialize_PointerToPointerTovin__BillingPlanPeriod(soap, (struct vin__BillingPlanPeriod **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__BillingPlanPeriod:
		soap_serialize_PointerTovin__BillingPlanPeriod(soap, (struct vin__BillingPlanPeriod *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__BillingPlanPrice:
		soap_serialize_PointerToPointerTovin__BillingPlanPrice(soap, (struct vin__BillingPlanPrice **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__BillingPlanPrice:
		soap_serialize_PointerTovin__BillingPlanPrice(soap, (struct vin__BillingPlanPrice *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__AutoBill:
		soap_serialize_PointerToPointerTovin__AutoBill(soap, (struct vin__AutoBill **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__AutoBill:
		soap_serialize_PointerTovin__AutoBill(soap, (struct vin__AutoBill *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__Activity:
		soap_serialize_PointerToPointerTovin__Activity(soap, (struct vin__Activity **const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__Activity:
		soap_serialize_PointerTovin__Activity(soap, (struct vin__Activity *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTovin__Account:
		soap_serialize_PointerToPointerTovin__Account(soap, (struct vin__Account **const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfTransactionItems:
		soap_serialize_PointerToArrayOfTransactionItems(soap, (struct ArrayOfTransactionItems *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfTransactionStatuses:
		soap_serialize_PointerToArrayOfTransactionStatuses(soap, (struct ArrayOfTransactionStatuses *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__AVSMatchType:
		soap_serialize_PointerTovin__AVSMatchType(soap, (enum vin__AVSMatchType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__TransactionStatusDirectDebit:
		soap_serialize_PointerTovin__TransactionStatusDirectDebit(soap, (struct vin__TransactionStatusDirectDebit *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__TransactionStatusPayPal:
		soap_serialize_PointerTovin__TransactionStatusPayPal(soap, (struct vin__TransactionStatusPayPal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__TransactionStatusBoleto:
		soap_serialize_PointerTovin__TransactionStatusBoleto(soap, (struct vin__TransactionStatusBoleto *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__TransactionStatusECP:
		soap_serialize_PointerTovin__TransactionStatusECP(soap, (struct vin__TransactionStatusECP *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__TransactionStatusCreditCard:
		soap_serialize_PointerTovin__TransactionStatusCreditCard(soap, (struct vin__TransactionStatusCreditCard *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__TaxRegion:
		soap_serialize_PointerTovin__TaxRegion(soap, (enum vin__TaxRegion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__RefundTokenAction:
		soap_serialize_PointerTovin__RefundTokenAction(soap, (enum vin__RefundTokenAction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__TaxClassification:
		soap_serialize_PointerTovin__TaxClassification(soap, (enum vin__TaxClassification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__ProductStatus:
		soap_serialize_PointerTovin__ProductStatus(soap, (enum vin__ProductStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__Token:
		soap_serialize_PointerTovin__Token(soap, (struct vin__Token *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__Boleto:
		soap_serialize_PointerTovin__Boleto(soap, (struct vin__Boleto *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__PayPal:
		soap_serialize_PointerTovin__PayPal(soap, (struct vin__PayPal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__DirectDebit:
		soap_serialize_PointerTovin__DirectDebit(soap, (struct vin__DirectDebit *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__ECP:
		soap_serialize_PointerTovin__ECP(soap, (struct vin__ECP *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__CreditCard:
		soap_serialize_PointerTovin__CreditCard(soap, (struct vin__CreditCard *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__PaymentMethodType:
		soap_serialize_PointerTovin__PaymentMethodType(soap, (enum vin__PaymentMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__ECPTransactionType:
		soap_serialize_PointerTovin__ECPTransactionType(soap, (enum vin__ECPTransactionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__AccountType:
		soap_serialize_PointerTovin__AccountType(soap, (enum vin__AccountType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__HashType:
		soap_serialize_PointerTovin__HashType(soap, (enum vin__HashType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__EmailTemplateType:
		soap_serialize_PointerTovin__EmailTemplateType(soap, (enum vin__EmailTemplateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__Transaction:
		soap_serialize_PointerTovin__Transaction(soap, (struct vin__Transaction *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfMerchantEntitlementIds:
		soap_serialize_PointerToArrayOfMerchantEntitlementIds(soap, (struct ArrayOfMerchantEntitlementIds *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfBillingPlanPeriods:
		soap_serialize_PointerToArrayOfBillingPlanPeriods(soap, (struct ArrayOfBillingPlanPeriods *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__BillingPlanStatus:
		soap_serialize_PointerTovin__BillingPlanStatus(soap, (enum vin__BillingPlanStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfBillingPlanPrices:
		soap_serialize_PointerToArrayOfBillingPlanPrices(soap, (struct ArrayOfBillingPlanPrices *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__BillingPeriodType:
		soap_serialize_PointerTovin__BillingPeriodType(soap, (enum vin__BillingPeriodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__TokenAmount:
		soap_serialize_PointerTovin__TokenAmount(soap, (struct vin__TokenAmount *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfTransactions:
		soap_serialize_PointerToArrayOfTransactions(soap, (struct ArrayOfTransactions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__AutoBillStatus:
		soap_serialize_PointerTovin__AutoBillStatus(soap, (enum vin__AutoBillStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__PaymentMethod:
		soap_serialize_PointerTovin__PaymentMethod(soap, (struct vin__PaymentMethod *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__BillingPlan:
		soap_serialize_PointerTovin__BillingPlan(soap, (struct vin__BillingPlan *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__Product:
		soap_serialize_PointerTovin__Product(soap, (struct vin__Product *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__ActivityTypeArg:
		soap_serialize_PointerTovin__ActivityTypeArg(soap, (struct vin__ActivityTypeArg *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__Account:
		soap_serialize_PointerTovin__Account(soap, (struct vin__Account *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__ActivityNote:
		soap_serialize_PointerTovin__ActivityNote(soap, (struct vin__ActivityNote *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__ActivityCancellation:
		soap_serialize_PointerTovin__ActivityCancellation(soap, (struct vin__ActivityCancellation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__ActivityNamedValue:
		soap_serialize_PointerTovin__ActivityNamedValue(soap, (struct vin__ActivityNamedValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__ActivityUsage:
		soap_serialize_PointerTovin__ActivityUsage(soap, (struct vin__ActivityUsage *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__ActivityFulfillment:
		soap_serialize_PointerTovin__ActivityFulfillment(soap, (struct vin__ActivityFulfillment *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__ActivityEmailContact:
		soap_serialize_PointerTovin__ActivityEmailContact(soap, (struct vin__ActivityEmailContact *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__ActivityPhoneContact:
		soap_serialize_PointerTovin__ActivityPhoneContact(soap, (struct vin__ActivityPhoneContact *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__ActivityURIView:
		soap_serialize_PointerTovin__ActivityURIView(soap, (struct vin__ActivityURIView *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__ActivityLogout:
		soap_serialize_PointerTovin__ActivityLogout(soap, (struct vin__ActivityLogout *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__ActivityLogin:
		soap_serialize_PointerTovin__ActivityLogin(soap, (struct vin__ActivityLogin *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfTokenAmounts:
		soap_serialize_PointerToArrayOfTokenAmounts(soap, (struct ArrayOfTokenAmounts *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfTaxExemptions:
		soap_serialize_PointerToArrayOfTaxExemptions(soap, (struct ArrayOfTaxExemptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfNameValuePairs:
		soap_serialize_PointerToArrayOfNameValuePairs(soap, (struct ArrayOfNameValuePairs *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfPaymentMethods:
		soap_serialize_PointerToArrayOfPaymentMethods(soap, (struct ArrayOfPaymentMethods *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__Address:
		soap_serialize_PointerTovin__Address(soap, (struct vin__Address *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__boolean:
		soap_serialize_PointerToxsd__boolean(soap, (enum xsd__boolean *const*)ptr);
		break;
	case SOAP_TYPE_PointerTovin__EmailPreference:
		soap_serialize_PointerTovin__EmailPreference(soap, (enum vin__EmailPreference *const*)ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__date:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	return soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__AVSMatchType(struct soap *soap, enum vin__AVSMatchType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__AVSMatchType
	*a = SOAP_DEFAULT_vin__AVSMatchType;
#else
	*a = (enum vin__AVSMatchType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__AVSMatchType(struct soap *soap, const enum vin__AVSMatchType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__AVSMatchType);
	if (soap_out_vin__AVSMatchType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__AVSMatchType[] =
{	{ (long)vin__AVSMatchType__FullMatch, "FullMatch" },
	{ (long)vin__AVSMatchType__PartialMatch, "PartialMatch" },
	{ (long)vin__AVSMatchType__NoMatch, "NoMatch" },
	{ (long)vin__AVSMatchType__IssuerError, "IssuerError" },
	{ (long)vin__AVSMatchType__NoOpinion, "NoOpinion" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__AVSMatchType2s(struct soap *soap, enum vin__AVSMatchType n)
{	const char *s = soap_code_str(soap_codes_vin__AVSMatchType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__AVSMatchType(struct soap *soap, const char *tag, int id, const enum vin__AVSMatchType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__AVSMatchType), type) || soap_send(soap, soap_vin__AVSMatchType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__AVSMatchType * SOAP_FMAC4 soap_get_vin__AVSMatchType(struct soap *soap, enum vin__AVSMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__AVSMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__AVSMatchType(struct soap *soap, const char *s, enum vin__AVSMatchType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__AVSMatchType, s);
	if (map)
		*a = (enum vin__AVSMatchType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__AVSMatchType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__AVSMatchType * SOAP_FMAC4 soap_in_vin__AVSMatchType(struct soap *soap, const char *tag, enum vin__AVSMatchType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__AVSMatchType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__AVSMatchType, sizeof(enum vin__AVSMatchType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__AVSMatchType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__AVSMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__AVSMatchType, 0, sizeof(enum vin__AVSMatchType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__TransactionStatusType(struct soap *soap, enum vin__TransactionStatusType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__TransactionStatusType
	*a = SOAP_DEFAULT_vin__TransactionStatusType;
#else
	*a = (enum vin__TransactionStatusType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__TransactionStatusType(struct soap *soap, const enum vin__TransactionStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__TransactionStatusType);
	if (soap_out_vin__TransactionStatusType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__TransactionStatusType[] =
{	{ (long)vin__TransactionStatusType__New, "New" },
	{ (long)vin__TransactionStatusType__AuthorizationPending, "AuthorizationPending" },
	{ (long)vin__TransactionStatusType__AuthorizedPending, "AuthorizedPending" },
	{ (long)vin__TransactionStatusType__Authorized, "Authorized" },
	{ (long)vin__TransactionStatusType__AuthorizedForValidation, "AuthorizedForValidation" },
	{ (long)vin__TransactionStatusType__Cancelled, "Cancelled" },
	{ (long)vin__TransactionStatusType__Captured, "Captured" },
	{ (long)vin__TransactionStatusType__Settled, "Settled" },
	{ (long)vin__TransactionStatusType__Refunded, "Refunded" },
	{ (long)vin__TransactionStatusType__Pending, "Pending" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__TransactionStatusType2s(struct soap *soap, enum vin__TransactionStatusType n)
{	const char *s = soap_code_str(soap_codes_vin__TransactionStatusType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__TransactionStatusType(struct soap *soap, const char *tag, int id, const enum vin__TransactionStatusType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__TransactionStatusType), type) || soap_send(soap, soap_vin__TransactionStatusType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__TransactionStatusType * SOAP_FMAC4 soap_get_vin__TransactionStatusType(struct soap *soap, enum vin__TransactionStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__TransactionStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__TransactionStatusType(struct soap *soap, const char *s, enum vin__TransactionStatusType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__TransactionStatusType, s);
	if (map)
		*a = (enum vin__TransactionStatusType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 9)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__TransactionStatusType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__TransactionStatusType * SOAP_FMAC4 soap_in_vin__TransactionStatusType(struct soap *soap, const char *tag, enum vin__TransactionStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__TransactionStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__TransactionStatusType, sizeof(enum vin__TransactionStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__TransactionStatusType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__TransactionStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__TransactionStatusType, 0, sizeof(enum vin__TransactionStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__TaxRegion(struct soap *soap, enum vin__TaxRegion *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__TaxRegion
	*a = SOAP_DEFAULT_vin__TaxRegion;
#else
	*a = (enum vin__TaxRegion)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__TaxRegion(struct soap *soap, const enum vin__TaxRegion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__TaxRegion);
	if (soap_out_vin__TaxRegion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__TaxRegion[] =
{	{ (long)vin__TaxRegion__AT, "AT" },
	{ (long)vin__TaxRegion__BE, "BE" },
	{ (long)vin__TaxRegion__BG, "BG" },
	{ (long)vin__TaxRegion__CY, "CY" },
	{ (long)vin__TaxRegion__CZ, "CZ" },
	{ (long)vin__TaxRegion__DE, "DE" },
	{ (long)vin__TaxRegion__DK, "DK" },
	{ (long)vin__TaxRegion__EE, "EE" },
	{ (long)vin__TaxRegion__EL, "EL" },
	{ (long)vin__TaxRegion__ES, "ES" },
	{ (long)vin__TaxRegion__FI, "FI" },
	{ (long)vin__TaxRegion__FR, "FR" },
	{ (long)vin__TaxRegion__GB, "GB" },
	{ (long)vin__TaxRegion__HU, "HU" },
	{ (long)vin__TaxRegion__IE, "IE" },
	{ (long)vin__TaxRegion__IT, "IT" },
	{ (long)vin__TaxRegion__LT, "LT" },
	{ (long)vin__TaxRegion__LU, "LU" },
	{ (long)vin__TaxRegion__LV, "LV" },
	{ (long)vin__TaxRegion__MT, "MT" },
	{ (long)vin__TaxRegion__NL, "NL" },
	{ (long)vin__TaxRegion__PL, "PL" },
	{ (long)vin__TaxRegion__PT, "PT" },
	{ (long)vin__TaxRegion__RO, "RO" },
	{ (long)vin__TaxRegion__SE, "SE" },
	{ (long)vin__TaxRegion__SI, "SI" },
	{ (long)vin__TaxRegion__SK, "SK" },
	{ (long)vin__TaxRegion__CH, "CH" },
	{ (long)vin__TaxRegion__CA, "CA" },
	{ (long)vin__TaxRegion__US, "US" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__TaxRegion2s(struct soap *soap, enum vin__TaxRegion n)
{	const char *s = soap_code_str(soap_codes_vin__TaxRegion, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__TaxRegion(struct soap *soap, const char *tag, int id, const enum vin__TaxRegion *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__TaxRegion), type) || soap_send(soap, soap_vin__TaxRegion2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__TaxRegion * SOAP_FMAC4 soap_get_vin__TaxRegion(struct soap *soap, enum vin__TaxRegion *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__TaxRegion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__TaxRegion(struct soap *soap, const char *s, enum vin__TaxRegion *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__TaxRegion, s);
	if (map)
		*a = (enum vin__TaxRegion)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 29)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__TaxRegion)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__TaxRegion * SOAP_FMAC4 soap_in_vin__TaxRegion(struct soap *soap, const char *tag, enum vin__TaxRegion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__TaxRegion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__TaxRegion, sizeof(enum vin__TaxRegion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__TaxRegion(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__TaxRegion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__TaxRegion, 0, sizeof(enum vin__TaxRegion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ReturnCode(struct soap *soap, enum vin__ReturnCode *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__ReturnCode
	*a = SOAP_DEFAULT_vin__ReturnCode;
#else
	*a = (enum vin__ReturnCode)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ReturnCode(struct soap *soap, const enum vin__ReturnCode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ReturnCode);
	if (soap_out_vin__ReturnCode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__ReturnCode[] =
{	{ (long)vin__ReturnCode__200, "200" },
	{ (long)vin__ReturnCode__201, "201" },
	{ (long)vin__ReturnCode__202, "202" },
	{ (long)vin__ReturnCode__203, "203" },
	{ (long)vin__ReturnCode__204, "204" },
	{ (long)vin__ReturnCode__205, "205" },
	{ (long)vin__ReturnCode__206, "206" },
	{ (long)vin__ReturnCode__300, "300" },
	{ (long)vin__ReturnCode__301, "301" },
	{ (long)vin__ReturnCode__302, "302" },
	{ (long)vin__ReturnCode__303, "303" },
	{ (long)vin__ReturnCode__304, "304" },
	{ (long)vin__ReturnCode__305, "305" },
	{ (long)vin__ReturnCode__306, "306" },
	{ (long)vin__ReturnCode__307, "307" },
	{ (long)vin__ReturnCode__400, "400" },
	{ (long)vin__ReturnCode__401, "401" },
	{ (long)vin__ReturnCode__402, "402" },
	{ (long)vin__ReturnCode__403, "403" },
	{ (long)vin__ReturnCode__404, "404" },
	{ (long)vin__ReturnCode__405, "405" },
	{ (long)vin__ReturnCode__406, "406" },
	{ (long)vin__ReturnCode__407, "407" },
	{ (long)vin__ReturnCode__408, "408" },
	{ (long)vin__ReturnCode__409, "409" },
	{ (long)vin__ReturnCode__410, "410" },
	{ (long)vin__ReturnCode__411, "411" },
	{ (long)vin__ReturnCode__412, "412" },
	{ (long)vin__ReturnCode__413, "413" },
	{ (long)vin__ReturnCode__414, "414" },
	{ (long)vin__ReturnCode__415, "415" },
	{ (long)vin__ReturnCode__416, "416" },
	{ (long)vin__ReturnCode__417, "417" },
	{ (long)vin__ReturnCode__500, "500" },
	{ (long)vin__ReturnCode__501, "501" },
	{ (long)vin__ReturnCode__502, "502" },
	{ (long)vin__ReturnCode__503, "503" },
	{ (long)vin__ReturnCode__504, "504" },
	{ (long)vin__ReturnCode__505, "505" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__ReturnCode2s(struct soap *soap, enum vin__ReturnCode n)
{	const char *s = soap_code_str(soap_codes_vin__ReturnCode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ReturnCode(struct soap *soap, const char *tag, int id, const enum vin__ReturnCode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ReturnCode), type) || soap_send(soap, soap_vin__ReturnCode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__ReturnCode * SOAP_FMAC4 soap_get_vin__ReturnCode(struct soap *soap, enum vin__ReturnCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ReturnCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__ReturnCode(struct soap *soap, const char *s, enum vin__ReturnCode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__ReturnCode, s);
	if (map)
		*a = (enum vin__ReturnCode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 505)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__ReturnCode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__ReturnCode * SOAP_FMAC4 soap_in_vin__ReturnCode(struct soap *soap, const char *tag, enum vin__ReturnCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__ReturnCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ReturnCode, sizeof(enum vin__ReturnCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__ReturnCode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__ReturnCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ReturnCode, 0, sizeof(enum vin__ReturnCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__RefundTokenAction(struct soap *soap, enum vin__RefundTokenAction *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__RefundTokenAction
	*a = SOAP_DEFAULT_vin__RefundTokenAction;
#else
	*a = (enum vin__RefundTokenAction)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__RefundTokenAction(struct soap *soap, const enum vin__RefundTokenAction *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__RefundTokenAction);
	if (soap_out_vin__RefundTokenAction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__RefundTokenAction[] =
{	{ (long)vin__RefundTokenAction__None, "None" },
	{ (long)vin__RefundTokenAction__CancelZeroBalance, "CancelZeroBalance" },
	{ (long)vin__RefundTokenAction__CancelNegativeBalance, "CancelNegativeBalance" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__RefundTokenAction2s(struct soap *soap, enum vin__RefundTokenAction n)
{	const char *s = soap_code_str(soap_codes_vin__RefundTokenAction, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__RefundTokenAction(struct soap *soap, const char *tag, int id, const enum vin__RefundTokenAction *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__RefundTokenAction), type) || soap_send(soap, soap_vin__RefundTokenAction2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__RefundTokenAction * SOAP_FMAC4 soap_get_vin__RefundTokenAction(struct soap *soap, enum vin__RefundTokenAction *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__RefundTokenAction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__RefundTokenAction(struct soap *soap, const char *s, enum vin__RefundTokenAction *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__RefundTokenAction, s);
	if (map)
		*a = (enum vin__RefundTokenAction)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__RefundTokenAction)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__RefundTokenAction * SOAP_FMAC4 soap_in_vin__RefundTokenAction(struct soap *soap, const char *tag, enum vin__RefundTokenAction *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__RefundTokenAction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__RefundTokenAction, sizeof(enum vin__RefundTokenAction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__RefundTokenAction(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__RefundTokenAction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__RefundTokenAction, 0, sizeof(enum vin__RefundTokenAction), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__TaxClassification(struct soap *soap, enum vin__TaxClassification *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__TaxClassification
	*a = SOAP_DEFAULT_vin__TaxClassification;
#else
	*a = (enum vin__TaxClassification)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__TaxClassification(struct soap *soap, const enum vin__TaxClassification *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__TaxClassification);
	if (soap_out_vin__TaxClassification(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__TaxClassification[] =
{	{ (long)vin__TaxClassification__PhysicalGoods, "PhysicalGoods" },
	{ (long)vin__TaxClassification__DownloadableExecutableSoftware, "DownloadableExecutableSoftware" },
	{ (long)vin__TaxClassification__DownloadableElectronicData, "DownloadableElectronicData" },
	{ (long)vin__TaxClassification__Service, "Service" },
	{ (long)vin__TaxClassification__TaxExempt, "TaxExempt" },
	{ (long)vin__TaxClassification__OtherTaxable, "OtherTaxable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__TaxClassification2s(struct soap *soap, enum vin__TaxClassification n)
{	const char *s = soap_code_str(soap_codes_vin__TaxClassification, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__TaxClassification(struct soap *soap, const char *tag, int id, const enum vin__TaxClassification *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__TaxClassification), type) || soap_send(soap, soap_vin__TaxClassification2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__TaxClassification * SOAP_FMAC4 soap_get_vin__TaxClassification(struct soap *soap, enum vin__TaxClassification *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__TaxClassification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__TaxClassification(struct soap *soap, const char *s, enum vin__TaxClassification *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__TaxClassification, s);
	if (map)
		*a = (enum vin__TaxClassification)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__TaxClassification)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__TaxClassification * SOAP_FMAC4 soap_in_vin__TaxClassification(struct soap *soap, const char *tag, enum vin__TaxClassification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__TaxClassification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__TaxClassification, sizeof(enum vin__TaxClassification), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__TaxClassification(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__TaxClassification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__TaxClassification, 0, sizeof(enum vin__TaxClassification), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ProductStatus(struct soap *soap, enum vin__ProductStatus *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__ProductStatus
	*a = SOAP_DEFAULT_vin__ProductStatus;
#else
	*a = (enum vin__ProductStatus)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ProductStatus(struct soap *soap, const enum vin__ProductStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ProductStatus);
	if (soap_out_vin__ProductStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__ProductStatus[] =
{	{ (long)vin__ProductStatus__Active, "Active" },
	{ (long)vin__ProductStatus__Suspended, "Suspended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__ProductStatus2s(struct soap *soap, enum vin__ProductStatus n)
{	const char *s = soap_code_str(soap_codes_vin__ProductStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ProductStatus(struct soap *soap, const char *tag, int id, const enum vin__ProductStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ProductStatus), type) || soap_send(soap, soap_vin__ProductStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__ProductStatus * SOAP_FMAC4 soap_get_vin__ProductStatus(struct soap *soap, enum vin__ProductStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ProductStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__ProductStatus(struct soap *soap, const char *s, enum vin__ProductStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__ProductStatus, s);
	if (map)
		*a = (enum vin__ProductStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__ProductStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__ProductStatus * SOAP_FMAC4 soap_in_vin__ProductStatus(struct soap *soap, const char *tag, enum vin__ProductStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__ProductStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ProductStatus, sizeof(enum vin__ProductStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__ProductStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__ProductStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ProductStatus, 0, sizeof(enum vin__ProductStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ECPTransactionType(struct soap *soap, enum vin__ECPTransactionType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__ECPTransactionType
	*a = SOAP_DEFAULT_vin__ECPTransactionType;
#else
	*a = (enum vin__ECPTransactionType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ECPTransactionType(struct soap *soap, const enum vin__ECPTransactionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ECPTransactionType);
	if (soap_out_vin__ECPTransactionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__ECPTransactionType[] =
{	{ (long)vin__ECPTransactionType__All, "All" },
	{ (long)vin__ECPTransactionType__Inbound, "Inbound" },
	{ (long)vin__ECPTransactionType__Outbound, "Outbound" },
	{ (long)vin__ECPTransactionType__InboundOutbound, "InboundOutbound" },
	{ (long)vin__ECPTransactionType__Transfer, "Transfer" },
	{ (long)vin__ECPTransactionType__NA, "NA" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__ECPTransactionType2s(struct soap *soap, enum vin__ECPTransactionType n)
{	const char *s = soap_code_str(soap_codes_vin__ECPTransactionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ECPTransactionType(struct soap *soap, const char *tag, int id, const enum vin__ECPTransactionType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ECPTransactionType), type) || soap_send(soap, soap_vin__ECPTransactionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__ECPTransactionType * SOAP_FMAC4 soap_get_vin__ECPTransactionType(struct soap *soap, enum vin__ECPTransactionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ECPTransactionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__ECPTransactionType(struct soap *soap, const char *s, enum vin__ECPTransactionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__ECPTransactionType, s);
	if (map)
		*a = (enum vin__ECPTransactionType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__ECPTransactionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__ECPTransactionType * SOAP_FMAC4 soap_in_vin__ECPTransactionType(struct soap *soap, const char *tag, enum vin__ECPTransactionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__ECPTransactionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ECPTransactionType, sizeof(enum vin__ECPTransactionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__ECPTransactionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__ECPTransactionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ECPTransactionType, 0, sizeof(enum vin__ECPTransactionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__AccountType(struct soap *soap, enum vin__AccountType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__AccountType
	*a = SOAP_DEFAULT_vin__AccountType;
#else
	*a = (enum vin__AccountType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__AccountType(struct soap *soap, const enum vin__AccountType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__AccountType);
	if (soap_out_vin__AccountType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__AccountType[] =
{	{ (long)vin__AccountType__ConsumerChecking, "ConsumerChecking" },
	{ (long)vin__AccountType__ConsumerSavings, "ConsumerSavings" },
	{ (long)vin__AccountType__CorporateChecking, "CorporateChecking" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__AccountType2s(struct soap *soap, enum vin__AccountType n)
{	const char *s = soap_code_str(soap_codes_vin__AccountType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__AccountType(struct soap *soap, const char *tag, int id, const enum vin__AccountType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__AccountType), type) || soap_send(soap, soap_vin__AccountType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__AccountType * SOAP_FMAC4 soap_get_vin__AccountType(struct soap *soap, enum vin__AccountType *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__AccountType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__AccountType(struct soap *soap, const char *s, enum vin__AccountType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__AccountType, s);
	if (map)
		*a = (enum vin__AccountType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__AccountType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__AccountType * SOAP_FMAC4 soap_in_vin__AccountType(struct soap *soap, const char *tag, enum vin__AccountType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__AccountType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__AccountType, sizeof(enum vin__AccountType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__AccountType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__AccountType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__AccountType, 0, sizeof(enum vin__AccountType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__HashType(struct soap *soap, enum vin__HashType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__HashType
	*a = SOAP_DEFAULT_vin__HashType;
#else
	*a = (enum vin__HashType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__HashType(struct soap *soap, const enum vin__HashType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__HashType);
	if (soap_out_vin__HashType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__HashType[] =
{	{ (long)vin__HashType__sha1, "sha1" },
	{ (long)vin__HashType__md5, "md5" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__HashType2s(struct soap *soap, enum vin__HashType n)
{	const char *s = soap_code_str(soap_codes_vin__HashType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__HashType(struct soap *soap, const char *tag, int id, const enum vin__HashType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__HashType), type) || soap_send(soap, soap_vin__HashType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__HashType * SOAP_FMAC4 soap_get_vin__HashType(struct soap *soap, enum vin__HashType *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__HashType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__HashType(struct soap *soap, const char *s, enum vin__HashType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__HashType, s);
	if (map)
		*a = (enum vin__HashType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__HashType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__HashType * SOAP_FMAC4 soap_in_vin__HashType(struct soap *soap, const char *tag, enum vin__HashType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__HashType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__HashType, sizeof(enum vin__HashType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__HashType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__HashType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__HashType, 0, sizeof(enum vin__HashType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__PaymentMethodType(struct soap *soap, enum vin__PaymentMethodType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__PaymentMethodType
	*a = SOAP_DEFAULT_vin__PaymentMethodType;
#else
	*a = (enum vin__PaymentMethodType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__PaymentMethodType(struct soap *soap, const enum vin__PaymentMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__PaymentMethodType);
	if (soap_out_vin__PaymentMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__PaymentMethodType[] =
{	{ (long)vin__PaymentMethodType__CreditCard, "CreditCard" },
	{ (long)vin__PaymentMethodType__PayPal, "PayPal" },
	{ (long)vin__PaymentMethodType__ECP, "ECP" },
	{ (long)vin__PaymentMethodType__DirectDebit, "DirectDebit" },
	{ (long)vin__PaymentMethodType__Token, "Token" },
	{ (long)vin__PaymentMethodType__Boleto, "Boleto" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__PaymentMethodType2s(struct soap *soap, enum vin__PaymentMethodType n)
{	const char *s = soap_code_str(soap_codes_vin__PaymentMethodType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__PaymentMethodType(struct soap *soap, const char *tag, int id, const enum vin__PaymentMethodType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__PaymentMethodType), type) || soap_send(soap, soap_vin__PaymentMethodType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__PaymentMethodType * SOAP_FMAC4 soap_get_vin__PaymentMethodType(struct soap *soap, enum vin__PaymentMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__PaymentMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__PaymentMethodType(struct soap *soap, const char *s, enum vin__PaymentMethodType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__PaymentMethodType, s);
	if (map)
		*a = (enum vin__PaymentMethodType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__PaymentMethodType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__PaymentMethodType * SOAP_FMAC4 soap_in_vin__PaymentMethodType(struct soap *soap, const char *tag, enum vin__PaymentMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__PaymentMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__PaymentMethodType, sizeof(enum vin__PaymentMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__PaymentMethodType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__PaymentMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__PaymentMethodType, 0, sizeof(enum vin__PaymentMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__MetricStatusType(struct soap *soap, enum vin__MetricStatusType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__MetricStatusType
	*a = SOAP_DEFAULT_vin__MetricStatusType;
#else
	*a = (enum vin__MetricStatusType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__MetricStatusType(struct soap *soap, const enum vin__MetricStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__MetricStatusType);
	if (soap_out_vin__MetricStatusType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__MetricStatusType[] =
{	{ (long)vin__MetricStatusType__Completed, "Completed" },
	{ (long)vin__MetricStatusType__TimedOut, "TimedOut" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__MetricStatusType2s(struct soap *soap, enum vin__MetricStatusType n)
{	const char *s = soap_code_str(soap_codes_vin__MetricStatusType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__MetricStatusType(struct soap *soap, const char *tag, int id, const enum vin__MetricStatusType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__MetricStatusType), type) || soap_send(soap, soap_vin__MetricStatusType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__MetricStatusType * SOAP_FMAC4 soap_get_vin__MetricStatusType(struct soap *soap, enum vin__MetricStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__MetricStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__MetricStatusType(struct soap *soap, const char *s, enum vin__MetricStatusType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__MetricStatusType, s);
	if (map)
		*a = (enum vin__MetricStatusType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__MetricStatusType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__MetricStatusType * SOAP_FMAC4 soap_in_vin__MetricStatusType(struct soap *soap, const char *tag, enum vin__MetricStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__MetricStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__MetricStatusType, sizeof(enum vin__MetricStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__MetricStatusType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__MetricStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__MetricStatusType, 0, sizeof(enum vin__MetricStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__EmailTemplateType(struct soap *soap, enum vin__EmailTemplateType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__EmailTemplateType
	*a = SOAP_DEFAULT_vin__EmailTemplateType;
#else
	*a = (enum vin__EmailTemplateType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__EmailTemplateType(struct soap *soap, const enum vin__EmailTemplateType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__EmailTemplateType);
	if (soap_out_vin__EmailTemplateType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__EmailTemplateType[] =
{	{ (long)vin__EmailTemplateType__PreBilling, "PreBilling" },
	{ (long)vin__EmailTemplateType__PreBillingNoPaymentMethod, "PreBillingNoPaymentMethod" },
	{ (long)vin__EmailTemplateType__Success, "Success" },
	{ (long)vin__EmailTemplateType__FailureSoftFail, "FailureSoftFail" },
	{ (long)vin__EmailTemplateType__FailureHardFail, "FailureHardFail" },
	{ (long)vin__EmailTemplateType__FailureNoPaymentMethod, "FailureNoPaymentMethod" },
	{ (long)vin__EmailTemplateType__BillingDelay, "BillingDelay" },
	{ (long)vin__EmailTemplateType__BillingDelayNoPaymentMethod, "BillingDelayNoPaymentMethod" },
	{ (long)vin__EmailTemplateType__Cancellation, "Cancellation" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__EmailTemplateType2s(struct soap *soap, enum vin__EmailTemplateType n)
{	const char *s = soap_code_str(soap_codes_vin__EmailTemplateType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__EmailTemplateType(struct soap *soap, const char *tag, int id, const enum vin__EmailTemplateType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__EmailTemplateType), type) || soap_send(soap, soap_vin__EmailTemplateType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__EmailTemplateType * SOAP_FMAC4 soap_get_vin__EmailTemplateType(struct soap *soap, enum vin__EmailTemplateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__EmailTemplateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__EmailTemplateType(struct soap *soap, const char *s, enum vin__EmailTemplateType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__EmailTemplateType, s);
	if (map)
		*a = (enum vin__EmailTemplateType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__EmailTemplateType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__EmailTemplateType * SOAP_FMAC4 soap_in_vin__EmailTemplateType(struct soap *soap, const char *tag, enum vin__EmailTemplateType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__EmailTemplateType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__EmailTemplateType, sizeof(enum vin__EmailTemplateType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__EmailTemplateType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__EmailTemplateType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__EmailTemplateType, 0, sizeof(enum vin__EmailTemplateType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ChargebackStatus(struct soap *soap, enum vin__ChargebackStatus *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__ChargebackStatus
	*a = SOAP_DEFAULT_vin__ChargebackStatus;
#else
	*a = (enum vin__ChargebackStatus)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ChargebackStatus(struct soap *soap, const enum vin__ChargebackStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ChargebackStatus);
	if (soap_out_vin__ChargebackStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__ChargebackStatus[] =
{	{ (long)vin__ChargebackStatus__New, "New" },
	{ (long)vin__ChargebackStatus__Retrieval, "Retrieval" },
	{ (long)vin__ChargebackStatus__Responded, "Responded" },
	{ (long)vin__ChargebackStatus__Legitimate, "Legitimate" },
	{ (long)vin__ChargebackStatus__Challenged, "Challenged" },
	{ (long)vin__ChargebackStatus__Represented, "Represented" },
	{ (long)vin__ChargebackStatus__Won, "Won" },
	{ (long)vin__ChargebackStatus__Lost, "Lost" },
	{ (long)vin__ChargebackStatus__CollectionsNew, "CollectionsNew" },
	{ (long)vin__ChargebackStatus__CollectionsWon, "CollectionsWon" },
	{ (long)vin__ChargebackStatus__CollectionsLost, "CollectionsLost" },
	{ (long)vin__ChargebackStatus__Expired, "Expired" },
	{ (long)vin__ChargebackStatus__Pass, "Pass" },
	{ (long)vin__ChargebackStatus__Incomplete, "Incomplete" },
	{ (long)vin__ChargebackStatus__NewSecondChargeback, "NewSecondChargeback" },
	{ (long)vin__ChargebackStatus__Duplicate, "Duplicate" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__ChargebackStatus2s(struct soap *soap, enum vin__ChargebackStatus n)
{	const char *s = soap_code_str(soap_codes_vin__ChargebackStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ChargebackStatus(struct soap *soap, const char *tag, int id, const enum vin__ChargebackStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ChargebackStatus), type) || soap_send(soap, soap_vin__ChargebackStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__ChargebackStatus * SOAP_FMAC4 soap_get_vin__ChargebackStatus(struct soap *soap, enum vin__ChargebackStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ChargebackStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__ChargebackStatus(struct soap *soap, const char *s, enum vin__ChargebackStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__ChargebackStatus, s);
	if (map)
		*a = (enum vin__ChargebackStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 15)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__ChargebackStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__ChargebackStatus * SOAP_FMAC4 soap_in_vin__ChargebackStatus(struct soap *soap, const char *tag, enum vin__ChargebackStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__ChargebackStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ChargebackStatus, sizeof(enum vin__ChargebackStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__ChargebackStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__ChargebackStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ChargebackStatus, 0, sizeof(enum vin__ChargebackStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__BillingPlanStatus(struct soap *soap, enum vin__BillingPlanStatus *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__BillingPlanStatus
	*a = SOAP_DEFAULT_vin__BillingPlanStatus;
#else
	*a = (enum vin__BillingPlanStatus)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__BillingPlanStatus(struct soap *soap, const enum vin__BillingPlanStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__BillingPlanStatus);
	if (soap_out_vin__BillingPlanStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__BillingPlanStatus[] =
{	{ (long)vin__BillingPlanStatus__Active, "Active" },
	{ (long)vin__BillingPlanStatus__Suspended, "Suspended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__BillingPlanStatus2s(struct soap *soap, enum vin__BillingPlanStatus n)
{	const char *s = soap_code_str(soap_codes_vin__BillingPlanStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__BillingPlanStatus(struct soap *soap, const char *tag, int id, const enum vin__BillingPlanStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__BillingPlanStatus), type) || soap_send(soap, soap_vin__BillingPlanStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__BillingPlanStatus * SOAP_FMAC4 soap_get_vin__BillingPlanStatus(struct soap *soap, enum vin__BillingPlanStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__BillingPlanStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__BillingPlanStatus(struct soap *soap, const char *s, enum vin__BillingPlanStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__BillingPlanStatus, s);
	if (map)
		*a = (enum vin__BillingPlanStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__BillingPlanStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__BillingPlanStatus * SOAP_FMAC4 soap_in_vin__BillingPlanStatus(struct soap *soap, const char *tag, enum vin__BillingPlanStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__BillingPlanStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__BillingPlanStatus, sizeof(enum vin__BillingPlanStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__BillingPlanStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__BillingPlanStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__BillingPlanStatus, 0, sizeof(enum vin__BillingPlanStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__BillingPeriodType(struct soap *soap, enum vin__BillingPeriodType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__BillingPeriodType
	*a = SOAP_DEFAULT_vin__BillingPeriodType;
#else
	*a = (enum vin__BillingPeriodType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__BillingPeriodType(struct soap *soap, const enum vin__BillingPeriodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__BillingPeriodType);
	if (soap_out_vin__BillingPeriodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__BillingPeriodType[] =
{	{ (long)vin__BillingPeriodType__Day, "Day" },
	{ (long)vin__BillingPeriodType__Week, "Week" },
	{ (long)vin__BillingPeriodType__Month, "Month" },
	{ (long)vin__BillingPeriodType__Year, "Year" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__BillingPeriodType2s(struct soap *soap, enum vin__BillingPeriodType n)
{	const char *s = soap_code_str(soap_codes_vin__BillingPeriodType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__BillingPeriodType(struct soap *soap, const char *tag, int id, const enum vin__BillingPeriodType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__BillingPeriodType), type) || soap_send(soap, soap_vin__BillingPeriodType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__BillingPeriodType * SOAP_FMAC4 soap_get_vin__BillingPeriodType(struct soap *soap, enum vin__BillingPeriodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__BillingPeriodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__BillingPeriodType(struct soap *soap, const char *s, enum vin__BillingPeriodType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__BillingPeriodType, s);
	if (map)
		*a = (enum vin__BillingPeriodType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__BillingPeriodType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__BillingPeriodType * SOAP_FMAC4 soap_in_vin__BillingPeriodType(struct soap *soap, const char *tag, enum vin__BillingPeriodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__BillingPeriodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__BillingPeriodType, sizeof(enum vin__BillingPeriodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__BillingPeriodType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__BillingPeriodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__BillingPeriodType, 0, sizeof(enum vin__BillingPeriodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__DuplicateBehavior(struct soap *soap, enum vin__DuplicateBehavior *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__DuplicateBehavior
	*a = SOAP_DEFAULT_vin__DuplicateBehavior;
#else
	*a = (enum vin__DuplicateBehavior)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__DuplicateBehavior(struct soap *soap, const enum vin__DuplicateBehavior *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__DuplicateBehavior);
	if (soap_out_vin__DuplicateBehavior(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__DuplicateBehavior[] =
{	{ (long)vin__DuplicateBehavior__Duplicate, "Duplicate" },
	{ (long)vin__DuplicateBehavior__SucceedIgnore, "SucceedIgnore" },
	{ (long)vin__DuplicateBehavior__Fail, "Fail" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__DuplicateBehavior2s(struct soap *soap, enum vin__DuplicateBehavior n)
{	const char *s = soap_code_str(soap_codes_vin__DuplicateBehavior, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__DuplicateBehavior(struct soap *soap, const char *tag, int id, const enum vin__DuplicateBehavior *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__DuplicateBehavior), type) || soap_send(soap, soap_vin__DuplicateBehavior2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__DuplicateBehavior * SOAP_FMAC4 soap_get_vin__DuplicateBehavior(struct soap *soap, enum vin__DuplicateBehavior *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__DuplicateBehavior(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__DuplicateBehavior(struct soap *soap, const char *s, enum vin__DuplicateBehavior *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__DuplicateBehavior, s);
	if (map)
		*a = (enum vin__DuplicateBehavior)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__DuplicateBehavior)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__DuplicateBehavior * SOAP_FMAC4 soap_in_vin__DuplicateBehavior(struct soap *soap, const char *tag, enum vin__DuplicateBehavior *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__DuplicateBehavior *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__DuplicateBehavior, sizeof(enum vin__DuplicateBehavior), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__DuplicateBehavior(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__DuplicateBehavior *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__DuplicateBehavior, 0, sizeof(enum vin__DuplicateBehavior), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__AutoBillStatus(struct soap *soap, enum vin__AutoBillStatus *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__AutoBillStatus
	*a = SOAP_DEFAULT_vin__AutoBillStatus;
#else
	*a = (enum vin__AutoBillStatus)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__AutoBillStatus(struct soap *soap, const enum vin__AutoBillStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__AutoBillStatus);
	if (soap_out_vin__AutoBillStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__AutoBillStatus[] =
{	{ (long)vin__AutoBillStatus__Active, "Active" },
	{ (long)vin__AutoBillStatus__Suspended, "Suspended" },
	{ (long)vin__AutoBillStatus__Cancelled, "Cancelled" },
	{ (long)vin__AutoBillStatus__Upgraded, "Upgraded" },
	{ (long)vin__AutoBillStatus__PendingCustomerAction, "PendingCustomerAction" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__AutoBillStatus2s(struct soap *soap, enum vin__AutoBillStatus n)
{	const char *s = soap_code_str(soap_codes_vin__AutoBillStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__AutoBillStatus(struct soap *soap, const char *tag, int id, const enum vin__AutoBillStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__AutoBillStatus), type) || soap_send(soap, soap_vin__AutoBillStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__AutoBillStatus * SOAP_FMAC4 soap_get_vin__AutoBillStatus(struct soap *soap, enum vin__AutoBillStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__AutoBillStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__AutoBillStatus(struct soap *soap, const char *s, enum vin__AutoBillStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__AutoBillStatus, s);
	if (map)
		*a = (enum vin__AutoBillStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__AutoBillStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__AutoBillStatus * SOAP_FMAC4 soap_in_vin__AutoBillStatus(struct soap *soap, const char *tag, enum vin__AutoBillStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__AutoBillStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__AutoBillStatus, sizeof(enum vin__AutoBillStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__AutoBillStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__AutoBillStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__AutoBillStatus, 0, sizeof(enum vin__AutoBillStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__AddressType(struct soap *soap, enum vin__AddressType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__AddressType
	*a = SOAP_DEFAULT_vin__AddressType;
#else
	*a = (enum vin__AddressType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__AddressType(struct soap *soap, const enum vin__AddressType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__AddressType);
	if (soap_out_vin__AddressType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__AddressType[] =
{	{ (long)vin__AddressType__Shipping, "Shipping" },
	{ (long)vin__AddressType__Billing, "Billing" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__AddressType2s(struct soap *soap, enum vin__AddressType n)
{	const char *s = soap_code_str(soap_codes_vin__AddressType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__AddressType(struct soap *soap, const char *tag, int id, const enum vin__AddressType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__AddressType), type) || soap_send(soap, soap_vin__AddressType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__AddressType * SOAP_FMAC4 soap_get_vin__AddressType(struct soap *soap, enum vin__AddressType *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__AddressType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__AddressType(struct soap *soap, const char *s, enum vin__AddressType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__AddressType, s);
	if (map)
		*a = (enum vin__AddressType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__AddressType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__AddressType * SOAP_FMAC4 soap_in_vin__AddressType(struct soap *soap, const char *tag, enum vin__AddressType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__AddressType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__AddressType, sizeof(enum vin__AddressType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__AddressType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__AddressType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__AddressType, 0, sizeof(enum vin__AddressType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ActivityCallType(struct soap *soap, enum vin__ActivityCallType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__ActivityCallType
	*a = SOAP_DEFAULT_vin__ActivityCallType;
#else
	*a = (enum vin__ActivityCallType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ActivityCallType(struct soap *soap, const enum vin__ActivityCallType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ActivityCallType);
	if (soap_out_vin__ActivityCallType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__ActivityCallType[] =
{	{ (long)vin__ActivityCallType__FromMerchantToCustomer, "FromMerchantToCustomer" },
	{ (long)vin__ActivityCallType__FromMerchantToOther, "FromMerchantToOther" },
	{ (long)vin__ActivityCallType__FromCustomerToMerchant, "FromCustomerToMerchant" },
	{ (long)vin__ActivityCallType__FromCustomerToOther, "FromCustomerToOther" },
	{ (long)vin__ActivityCallType__FromOtherToCustomer, "FromOtherToCustomer" },
	{ (long)vin__ActivityCallType__FromOtherToMerchant, "FromOtherToMerchant" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__ActivityCallType2s(struct soap *soap, enum vin__ActivityCallType n)
{	const char *s = soap_code_str(soap_codes_vin__ActivityCallType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ActivityCallType(struct soap *soap, const char *tag, int id, const enum vin__ActivityCallType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ActivityCallType), type) || soap_send(soap, soap_vin__ActivityCallType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__ActivityCallType * SOAP_FMAC4 soap_get_vin__ActivityCallType(struct soap *soap, enum vin__ActivityCallType *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ActivityCallType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__ActivityCallType(struct soap *soap, const char *s, enum vin__ActivityCallType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__ActivityCallType, s);
	if (map)
		*a = (enum vin__ActivityCallType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__ActivityCallType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__ActivityCallType * SOAP_FMAC4 soap_in_vin__ActivityCallType(struct soap *soap, const char *tag, enum vin__ActivityCallType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__ActivityCallType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ActivityCallType, sizeof(enum vin__ActivityCallType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__ActivityCallType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__ActivityCallType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ActivityCallType, 0, sizeof(enum vin__ActivityCallType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ActivityType(struct soap *soap, enum vin__ActivityType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__ActivityType
	*a = SOAP_DEFAULT_vin__ActivityType;
#else
	*a = (enum vin__ActivityType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ActivityType(struct soap *soap, const enum vin__ActivityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ActivityType);
	if (soap_out_vin__ActivityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__ActivityType[] =
{	{ (long)vin__ActivityType__Login, "Login" },
	{ (long)vin__ActivityType__Logout, "Logout" },
	{ (long)vin__ActivityType__URIView, "URIView" },
	{ (long)vin__ActivityType__Phone, "Phone" },
	{ (long)vin__ActivityType__Email, "Email" },
	{ (long)vin__ActivityType__Fulfillment, "Fulfillment" },
	{ (long)vin__ActivityType__Usage, "Usage" },
	{ (long)vin__ActivityType__NamedValue, "NamedValue" },
	{ (long)vin__ActivityType__Cancellation, "Cancellation" },
	{ (long)vin__ActivityType__Note, "Note" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__ActivityType2s(struct soap *soap, enum vin__ActivityType n)
{	const char *s = soap_code_str(soap_codes_vin__ActivityType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ActivityType(struct soap *soap, const char *tag, int id, const enum vin__ActivityType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ActivityType), type) || soap_send(soap, soap_vin__ActivityType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__ActivityType * SOAP_FMAC4 soap_get_vin__ActivityType(struct soap *soap, enum vin__ActivityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ActivityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__ActivityType(struct soap *soap, const char *s, enum vin__ActivityType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__ActivityType, s);
	if (map)
		*a = (enum vin__ActivityType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 9)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__ActivityType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__ActivityType * SOAP_FMAC4 soap_in_vin__ActivityType(struct soap *soap, const char *tag, enum vin__ActivityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__ActivityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ActivityType, sizeof(enum vin__ActivityType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__ActivityType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__ActivityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ActivityType, 0, sizeof(enum vin__ActivityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ActivityCancelInitType(struct soap *soap, enum vin__ActivityCancelInitType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__ActivityCancelInitType
	*a = SOAP_DEFAULT_vin__ActivityCancelInitType;
#else
	*a = (enum vin__ActivityCancelInitType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ActivityCancelInitType(struct soap *soap, const enum vin__ActivityCancelInitType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ActivityCancelInitType);
	if (soap_out_vin__ActivityCancelInitType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__ActivityCancelInitType[] =
{	{ (long)vin__ActivityCancelInitType__Merchant, "Merchant" },
	{ (long)vin__ActivityCancelInitType__Customer, "Customer" },
	{ (long)vin__ActivityCancelInitType__Chargeback, "Chargeback" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__ActivityCancelInitType2s(struct soap *soap, enum vin__ActivityCancelInitType n)
{	const char *s = soap_code_str(soap_codes_vin__ActivityCancelInitType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ActivityCancelInitType(struct soap *soap, const char *tag, int id, const enum vin__ActivityCancelInitType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ActivityCancelInitType), type) || soap_send(soap, soap_vin__ActivityCancelInitType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__ActivityCancelInitType * SOAP_FMAC4 soap_get_vin__ActivityCancelInitType(struct soap *soap, enum vin__ActivityCancelInitType *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ActivityCancelInitType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__ActivityCancelInitType(struct soap *soap, const char *s, enum vin__ActivityCancelInitType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__ActivityCancelInitType, s);
	if (map)
		*a = (enum vin__ActivityCancelInitType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__ActivityCancelInitType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__ActivityCancelInitType * SOAP_FMAC4 soap_in_vin__ActivityCancelInitType(struct soap *soap, const char *tag, enum vin__ActivityCancelInitType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__ActivityCancelInitType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ActivityCancelInitType, sizeof(enum vin__ActivityCancelInitType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__ActivityCancelInitType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__ActivityCancelInitType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ActivityCancelInitType, 0, sizeof(enum vin__ActivityCancelInitType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__PaymentUpdateBehavior(struct soap *soap, enum vin__PaymentUpdateBehavior *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__PaymentUpdateBehavior
	*a = SOAP_DEFAULT_vin__PaymentUpdateBehavior;
#else
	*a = (enum vin__PaymentUpdateBehavior)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__PaymentUpdateBehavior(struct soap *soap, const enum vin__PaymentUpdateBehavior *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__PaymentUpdateBehavior);
	if (soap_out_vin__PaymentUpdateBehavior(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__PaymentUpdateBehavior[] =
{	{ (long)vin__PaymentUpdateBehavior__Update, "Update" },
	{ (long)vin__PaymentUpdateBehavior__Validate, "Validate" },
	{ (long)vin__PaymentUpdateBehavior__CatchUp, "CatchUp" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__PaymentUpdateBehavior2s(struct soap *soap, enum vin__PaymentUpdateBehavior n)
{	const char *s = soap_code_str(soap_codes_vin__PaymentUpdateBehavior, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__PaymentUpdateBehavior(struct soap *soap, const char *tag, int id, const enum vin__PaymentUpdateBehavior *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__PaymentUpdateBehavior), type) || soap_send(soap, soap_vin__PaymentUpdateBehavior2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__PaymentUpdateBehavior * SOAP_FMAC4 soap_get_vin__PaymentUpdateBehavior(struct soap *soap, enum vin__PaymentUpdateBehavior *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__PaymentUpdateBehavior(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__PaymentUpdateBehavior(struct soap *soap, const char *s, enum vin__PaymentUpdateBehavior *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__PaymentUpdateBehavior, s);
	if (map)
		*a = (enum vin__PaymentUpdateBehavior)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__PaymentUpdateBehavior)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__PaymentUpdateBehavior * SOAP_FMAC4 soap_in_vin__PaymentUpdateBehavior(struct soap *soap, const char *tag, enum vin__PaymentUpdateBehavior *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__PaymentUpdateBehavior *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__PaymentUpdateBehavior, sizeof(enum vin__PaymentUpdateBehavior), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__PaymentUpdateBehavior(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__PaymentUpdateBehavior *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__PaymentUpdateBehavior, 0, sizeof(enum vin__PaymentUpdateBehavior), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__EmailPreference(struct soap *soap, enum vin__EmailPreference *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_vin__EmailPreference
	*a = SOAP_DEFAULT_vin__EmailPreference;
#else
	*a = (enum vin__EmailPreference)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__EmailPreference(struct soap *soap, const enum vin__EmailPreference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__EmailPreference);
	if (soap_out_vin__EmailPreference(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_vin__EmailPreference[] =
{	{ (long)vin__EmailPreference__plaintext, "plaintext" },
	{ (long)vin__EmailPreference__html, "html" },
	{ (long)vin__EmailPreference__multipart, "multipart" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_vin__EmailPreference2s(struct soap *soap, enum vin__EmailPreference n)
{	const char *s = soap_code_str(soap_codes_vin__EmailPreference, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__EmailPreference(struct soap *soap, const char *tag, int id, const enum vin__EmailPreference *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__EmailPreference), type) || soap_send(soap, soap_vin__EmailPreference2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum vin__EmailPreference * SOAP_FMAC4 soap_get_vin__EmailPreference(struct soap *soap, enum vin__EmailPreference *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__EmailPreference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2vin__EmailPreference(struct soap *soap, const char *s, enum vin__EmailPreference *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_vin__EmailPreference, s);
	if (map)
		*a = (enum vin__EmailPreference)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum vin__EmailPreference)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum vin__EmailPreference * SOAP_FMAC4 soap_in_vin__EmailPreference(struct soap *soap, const char *tag, enum vin__EmailPreference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum vin__EmailPreference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__EmailPreference, sizeof(enum vin__EmailPreference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2vin__EmailPreference(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum vin__EmailPreference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__EmailPreference, 0, sizeof(enum vin__EmailPreference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__boolean(struct soap *soap, enum xsd__boolean *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (enum xsd__boolean)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (soap_out_xsd__boolean(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (long)xsd__boolean__false_, "false" },
	{ (long)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{	return soap_code_str(soap_codes_xsd__boolean, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, 0, sizeof(enum xsd__boolean), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__score(struct soap *soap, struct trn__score *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_transaction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__score(struct soap *soap, const struct trn__score *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Transaction(soap, &a->_transaction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__score(struct soap *soap, const struct trn__score *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__score);
	if (soap_out_trn__score(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__score(struct soap *soap, const char *tag, int id, const struct trn__score *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__score), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Transaction(soap, "transaction", -1, &a->_transaction, "vin:Transaction"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__score * SOAP_FMAC4 soap_get_trn__score(struct soap *soap, struct trn__score *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__score(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__score * SOAP_FMAC4 soap_in_trn__score(struct soap *soap, const char *tag, struct trn__score *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__transaction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__score *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__score, sizeof(struct trn__score), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__score(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__transaction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Transaction(soap, NULL, &a->_transaction, "vin:Transaction"))
				{	soap_flag__transaction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__score *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__score, 0, sizeof(struct trn__score), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__scoreResponse(struct soap *soap, struct trn__scoreResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_transaction = NULL;
	soap_default_int(soap, &a->_score);
	a->_scoreCodes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__scoreResponse(struct soap *soap, const struct trn__scoreResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Transaction(soap, &a->_transaction);
	soap_embedded(soap, &a->_score, SOAP_TYPE_int);
	soap_serialize_PointerToArrayOfScoreCodes(soap, &a->_scoreCodes);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__scoreResponse(struct soap *soap, const struct trn__scoreResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__scoreResponse);
	if (soap_out_trn__scoreResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__scoreResponse(struct soap *soap, const char *tag, int id, const struct trn__scoreResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__scoreResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Transaction(soap, "transaction", -1, &a->_transaction, "vin:Transaction"))
		return soap->error;
	if (soap_out_int(soap, "score", -1, &a->_score, "xsd:int"))
		return soap->error;
	if (soap_out_PointerToArrayOfScoreCodes(soap, "scoreCodes", -1, &a->_scoreCodes, "vin:ScoreCode"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__scoreResponse * SOAP_FMAC4 soap_get_trn__scoreResponse(struct soap *soap, struct trn__scoreResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__scoreResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__scoreResponse * SOAP_FMAC4 soap_in_trn__scoreResponse(struct soap *soap, const char *tag, struct trn__scoreResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__transaction = 1;
	size_t soap_flag__score = 1;
	size_t soap_flag__scoreCodes = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__scoreResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__scoreResponse, sizeof(struct trn__scoreResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__scoreResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__transaction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Transaction(soap, NULL, &a->_transaction, "vin:Transaction"))
				{	soap_flag__transaction--;
					continue;
				}
			if (soap_flag__score && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_score, "xsd:int"))
				{	soap_flag__score--;
					continue;
				}
			if (soap_flag__scoreCodes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfScoreCodes(soap, NULL, &a->_scoreCodes, "vin:ScoreCode"))
				{	soap_flag__scoreCodes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__scoreResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__scoreResponse, 0, sizeof(struct trn__scoreResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__score > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__report(struct soap *soap, struct trn__report *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_transactions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__report(struct soap *soap, const struct trn__report *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerToArrayOfTransactions(soap, &a->_transactions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__report(struct soap *soap, const struct trn__report *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__report);
	if (soap_out_trn__report(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__report(struct soap *soap, const char *tag, int id, const struct trn__report *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__report), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerToArrayOfTransactions(soap, "transactions", -1, &a->_transactions, "vin:Transaction"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__report * SOAP_FMAC4 soap_get_trn__report(struct soap *soap, struct trn__report *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__report(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__report * SOAP_FMAC4 soap_in_trn__report(struct soap *soap, const char *tag, struct trn__report *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__transactions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__report *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__report, sizeof(struct trn__report), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__report(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__transactions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTransactions(soap, NULL, &a->_transactions, "vin:Transaction"))
				{	soap_flag__transactions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__report *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__report, 0, sizeof(struct trn__report), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__reportResponse(struct soap *soap, struct trn__reportResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__reportResponse(struct soap *soap, const struct trn__reportResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__reportResponse(struct soap *soap, const struct trn__reportResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__reportResponse);
	if (soap_out_trn__reportResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__reportResponse(struct soap *soap, const char *tag, int id, const struct trn__reportResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__reportResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__reportResponse * SOAP_FMAC4 soap_get_trn__reportResponse(struct soap *soap, struct trn__reportResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__reportResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__reportResponse * SOAP_FMAC4 soap_in_trn__reportResponse(struct soap *soap, const char *tag, struct trn__reportResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__reportResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__reportResponse, sizeof(struct trn__reportResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__reportResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__reportResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__reportResponse, 0, sizeof(struct trn__reportResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__authCapture(struct soap *soap, struct trn__authCapture *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_transaction = NULL;
	soap_default_xsd__boolean(soap, &a->_sendEmailNotification);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__authCapture(struct soap *soap, const struct trn__authCapture *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Transaction(soap, &a->_transaction);
	soap_embedded(soap, &a->_sendEmailNotification, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__authCapture(struct soap *soap, const struct trn__authCapture *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__authCapture);
	if (soap_out_trn__authCapture(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__authCapture(struct soap *soap, const char *tag, int id, const struct trn__authCapture *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__authCapture), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Transaction(soap, "transaction", -1, &a->_transaction, "vin:Transaction"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "sendEmailNotification", -1, &a->_sendEmailNotification, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__authCapture * SOAP_FMAC4 soap_get_trn__authCapture(struct soap *soap, struct trn__authCapture *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__authCapture(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__authCapture * SOAP_FMAC4 soap_in_trn__authCapture(struct soap *soap, const char *tag, struct trn__authCapture *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__transaction = 1;
	size_t soap_flag__sendEmailNotification = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__authCapture *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__authCapture, sizeof(struct trn__authCapture), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__authCapture(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__transaction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Transaction(soap, NULL, &a->_transaction, "vin:Transaction"))
				{	soap_flag__transaction--;
					continue;
				}
			if (soap_flag__sendEmailNotification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_sendEmailNotification, "xsd:boolean"))
				{	soap_flag__sendEmailNotification--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__authCapture *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__authCapture, 0, sizeof(struct trn__authCapture), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__sendEmailNotification > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__authCaptureResponse(struct soap *soap, struct trn__authCaptureResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_transaction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__authCaptureResponse(struct soap *soap, const struct trn__authCaptureResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Transaction(soap, &a->_transaction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__authCaptureResponse(struct soap *soap, const struct trn__authCaptureResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__authCaptureResponse);
	if (soap_out_trn__authCaptureResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__authCaptureResponse(struct soap *soap, const char *tag, int id, const struct trn__authCaptureResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__authCaptureResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Transaction(soap, "transaction", -1, &a->_transaction, "vin:Transaction"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__authCaptureResponse * SOAP_FMAC4 soap_get_trn__authCaptureResponse(struct soap *soap, struct trn__authCaptureResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__authCaptureResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__authCaptureResponse * SOAP_FMAC4 soap_in_trn__authCaptureResponse(struct soap *soap, const char *tag, struct trn__authCaptureResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__transaction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__authCaptureResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__authCaptureResponse, sizeof(struct trn__authCaptureResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__authCaptureResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__transaction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Transaction(soap, NULL, &a->_transaction, "vin:Transaction"))
				{	soap_flag__transaction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__authCaptureResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__authCaptureResponse, 0, sizeof(struct trn__authCaptureResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__cancel(struct soap *soap, struct trn__cancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_transactions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__cancel(struct soap *soap, const struct trn__cancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerToArrayOfTransactions(soap, &a->_transactions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__cancel(struct soap *soap, const struct trn__cancel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__cancel);
	if (soap_out_trn__cancel(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__cancel(struct soap *soap, const char *tag, int id, const struct trn__cancel *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__cancel), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerToArrayOfTransactions(soap, "transactions", -1, &a->_transactions, "vin:Transaction"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__cancel * SOAP_FMAC4 soap_get_trn__cancel(struct soap *soap, struct trn__cancel *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__cancel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__cancel * SOAP_FMAC4 soap_in_trn__cancel(struct soap *soap, const char *tag, struct trn__cancel *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__transactions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__cancel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__cancel, sizeof(struct trn__cancel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__cancel(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__transactions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTransactions(soap, NULL, &a->_transactions, "vin:Transaction"))
				{	soap_flag__transactions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__cancel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__cancel, 0, sizeof(struct trn__cancel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__cancelResponse(struct soap *soap, struct trn__cancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	soap_default_int(soap, &a->_qtySuccess);
	soap_default_int(soap, &a->_qtyFail);
	a->_results = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__cancelResponse(struct soap *soap, const struct trn__cancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_embedded(soap, &a->_qtySuccess, SOAP_TYPE_int);
	soap_embedded(soap, &a->_qtyFail, SOAP_TYPE_int);
	soap_serialize_PointerToArrayOfCancelResults(soap, &a->_results);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__cancelResponse(struct soap *soap, const struct trn__cancelResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__cancelResponse);
	if (soap_out_trn__cancelResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__cancelResponse(struct soap *soap, const char *tag, int id, const struct trn__cancelResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__cancelResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_int(soap, "qtySuccess", -1, &a->_qtySuccess, "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "qtyFail", -1, &a->_qtyFail, "xsd:int"))
		return soap->error;
	if (soap_out_PointerToArrayOfCancelResults(soap, "results", -1, &a->_results, "vin:CancelResult"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__cancelResponse * SOAP_FMAC4 soap_get_trn__cancelResponse(struct soap *soap, struct trn__cancelResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__cancelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__cancelResponse * SOAP_FMAC4 soap_in_trn__cancelResponse(struct soap *soap, const char *tag, struct trn__cancelResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__qtySuccess = 1;
	size_t soap_flag__qtyFail = 1;
	size_t soap_flag__results = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__cancelResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__cancelResponse, sizeof(struct trn__cancelResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__cancelResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__qtySuccess && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_qtySuccess, "xsd:int"))
				{	soap_flag__qtySuccess--;
					continue;
				}
			if (soap_flag__qtyFail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_qtyFail, "xsd:int"))
				{	soap_flag__qtyFail--;
					continue;
				}
			if (soap_flag__results && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCancelResults(soap, NULL, &a->_results, "vin:CancelResult"))
				{	soap_flag__results--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__cancelResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__cancelResponse, 0, sizeof(struct trn__cancelResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__qtySuccess > 0 || soap_flag__qtyFail > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__capture(struct soap *soap, struct trn__capture *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_transactions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__capture(struct soap *soap, const struct trn__capture *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerToArrayOfTransactions(soap, &a->_transactions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__capture(struct soap *soap, const struct trn__capture *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__capture);
	if (soap_out_trn__capture(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__capture(struct soap *soap, const char *tag, int id, const struct trn__capture *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__capture), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerToArrayOfTransactions(soap, "transactions", -1, &a->_transactions, "vin:Transaction"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__capture * SOAP_FMAC4 soap_get_trn__capture(struct soap *soap, struct trn__capture *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__capture(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__capture * SOAP_FMAC4 soap_in_trn__capture(struct soap *soap, const char *tag, struct trn__capture *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__transactions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__capture *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__capture, sizeof(struct trn__capture), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__capture(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__transactions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTransactions(soap, NULL, &a->_transactions, "vin:Transaction"))
				{	soap_flag__transactions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__capture *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__capture, 0, sizeof(struct trn__capture), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__captureResponse(struct soap *soap, struct trn__captureResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	soap_default_int(soap, &a->_qtySuccess);
	soap_default_int(soap, &a->_qtyFail);
	a->_results = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__captureResponse(struct soap *soap, const struct trn__captureResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_embedded(soap, &a->_qtySuccess, SOAP_TYPE_int);
	soap_embedded(soap, &a->_qtyFail, SOAP_TYPE_int);
	soap_serialize_PointerToArrayOfCaptureResults(soap, &a->_results);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__captureResponse(struct soap *soap, const struct trn__captureResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__captureResponse);
	if (soap_out_trn__captureResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__captureResponse(struct soap *soap, const char *tag, int id, const struct trn__captureResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__captureResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_int(soap, "qtySuccess", -1, &a->_qtySuccess, "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "qtyFail", -1, &a->_qtyFail, "xsd:int"))
		return soap->error;
	if (soap_out_PointerToArrayOfCaptureResults(soap, "results", -1, &a->_results, "vin:CaptureResult"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__captureResponse * SOAP_FMAC4 soap_get_trn__captureResponse(struct soap *soap, struct trn__captureResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__captureResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__captureResponse * SOAP_FMAC4 soap_in_trn__captureResponse(struct soap *soap, const char *tag, struct trn__captureResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__qtySuccess = 1;
	size_t soap_flag__qtyFail = 1;
	size_t soap_flag__results = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__captureResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__captureResponse, sizeof(struct trn__captureResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__captureResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__qtySuccess && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_qtySuccess, "xsd:int"))
				{	soap_flag__qtySuccess--;
					continue;
				}
			if (soap_flag__qtyFail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_qtyFail, "xsd:int"))
				{	soap_flag__qtyFail--;
					continue;
				}
			if (soap_flag__results && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCaptureResults(soap, NULL, &a->_results, "vin:CaptureResult"))
				{	soap_flag__results--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__captureResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__captureResponse, 0, sizeof(struct trn__captureResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__qtySuccess > 0 || soap_flag__qtyFail > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__calculateSalesTax(struct soap *soap, struct trn__calculateSalesTax *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_transaction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__calculateSalesTax(struct soap *soap, const struct trn__calculateSalesTax *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Transaction(soap, &a->_transaction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__calculateSalesTax(struct soap *soap, const struct trn__calculateSalesTax *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__calculateSalesTax);
	if (soap_out_trn__calculateSalesTax(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__calculateSalesTax(struct soap *soap, const char *tag, int id, const struct trn__calculateSalesTax *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__calculateSalesTax), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Transaction(soap, "transaction", -1, &a->_transaction, "vin:Transaction"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__calculateSalesTax * SOAP_FMAC4 soap_get_trn__calculateSalesTax(struct soap *soap, struct trn__calculateSalesTax *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__calculateSalesTax(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__calculateSalesTax * SOAP_FMAC4 soap_in_trn__calculateSalesTax(struct soap *soap, const char *tag, struct trn__calculateSalesTax *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__transaction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__calculateSalesTax *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__calculateSalesTax, sizeof(struct trn__calculateSalesTax), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__calculateSalesTax(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__transaction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Transaction(soap, NULL, &a->_transaction, "vin:Transaction"))
				{	soap_flag__transaction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__calculateSalesTax *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__calculateSalesTax, 0, sizeof(struct trn__calculateSalesTax), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__calculateSalesTaxResponse(struct soap *soap, struct trn__calculateSalesTaxResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_transaction = NULL;
	soap_default_vin__AddressType(soap, &a->_addressType);
	a->_originalAddress = NULL;
	a->_correctedAddress = NULL;
	a->_taxItems = NULL;
	soap_default_xsd__decimal(soap, &a->_totalTax);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__calculateSalesTaxResponse(struct soap *soap, const struct trn__calculateSalesTaxResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Transaction(soap, &a->_transaction);
	soap_serialize_PointerTovin__Address(soap, &a->_originalAddress);
	soap_serialize_PointerTovin__Address(soap, &a->_correctedAddress);
	soap_serialize_PointerToArrayOfSalesTaxes(soap, &a->_taxItems);
	soap_serialize_xsd__decimal(soap, &a->_totalTax);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__calculateSalesTaxResponse(struct soap *soap, const struct trn__calculateSalesTaxResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__calculateSalesTaxResponse);
	if (soap_out_trn__calculateSalesTaxResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__calculateSalesTaxResponse(struct soap *soap, const char *tag, int id, const struct trn__calculateSalesTaxResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__calculateSalesTaxResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Transaction(soap, "transaction", -1, &a->_transaction, "vin:Transaction"))
		return soap->error;
	if (soap_out_vin__AddressType(soap, "addressType", -1, &a->_addressType, "vin:AddressType"))
		return soap->error;
	if (soap_out_PointerTovin__Address(soap, "originalAddress", -1, &a->_originalAddress, "vin:Address"))
		return soap->error;
	if (soap_out_PointerTovin__Address(soap, "correctedAddress", -1, &a->_correctedAddress, "vin:Address"))
		return soap->error;
	if (soap_out_PointerToArrayOfSalesTaxes(soap, "taxItems", -1, &a->_taxItems, "vin:SalesTax"))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "totalTax", -1, &a->_totalTax, "xsd:decimal"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__calculateSalesTaxResponse * SOAP_FMAC4 soap_get_trn__calculateSalesTaxResponse(struct soap *soap, struct trn__calculateSalesTaxResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__calculateSalesTaxResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__calculateSalesTaxResponse * SOAP_FMAC4 soap_in_trn__calculateSalesTaxResponse(struct soap *soap, const char *tag, struct trn__calculateSalesTaxResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__transaction = 1;
	size_t soap_flag__addressType = 1;
	size_t soap_flag__originalAddress = 1;
	size_t soap_flag__correctedAddress = 1;
	size_t soap_flag__taxItems = 1;
	size_t soap_flag__totalTax = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__calculateSalesTaxResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__calculateSalesTaxResponse, sizeof(struct trn__calculateSalesTaxResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__calculateSalesTaxResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__transaction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Transaction(soap, NULL, &a->_transaction, "vin:Transaction"))
				{	soap_flag__transaction--;
					continue;
				}
			if (soap_flag__addressType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_vin__AddressType(soap, NULL, &a->_addressType, "vin:AddressType"))
				{	soap_flag__addressType--;
					continue;
				}
			if (soap_flag__originalAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Address(soap, NULL, &a->_originalAddress, "vin:Address"))
				{	soap_flag__originalAddress--;
					continue;
				}
			if (soap_flag__correctedAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Address(soap, NULL, &a->_correctedAddress, "vin:Address"))
				{	soap_flag__correctedAddress--;
					continue;
				}
			if (soap_flag__taxItems && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfSalesTaxes(soap, NULL, &a->_taxItems, "vin:SalesTax"))
				{	soap_flag__taxItems--;
					continue;
				}
			if (soap_flag__totalTax && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, NULL, &a->_totalTax, "xsd:decimal"))
				{	soap_flag__totalTax--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__calculateSalesTaxResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__calculateSalesTaxResponse, 0, sizeof(struct trn__calculateSalesTaxResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__addressType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__auth(struct soap *soap, struct trn__auth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_transaction = NULL;
	soap_default_int(soap, &a->_minChargebackProbability);
	soap_default_xsd__boolean(soap, &a->_sendEmailNotification);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__auth(struct soap *soap, const struct trn__auth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Transaction(soap, &a->_transaction);
	soap_embedded(soap, &a->_minChargebackProbability, SOAP_TYPE_int);
	soap_embedded(soap, &a->_sendEmailNotification, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__auth(struct soap *soap, const struct trn__auth *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__auth);
	if (soap_out_trn__auth(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__auth(struct soap *soap, const char *tag, int id, const struct trn__auth *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__auth), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Transaction(soap, "transaction", -1, &a->_transaction, "vin:Transaction"))
		return soap->error;
	if (soap_out_int(soap, "minChargebackProbability", -1, &a->_minChargebackProbability, "xsd:int"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "sendEmailNotification", -1, &a->_sendEmailNotification, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__auth * SOAP_FMAC4 soap_get_trn__auth(struct soap *soap, struct trn__auth *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__auth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__auth * SOAP_FMAC4 soap_in_trn__auth(struct soap *soap, const char *tag, struct trn__auth *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__transaction = 1;
	size_t soap_flag__minChargebackProbability = 1;
	size_t soap_flag__sendEmailNotification = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__auth *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__auth, sizeof(struct trn__auth), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__auth(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__transaction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Transaction(soap, NULL, &a->_transaction, "vin:Transaction"))
				{	soap_flag__transaction--;
					continue;
				}
			if (soap_flag__minChargebackProbability && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_minChargebackProbability, "xsd:int"))
				{	soap_flag__minChargebackProbability--;
					continue;
				}
			if (soap_flag__sendEmailNotification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_sendEmailNotification, "xsd:boolean"))
				{	soap_flag__sendEmailNotification--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__auth *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__auth, 0, sizeof(struct trn__auth), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__minChargebackProbability > 0 || soap_flag__sendEmailNotification > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__authResponse(struct soap *soap, struct trn__authResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_transaction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__authResponse(struct soap *soap, const struct trn__authResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Transaction(soap, &a->_transaction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__authResponse(struct soap *soap, const struct trn__authResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__authResponse);
	if (soap_out_trn__authResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__authResponse(struct soap *soap, const char *tag, int id, const struct trn__authResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__authResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Transaction(soap, "transaction", -1, &a->_transaction, "vin:Transaction"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__authResponse * SOAP_FMAC4 soap_get_trn__authResponse(struct soap *soap, struct trn__authResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__authResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__authResponse * SOAP_FMAC4 soap_in_trn__authResponse(struct soap *soap, const char *tag, struct trn__authResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__transaction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__authResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__authResponse, sizeof(struct trn__authResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__authResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__transaction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Transaction(soap, NULL, &a->_transaction, "vin:Transaction"))
				{	soap_flag__transaction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__authResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__authResponse, 0, sizeof(struct trn__authResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__fetchByPaymentMethod(struct soap *soap, struct trn__fetchByPaymentMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_paymentMethod = NULL;
	soap_default_int(soap, &a->_page);
	soap_default_int(soap, &a->_pageSize);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__fetchByPaymentMethod(struct soap *soap, const struct trn__fetchByPaymentMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__PaymentMethod(soap, &a->_paymentMethod);
	soap_embedded(soap, &a->_page, SOAP_TYPE_int);
	soap_embedded(soap, &a->_pageSize, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__fetchByPaymentMethod(struct soap *soap, const struct trn__fetchByPaymentMethod *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__fetchByPaymentMethod);
	if (soap_out_trn__fetchByPaymentMethod(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__fetchByPaymentMethod(struct soap *soap, const char *tag, int id, const struct trn__fetchByPaymentMethod *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__fetchByPaymentMethod), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentMethod(soap, "paymentMethod", -1, &a->_paymentMethod, "vin:PaymentMethod"))
		return soap->error;
	if (soap_out_int(soap, "page", -1, &a->_page, "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "pageSize", -1, &a->_pageSize, "xsd:int"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__fetchByPaymentMethod * SOAP_FMAC4 soap_get_trn__fetchByPaymentMethod(struct soap *soap, struct trn__fetchByPaymentMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__fetchByPaymentMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchByPaymentMethod * SOAP_FMAC4 soap_in_trn__fetchByPaymentMethod(struct soap *soap, const char *tag, struct trn__fetchByPaymentMethod *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__paymentMethod = 1;
	size_t soap_flag__page = 1;
	size_t soap_flag__pageSize = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__fetchByPaymentMethod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__fetchByPaymentMethod, sizeof(struct trn__fetchByPaymentMethod), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__fetchByPaymentMethod(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__paymentMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentMethod(soap, NULL, &a->_paymentMethod, "vin:PaymentMethod"))
				{	soap_flag__paymentMethod--;
					continue;
				}
			if (soap_flag__page && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_page, "xsd:int"))
				{	soap_flag__page--;
					continue;
				}
			if (soap_flag__pageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_pageSize, "xsd:int"))
				{	soap_flag__pageSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__fetchByPaymentMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__fetchByPaymentMethod, 0, sizeof(struct trn__fetchByPaymentMethod), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__page > 0 || soap_flag__pageSize > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__fetchByPaymentMethodResponse(struct soap *soap, struct trn__fetchByPaymentMethodResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_transactions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__fetchByPaymentMethodResponse(struct soap *soap, const struct trn__fetchByPaymentMethodResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfTransactions(soap, &a->_transactions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__fetchByPaymentMethodResponse(struct soap *soap, const struct trn__fetchByPaymentMethodResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__fetchByPaymentMethodResponse);
	if (soap_out_trn__fetchByPaymentMethodResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__fetchByPaymentMethodResponse(struct soap *soap, const char *tag, int id, const struct trn__fetchByPaymentMethodResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__fetchByPaymentMethodResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfTransactions(soap, "transactions", -1, &a->_transactions, "vin:Transaction"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__fetchByPaymentMethodResponse * SOAP_FMAC4 soap_get_trn__fetchByPaymentMethodResponse(struct soap *soap, struct trn__fetchByPaymentMethodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__fetchByPaymentMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchByPaymentMethodResponse * SOAP_FMAC4 soap_in_trn__fetchByPaymentMethodResponse(struct soap *soap, const char *tag, struct trn__fetchByPaymentMethodResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__transactions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__fetchByPaymentMethodResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__fetchByPaymentMethodResponse, sizeof(struct trn__fetchByPaymentMethodResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__fetchByPaymentMethodResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__transactions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTransactions(soap, NULL, &a->_transactions, "vin:Transaction"))
				{	soap_flag__transactions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__fetchByPaymentMethodResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__fetchByPaymentMethodResponse, 0, sizeof(struct trn__fetchByPaymentMethodResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__fetchSearchPage(struct soap *soap, struct trn__fetchSearchPage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_VID);
	soap_default_int(soap, &a->_objectsPerPage);
	soap_default_int(soap, &a->_pageNumber);
	a->_nameValues = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__fetchSearchPage(struct soap *soap, const struct trn__fetchSearchPage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_VID);
	soap_embedded(soap, &a->_objectsPerPage, SOAP_TYPE_int);
	soap_embedded(soap, &a->_pageNumber, SOAP_TYPE_int);
	soap_serialize_PointerToArrayOfNameValuePairs(soap, &a->_nameValues);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__fetchSearchPage(struct soap *soap, const struct trn__fetchSearchPage *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__fetchSearchPage);
	if (soap_out_trn__fetchSearchPage(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__fetchSearchPage(struct soap *soap, const char *tag, int id, const struct trn__fetchSearchPage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__fetchSearchPage), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "VID", -1, &a->_VID, "xsd:string"))
		return soap->error;
	if (soap_out_int(soap, "objectsPerPage", -1, &a->_objectsPerPage, "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "pageNumber", -1, &a->_pageNumber, "xsd:int"))
		return soap->error;
	if (soap_out_PointerToArrayOfNameValuePairs(soap, "nameValues", -1, &a->_nameValues, "vin:NameValuePair"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__fetchSearchPage * SOAP_FMAC4 soap_get_trn__fetchSearchPage(struct soap *soap, struct trn__fetchSearchPage *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__fetchSearchPage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchSearchPage * SOAP_FMAC4 soap_in_trn__fetchSearchPage(struct soap *soap, const char *tag, struct trn__fetchSearchPage *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__VID = 1;
	size_t soap_flag__objectsPerPage = 1;
	size_t soap_flag__pageNumber = 1;
	size_t soap_flag__nameValues = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__fetchSearchPage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__fetchSearchPage, sizeof(struct trn__fetchSearchPage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__fetchSearchPage(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__VID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_VID, "xsd:string"))
				{	soap_flag__VID--;
					continue;
				}
			if (soap_flag__objectsPerPage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_objectsPerPage, "xsd:int"))
				{	soap_flag__objectsPerPage--;
					continue;
				}
			if (soap_flag__pageNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_pageNumber, "xsd:int"))
				{	soap_flag__pageNumber--;
					continue;
				}
			if (soap_flag__nameValues && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfNameValuePairs(soap, NULL, &a->_nameValues, "vin:NameValuePair"))
				{	soap_flag__nameValues--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__fetchSearchPage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__fetchSearchPage, 0, sizeof(struct trn__fetchSearchPage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__objectsPerPage > 0 || soap_flag__pageNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__fetchSearchPageResponse(struct soap *soap, struct trn__fetchSearchPageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_transactions = NULL;
	soap_default_int(soap, &a->_objectsPerPage);
	soap_default_int(soap, &a->_pageNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__fetchSearchPageResponse(struct soap *soap, const struct trn__fetchSearchPageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfTransactions(soap, &a->_transactions);
	soap_embedded(soap, &a->_objectsPerPage, SOAP_TYPE_int);
	soap_embedded(soap, &a->_pageNumber, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__fetchSearchPageResponse(struct soap *soap, const struct trn__fetchSearchPageResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__fetchSearchPageResponse);
	if (soap_out_trn__fetchSearchPageResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__fetchSearchPageResponse(struct soap *soap, const char *tag, int id, const struct trn__fetchSearchPageResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__fetchSearchPageResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfTransactions(soap, "transactions", -1, &a->_transactions, "vin:Transaction"))
		return soap->error;
	if (soap_out_int(soap, "objectsPerPage", -1, &a->_objectsPerPage, "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "pageNumber", -1, &a->_pageNumber, "xsd:int"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__fetchSearchPageResponse * SOAP_FMAC4 soap_get_trn__fetchSearchPageResponse(struct soap *soap, struct trn__fetchSearchPageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__fetchSearchPageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchSearchPageResponse * SOAP_FMAC4 soap_in_trn__fetchSearchPageResponse(struct soap *soap, const char *tag, struct trn__fetchSearchPageResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__transactions = 1;
	size_t soap_flag__objectsPerPage = 1;
	size_t soap_flag__pageNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__fetchSearchPageResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__fetchSearchPageResponse, sizeof(struct trn__fetchSearchPageResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__fetchSearchPageResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__transactions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTransactions(soap, NULL, &a->_transactions, "vin:Transaction"))
				{	soap_flag__transactions--;
					continue;
				}
			if (soap_flag__objectsPerPage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_objectsPerPage, "xsd:int"))
				{	soap_flag__objectsPerPage--;
					continue;
				}
			if (soap_flag__pageNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_pageNumber, "xsd:int"))
				{	soap_flag__pageNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__fetchSearchPageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__fetchSearchPageResponse, 0, sizeof(struct trn__fetchSearchPageResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__objectsPerPage > 0 || soap_flag__pageNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__fetchByAutobill(struct soap *soap, struct trn__fetchByAutobill *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_autobill = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__fetchByAutobill(struct soap *soap, const struct trn__fetchByAutobill *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__AutoBill(soap, &a->_autobill);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__fetchByAutobill(struct soap *soap, const struct trn__fetchByAutobill *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__fetchByAutobill);
	if (soap_out_trn__fetchByAutobill(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__fetchByAutobill(struct soap *soap, const char *tag, int id, const struct trn__fetchByAutobill *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__fetchByAutobill), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__AutoBill(soap, "autobill", -1, &a->_autobill, "vin:AutoBill"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__fetchByAutobill * SOAP_FMAC4 soap_get_trn__fetchByAutobill(struct soap *soap, struct trn__fetchByAutobill *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__fetchByAutobill(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchByAutobill * SOAP_FMAC4 soap_in_trn__fetchByAutobill(struct soap *soap, const char *tag, struct trn__fetchByAutobill *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__autobill = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__fetchByAutobill *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__fetchByAutobill, sizeof(struct trn__fetchByAutobill), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__fetchByAutobill(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__autobill && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__AutoBill(soap, NULL, &a->_autobill, "vin:AutoBill"))
				{	soap_flag__autobill--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__fetchByAutobill *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__fetchByAutobill, 0, sizeof(struct trn__fetchByAutobill), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__fetchByAutobillResponse(struct soap *soap, struct trn__fetchByAutobillResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_transactions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__fetchByAutobillResponse(struct soap *soap, const struct trn__fetchByAutobillResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfTransactions(soap, &a->_transactions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__fetchByAutobillResponse(struct soap *soap, const struct trn__fetchByAutobillResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__fetchByAutobillResponse);
	if (soap_out_trn__fetchByAutobillResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__fetchByAutobillResponse(struct soap *soap, const char *tag, int id, const struct trn__fetchByAutobillResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__fetchByAutobillResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfTransactions(soap, "transactions", -1, &a->_transactions, "vin:Transaction"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__fetchByAutobillResponse * SOAP_FMAC4 soap_get_trn__fetchByAutobillResponse(struct soap *soap, struct trn__fetchByAutobillResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__fetchByAutobillResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchByAutobillResponse * SOAP_FMAC4 soap_in_trn__fetchByAutobillResponse(struct soap *soap, const char *tag, struct trn__fetchByAutobillResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__transactions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__fetchByAutobillResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__fetchByAutobillResponse, sizeof(struct trn__fetchByAutobillResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__fetchByAutobillResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__transactions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTransactions(soap, NULL, &a->_transactions, "vin:Transaction"))
				{	soap_flag__transactions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__fetchByAutobillResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__fetchByAutobillResponse, 0, sizeof(struct trn__fetchByAutobillResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__fetchDelta(struct soap *soap, struct trn__fetchDelta *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_int(soap, &a->_pageSize);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__fetchDelta(struct soap *soap, const struct trn__fetchDelta *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_embedded(soap, &a->_pageSize, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__fetchDelta(struct soap *soap, const struct trn__fetchDelta *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__fetchDelta);
	if (soap_out_trn__fetchDelta(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__fetchDelta(struct soap *soap, const char *tag, int id, const struct trn__fetchDelta *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__fetchDelta), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_int(soap, "pageSize", -1, &a->_pageSize, "xsd:int"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__fetchDelta * SOAP_FMAC4 soap_get_trn__fetchDelta(struct soap *soap, struct trn__fetchDelta *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__fetchDelta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchDelta * SOAP_FMAC4 soap_in_trn__fetchDelta(struct soap *soap, const char *tag, struct trn__fetchDelta *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__pageSize = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__fetchDelta *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__fetchDelta, sizeof(struct trn__fetchDelta), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__fetchDelta(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__pageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_pageSize, "xsd:int"))
				{	soap_flag__pageSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__fetchDelta *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__fetchDelta, 0, sizeof(struct trn__fetchDelta), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__pageSize > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__fetchDeltaResponse(struct soap *soap, struct trn__fetchDeltaResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_transactions = NULL;
	soap_default_time(soap, &a->_startDate);
	soap_default_time(soap, &a->_endDate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__fetchDeltaResponse(struct soap *soap, const struct trn__fetchDeltaResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfTransactions(soap, &a->_transactions);
	soap_embedded(soap, &a->_startDate, SOAP_TYPE_time);
	soap_embedded(soap, &a->_endDate, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__fetchDeltaResponse(struct soap *soap, const struct trn__fetchDeltaResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__fetchDeltaResponse);
	if (soap_out_trn__fetchDeltaResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__fetchDeltaResponse(struct soap *soap, const char *tag, int id, const struct trn__fetchDeltaResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__fetchDeltaResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfTransactions(soap, "transactions", -1, &a->_transactions, "vin:Transaction"))
		return soap->error;
	if (soap_out_time(soap, "startDate", -1, &a->_startDate, "xsd:dateTime"))
		return soap->error;
	if (soap_out_time(soap, "endDate", -1, &a->_endDate, "xsd:dateTime"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__fetchDeltaResponse * SOAP_FMAC4 soap_get_trn__fetchDeltaResponse(struct soap *soap, struct trn__fetchDeltaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__fetchDeltaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchDeltaResponse * SOAP_FMAC4 soap_in_trn__fetchDeltaResponse(struct soap *soap, const char *tag, struct trn__fetchDeltaResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__transactions = 1;
	size_t soap_flag__startDate = 1;
	size_t soap_flag__endDate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__fetchDeltaResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__fetchDeltaResponse, sizeof(struct trn__fetchDeltaResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__fetchDeltaResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__transactions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTransactions(soap, NULL, &a->_transactions, "vin:Transaction"))
				{	soap_flag__transactions--;
					continue;
				}
			if (soap_flag__startDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_startDate, "xsd:dateTime"))
				{	soap_flag__startDate--;
					continue;
				}
			if (soap_flag__endDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_endDate, "xsd:dateTime"))
				{	soap_flag__endDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__fetchDeltaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__fetchDeltaResponse, 0, sizeof(struct trn__fetchDeltaResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__startDate > 0 || soap_flag__endDate > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__fetchDeltaSince(struct soap *soap, struct trn__fetchDeltaSince *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_time(soap, &a->_timestamp);
	soap_default_time(soap, &a->_endTimestamp);
	soap_default_int(soap, &a->_page);
	soap_default_int(soap, &a->_pageSize);
	a->_paymentMethod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__fetchDeltaSince(struct soap *soap, const struct trn__fetchDeltaSince *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_embedded(soap, &a->_timestamp, SOAP_TYPE_time);
	soap_embedded(soap, &a->_endTimestamp, SOAP_TYPE_time);
	soap_embedded(soap, &a->_page, SOAP_TYPE_int);
	soap_embedded(soap, &a->_pageSize, SOAP_TYPE_int);
	soap_serialize_PointerTovin__PaymentMethod(soap, &a->_paymentMethod);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__fetchDeltaSince(struct soap *soap, const struct trn__fetchDeltaSince *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__fetchDeltaSince);
	if (soap_out_trn__fetchDeltaSince(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__fetchDeltaSince(struct soap *soap, const char *tag, int id, const struct trn__fetchDeltaSince *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__fetchDeltaSince), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_time(soap, "timestamp", -1, &a->_timestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_time(soap, "endTimestamp", -1, &a->_endTimestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_int(soap, "page", -1, &a->_page, "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "pageSize", -1, &a->_pageSize, "xsd:int"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentMethod(soap, "paymentMethod", -1, &a->_paymentMethod, "vin:PaymentMethod"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__fetchDeltaSince * SOAP_FMAC4 soap_get_trn__fetchDeltaSince(struct soap *soap, struct trn__fetchDeltaSince *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__fetchDeltaSince(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchDeltaSince * SOAP_FMAC4 soap_in_trn__fetchDeltaSince(struct soap *soap, const char *tag, struct trn__fetchDeltaSince *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__timestamp = 1;
	size_t soap_flag__endTimestamp = 1;
	size_t soap_flag__page = 1;
	size_t soap_flag__pageSize = 1;
	size_t soap_flag__paymentMethod = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__fetchDeltaSince *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__fetchDeltaSince, sizeof(struct trn__fetchDeltaSince), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__fetchDeltaSince(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_timestamp, "xsd:dateTime"))
				{	soap_flag__timestamp--;
					continue;
				}
			if (soap_flag__endTimestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_endTimestamp, "xsd:dateTime"))
				{	soap_flag__endTimestamp--;
					continue;
				}
			if (soap_flag__page && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_page, "xsd:int"))
				{	soap_flag__page--;
					continue;
				}
			if (soap_flag__pageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_pageSize, "xsd:int"))
				{	soap_flag__pageSize--;
					continue;
				}
			if (soap_flag__paymentMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentMethod(soap, NULL, &a->_paymentMethod, "vin:PaymentMethod"))
				{	soap_flag__paymentMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__fetchDeltaSince *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__fetchDeltaSince, 0, sizeof(struct trn__fetchDeltaSince), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__timestamp > 0 || soap_flag__endTimestamp > 0 || soap_flag__page > 0 || soap_flag__pageSize > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__fetchDeltaSinceResponse(struct soap *soap, struct trn__fetchDeltaSinceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_transactions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__fetchDeltaSinceResponse(struct soap *soap, const struct trn__fetchDeltaSinceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfTransactions(soap, &a->_transactions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__fetchDeltaSinceResponse(struct soap *soap, const struct trn__fetchDeltaSinceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__fetchDeltaSinceResponse);
	if (soap_out_trn__fetchDeltaSinceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__fetchDeltaSinceResponse(struct soap *soap, const char *tag, int id, const struct trn__fetchDeltaSinceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__fetchDeltaSinceResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfTransactions(soap, "transactions", -1, &a->_transactions, "vin:Transaction"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__fetchDeltaSinceResponse * SOAP_FMAC4 soap_get_trn__fetchDeltaSinceResponse(struct soap *soap, struct trn__fetchDeltaSinceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__fetchDeltaSinceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchDeltaSinceResponse * SOAP_FMAC4 soap_in_trn__fetchDeltaSinceResponse(struct soap *soap, const char *tag, struct trn__fetchDeltaSinceResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__transactions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__fetchDeltaSinceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__fetchDeltaSinceResponse, sizeof(struct trn__fetchDeltaSinceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__fetchDeltaSinceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__transactions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTransactions(soap, NULL, &a->_transactions, "vin:Transaction"))
				{	soap_flag__transactions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__fetchDeltaSinceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__fetchDeltaSinceResponse, 0, sizeof(struct trn__fetchDeltaSinceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__fetchByMerchantTransactionId(struct soap *soap, struct trn__fetchByMerchantTransactionId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_merchantTransactionId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__fetchByMerchantTransactionId(struct soap *soap, const struct trn__fetchByMerchantTransactionId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_merchantTransactionId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__fetchByMerchantTransactionId(struct soap *soap, const struct trn__fetchByMerchantTransactionId *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__fetchByMerchantTransactionId);
	if (soap_out_trn__fetchByMerchantTransactionId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__fetchByMerchantTransactionId(struct soap *soap, const char *tag, int id, const struct trn__fetchByMerchantTransactionId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__fetchByMerchantTransactionId), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "merchantTransactionId", -1, &a->_merchantTransactionId, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__fetchByMerchantTransactionId * SOAP_FMAC4 soap_get_trn__fetchByMerchantTransactionId(struct soap *soap, struct trn__fetchByMerchantTransactionId *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__fetchByMerchantTransactionId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchByMerchantTransactionId * SOAP_FMAC4 soap_in_trn__fetchByMerchantTransactionId(struct soap *soap, const char *tag, struct trn__fetchByMerchantTransactionId *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__merchantTransactionId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__fetchByMerchantTransactionId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__fetchByMerchantTransactionId, sizeof(struct trn__fetchByMerchantTransactionId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__fetchByMerchantTransactionId(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__merchantTransactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_merchantTransactionId, "xsd:string"))
				{	soap_flag__merchantTransactionId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__fetchByMerchantTransactionId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__fetchByMerchantTransactionId, 0, sizeof(struct trn__fetchByMerchantTransactionId), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__fetchByMerchantTransactionIdResponse(struct soap *soap, struct trn__fetchByMerchantTransactionIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_transaction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__fetchByMerchantTransactionIdResponse(struct soap *soap, const struct trn__fetchByMerchantTransactionIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Transaction(soap, &a->_transaction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__fetchByMerchantTransactionIdResponse(struct soap *soap, const struct trn__fetchByMerchantTransactionIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__fetchByMerchantTransactionIdResponse);
	if (soap_out_trn__fetchByMerchantTransactionIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__fetchByMerchantTransactionIdResponse(struct soap *soap, const char *tag, int id, const struct trn__fetchByMerchantTransactionIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__fetchByMerchantTransactionIdResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Transaction(soap, "transaction", -1, &a->_transaction, "vin:Transaction"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__fetchByMerchantTransactionIdResponse * SOAP_FMAC4 soap_get_trn__fetchByMerchantTransactionIdResponse(struct soap *soap, struct trn__fetchByMerchantTransactionIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__fetchByMerchantTransactionIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchByMerchantTransactionIdResponse * SOAP_FMAC4 soap_in_trn__fetchByMerchantTransactionIdResponse(struct soap *soap, const char *tag, struct trn__fetchByMerchantTransactionIdResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__transaction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__fetchByMerchantTransactionIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__fetchByMerchantTransactionIdResponse, sizeof(struct trn__fetchByMerchantTransactionIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__fetchByMerchantTransactionIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__transaction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Transaction(soap, NULL, &a->_transaction, "vin:Transaction"))
				{	soap_flag__transaction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__fetchByMerchantTransactionIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__fetchByMerchantTransactionIdResponse, 0, sizeof(struct trn__fetchByMerchantTransactionIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__fetchByAccount(struct soap *soap, struct trn__fetchByAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_account = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__fetchByAccount(struct soap *soap, const struct trn__fetchByAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__fetchByAccount(struct soap *soap, const struct trn__fetchByAccount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__fetchByAccount);
	if (soap_out_trn__fetchByAccount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__fetchByAccount(struct soap *soap, const char *tag, int id, const struct trn__fetchByAccount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__fetchByAccount), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__fetchByAccount * SOAP_FMAC4 soap_get_trn__fetchByAccount(struct soap *soap, struct trn__fetchByAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__fetchByAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchByAccount * SOAP_FMAC4 soap_in_trn__fetchByAccount(struct soap *soap, const char *tag, struct trn__fetchByAccount *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__account = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__fetchByAccount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__fetchByAccount, sizeof(struct trn__fetchByAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__fetchByAccount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__fetchByAccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__fetchByAccount, 0, sizeof(struct trn__fetchByAccount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__fetchByAccountResponse(struct soap *soap, struct trn__fetchByAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_transactions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__fetchByAccountResponse(struct soap *soap, const struct trn__fetchByAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfTransactions(soap, &a->_transactions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__fetchByAccountResponse(struct soap *soap, const struct trn__fetchByAccountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__fetchByAccountResponse);
	if (soap_out_trn__fetchByAccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__fetchByAccountResponse(struct soap *soap, const char *tag, int id, const struct trn__fetchByAccountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__fetchByAccountResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfTransactions(soap, "transactions", -1, &a->_transactions, "vin:Transaction"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__fetchByAccountResponse * SOAP_FMAC4 soap_get_trn__fetchByAccountResponse(struct soap *soap, struct trn__fetchByAccountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__fetchByAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchByAccountResponse * SOAP_FMAC4 soap_in_trn__fetchByAccountResponse(struct soap *soap, const char *tag, struct trn__fetchByAccountResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__transactions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__fetchByAccountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__fetchByAccountResponse, sizeof(struct trn__fetchByAccountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__fetchByAccountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__transactions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTransactions(soap, NULL, &a->_transactions, "vin:Transaction"))
				{	soap_flag__transactions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__fetchByAccountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__fetchByAccountResponse, 0, sizeof(struct trn__fetchByAccountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__fetchByVid(struct soap *soap, struct trn__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_vid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__fetchByVid(struct soap *soap, const struct trn__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_vid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__fetchByVid(struct soap *soap, const struct trn__fetchByVid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__fetchByVid);
	if (soap_out_trn__fetchByVid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__fetchByVid(struct soap *soap, const char *tag, int id, const struct trn__fetchByVid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__fetchByVid), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "vid", -1, &a->_vid, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__fetchByVid * SOAP_FMAC4 soap_get_trn__fetchByVid(struct soap *soap, struct trn__fetchByVid *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__fetchByVid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchByVid * SOAP_FMAC4 soap_in_trn__fetchByVid(struct soap *soap, const char *tag, struct trn__fetchByVid *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__vid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__fetchByVid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__fetchByVid, sizeof(struct trn__fetchByVid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__fetchByVid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__vid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_vid, "xsd:string"))
				{	soap_flag__vid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__fetchByVid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__fetchByVid, 0, sizeof(struct trn__fetchByVid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trn__fetchByVidResponse(struct soap *soap, struct trn__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_transaction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trn__fetchByVidResponse(struct soap *soap, const struct trn__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Transaction(soap, &a->_transaction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trn__fetchByVidResponse(struct soap *soap, const struct trn__fetchByVidResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trn__fetchByVidResponse);
	if (soap_out_trn__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trn__fetchByVidResponse(struct soap *soap, const char *tag, int id, const struct trn__fetchByVidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trn__fetchByVidResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Transaction(soap, "transaction", -1, &a->_transaction, "vin:Transaction"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trn__fetchByVidResponse * SOAP_FMAC4 soap_get_trn__fetchByVidResponse(struct soap *soap, struct trn__fetchByVidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_trn__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchByVidResponse * SOAP_FMAC4 soap_in_trn__fetchByVidResponse(struct soap *soap, const char *tag, struct trn__fetchByVidResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__transaction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trn__fetchByVidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trn__fetchByVidResponse, sizeof(struct trn__fetchByVidResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trn__fetchByVidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__transaction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Transaction(soap, NULL, &a->_transaction, "vin:Transaction"))
				{	soap_flag__transaction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trn__fetchByVidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trn__fetchByVidResponse, 0, sizeof(struct trn__fetchByVidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rfd__perform(struct soap *soap, struct rfd__perform *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_refunds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rfd__perform(struct soap *soap, const struct rfd__perform *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerToArrayOfRefunds(soap, &a->_refunds);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rfd__perform(struct soap *soap, const struct rfd__perform *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rfd__perform);
	if (soap_out_rfd__perform(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rfd__perform(struct soap *soap, const char *tag, int id, const struct rfd__perform *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rfd__perform), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerToArrayOfRefunds(soap, "refunds", -1, &a->_refunds, "vin:Refund"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rfd__perform * SOAP_FMAC4 soap_get_rfd__perform(struct soap *soap, struct rfd__perform *p, const char *tag, const char *type)
{
	if ((p = soap_in_rfd__perform(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__perform * SOAP_FMAC4 soap_in_rfd__perform(struct soap *soap, const char *tag, struct rfd__perform *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__refunds = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rfd__perform *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rfd__perform, sizeof(struct rfd__perform), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_rfd__perform(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__refunds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfRefunds(soap, NULL, &a->_refunds, "vin:Refund"))
				{	soap_flag__refunds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rfd__perform *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rfd__perform, 0, sizeof(struct rfd__perform), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rfd__performResponse(struct soap *soap, struct rfd__performResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_refunds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rfd__performResponse(struct soap *soap, const struct rfd__performResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfRefunds(soap, &a->_refunds);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rfd__performResponse(struct soap *soap, const struct rfd__performResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rfd__performResponse);
	if (soap_out_rfd__performResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rfd__performResponse(struct soap *soap, const char *tag, int id, const struct rfd__performResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rfd__performResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfRefunds(soap, "refunds", -1, &a->_refunds, "vin:Refund"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rfd__performResponse * SOAP_FMAC4 soap_get_rfd__performResponse(struct soap *soap, struct rfd__performResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rfd__performResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__performResponse * SOAP_FMAC4 soap_in_rfd__performResponse(struct soap *soap, const char *tag, struct rfd__performResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__refunds = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rfd__performResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rfd__performResponse, sizeof(struct rfd__performResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_rfd__performResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__refunds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfRefunds(soap, NULL, &a->_refunds, "vin:Refund"))
				{	soap_flag__refunds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rfd__performResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rfd__performResponse, 0, sizeof(struct rfd__performResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rfd__report(struct soap *soap, struct rfd__report *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_refunds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rfd__report(struct soap *soap, const struct rfd__report *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerToArrayOfRefunds(soap, &a->_refunds);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rfd__report(struct soap *soap, const struct rfd__report *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rfd__report);
	if (soap_out_rfd__report(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rfd__report(struct soap *soap, const char *tag, int id, const struct rfd__report *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rfd__report), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerToArrayOfRefunds(soap, "refunds", -1, &a->_refunds, "vin:Refund"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rfd__report * SOAP_FMAC4 soap_get_rfd__report(struct soap *soap, struct rfd__report *p, const char *tag, const char *type)
{
	if ((p = soap_in_rfd__report(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__report * SOAP_FMAC4 soap_in_rfd__report(struct soap *soap, const char *tag, struct rfd__report *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__refunds = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rfd__report *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rfd__report, sizeof(struct rfd__report), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_rfd__report(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__refunds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfRefunds(soap, NULL, &a->_refunds, "vin:Refund"))
				{	soap_flag__refunds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rfd__report *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rfd__report, 0, sizeof(struct rfd__report), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rfd__reportResponse(struct soap *soap, struct rfd__reportResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_refunds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rfd__reportResponse(struct soap *soap, const struct rfd__reportResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfRefunds(soap, &a->_refunds);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rfd__reportResponse(struct soap *soap, const struct rfd__reportResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rfd__reportResponse);
	if (soap_out_rfd__reportResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rfd__reportResponse(struct soap *soap, const char *tag, int id, const struct rfd__reportResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rfd__reportResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfRefunds(soap, "refunds", -1, &a->_refunds, "vin:Refund"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rfd__reportResponse * SOAP_FMAC4 soap_get_rfd__reportResponse(struct soap *soap, struct rfd__reportResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rfd__reportResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__reportResponse * SOAP_FMAC4 soap_in_rfd__reportResponse(struct soap *soap, const char *tag, struct rfd__reportResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__refunds = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rfd__reportResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rfd__reportResponse, sizeof(struct rfd__reportResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_rfd__reportResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__refunds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfRefunds(soap, NULL, &a->_refunds, "vin:Refund"))
				{	soap_flag__refunds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rfd__reportResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rfd__reportResponse, 0, sizeof(struct rfd__reportResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rfd__fetchDeltaSince(struct soap *soap, struct rfd__fetchDeltaSince *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_time(soap, &a->_timestamp);
	soap_default_time(soap, &a->_endTimestamp);
	a->_paymentMethod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rfd__fetchDeltaSince(struct soap *soap, const struct rfd__fetchDeltaSince *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_embedded(soap, &a->_timestamp, SOAP_TYPE_time);
	soap_embedded(soap, &a->_endTimestamp, SOAP_TYPE_time);
	soap_serialize_PointerTovin__PaymentMethod(soap, &a->_paymentMethod);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rfd__fetchDeltaSince(struct soap *soap, const struct rfd__fetchDeltaSince *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rfd__fetchDeltaSince);
	if (soap_out_rfd__fetchDeltaSince(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rfd__fetchDeltaSince(struct soap *soap, const char *tag, int id, const struct rfd__fetchDeltaSince *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rfd__fetchDeltaSince), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_time(soap, "timestamp", -1, &a->_timestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_time(soap, "endTimestamp", -1, &a->_endTimestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentMethod(soap, "paymentMethod", -1, &a->_paymentMethod, "vin:PaymentMethod"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rfd__fetchDeltaSince * SOAP_FMAC4 soap_get_rfd__fetchDeltaSince(struct soap *soap, struct rfd__fetchDeltaSince *p, const char *tag, const char *type)
{
	if ((p = soap_in_rfd__fetchDeltaSince(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__fetchDeltaSince * SOAP_FMAC4 soap_in_rfd__fetchDeltaSince(struct soap *soap, const char *tag, struct rfd__fetchDeltaSince *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__timestamp = 1;
	size_t soap_flag__endTimestamp = 1;
	size_t soap_flag__paymentMethod = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rfd__fetchDeltaSince *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rfd__fetchDeltaSince, sizeof(struct rfd__fetchDeltaSince), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_rfd__fetchDeltaSince(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_timestamp, "xsd:dateTime"))
				{	soap_flag__timestamp--;
					continue;
				}
			if (soap_flag__endTimestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_endTimestamp, "xsd:dateTime"))
				{	soap_flag__endTimestamp--;
					continue;
				}
			if (soap_flag__paymentMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentMethod(soap, NULL, &a->_paymentMethod, "vin:PaymentMethod"))
				{	soap_flag__paymentMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rfd__fetchDeltaSince *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rfd__fetchDeltaSince, 0, sizeof(struct rfd__fetchDeltaSince), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__timestamp > 0 || soap_flag__endTimestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rfd__fetchDeltaSinceResponse(struct soap *soap, struct rfd__fetchDeltaSinceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_refunds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rfd__fetchDeltaSinceResponse(struct soap *soap, const struct rfd__fetchDeltaSinceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfRefunds(soap, &a->_refunds);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rfd__fetchDeltaSinceResponse(struct soap *soap, const struct rfd__fetchDeltaSinceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rfd__fetchDeltaSinceResponse);
	if (soap_out_rfd__fetchDeltaSinceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rfd__fetchDeltaSinceResponse(struct soap *soap, const char *tag, int id, const struct rfd__fetchDeltaSinceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rfd__fetchDeltaSinceResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfRefunds(soap, "refunds", -1, &a->_refunds, "vin:Refund"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rfd__fetchDeltaSinceResponse * SOAP_FMAC4 soap_get_rfd__fetchDeltaSinceResponse(struct soap *soap, struct rfd__fetchDeltaSinceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rfd__fetchDeltaSinceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__fetchDeltaSinceResponse * SOAP_FMAC4 soap_in_rfd__fetchDeltaSinceResponse(struct soap *soap, const char *tag, struct rfd__fetchDeltaSinceResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__refunds = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rfd__fetchDeltaSinceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rfd__fetchDeltaSinceResponse, sizeof(struct rfd__fetchDeltaSinceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_rfd__fetchDeltaSinceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__refunds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfRefunds(soap, NULL, &a->_refunds, "vin:Refund"))
				{	soap_flag__refunds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rfd__fetchDeltaSinceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rfd__fetchDeltaSinceResponse, 0, sizeof(struct rfd__fetchDeltaSinceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rfd__fetchByTransaction(struct soap *soap, struct rfd__fetchByTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_transaction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rfd__fetchByTransaction(struct soap *soap, const struct rfd__fetchByTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Transaction(soap, &a->_transaction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rfd__fetchByTransaction(struct soap *soap, const struct rfd__fetchByTransaction *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rfd__fetchByTransaction);
	if (soap_out_rfd__fetchByTransaction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rfd__fetchByTransaction(struct soap *soap, const char *tag, int id, const struct rfd__fetchByTransaction *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rfd__fetchByTransaction), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Transaction(soap, "transaction", -1, &a->_transaction, "vin:Transaction"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rfd__fetchByTransaction * SOAP_FMAC4 soap_get_rfd__fetchByTransaction(struct soap *soap, struct rfd__fetchByTransaction *p, const char *tag, const char *type)
{
	if ((p = soap_in_rfd__fetchByTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__fetchByTransaction * SOAP_FMAC4 soap_in_rfd__fetchByTransaction(struct soap *soap, const char *tag, struct rfd__fetchByTransaction *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__transaction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rfd__fetchByTransaction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rfd__fetchByTransaction, sizeof(struct rfd__fetchByTransaction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_rfd__fetchByTransaction(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__transaction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Transaction(soap, NULL, &a->_transaction, "vin:Transaction"))
				{	soap_flag__transaction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rfd__fetchByTransaction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rfd__fetchByTransaction, 0, sizeof(struct rfd__fetchByTransaction), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rfd__fetchByTransactionResponse(struct soap *soap, struct rfd__fetchByTransactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_refunds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rfd__fetchByTransactionResponse(struct soap *soap, const struct rfd__fetchByTransactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfRefunds(soap, &a->_refunds);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rfd__fetchByTransactionResponse(struct soap *soap, const struct rfd__fetchByTransactionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rfd__fetchByTransactionResponse);
	if (soap_out_rfd__fetchByTransactionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rfd__fetchByTransactionResponse(struct soap *soap, const char *tag, int id, const struct rfd__fetchByTransactionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rfd__fetchByTransactionResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfRefunds(soap, "refunds", -1, &a->_refunds, "vin:Refund"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rfd__fetchByTransactionResponse * SOAP_FMAC4 soap_get_rfd__fetchByTransactionResponse(struct soap *soap, struct rfd__fetchByTransactionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rfd__fetchByTransactionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__fetchByTransactionResponse * SOAP_FMAC4 soap_in_rfd__fetchByTransactionResponse(struct soap *soap, const char *tag, struct rfd__fetchByTransactionResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__refunds = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rfd__fetchByTransactionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rfd__fetchByTransactionResponse, sizeof(struct rfd__fetchByTransactionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_rfd__fetchByTransactionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__refunds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfRefunds(soap, NULL, &a->_refunds, "vin:Refund"))
				{	soap_flag__refunds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rfd__fetchByTransactionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rfd__fetchByTransactionResponse, 0, sizeof(struct rfd__fetchByTransactionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rfd__fetchByAccount(struct soap *soap, struct rfd__fetchByAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_account = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rfd__fetchByAccount(struct soap *soap, const struct rfd__fetchByAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rfd__fetchByAccount(struct soap *soap, const struct rfd__fetchByAccount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rfd__fetchByAccount);
	if (soap_out_rfd__fetchByAccount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rfd__fetchByAccount(struct soap *soap, const char *tag, int id, const struct rfd__fetchByAccount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rfd__fetchByAccount), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rfd__fetchByAccount * SOAP_FMAC4 soap_get_rfd__fetchByAccount(struct soap *soap, struct rfd__fetchByAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in_rfd__fetchByAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__fetchByAccount * SOAP_FMAC4 soap_in_rfd__fetchByAccount(struct soap *soap, const char *tag, struct rfd__fetchByAccount *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__account = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rfd__fetchByAccount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rfd__fetchByAccount, sizeof(struct rfd__fetchByAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_rfd__fetchByAccount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rfd__fetchByAccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rfd__fetchByAccount, 0, sizeof(struct rfd__fetchByAccount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rfd__fetchByAccountResponse(struct soap *soap, struct rfd__fetchByAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_refunds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rfd__fetchByAccountResponse(struct soap *soap, const struct rfd__fetchByAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfRefunds(soap, &a->_refunds);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rfd__fetchByAccountResponse(struct soap *soap, const struct rfd__fetchByAccountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rfd__fetchByAccountResponse);
	if (soap_out_rfd__fetchByAccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rfd__fetchByAccountResponse(struct soap *soap, const char *tag, int id, const struct rfd__fetchByAccountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rfd__fetchByAccountResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfRefunds(soap, "refunds", -1, &a->_refunds, "vin:Refund"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rfd__fetchByAccountResponse * SOAP_FMAC4 soap_get_rfd__fetchByAccountResponse(struct soap *soap, struct rfd__fetchByAccountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rfd__fetchByAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__fetchByAccountResponse * SOAP_FMAC4 soap_in_rfd__fetchByAccountResponse(struct soap *soap, const char *tag, struct rfd__fetchByAccountResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__refunds = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rfd__fetchByAccountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rfd__fetchByAccountResponse, sizeof(struct rfd__fetchByAccountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_rfd__fetchByAccountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__refunds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfRefunds(soap, NULL, &a->_refunds, "vin:Refund"))
				{	soap_flag__refunds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rfd__fetchByAccountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rfd__fetchByAccountResponse, 0, sizeof(struct rfd__fetchByAccountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rfd__fetchByVid(struct soap *soap, struct rfd__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_vid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rfd__fetchByVid(struct soap *soap, const struct rfd__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_vid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rfd__fetchByVid(struct soap *soap, const struct rfd__fetchByVid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rfd__fetchByVid);
	if (soap_out_rfd__fetchByVid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rfd__fetchByVid(struct soap *soap, const char *tag, int id, const struct rfd__fetchByVid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rfd__fetchByVid), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "vid", -1, &a->_vid, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rfd__fetchByVid * SOAP_FMAC4 soap_get_rfd__fetchByVid(struct soap *soap, struct rfd__fetchByVid *p, const char *tag, const char *type)
{
	if ((p = soap_in_rfd__fetchByVid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__fetchByVid * SOAP_FMAC4 soap_in_rfd__fetchByVid(struct soap *soap, const char *tag, struct rfd__fetchByVid *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__vid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rfd__fetchByVid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rfd__fetchByVid, sizeof(struct rfd__fetchByVid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_rfd__fetchByVid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__vid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_vid, "xsd:string"))
				{	soap_flag__vid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rfd__fetchByVid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rfd__fetchByVid, 0, sizeof(struct rfd__fetchByVid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_rfd__fetchByVidResponse(struct soap *soap, struct rfd__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_refund = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_rfd__fetchByVidResponse(struct soap *soap, const struct rfd__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Refund(soap, &a->_refund);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_rfd__fetchByVidResponse(struct soap *soap, const struct rfd__fetchByVidResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_rfd__fetchByVidResponse);
	if (soap_out_rfd__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_rfd__fetchByVidResponse(struct soap *soap, const char *tag, int id, const struct rfd__fetchByVidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_rfd__fetchByVidResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Refund(soap, "refund", -1, &a->_refund, "vin:Refund"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct rfd__fetchByVidResponse * SOAP_FMAC4 soap_get_rfd__fetchByVidResponse(struct soap *soap, struct rfd__fetchByVidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_rfd__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__fetchByVidResponse * SOAP_FMAC4 soap_in_rfd__fetchByVidResponse(struct soap *soap, const char *tag, struct rfd__fetchByVidResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__refund = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct rfd__fetchByVidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_rfd__fetchByVidResponse, sizeof(struct rfd__fetchByVidResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_rfd__fetchByVidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__refund && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Refund(soap, NULL, &a->_refund, "vin:Refund"))
				{	soap_flag__refund--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct rfd__fetchByVidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_rfd__fetchByVidResponse, 0, sizeof(struct rfd__fetchByVidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_pyp__fetchByVid(struct soap *soap, struct pyp__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_vid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_pyp__fetchByVid(struct soap *soap, const struct pyp__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_vid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_pyp__fetchByVid(struct soap *soap, const struct pyp__fetchByVid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_pyp__fetchByVid);
	if (soap_out_pyp__fetchByVid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pyp__fetchByVid(struct soap *soap, const char *tag, int id, const struct pyp__fetchByVid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pyp__fetchByVid), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "vid", -1, &a->_vid, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct pyp__fetchByVid * SOAP_FMAC4 soap_get_pyp__fetchByVid(struct soap *soap, struct pyp__fetchByVid *p, const char *tag, const char *type)
{
	if ((p = soap_in_pyp__fetchByVid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pyp__fetchByVid * SOAP_FMAC4 soap_in_pyp__fetchByVid(struct soap *soap, const char *tag, struct pyp__fetchByVid *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__vid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct pyp__fetchByVid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_pyp__fetchByVid, sizeof(struct pyp__fetchByVid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_pyp__fetchByVid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__vid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_vid, "xsd:string"))
				{	soap_flag__vid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct pyp__fetchByVid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pyp__fetchByVid, 0, sizeof(struct pyp__fetchByVid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_pyp__fetchByVidResponse(struct soap *soap, struct pyp__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_paymentProvider = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_pyp__fetchByVidResponse(struct soap *soap, const struct pyp__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__PaymentProvider(soap, &a->_paymentProvider);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_pyp__fetchByVidResponse(struct soap *soap, const struct pyp__fetchByVidResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_pyp__fetchByVidResponse);
	if (soap_out_pyp__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pyp__fetchByVidResponse(struct soap *soap, const char *tag, int id, const struct pyp__fetchByVidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pyp__fetchByVidResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentProvider(soap, "paymentProvider", -1, &a->_paymentProvider, "vin:PaymentProvider"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct pyp__fetchByVidResponse * SOAP_FMAC4 soap_get_pyp__fetchByVidResponse(struct soap *soap, struct pyp__fetchByVidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_pyp__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pyp__fetchByVidResponse * SOAP_FMAC4 soap_in_pyp__fetchByVidResponse(struct soap *soap, const char *tag, struct pyp__fetchByVidResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__paymentProvider = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct pyp__fetchByVidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_pyp__fetchByVidResponse, sizeof(struct pyp__fetchByVidResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_pyp__fetchByVidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__paymentProvider && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentProvider(soap, NULL, &a->_paymentProvider, "vin:PaymentProvider"))
				{	soap_flag__paymentProvider--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct pyp__fetchByVidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pyp__fetchByVidResponse, 0, sizeof(struct pyp__fetchByVidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_pyp__update(struct soap *soap, struct pyp__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_paymentProvider = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_pyp__update(struct soap *soap, const struct pyp__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__PaymentProvider(soap, &a->_paymentProvider);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_pyp__update(struct soap *soap, const struct pyp__update *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_pyp__update);
	if (soap_out_pyp__update(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pyp__update(struct soap *soap, const char *tag, int id, const struct pyp__update *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pyp__update), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentProvider(soap, "paymentProvider", -1, &a->_paymentProvider, "vin:PaymentProvider"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct pyp__update * SOAP_FMAC4 soap_get_pyp__update(struct soap *soap, struct pyp__update *p, const char *tag, const char *type)
{
	if ((p = soap_in_pyp__update(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pyp__update * SOAP_FMAC4 soap_in_pyp__update(struct soap *soap, const char *tag, struct pyp__update *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__paymentProvider = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct pyp__update *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_pyp__update, sizeof(struct pyp__update), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_pyp__update(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__paymentProvider && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentProvider(soap, NULL, &a->_paymentProvider, "vin:PaymentProvider"))
				{	soap_flag__paymentProvider--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct pyp__update *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pyp__update, 0, sizeof(struct pyp__update), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_pyp__updateResponse(struct soap *soap, struct pyp__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_paymentProvider = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_pyp__updateResponse(struct soap *soap, const struct pyp__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__PaymentProvider(soap, &a->_paymentProvider);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_pyp__updateResponse(struct soap *soap, const struct pyp__updateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_pyp__updateResponse);
	if (soap_out_pyp__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pyp__updateResponse(struct soap *soap, const char *tag, int id, const struct pyp__updateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pyp__updateResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentProvider(soap, "paymentProvider", -1, &a->_paymentProvider, "vin:PaymentProvider"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct pyp__updateResponse * SOAP_FMAC4 soap_get_pyp__updateResponse(struct soap *soap, struct pyp__updateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_pyp__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pyp__updateResponse * SOAP_FMAC4 soap_in_pyp__updateResponse(struct soap *soap, const char *tag, struct pyp__updateResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__paymentProvider = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct pyp__updateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_pyp__updateResponse, sizeof(struct pyp__updateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_pyp__updateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__paymentProvider && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentProvider(soap, NULL, &a->_paymentProvider, "vin:PaymentProvider"))
				{	soap_flag__paymentProvider--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct pyp__updateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pyp__updateResponse, 0, sizeof(struct pyp__updateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_pym__validate(struct soap *soap, struct pym__validate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_paymentMethod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_pym__validate(struct soap *soap, const struct pym__validate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__PaymentMethod(soap, &a->_paymentMethod);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_pym__validate(struct soap *soap, const struct pym__validate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_pym__validate);
	if (soap_out_pym__validate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pym__validate(struct soap *soap, const char *tag, int id, const struct pym__validate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pym__validate), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentMethod(soap, "paymentMethod", -1, &a->_paymentMethod, "vin:PaymentMethod"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct pym__validate * SOAP_FMAC4 soap_get_pym__validate(struct soap *soap, struct pym__validate *p, const char *tag, const char *type)
{
	if ((p = soap_in_pym__validate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pym__validate * SOAP_FMAC4 soap_in_pym__validate(struct soap *soap, const char *tag, struct pym__validate *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__paymentMethod = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct pym__validate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_pym__validate, sizeof(struct pym__validate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_pym__validate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__paymentMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentMethod(soap, NULL, &a->_paymentMethod, "vin:PaymentMethod"))
				{	soap_flag__paymentMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct pym__validate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pym__validate, 0, sizeof(struct pym__validate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_pym__validateResponse(struct soap *soap, struct pym__validateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	soap_default_xsd__boolean(soap, &a->_validated);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_pym__validateResponse(struct soap *soap, const struct pym__validateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_embedded(soap, &a->_validated, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_pym__validateResponse(struct soap *soap, const struct pym__validateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_pym__validateResponse);
	if (soap_out_pym__validateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pym__validateResponse(struct soap *soap, const char *tag, int id, const struct pym__validateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pym__validateResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "validated", -1, &a->_validated, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct pym__validateResponse * SOAP_FMAC4 soap_get_pym__validateResponse(struct soap *soap, struct pym__validateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_pym__validateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pym__validateResponse * SOAP_FMAC4 soap_in_pym__validateResponse(struct soap *soap, const char *tag, struct pym__validateResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__validated = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct pym__validateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_pym__validateResponse, sizeof(struct pym__validateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_pym__validateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__validated && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_validated, "xsd:boolean"))
				{	soap_flag__validated--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct pym__validateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pym__validateResponse, 0, sizeof(struct pym__validateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__validated > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_pym__fetchByMerchantPaymentMethodId(struct soap *soap, struct pym__fetchByMerchantPaymentMethodId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_paymentMethodId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_pym__fetchByMerchantPaymentMethodId(struct soap *soap, const struct pym__fetchByMerchantPaymentMethodId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_paymentMethodId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_pym__fetchByMerchantPaymentMethodId(struct soap *soap, const struct pym__fetchByMerchantPaymentMethodId *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_pym__fetchByMerchantPaymentMethodId);
	if (soap_out_pym__fetchByMerchantPaymentMethodId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pym__fetchByMerchantPaymentMethodId(struct soap *soap, const char *tag, int id, const struct pym__fetchByMerchantPaymentMethodId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pym__fetchByMerchantPaymentMethodId), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "paymentMethodId", -1, &a->_paymentMethodId, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct pym__fetchByMerchantPaymentMethodId * SOAP_FMAC4 soap_get_pym__fetchByMerchantPaymentMethodId(struct soap *soap, struct pym__fetchByMerchantPaymentMethodId *p, const char *tag, const char *type)
{
	if ((p = soap_in_pym__fetchByMerchantPaymentMethodId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pym__fetchByMerchantPaymentMethodId * SOAP_FMAC4 soap_in_pym__fetchByMerchantPaymentMethodId(struct soap *soap, const char *tag, struct pym__fetchByMerchantPaymentMethodId *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__paymentMethodId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct pym__fetchByMerchantPaymentMethodId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_pym__fetchByMerchantPaymentMethodId, sizeof(struct pym__fetchByMerchantPaymentMethodId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_pym__fetchByMerchantPaymentMethodId(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__paymentMethodId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_paymentMethodId, "xsd:string"))
				{	soap_flag__paymentMethodId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct pym__fetchByMerchantPaymentMethodId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pym__fetchByMerchantPaymentMethodId, 0, sizeof(struct pym__fetchByMerchantPaymentMethodId), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_pym__fetchByMerchantPaymentMethodIdResponse(struct soap *soap, struct pym__fetchByMerchantPaymentMethodIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_paymentMethod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_pym__fetchByMerchantPaymentMethodIdResponse(struct soap *soap, const struct pym__fetchByMerchantPaymentMethodIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__PaymentMethod(soap, &a->_paymentMethod);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_pym__fetchByMerchantPaymentMethodIdResponse(struct soap *soap, const struct pym__fetchByMerchantPaymentMethodIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_pym__fetchByMerchantPaymentMethodIdResponse);
	if (soap_out_pym__fetchByMerchantPaymentMethodIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pym__fetchByMerchantPaymentMethodIdResponse(struct soap *soap, const char *tag, int id, const struct pym__fetchByMerchantPaymentMethodIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pym__fetchByMerchantPaymentMethodIdResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentMethod(soap, "paymentMethod", -1, &a->_paymentMethod, "vin:PaymentMethod"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct pym__fetchByMerchantPaymentMethodIdResponse * SOAP_FMAC4 soap_get_pym__fetchByMerchantPaymentMethodIdResponse(struct soap *soap, struct pym__fetchByMerchantPaymentMethodIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_pym__fetchByMerchantPaymentMethodIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pym__fetchByMerchantPaymentMethodIdResponse * SOAP_FMAC4 soap_in_pym__fetchByMerchantPaymentMethodIdResponse(struct soap *soap, const char *tag, struct pym__fetchByMerchantPaymentMethodIdResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__paymentMethod = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct pym__fetchByMerchantPaymentMethodIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_pym__fetchByMerchantPaymentMethodIdResponse, sizeof(struct pym__fetchByMerchantPaymentMethodIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_pym__fetchByMerchantPaymentMethodIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__paymentMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentMethod(soap, NULL, &a->_paymentMethod, "vin:PaymentMethod"))
				{	soap_flag__paymentMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct pym__fetchByMerchantPaymentMethodIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pym__fetchByMerchantPaymentMethodIdResponse, 0, sizeof(struct pym__fetchByMerchantPaymentMethodIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_pym__fetchByAccount(struct soap *soap, struct pym__fetchByAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_account = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_pym__fetchByAccount(struct soap *soap, const struct pym__fetchByAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_pym__fetchByAccount(struct soap *soap, const struct pym__fetchByAccount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_pym__fetchByAccount);
	if (soap_out_pym__fetchByAccount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pym__fetchByAccount(struct soap *soap, const char *tag, int id, const struct pym__fetchByAccount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pym__fetchByAccount), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct pym__fetchByAccount * SOAP_FMAC4 soap_get_pym__fetchByAccount(struct soap *soap, struct pym__fetchByAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in_pym__fetchByAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pym__fetchByAccount * SOAP_FMAC4 soap_in_pym__fetchByAccount(struct soap *soap, const char *tag, struct pym__fetchByAccount *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__account = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct pym__fetchByAccount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_pym__fetchByAccount, sizeof(struct pym__fetchByAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_pym__fetchByAccount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct pym__fetchByAccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pym__fetchByAccount, 0, sizeof(struct pym__fetchByAccount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_pym__fetchByAccountResponse(struct soap *soap, struct pym__fetchByAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_paymentMethods = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_pym__fetchByAccountResponse(struct soap *soap, const struct pym__fetchByAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfPaymentMethods(soap, &a->_paymentMethods);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_pym__fetchByAccountResponse(struct soap *soap, const struct pym__fetchByAccountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_pym__fetchByAccountResponse);
	if (soap_out_pym__fetchByAccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pym__fetchByAccountResponse(struct soap *soap, const char *tag, int id, const struct pym__fetchByAccountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pym__fetchByAccountResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfPaymentMethods(soap, "paymentMethods", -1, &a->_paymentMethods, "vin:PaymentMethod"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct pym__fetchByAccountResponse * SOAP_FMAC4 soap_get_pym__fetchByAccountResponse(struct soap *soap, struct pym__fetchByAccountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_pym__fetchByAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pym__fetchByAccountResponse * SOAP_FMAC4 soap_in_pym__fetchByAccountResponse(struct soap *soap, const char *tag, struct pym__fetchByAccountResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__paymentMethods = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct pym__fetchByAccountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_pym__fetchByAccountResponse, sizeof(struct pym__fetchByAccountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_pym__fetchByAccountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__paymentMethods && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfPaymentMethods(soap, NULL, &a->_paymentMethods, "vin:PaymentMethod"))
				{	soap_flag__paymentMethods--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct pym__fetchByAccountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pym__fetchByAccountResponse, 0, sizeof(struct pym__fetchByAccountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_pym__fetchByVid(struct soap *soap, struct pym__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_vid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_pym__fetchByVid(struct soap *soap, const struct pym__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_vid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_pym__fetchByVid(struct soap *soap, const struct pym__fetchByVid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_pym__fetchByVid);
	if (soap_out_pym__fetchByVid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pym__fetchByVid(struct soap *soap, const char *tag, int id, const struct pym__fetchByVid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pym__fetchByVid), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "vid", -1, &a->_vid, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct pym__fetchByVid * SOAP_FMAC4 soap_get_pym__fetchByVid(struct soap *soap, struct pym__fetchByVid *p, const char *tag, const char *type)
{
	if ((p = soap_in_pym__fetchByVid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pym__fetchByVid * SOAP_FMAC4 soap_in_pym__fetchByVid(struct soap *soap, const char *tag, struct pym__fetchByVid *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__vid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct pym__fetchByVid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_pym__fetchByVid, sizeof(struct pym__fetchByVid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_pym__fetchByVid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__vid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_vid, "xsd:string"))
				{	soap_flag__vid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct pym__fetchByVid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pym__fetchByVid, 0, sizeof(struct pym__fetchByVid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_pym__fetchByVidResponse(struct soap *soap, struct pym__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_paymentMethod = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_pym__fetchByVidResponse(struct soap *soap, const struct pym__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__PaymentMethod(soap, &a->_paymentMethod);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_pym__fetchByVidResponse(struct soap *soap, const struct pym__fetchByVidResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_pym__fetchByVidResponse);
	if (soap_out_pym__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pym__fetchByVidResponse(struct soap *soap, const char *tag, int id, const struct pym__fetchByVidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pym__fetchByVidResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentMethod(soap, "paymentMethod", -1, &a->_paymentMethod, "vin:PaymentMethod"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct pym__fetchByVidResponse * SOAP_FMAC4 soap_get_pym__fetchByVidResponse(struct soap *soap, struct pym__fetchByVidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_pym__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pym__fetchByVidResponse * SOAP_FMAC4 soap_in_pym__fetchByVidResponse(struct soap *soap, const char *tag, struct pym__fetchByVidResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__paymentMethod = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct pym__fetchByVidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_pym__fetchByVidResponse, sizeof(struct pym__fetchByVidResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_pym__fetchByVidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__paymentMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentMethod(soap, NULL, &a->_paymentMethod, "vin:PaymentMethod"))
				{	soap_flag__paymentMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct pym__fetchByVidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pym__fetchByVidResponse, 0, sizeof(struct pym__fetchByVidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_pym__update(struct soap *soap, struct pym__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_paymentMethod = NULL;
	soap_default_xsd__boolean(soap, &a->_validate);
	soap_default_int(soap, &a->_minChargebackProbability);
	soap_default_xsd__boolean(soap, &a->_replaceOnAllAutoBills);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_pym__update(struct soap *soap, const struct pym__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__PaymentMethod(soap, &a->_paymentMethod);
	soap_embedded(soap, &a->_validate, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->_minChargebackProbability, SOAP_TYPE_int);
	soap_embedded(soap, &a->_replaceOnAllAutoBills, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_pym__update(struct soap *soap, const struct pym__update *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_pym__update);
	if (soap_out_pym__update(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pym__update(struct soap *soap, const char *tag, int id, const struct pym__update *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pym__update), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentMethod(soap, "paymentMethod", -1, &a->_paymentMethod, "vin:PaymentMethod"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "validate", -1, &a->_validate, "xsd:boolean"))
		return soap->error;
	if (soap_out_int(soap, "minChargebackProbability", -1, &a->_minChargebackProbability, "xsd:int"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "replaceOnAllAutoBills", -1, &a->_replaceOnAllAutoBills, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct pym__update * SOAP_FMAC4 soap_get_pym__update(struct soap *soap, struct pym__update *p, const char *tag, const char *type)
{
	if ((p = soap_in_pym__update(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pym__update * SOAP_FMAC4 soap_in_pym__update(struct soap *soap, const char *tag, struct pym__update *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__paymentMethod = 1;
	size_t soap_flag__validate = 1;
	size_t soap_flag__minChargebackProbability = 1;
	size_t soap_flag__replaceOnAllAutoBills = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct pym__update *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_pym__update, sizeof(struct pym__update), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_pym__update(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__paymentMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentMethod(soap, NULL, &a->_paymentMethod, "vin:PaymentMethod"))
				{	soap_flag__paymentMethod--;
					continue;
				}
			if (soap_flag__validate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_validate, "xsd:boolean"))
				{	soap_flag__validate--;
					continue;
				}
			if (soap_flag__minChargebackProbability && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_minChargebackProbability, "xsd:int"))
				{	soap_flag__minChargebackProbability--;
					continue;
				}
			if (soap_flag__replaceOnAllAutoBills && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_replaceOnAllAutoBills, "xsd:boolean"))
				{	soap_flag__replaceOnAllAutoBills--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct pym__update *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pym__update, 0, sizeof(struct pym__update), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__validate > 0 || soap_flag__minChargebackProbability > 0 || soap_flag__replaceOnAllAutoBills > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_pym__updateResponse(struct soap *soap, struct pym__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_paymentMethod = NULL;
	soap_default_xsd__boolean(soap, &a->_created);
	soap_default_xsd__boolean(soap, &a->_validated);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_pym__updateResponse(struct soap *soap, const struct pym__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__PaymentMethod(soap, &a->_paymentMethod);
	soap_embedded(soap, &a->_created, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->_validated, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_pym__updateResponse(struct soap *soap, const struct pym__updateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_pym__updateResponse);
	if (soap_out_pym__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pym__updateResponse(struct soap *soap, const char *tag, int id, const struct pym__updateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pym__updateResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentMethod(soap, "paymentMethod", -1, &a->_paymentMethod, "vin:PaymentMethod"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "created", -1, &a->_created, "xsd:boolean"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "validated", -1, &a->_validated, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct pym__updateResponse * SOAP_FMAC4 soap_get_pym__updateResponse(struct soap *soap, struct pym__updateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_pym__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pym__updateResponse * SOAP_FMAC4 soap_in_pym__updateResponse(struct soap *soap, const char *tag, struct pym__updateResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__paymentMethod = 1;
	size_t soap_flag__created = 1;
	size_t soap_flag__validated = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct pym__updateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_pym__updateResponse, sizeof(struct pym__updateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_pym__updateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__paymentMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentMethod(soap, NULL, &a->_paymentMethod, "vin:PaymentMethod"))
				{	soap_flag__paymentMethod--;
					continue;
				}
			if (soap_flag__created && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_created, "xsd:boolean"))
				{	soap_flag__created--;
					continue;
				}
			if (soap_flag__validated && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_validated, "xsd:boolean"))
				{	soap_flag__validated--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct pym__updateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pym__updateResponse, 0, sizeof(struct pym__updateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__created > 0 || soap_flag__validated > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_prd__fetchByMerchantEntitlementId(struct soap *soap, struct prd__fetchByMerchantEntitlementId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_merchantEntitlementId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_prd__fetchByMerchantEntitlementId(struct soap *soap, const struct prd__fetchByMerchantEntitlementId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_merchantEntitlementId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_prd__fetchByMerchantEntitlementId(struct soap *soap, const struct prd__fetchByMerchantEntitlementId *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_prd__fetchByMerchantEntitlementId);
	if (soap_out_prd__fetchByMerchantEntitlementId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_prd__fetchByMerchantEntitlementId(struct soap *soap, const char *tag, int id, const struct prd__fetchByMerchantEntitlementId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_prd__fetchByMerchantEntitlementId), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "merchantEntitlementId", -1, &a->_merchantEntitlementId, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct prd__fetchByMerchantEntitlementId * SOAP_FMAC4 soap_get_prd__fetchByMerchantEntitlementId(struct soap *soap, struct prd__fetchByMerchantEntitlementId *p, const char *tag, const char *type)
{
	if ((p = soap_in_prd__fetchByMerchantEntitlementId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__fetchByMerchantEntitlementId * SOAP_FMAC4 soap_in_prd__fetchByMerchantEntitlementId(struct soap *soap, const char *tag, struct prd__fetchByMerchantEntitlementId *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__merchantEntitlementId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct prd__fetchByMerchantEntitlementId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_prd__fetchByMerchantEntitlementId, sizeof(struct prd__fetchByMerchantEntitlementId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_prd__fetchByMerchantEntitlementId(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__merchantEntitlementId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_merchantEntitlementId, "xsd:string"))
				{	soap_flag__merchantEntitlementId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct prd__fetchByMerchantEntitlementId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_prd__fetchByMerchantEntitlementId, 0, sizeof(struct prd__fetchByMerchantEntitlementId), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_prd__fetchByMerchantEntitlementIdResponse(struct soap *soap, struct prd__fetchByMerchantEntitlementIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_products = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_prd__fetchByMerchantEntitlementIdResponse(struct soap *soap, const struct prd__fetchByMerchantEntitlementIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfProducts(soap, &a->_products);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_prd__fetchByMerchantEntitlementIdResponse(struct soap *soap, const struct prd__fetchByMerchantEntitlementIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_prd__fetchByMerchantEntitlementIdResponse);
	if (soap_out_prd__fetchByMerchantEntitlementIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_prd__fetchByMerchantEntitlementIdResponse(struct soap *soap, const char *tag, int id, const struct prd__fetchByMerchantEntitlementIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_prd__fetchByMerchantEntitlementIdResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfProducts(soap, "products", -1, &a->_products, "vin:Product"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct prd__fetchByMerchantEntitlementIdResponse * SOAP_FMAC4 soap_get_prd__fetchByMerchantEntitlementIdResponse(struct soap *soap, struct prd__fetchByMerchantEntitlementIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_prd__fetchByMerchantEntitlementIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__fetchByMerchantEntitlementIdResponse * SOAP_FMAC4 soap_in_prd__fetchByMerchantEntitlementIdResponse(struct soap *soap, const char *tag, struct prd__fetchByMerchantEntitlementIdResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__products = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct prd__fetchByMerchantEntitlementIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_prd__fetchByMerchantEntitlementIdResponse, sizeof(struct prd__fetchByMerchantEntitlementIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_prd__fetchByMerchantEntitlementIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__products && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfProducts(soap, NULL, &a->_products, "vin:Product"))
				{	soap_flag__products--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct prd__fetchByMerchantEntitlementIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_prd__fetchByMerchantEntitlementIdResponse, 0, sizeof(struct prd__fetchByMerchantEntitlementIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_prd__fetchAll(struct soap *soap, struct prd__fetchAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_int(soap, &a->_page);
	soap_default_int(soap, &a->_pageSize);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_prd__fetchAll(struct soap *soap, const struct prd__fetchAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_embedded(soap, &a->_page, SOAP_TYPE_int);
	soap_embedded(soap, &a->_pageSize, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_prd__fetchAll(struct soap *soap, const struct prd__fetchAll *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_prd__fetchAll);
	if (soap_out_prd__fetchAll(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_prd__fetchAll(struct soap *soap, const char *tag, int id, const struct prd__fetchAll *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_prd__fetchAll), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_int(soap, "page", -1, &a->_page, "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "pageSize", -1, &a->_pageSize, "xsd:int"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct prd__fetchAll * SOAP_FMAC4 soap_get_prd__fetchAll(struct soap *soap, struct prd__fetchAll *p, const char *tag, const char *type)
{
	if ((p = soap_in_prd__fetchAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__fetchAll * SOAP_FMAC4 soap_in_prd__fetchAll(struct soap *soap, const char *tag, struct prd__fetchAll *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__page = 1;
	size_t soap_flag__pageSize = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct prd__fetchAll *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_prd__fetchAll, sizeof(struct prd__fetchAll), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_prd__fetchAll(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__page && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_page, "xsd:int"))
				{	soap_flag__page--;
					continue;
				}
			if (soap_flag__pageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_pageSize, "xsd:int"))
				{	soap_flag__pageSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct prd__fetchAll *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_prd__fetchAll, 0, sizeof(struct prd__fetchAll), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__page > 0 || soap_flag__pageSize > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_prd__fetchAllResponse(struct soap *soap, struct prd__fetchAllResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_products = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_prd__fetchAllResponse(struct soap *soap, const struct prd__fetchAllResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfProducts(soap, &a->_products);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_prd__fetchAllResponse(struct soap *soap, const struct prd__fetchAllResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_prd__fetchAllResponse);
	if (soap_out_prd__fetchAllResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_prd__fetchAllResponse(struct soap *soap, const char *tag, int id, const struct prd__fetchAllResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_prd__fetchAllResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfProducts(soap, "products", -1, &a->_products, "vin:Product"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct prd__fetchAllResponse * SOAP_FMAC4 soap_get_prd__fetchAllResponse(struct soap *soap, struct prd__fetchAllResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_prd__fetchAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__fetchAllResponse * SOAP_FMAC4 soap_in_prd__fetchAllResponse(struct soap *soap, const char *tag, struct prd__fetchAllResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__products = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct prd__fetchAllResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_prd__fetchAllResponse, sizeof(struct prd__fetchAllResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_prd__fetchAllResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__products && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfProducts(soap, NULL, &a->_products, "vin:Product"))
				{	soap_flag__products--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct prd__fetchAllResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_prd__fetchAllResponse, 0, sizeof(struct prd__fetchAllResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_prd__fetchByAccount(struct soap *soap, struct prd__fetchByAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_account = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_prd__fetchByAccount(struct soap *soap, const struct prd__fetchByAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_prd__fetchByAccount(struct soap *soap, const struct prd__fetchByAccount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_prd__fetchByAccount);
	if (soap_out_prd__fetchByAccount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_prd__fetchByAccount(struct soap *soap, const char *tag, int id, const struct prd__fetchByAccount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_prd__fetchByAccount), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct prd__fetchByAccount * SOAP_FMAC4 soap_get_prd__fetchByAccount(struct soap *soap, struct prd__fetchByAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in_prd__fetchByAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__fetchByAccount * SOAP_FMAC4 soap_in_prd__fetchByAccount(struct soap *soap, const char *tag, struct prd__fetchByAccount *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__account = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct prd__fetchByAccount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_prd__fetchByAccount, sizeof(struct prd__fetchByAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_prd__fetchByAccount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct prd__fetchByAccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_prd__fetchByAccount, 0, sizeof(struct prd__fetchByAccount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_prd__fetchByAccountResponse(struct soap *soap, struct prd__fetchByAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_products = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_prd__fetchByAccountResponse(struct soap *soap, const struct prd__fetchByAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfProducts(soap, &a->_products);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_prd__fetchByAccountResponse(struct soap *soap, const struct prd__fetchByAccountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_prd__fetchByAccountResponse);
	if (soap_out_prd__fetchByAccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_prd__fetchByAccountResponse(struct soap *soap, const char *tag, int id, const struct prd__fetchByAccountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_prd__fetchByAccountResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfProducts(soap, "products", -1, &a->_products, "vin:Product"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct prd__fetchByAccountResponse * SOAP_FMAC4 soap_get_prd__fetchByAccountResponse(struct soap *soap, struct prd__fetchByAccountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_prd__fetchByAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__fetchByAccountResponse * SOAP_FMAC4 soap_in_prd__fetchByAccountResponse(struct soap *soap, const char *tag, struct prd__fetchByAccountResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__products = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct prd__fetchByAccountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_prd__fetchByAccountResponse, sizeof(struct prd__fetchByAccountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_prd__fetchByAccountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__products && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfProducts(soap, NULL, &a->_products, "vin:Product"))
				{	soap_flag__products--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct prd__fetchByAccountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_prd__fetchByAccountResponse, 0, sizeof(struct prd__fetchByAccountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_prd__fetchByMerchantProductId(struct soap *soap, struct prd__fetchByMerchantProductId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_merchantProductId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_prd__fetchByMerchantProductId(struct soap *soap, const struct prd__fetchByMerchantProductId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_merchantProductId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_prd__fetchByMerchantProductId(struct soap *soap, const struct prd__fetchByMerchantProductId *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_prd__fetchByMerchantProductId);
	if (soap_out_prd__fetchByMerchantProductId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_prd__fetchByMerchantProductId(struct soap *soap, const char *tag, int id, const struct prd__fetchByMerchantProductId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_prd__fetchByMerchantProductId), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "merchantProductId", -1, &a->_merchantProductId, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct prd__fetchByMerchantProductId * SOAP_FMAC4 soap_get_prd__fetchByMerchantProductId(struct soap *soap, struct prd__fetchByMerchantProductId *p, const char *tag, const char *type)
{
	if ((p = soap_in_prd__fetchByMerchantProductId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__fetchByMerchantProductId * SOAP_FMAC4 soap_in_prd__fetchByMerchantProductId(struct soap *soap, const char *tag, struct prd__fetchByMerchantProductId *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__merchantProductId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct prd__fetchByMerchantProductId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_prd__fetchByMerchantProductId, sizeof(struct prd__fetchByMerchantProductId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_prd__fetchByMerchantProductId(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__merchantProductId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_merchantProductId, "xsd:string"))
				{	soap_flag__merchantProductId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct prd__fetchByMerchantProductId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_prd__fetchByMerchantProductId, 0, sizeof(struct prd__fetchByMerchantProductId), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_prd__fetchByMerchantProductIdResponse(struct soap *soap, struct prd__fetchByMerchantProductIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_product = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_prd__fetchByMerchantProductIdResponse(struct soap *soap, const struct prd__fetchByMerchantProductIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Product(soap, &a->_product);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_prd__fetchByMerchantProductIdResponse(struct soap *soap, const struct prd__fetchByMerchantProductIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_prd__fetchByMerchantProductIdResponse);
	if (soap_out_prd__fetchByMerchantProductIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_prd__fetchByMerchantProductIdResponse(struct soap *soap, const char *tag, int id, const struct prd__fetchByMerchantProductIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_prd__fetchByMerchantProductIdResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Product(soap, "product", -1, &a->_product, "vin:Product"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct prd__fetchByMerchantProductIdResponse * SOAP_FMAC4 soap_get_prd__fetchByMerchantProductIdResponse(struct soap *soap, struct prd__fetchByMerchantProductIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_prd__fetchByMerchantProductIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__fetchByMerchantProductIdResponse * SOAP_FMAC4 soap_in_prd__fetchByMerchantProductIdResponse(struct soap *soap, const char *tag, struct prd__fetchByMerchantProductIdResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__product = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct prd__fetchByMerchantProductIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_prd__fetchByMerchantProductIdResponse, sizeof(struct prd__fetchByMerchantProductIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_prd__fetchByMerchantProductIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__product && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Product(soap, NULL, &a->_product, "vin:Product"))
				{	soap_flag__product--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct prd__fetchByMerchantProductIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_prd__fetchByMerchantProductIdResponse, 0, sizeof(struct prd__fetchByMerchantProductIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_prd__fetchByVid(struct soap *soap, struct prd__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_vid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_prd__fetchByVid(struct soap *soap, const struct prd__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_vid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_prd__fetchByVid(struct soap *soap, const struct prd__fetchByVid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_prd__fetchByVid);
	if (soap_out_prd__fetchByVid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_prd__fetchByVid(struct soap *soap, const char *tag, int id, const struct prd__fetchByVid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_prd__fetchByVid), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "vid", -1, &a->_vid, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct prd__fetchByVid * SOAP_FMAC4 soap_get_prd__fetchByVid(struct soap *soap, struct prd__fetchByVid *p, const char *tag, const char *type)
{
	if ((p = soap_in_prd__fetchByVid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__fetchByVid * SOAP_FMAC4 soap_in_prd__fetchByVid(struct soap *soap, const char *tag, struct prd__fetchByVid *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__vid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct prd__fetchByVid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_prd__fetchByVid, sizeof(struct prd__fetchByVid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_prd__fetchByVid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__vid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_vid, "xsd:string"))
				{	soap_flag__vid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct prd__fetchByVid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_prd__fetchByVid, 0, sizeof(struct prd__fetchByVid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_prd__fetchByVidResponse(struct soap *soap, struct prd__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_product = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_prd__fetchByVidResponse(struct soap *soap, const struct prd__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Product(soap, &a->_product);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_prd__fetchByVidResponse(struct soap *soap, const struct prd__fetchByVidResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_prd__fetchByVidResponse);
	if (soap_out_prd__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_prd__fetchByVidResponse(struct soap *soap, const char *tag, int id, const struct prd__fetchByVidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_prd__fetchByVidResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Product(soap, "product", -1, &a->_product, "vin:Product"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct prd__fetchByVidResponse * SOAP_FMAC4 soap_get_prd__fetchByVidResponse(struct soap *soap, struct prd__fetchByVidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_prd__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__fetchByVidResponse * SOAP_FMAC4 soap_in_prd__fetchByVidResponse(struct soap *soap, const char *tag, struct prd__fetchByVidResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__product = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct prd__fetchByVidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_prd__fetchByVidResponse, sizeof(struct prd__fetchByVidResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_prd__fetchByVidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__product && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Product(soap, NULL, &a->_product, "vin:Product"))
				{	soap_flag__product--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct prd__fetchByVidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_prd__fetchByVidResponse, 0, sizeof(struct prd__fetchByVidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_prd__update(struct soap *soap, struct prd__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_product = NULL;
	soap_default_vin__DuplicateBehavior(soap, &a->_duplicateBehavior);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_prd__update(struct soap *soap, const struct prd__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Product(soap, &a->_product);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_prd__update(struct soap *soap, const struct prd__update *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_prd__update);
	if (soap_out_prd__update(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_prd__update(struct soap *soap, const char *tag, int id, const struct prd__update *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_prd__update), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Product(soap, "product", -1, &a->_product, "vin:Product"))
		return soap->error;
	if (soap_out_vin__DuplicateBehavior(soap, "duplicateBehavior", -1, &a->_duplicateBehavior, "vin:DuplicateBehavior"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct prd__update * SOAP_FMAC4 soap_get_prd__update(struct soap *soap, struct prd__update *p, const char *tag, const char *type)
{
	if ((p = soap_in_prd__update(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__update * SOAP_FMAC4 soap_in_prd__update(struct soap *soap, const char *tag, struct prd__update *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__product = 1;
	size_t soap_flag__duplicateBehavior = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct prd__update *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_prd__update, sizeof(struct prd__update), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_prd__update(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__product && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Product(soap, NULL, &a->_product, "vin:Product"))
				{	soap_flag__product--;
					continue;
				}
			if (soap_flag__duplicateBehavior && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_vin__DuplicateBehavior(soap, NULL, &a->_duplicateBehavior, "vin:DuplicateBehavior"))
				{	soap_flag__duplicateBehavior--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct prd__update *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_prd__update, 0, sizeof(struct prd__update), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__duplicateBehavior > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_prd__updateResponse(struct soap *soap, struct prd__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_product = NULL;
	soap_default_xsd__boolean(soap, &a->_created);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_prd__updateResponse(struct soap *soap, const struct prd__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Product(soap, &a->_product);
	soap_embedded(soap, &a->_created, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_prd__updateResponse(struct soap *soap, const struct prd__updateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_prd__updateResponse);
	if (soap_out_prd__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_prd__updateResponse(struct soap *soap, const char *tag, int id, const struct prd__updateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_prd__updateResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Product(soap, "product", -1, &a->_product, "vin:Product"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "created", -1, &a->_created, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct prd__updateResponse * SOAP_FMAC4 soap_get_prd__updateResponse(struct soap *soap, struct prd__updateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_prd__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__updateResponse * SOAP_FMAC4 soap_in_prd__updateResponse(struct soap *soap, const char *tag, struct prd__updateResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__product = 1;
	size_t soap_flag__created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct prd__updateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_prd__updateResponse, sizeof(struct prd__updateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_prd__updateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__product && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Product(soap, NULL, &a->_product, "vin:Product"))
				{	soap_flag__product--;
					continue;
				}
			if (soap_flag__created && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_created, "xsd:boolean"))
				{	soap_flag__created--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct prd__updateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_prd__updateResponse, 0, sizeof(struct prd__updateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__created > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_met__report(struct soap *soap, struct met__report *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_method);
	soap_default_time(soap, &a->_begin);
	soap_default_time(soap, &a->_end);
	soap_default_int(soap, &a->_numFailed);
	a->_stats = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_met__report(struct soap *soap, const struct met__report *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_method);
	soap_embedded(soap, &a->_begin, SOAP_TYPE_time);
	soap_embedded(soap, &a->_end, SOAP_TYPE_time);
	soap_embedded(soap, &a->_numFailed, SOAP_TYPE_int);
	soap_serialize_PointerToArrayOfMetricStats(soap, &a->_stats);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_met__report(struct soap *soap, const struct met__report *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_met__report);
	if (soap_out_met__report(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_met__report(struct soap *soap, const char *tag, int id, const struct met__report *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_met__report), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "method", -1, &a->_method, "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "begin", -1, &a->_begin, "xsd:dateTime"))
		return soap->error;
	if (soap_out_time(soap, "end", -1, &a->_end, "xsd:dateTime"))
		return soap->error;
	if (soap_out_int(soap, "numFailed", -1, &a->_numFailed, "xsd:int"))
		return soap->error;
	if (soap_out_PointerToArrayOfMetricStats(soap, "stats", -1, &a->_stats, "vin:MetricStatistics"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct met__report * SOAP_FMAC4 soap_get_met__report(struct soap *soap, struct met__report *p, const char *tag, const char *type)
{
	if ((p = soap_in_met__report(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct met__report * SOAP_FMAC4 soap_in_met__report(struct soap *soap, const char *tag, struct met__report *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__method = 1;
	size_t soap_flag__begin = 1;
	size_t soap_flag__end = 1;
	size_t soap_flag__numFailed = 1;
	size_t soap_flag__stats = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct met__report *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_met__report, sizeof(struct met__report), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_met__report(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__method && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_method, "xsd:string"))
				{	soap_flag__method--;
					continue;
				}
			if (soap_flag__begin && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_begin, "xsd:dateTime"))
				{	soap_flag__begin--;
					continue;
				}
			if (soap_flag__end && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_end, "xsd:dateTime"))
				{	soap_flag__end--;
					continue;
				}
			if (soap_flag__numFailed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_numFailed, "xsd:int"))
				{	soap_flag__numFailed--;
					continue;
				}
			if (soap_flag__stats && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfMetricStats(soap, NULL, &a->_stats, "vin:MetricStatistics"))
				{	soap_flag__stats--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct met__report *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_met__report, 0, sizeof(struct met__report), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__begin > 0 || soap_flag__end > 0 || soap_flag__numFailed > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_met__reportResponse(struct soap *soap, struct met__reportResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_met__reportResponse(struct soap *soap, const struct met__reportResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_met__reportResponse(struct soap *soap, const struct met__reportResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_met__reportResponse);
	if (soap_out_met__reportResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_met__reportResponse(struct soap *soap, const char *tag, int id, const struct met__reportResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_met__reportResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct met__reportResponse * SOAP_FMAC4 soap_get_met__reportResponse(struct soap *soap, struct met__reportResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_met__reportResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct met__reportResponse * SOAP_FMAC4 soap_in_met__reportResponse(struct soap *soap, const char *tag, struct met__reportResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct met__reportResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_met__reportResponse, sizeof(struct met__reportResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_met__reportResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct met__reportResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_met__reportResponse, 0, sizeof(struct met__reportResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_etp__fetchByTypeAndVersion(struct soap *soap, struct etp__fetchByTypeAndVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_product = NULL;
	soap_default_vin__EmailTemplateType(soap, &a->_type);
	soap_default_string(soap, &a->_version);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_etp__fetchByTypeAndVersion(struct soap *soap, const struct etp__fetchByTypeAndVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Product(soap, &a->_product);
	soap_embedded(soap, &a->_type, SOAP_TYPE_vin__EmailTemplateType);
	soap_serialize_string(soap, &a->_version);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_etp__fetchByTypeAndVersion(struct soap *soap, const struct etp__fetchByTypeAndVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_etp__fetchByTypeAndVersion);
	if (soap_out_etp__fetchByTypeAndVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_etp__fetchByTypeAndVersion(struct soap *soap, const char *tag, int id, const struct etp__fetchByTypeAndVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_etp__fetchByTypeAndVersion), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Product(soap, "product", -1, &a->_product, "vin:Product"))
		return soap->error;
	if (soap_out_vin__EmailTemplateType(soap, "type", -1, &a->_type, "vin:EmailTemplateType"))
		return soap->error;
	if (soap_out_string(soap, "version", -1, &a->_version, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct etp__fetchByTypeAndVersion * SOAP_FMAC4 soap_get_etp__fetchByTypeAndVersion(struct soap *soap, struct etp__fetchByTypeAndVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_etp__fetchByTypeAndVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct etp__fetchByTypeAndVersion * SOAP_FMAC4 soap_in_etp__fetchByTypeAndVersion(struct soap *soap, const char *tag, struct etp__fetchByTypeAndVersion *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__product = 1;
	size_t soap_flag__type = 1;
	size_t soap_flag__version = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct etp__fetchByTypeAndVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_etp__fetchByTypeAndVersion, sizeof(struct etp__fetchByTypeAndVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_etp__fetchByTypeAndVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__product && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Product(soap, NULL, &a->_product, "vin:Product"))
				{	soap_flag__product--;
					continue;
				}
			if (soap_flag__type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_vin__EmailTemplateType(soap, NULL, &a->_type, "vin:EmailTemplateType"))
				{	soap_flag__type--;
					continue;
				}
			if (soap_flag__version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_version, "xsd:string"))
				{	soap_flag__version--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct etp__fetchByTypeAndVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_etp__fetchByTypeAndVersion, 0, sizeof(struct etp__fetchByTypeAndVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_etp__fetchByTypeAndVersionResponse(struct soap *soap, struct etp__fetchByTypeAndVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_template_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_etp__fetchByTypeAndVersionResponse(struct soap *soap, const struct etp__fetchByTypeAndVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__EmailTemplate(soap, &a->_template_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_etp__fetchByTypeAndVersionResponse(struct soap *soap, const struct etp__fetchByTypeAndVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_etp__fetchByTypeAndVersionResponse);
	if (soap_out_etp__fetchByTypeAndVersionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_etp__fetchByTypeAndVersionResponse(struct soap *soap, const char *tag, int id, const struct etp__fetchByTypeAndVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_etp__fetchByTypeAndVersionResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__EmailTemplate(soap, "template", -1, &a->_template_, "vin:EmailTemplate"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct etp__fetchByTypeAndVersionResponse * SOAP_FMAC4 soap_get_etp__fetchByTypeAndVersionResponse(struct soap *soap, struct etp__fetchByTypeAndVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_etp__fetchByTypeAndVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct etp__fetchByTypeAndVersionResponse * SOAP_FMAC4 soap_in_etp__fetchByTypeAndVersionResponse(struct soap *soap, const char *tag, struct etp__fetchByTypeAndVersionResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__template_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct etp__fetchByTypeAndVersionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_etp__fetchByTypeAndVersionResponse, sizeof(struct etp__fetchByTypeAndVersionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_etp__fetchByTypeAndVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__template_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__EmailTemplate(soap, NULL, &a->_template_, "vin:EmailTemplate"))
				{	soap_flag__template_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct etp__fetchByTypeAndVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_etp__fetchByTypeAndVersionResponse, 0, sizeof(struct etp__fetchByTypeAndVersionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_etp__fetchByType(struct soap *soap, struct etp__fetchByType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_product = NULL;
	soap_default_vin__EmailTemplateType(soap, &a->_type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_etp__fetchByType(struct soap *soap, const struct etp__fetchByType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Product(soap, &a->_product);
	soap_embedded(soap, &a->_type, SOAP_TYPE_vin__EmailTemplateType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_etp__fetchByType(struct soap *soap, const struct etp__fetchByType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_etp__fetchByType);
	if (soap_out_etp__fetchByType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_etp__fetchByType(struct soap *soap, const char *tag, int id, const struct etp__fetchByType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_etp__fetchByType), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Product(soap, "product", -1, &a->_product, "vin:Product"))
		return soap->error;
	if (soap_out_vin__EmailTemplateType(soap, "type", -1, &a->_type, "vin:EmailTemplateType"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct etp__fetchByType * SOAP_FMAC4 soap_get_etp__fetchByType(struct soap *soap, struct etp__fetchByType *p, const char *tag, const char *type)
{
	if ((p = soap_in_etp__fetchByType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct etp__fetchByType * SOAP_FMAC4 soap_in_etp__fetchByType(struct soap *soap, const char *tag, struct etp__fetchByType *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__product = 1;
	size_t soap_flag__type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct etp__fetchByType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_etp__fetchByType, sizeof(struct etp__fetchByType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_etp__fetchByType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__product && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Product(soap, NULL, &a->_product, "vin:Product"))
				{	soap_flag__product--;
					continue;
				}
			if (soap_flag__type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_vin__EmailTemplateType(soap, NULL, &a->_type, "vin:EmailTemplateType"))
				{	soap_flag__type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct etp__fetchByType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_etp__fetchByType, 0, sizeof(struct etp__fetchByType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_etp__fetchByTypeResponse(struct soap *soap, struct etp__fetchByTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_template_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_etp__fetchByTypeResponse(struct soap *soap, const struct etp__fetchByTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfEmailTemplates(soap, &a->_template_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_etp__fetchByTypeResponse(struct soap *soap, const struct etp__fetchByTypeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_etp__fetchByTypeResponse);
	if (soap_out_etp__fetchByTypeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_etp__fetchByTypeResponse(struct soap *soap, const char *tag, int id, const struct etp__fetchByTypeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_etp__fetchByTypeResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfEmailTemplates(soap, "template", -1, &a->_template_, "vin:EmailTemplate"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct etp__fetchByTypeResponse * SOAP_FMAC4 soap_get_etp__fetchByTypeResponse(struct soap *soap, struct etp__fetchByTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_etp__fetchByTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct etp__fetchByTypeResponse * SOAP_FMAC4 soap_in_etp__fetchByTypeResponse(struct soap *soap, const char *tag, struct etp__fetchByTypeResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__template_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct etp__fetchByTypeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_etp__fetchByTypeResponse, sizeof(struct etp__fetchByTypeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_etp__fetchByTypeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__template_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfEmailTemplates(soap, NULL, &a->_template_, "vin:EmailTemplate"))
				{	soap_flag__template_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct etp__fetchByTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_etp__fetchByTypeResponse, 0, sizeof(struct etp__fetchByTypeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_etp__fetchByProduct(struct soap *soap, struct etp__fetchByProduct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_product = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_etp__fetchByProduct(struct soap *soap, const struct etp__fetchByProduct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Product(soap, &a->_product);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_etp__fetchByProduct(struct soap *soap, const struct etp__fetchByProduct *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_etp__fetchByProduct);
	if (soap_out_etp__fetchByProduct(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_etp__fetchByProduct(struct soap *soap, const char *tag, int id, const struct etp__fetchByProduct *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_etp__fetchByProduct), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Product(soap, "product", -1, &a->_product, "vin:Product"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct etp__fetchByProduct * SOAP_FMAC4 soap_get_etp__fetchByProduct(struct soap *soap, struct etp__fetchByProduct *p, const char *tag, const char *type)
{
	if ((p = soap_in_etp__fetchByProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct etp__fetchByProduct * SOAP_FMAC4 soap_in_etp__fetchByProduct(struct soap *soap, const char *tag, struct etp__fetchByProduct *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__product = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct etp__fetchByProduct *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_etp__fetchByProduct, sizeof(struct etp__fetchByProduct), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_etp__fetchByProduct(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__product && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Product(soap, NULL, &a->_product, "vin:Product"))
				{	soap_flag__product--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct etp__fetchByProduct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_etp__fetchByProduct, 0, sizeof(struct etp__fetchByProduct), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_etp__fetchByProductResponse(struct soap *soap, struct etp__fetchByProductResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_templates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_etp__fetchByProductResponse(struct soap *soap, const struct etp__fetchByProductResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfEmailTemplates(soap, &a->_templates);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_etp__fetchByProductResponse(struct soap *soap, const struct etp__fetchByProductResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_etp__fetchByProductResponse);
	if (soap_out_etp__fetchByProductResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_etp__fetchByProductResponse(struct soap *soap, const char *tag, int id, const struct etp__fetchByProductResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_etp__fetchByProductResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfEmailTemplates(soap, "templates", -1, &a->_templates, "vin:EmailTemplate"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct etp__fetchByProductResponse * SOAP_FMAC4 soap_get_etp__fetchByProductResponse(struct soap *soap, struct etp__fetchByProductResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_etp__fetchByProductResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct etp__fetchByProductResponse * SOAP_FMAC4 soap_in_etp__fetchByProductResponse(struct soap *soap, const char *tag, struct etp__fetchByProductResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__templates = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct etp__fetchByProductResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_etp__fetchByProductResponse, sizeof(struct etp__fetchByProductResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_etp__fetchByProductResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__templates && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfEmailTemplates(soap, NULL, &a->_templates, "vin:EmailTemplate"))
				{	soap_flag__templates--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct etp__fetchByProductResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_etp__fetchByProductResponse, 0, sizeof(struct etp__fetchByProductResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_etp__fetchByVid(struct soap *soap, struct etp__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_vid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_etp__fetchByVid(struct soap *soap, const struct etp__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_vid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_etp__fetchByVid(struct soap *soap, const struct etp__fetchByVid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_etp__fetchByVid);
	if (soap_out_etp__fetchByVid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_etp__fetchByVid(struct soap *soap, const char *tag, int id, const struct etp__fetchByVid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_etp__fetchByVid), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "vid", -1, &a->_vid, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct etp__fetchByVid * SOAP_FMAC4 soap_get_etp__fetchByVid(struct soap *soap, struct etp__fetchByVid *p, const char *tag, const char *type)
{
	if ((p = soap_in_etp__fetchByVid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct etp__fetchByVid * SOAP_FMAC4 soap_in_etp__fetchByVid(struct soap *soap, const char *tag, struct etp__fetchByVid *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__vid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct etp__fetchByVid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_etp__fetchByVid, sizeof(struct etp__fetchByVid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_etp__fetchByVid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__vid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_vid, "xsd:string"))
				{	soap_flag__vid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct etp__fetchByVid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_etp__fetchByVid, 0, sizeof(struct etp__fetchByVid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_etp__fetchByVidResponse(struct soap *soap, struct etp__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_template_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_etp__fetchByVidResponse(struct soap *soap, const struct etp__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__EmailTemplate(soap, &a->_template_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_etp__fetchByVidResponse(struct soap *soap, const struct etp__fetchByVidResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_etp__fetchByVidResponse);
	if (soap_out_etp__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_etp__fetchByVidResponse(struct soap *soap, const char *tag, int id, const struct etp__fetchByVidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_etp__fetchByVidResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__EmailTemplate(soap, "template", -1, &a->_template_, "vin:EmailTemplate"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct etp__fetchByVidResponse * SOAP_FMAC4 soap_get_etp__fetchByVidResponse(struct soap *soap, struct etp__fetchByVidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_etp__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct etp__fetchByVidResponse * SOAP_FMAC4 soap_in_etp__fetchByVidResponse(struct soap *soap, const char *tag, struct etp__fetchByVidResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__template_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct etp__fetchByVidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_etp__fetchByVidResponse, sizeof(struct etp__fetchByVidResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_etp__fetchByVidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__template_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__EmailTemplate(soap, NULL, &a->_template_, "vin:EmailTemplate"))
				{	soap_flag__template_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct etp__fetchByVidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_etp__fetchByVidResponse, 0, sizeof(struct etp__fetchByVidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_etp__update(struct soap *soap, struct etp__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_template_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_etp__update(struct soap *soap, const struct etp__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__EmailTemplate(soap, &a->_template_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_etp__update(struct soap *soap, const struct etp__update *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_etp__update);
	if (soap_out_etp__update(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_etp__update(struct soap *soap, const char *tag, int id, const struct etp__update *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_etp__update), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__EmailTemplate(soap, "template", -1, &a->_template_, "vin:EmailTemplate"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct etp__update * SOAP_FMAC4 soap_get_etp__update(struct soap *soap, struct etp__update *p, const char *tag, const char *type)
{
	if ((p = soap_in_etp__update(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct etp__update * SOAP_FMAC4 soap_in_etp__update(struct soap *soap, const char *tag, struct etp__update *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__template_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct etp__update *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_etp__update, sizeof(struct etp__update), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_etp__update(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__template_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__EmailTemplate(soap, NULL, &a->_template_, "vin:EmailTemplate"))
				{	soap_flag__template_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct etp__update *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_etp__update, 0, sizeof(struct etp__update), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_etp__updateResponse(struct soap *soap, struct etp__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_template_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_etp__updateResponse(struct soap *soap, const struct etp__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__EmailTemplate(soap, &a->_template_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_etp__updateResponse(struct soap *soap, const struct etp__updateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_etp__updateResponse);
	if (soap_out_etp__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_etp__updateResponse(struct soap *soap, const char *tag, int id, const struct etp__updateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_etp__updateResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__EmailTemplate(soap, "template", -1, &a->_template_, "vin:EmailTemplate"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct etp__updateResponse * SOAP_FMAC4 soap_get_etp__updateResponse(struct soap *soap, struct etp__updateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_etp__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct etp__updateResponse * SOAP_FMAC4 soap_in_etp__updateResponse(struct soap *soap, const char *tag, struct etp__updateResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__template_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct etp__updateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_etp__updateResponse, sizeof(struct etp__updateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_etp__updateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__template_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__EmailTemplate(soap, NULL, &a->_template_, "vin:EmailTemplate"))
				{	soap_flag__template_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct etp__updateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_etp__updateResponse, 0, sizeof(struct etp__updateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__fetchDeltaSince(struct soap *soap, struct ent__fetchDeltaSince *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_time(soap, &a->_timestamp);
	soap_default_int(soap, &a->_page);
	soap_default_int(soap, &a->_pageSize);
	soap_default_time(soap, &a->_endTimestamp);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ent__fetchDeltaSince(struct soap *soap, const struct ent__fetchDeltaSince *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_embedded(soap, &a->_timestamp, SOAP_TYPE_time);
	soap_embedded(soap, &a->_page, SOAP_TYPE_int);
	soap_embedded(soap, &a->_pageSize, SOAP_TYPE_int);
	soap_embedded(soap, &a->_endTimestamp, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__fetchDeltaSince(struct soap *soap, const struct ent__fetchDeltaSince *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__fetchDeltaSince);
	if (soap_out_ent__fetchDeltaSince(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ent__fetchDeltaSince(struct soap *soap, const char *tag, int id, const struct ent__fetchDeltaSince *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__fetchDeltaSince), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_time(soap, "timestamp", -1, &a->_timestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_int(soap, "page", -1, &a->_page, "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "pageSize", -1, &a->_pageSize, "xsd:int"))
		return soap->error;
	if (soap_out_time(soap, "endTimestamp", -1, &a->_endTimestamp, "xsd:dateTime"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ent__fetchDeltaSince * SOAP_FMAC4 soap_get_ent__fetchDeltaSince(struct soap *soap, struct ent__fetchDeltaSince *p, const char *tag, const char *type)
{
	if ((p = soap_in_ent__fetchDeltaSince(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ent__fetchDeltaSince * SOAP_FMAC4 soap_in_ent__fetchDeltaSince(struct soap *soap, const char *tag, struct ent__fetchDeltaSince *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__timestamp = 1;
	size_t soap_flag__page = 1;
	size_t soap_flag__pageSize = 1;
	size_t soap_flag__endTimestamp = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ent__fetchDeltaSince *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__fetchDeltaSince, sizeof(struct ent__fetchDeltaSince), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ent__fetchDeltaSince(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_timestamp, "xsd:dateTime"))
				{	soap_flag__timestamp--;
					continue;
				}
			if (soap_flag__page && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_page, "xsd:int"))
				{	soap_flag__page--;
					continue;
				}
			if (soap_flag__pageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_pageSize, "xsd:int"))
				{	soap_flag__pageSize--;
					continue;
				}
			if (soap_flag__endTimestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_endTimestamp, "xsd:dateTime"))
				{	soap_flag__endTimestamp--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ent__fetchDeltaSince *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__fetchDeltaSince, 0, sizeof(struct ent__fetchDeltaSince), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__timestamp > 0 || soap_flag__page > 0 || soap_flag__pageSize > 0 || soap_flag__endTimestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__fetchDeltaSinceResponse(struct soap *soap, struct ent__fetchDeltaSinceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_entitlements = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ent__fetchDeltaSinceResponse(struct soap *soap, const struct ent__fetchDeltaSinceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfEntitlements(soap, &a->_entitlements);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__fetchDeltaSinceResponse(struct soap *soap, const struct ent__fetchDeltaSinceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__fetchDeltaSinceResponse);
	if (soap_out_ent__fetchDeltaSinceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ent__fetchDeltaSinceResponse(struct soap *soap, const char *tag, int id, const struct ent__fetchDeltaSinceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__fetchDeltaSinceResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfEntitlements(soap, "entitlements", -1, &a->_entitlements, "vin:Entitlement"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ent__fetchDeltaSinceResponse * SOAP_FMAC4 soap_get_ent__fetchDeltaSinceResponse(struct soap *soap, struct ent__fetchDeltaSinceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ent__fetchDeltaSinceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ent__fetchDeltaSinceResponse * SOAP_FMAC4 soap_in_ent__fetchDeltaSinceResponse(struct soap *soap, const char *tag, struct ent__fetchDeltaSinceResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__entitlements = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ent__fetchDeltaSinceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__fetchDeltaSinceResponse, sizeof(struct ent__fetchDeltaSinceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ent__fetchDeltaSinceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__entitlements && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfEntitlements(soap, NULL, &a->_entitlements, "vin:Entitlement"))
				{	soap_flag__entitlements--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ent__fetchDeltaSinceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__fetchDeltaSinceResponse, 0, sizeof(struct ent__fetchDeltaSinceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__fetchByAccount(struct soap *soap, struct ent__fetchByAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_account = NULL;
	soap_default_xsd__boolean(soap, &a->_showAll);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ent__fetchByAccount(struct soap *soap, const struct ent__fetchByAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
	soap_embedded(soap, &a->_showAll, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__fetchByAccount(struct soap *soap, const struct ent__fetchByAccount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__fetchByAccount);
	if (soap_out_ent__fetchByAccount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ent__fetchByAccount(struct soap *soap, const char *tag, int id, const struct ent__fetchByAccount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__fetchByAccount), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "showAll", -1, &a->_showAll, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ent__fetchByAccount * SOAP_FMAC4 soap_get_ent__fetchByAccount(struct soap *soap, struct ent__fetchByAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ent__fetchByAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ent__fetchByAccount * SOAP_FMAC4 soap_in_ent__fetchByAccount(struct soap *soap, const char *tag, struct ent__fetchByAccount *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__account = 1;
	size_t soap_flag__showAll = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ent__fetchByAccount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__fetchByAccount, sizeof(struct ent__fetchByAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ent__fetchByAccount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap_flag__showAll && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_showAll, "xsd:boolean"))
				{	soap_flag__showAll--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ent__fetchByAccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__fetchByAccount, 0, sizeof(struct ent__fetchByAccount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__showAll > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__fetchByAccountResponse(struct soap *soap, struct ent__fetchByAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_entitlements = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ent__fetchByAccountResponse(struct soap *soap, const struct ent__fetchByAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfEntitlements(soap, &a->_entitlements);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__fetchByAccountResponse(struct soap *soap, const struct ent__fetchByAccountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__fetchByAccountResponse);
	if (soap_out_ent__fetchByAccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ent__fetchByAccountResponse(struct soap *soap, const char *tag, int id, const struct ent__fetchByAccountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__fetchByAccountResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfEntitlements(soap, "entitlements", -1, &a->_entitlements, "vin:Entitlement"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ent__fetchByAccountResponse * SOAP_FMAC4 soap_get_ent__fetchByAccountResponse(struct soap *soap, struct ent__fetchByAccountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ent__fetchByAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ent__fetchByAccountResponse * SOAP_FMAC4 soap_in_ent__fetchByAccountResponse(struct soap *soap, const char *tag, struct ent__fetchByAccountResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__entitlements = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ent__fetchByAccountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__fetchByAccountResponse, sizeof(struct ent__fetchByAccountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ent__fetchByAccountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__entitlements && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfEntitlements(soap, NULL, &a->_entitlements, "vin:Entitlement"))
				{	soap_flag__entitlements--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ent__fetchByAccountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__fetchByAccountResponse, 0, sizeof(struct ent__fetchByAccountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__fetchByEntitlementIdAndAccount(struct soap *soap, struct ent__fetchByEntitlementIdAndAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_entitlementId);
	a->_account = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ent__fetchByEntitlementIdAndAccount(struct soap *soap, const struct ent__fetchByEntitlementIdAndAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_entitlementId);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__fetchByEntitlementIdAndAccount(struct soap *soap, const struct ent__fetchByEntitlementIdAndAccount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__fetchByEntitlementIdAndAccount);
	if (soap_out_ent__fetchByEntitlementIdAndAccount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ent__fetchByEntitlementIdAndAccount(struct soap *soap, const char *tag, int id, const struct ent__fetchByEntitlementIdAndAccount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__fetchByEntitlementIdAndAccount), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "entitlementId", -1, &a->_entitlementId, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ent__fetchByEntitlementIdAndAccount * SOAP_FMAC4 soap_get_ent__fetchByEntitlementIdAndAccount(struct soap *soap, struct ent__fetchByEntitlementIdAndAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ent__fetchByEntitlementIdAndAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ent__fetchByEntitlementIdAndAccount * SOAP_FMAC4 soap_in_ent__fetchByEntitlementIdAndAccount(struct soap *soap, const char *tag, struct ent__fetchByEntitlementIdAndAccount *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__entitlementId = 1;
	size_t soap_flag__account = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ent__fetchByEntitlementIdAndAccount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__fetchByEntitlementIdAndAccount, sizeof(struct ent__fetchByEntitlementIdAndAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ent__fetchByEntitlementIdAndAccount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__entitlementId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_entitlementId, "xsd:string"))
				{	soap_flag__entitlementId--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ent__fetchByEntitlementIdAndAccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__fetchByEntitlementIdAndAccount, 0, sizeof(struct ent__fetchByEntitlementIdAndAccount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ent__fetchByEntitlementIdAndAccountResponse(struct soap *soap, struct ent__fetchByEntitlementIdAndAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_entitlement = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ent__fetchByEntitlementIdAndAccountResponse(struct soap *soap, const struct ent__fetchByEntitlementIdAndAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Entitlement(soap, &a->_entitlement);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ent__fetchByEntitlementIdAndAccountResponse(struct soap *soap, const struct ent__fetchByEntitlementIdAndAccountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ent__fetchByEntitlementIdAndAccountResponse);
	if (soap_out_ent__fetchByEntitlementIdAndAccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ent__fetchByEntitlementIdAndAccountResponse(struct soap *soap, const char *tag, int id, const struct ent__fetchByEntitlementIdAndAccountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ent__fetchByEntitlementIdAndAccountResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Entitlement(soap, "entitlement", -1, &a->_entitlement, "vin:Entitlement"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ent__fetchByEntitlementIdAndAccountResponse * SOAP_FMAC4 soap_get_ent__fetchByEntitlementIdAndAccountResponse(struct soap *soap, struct ent__fetchByEntitlementIdAndAccountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ent__fetchByEntitlementIdAndAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ent__fetchByEntitlementIdAndAccountResponse * SOAP_FMAC4 soap_in_ent__fetchByEntitlementIdAndAccountResponse(struct soap *soap, const char *tag, struct ent__fetchByEntitlementIdAndAccountResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__entitlement = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ent__fetchByEntitlementIdAndAccountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ent__fetchByEntitlementIdAndAccountResponse, sizeof(struct ent__fetchByEntitlementIdAndAccountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ent__fetchByEntitlementIdAndAccountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__entitlement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Entitlement(soap, NULL, &a->_entitlement, "vin:Entitlement"))
				{	soap_flag__entitlement--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ent__fetchByEntitlementIdAndAccountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ent__fetchByEntitlementIdAndAccountResponse, 0, sizeof(struct ent__fetchByEntitlementIdAndAccountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ecs__getSignatureBlock(struct soap *soap, struct ecs__getSignatureBlock *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_vindiciaUriBase);
	soap_default_string(soap, &a->_formTarget);
	soap_default_string(soap, &a->_noscript);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ecs__getSignatureBlock(struct soap *soap, const struct ecs__getSignatureBlock *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_vindiciaUriBase);
	soap_serialize_string(soap, &a->_formTarget);
	soap_serialize_string(soap, &a->_noscript);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ecs__getSignatureBlock(struct soap *soap, const struct ecs__getSignatureBlock *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ecs__getSignatureBlock);
	if (soap_out_ecs__getSignatureBlock(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ecs__getSignatureBlock(struct soap *soap, const char *tag, int id, const struct ecs__getSignatureBlock *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ecs__getSignatureBlock), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "vindiciaUriBase", -1, &a->_vindiciaUriBase, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "formTarget", -1, &a->_formTarget, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "noscript", -1, &a->_noscript, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ecs__getSignatureBlock * SOAP_FMAC4 soap_get_ecs__getSignatureBlock(struct soap *soap, struct ecs__getSignatureBlock *p, const char *tag, const char *type)
{
	if ((p = soap_in_ecs__getSignatureBlock(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ecs__getSignatureBlock * SOAP_FMAC4 soap_in_ecs__getSignatureBlock(struct soap *soap, const char *tag, struct ecs__getSignatureBlock *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__vindiciaUriBase = 1;
	size_t soap_flag__formTarget = 1;
	size_t soap_flag__noscript = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ecs__getSignatureBlock *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ecs__getSignatureBlock, sizeof(struct ecs__getSignatureBlock), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ecs__getSignatureBlock(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__vindiciaUriBase && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_vindiciaUriBase, "xsd:string"))
				{	soap_flag__vindiciaUriBase--;
					continue;
				}
			if (soap_flag__formTarget && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_formTarget, "xsd:string"))
				{	soap_flag__formTarget--;
					continue;
				}
			if (soap_flag__noscript && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_noscript, "xsd:string"))
				{	soap_flag__noscript--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ecs__getSignatureBlock *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ecs__getSignatureBlock, 0, sizeof(struct ecs__getSignatureBlock), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ecs__getSignatureBlockResponse(struct soap *soap, struct ecs__getSignatureBlockResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	soap_default_string(soap, &a->_signatureBlock);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ecs__getSignatureBlockResponse(struct soap *soap, const struct ecs__getSignatureBlockResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_string(soap, &a->_signatureBlock);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ecs__getSignatureBlockResponse(struct soap *soap, const struct ecs__getSignatureBlockResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ecs__getSignatureBlockResponse);
	if (soap_out_ecs__getSignatureBlockResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ecs__getSignatureBlockResponse(struct soap *soap, const char *tag, int id, const struct ecs__getSignatureBlockResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ecs__getSignatureBlockResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_string(soap, "signatureBlock", -1, &a->_signatureBlock, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ecs__getSignatureBlockResponse * SOAP_FMAC4 soap_get_ecs__getSignatureBlockResponse(struct soap *soap, struct ecs__getSignatureBlockResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ecs__getSignatureBlockResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ecs__getSignatureBlockResponse * SOAP_FMAC4 soap_in_ecs__getSignatureBlockResponse(struct soap *soap, const char *tag, struct ecs__getSignatureBlockResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__signatureBlock = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ecs__getSignatureBlockResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ecs__getSignatureBlockResponse, sizeof(struct ecs__getSignatureBlockResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ecs__getSignatureBlockResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__signatureBlock && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_signatureBlock, "xsd:string"))
				{	soap_flag__signatureBlock--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ecs__getSignatureBlockResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ecs__getSignatureBlockResponse, 0, sizeof(struct ecs__getSignatureBlockResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ecs__sign(struct soap *soap, struct ecs__sign *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_signature = NULL;
	soap_default_string(soap, &a->_formData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ecs__sign(struct soap *soap, const struct ecs__sign *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__ElectronicSignature(soap, &a->_signature);
	soap_serialize_string(soap, &a->_formData);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ecs__sign(struct soap *soap, const struct ecs__sign *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ecs__sign);
	if (soap_out_ecs__sign(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ecs__sign(struct soap *soap, const char *tag, int id, const struct ecs__sign *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ecs__sign), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__ElectronicSignature(soap, "signature", -1, &a->_signature, "vin:ElectronicSignature"))
		return soap->error;
	if (soap_out_string(soap, "formData", -1, &a->_formData, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ecs__sign * SOAP_FMAC4 soap_get_ecs__sign(struct soap *soap, struct ecs__sign *p, const char *tag, const char *type)
{
	if ((p = soap_in_ecs__sign(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ecs__sign * SOAP_FMAC4 soap_in_ecs__sign(struct soap *soap, const char *tag, struct ecs__sign *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__signature = 1;
	size_t soap_flag__formData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ecs__sign *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ecs__sign, sizeof(struct ecs__sign), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ecs__sign(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__signature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__ElectronicSignature(soap, NULL, &a->_signature, "vin:ElectronicSignature"))
				{	soap_flag__signature--;
					continue;
				}
			if (soap_flag__formData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_formData, "xsd:string"))
				{	soap_flag__formData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ecs__sign *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ecs__sign, 0, sizeof(struct ecs__sign), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ecs__signResponse(struct soap *soap, struct ecs__signResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	soap_default_string(soap, &a->_signatureBlock);
	soap_default_xsd__boolean(soap, &a->_signatureOk);
	a->_signature = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ecs__signResponse(struct soap *soap, const struct ecs__signResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_string(soap, &a->_signatureBlock);
	soap_embedded(soap, &a->_signatureOk, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTovin__ElectronicSignature(soap, &a->_signature);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ecs__signResponse(struct soap *soap, const struct ecs__signResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ecs__signResponse);
	if (soap_out_ecs__signResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ecs__signResponse(struct soap *soap, const char *tag, int id, const struct ecs__signResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ecs__signResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_string(soap, "signatureBlock", -1, &a->_signatureBlock, "xsd:string"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "signatureOk", -1, &a->_signatureOk, "xsd:boolean"))
		return soap->error;
	if (soap_out_PointerTovin__ElectronicSignature(soap, "signature", -1, &a->_signature, "vin:ElectronicSignature"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ecs__signResponse * SOAP_FMAC4 soap_get_ecs__signResponse(struct soap *soap, struct ecs__signResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ecs__signResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ecs__signResponse * SOAP_FMAC4 soap_in_ecs__signResponse(struct soap *soap, const char *tag, struct ecs__signResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__signatureBlock = 1;
	size_t soap_flag__signatureOk = 1;
	size_t soap_flag__signature = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ecs__signResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ecs__signResponse, sizeof(struct ecs__signResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ecs__signResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__signatureBlock && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_signatureBlock, "xsd:string"))
				{	soap_flag__signatureBlock--;
					continue;
				}
			if (soap_flag__signatureOk && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_signatureOk, "xsd:boolean"))
				{	soap_flag__signatureOk--;
					continue;
				}
			if (soap_flag__signature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__ElectronicSignature(soap, NULL, &a->_signature, "vin:ElectronicSignature"))
				{	soap_flag__signature--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ecs__signResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ecs__signResponse, 0, sizeof(struct ecs__signResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__signatureOk > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__report(struct soap *soap, struct cgb__report *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_chargebacks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__report(struct soap *soap, const struct cgb__report *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerToArrayOfChargebacks(soap, &a->_chargebacks);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__report(struct soap *soap, const struct cgb__report *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__report);
	if (soap_out_cgb__report(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__report(struct soap *soap, const char *tag, int id, const struct cgb__report *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__report), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerToArrayOfChargebacks(soap, "chargebacks", -1, &a->_chargebacks, "vin:Chargeback"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__report * SOAP_FMAC4 soap_get_cgb__report(struct soap *soap, struct cgb__report *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__report(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__report * SOAP_FMAC4 soap_in_cgb__report(struct soap *soap, const char *tag, struct cgb__report *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__chargebacks = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__report *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__report, sizeof(struct cgb__report), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__report(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__chargebacks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfChargebacks(soap, NULL, &a->_chargebacks, "vin:Chargeback"))
				{	soap_flag__chargebacks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__report *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__report, 0, sizeof(struct cgb__report), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__reportResponse(struct soap *soap, struct cgb__reportResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__reportResponse(struct soap *soap, const struct cgb__reportResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__reportResponse(struct soap *soap, const struct cgb__reportResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__reportResponse);
	if (soap_out_cgb__reportResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__reportResponse(struct soap *soap, const char *tag, int id, const struct cgb__reportResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__reportResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__reportResponse * SOAP_FMAC4 soap_get_cgb__reportResponse(struct soap *soap, struct cgb__reportResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__reportResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__reportResponse * SOAP_FMAC4 soap_in_cgb__reportResponse(struct soap *soap, const char *tag, struct cgb__reportResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__reportResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__reportResponse, sizeof(struct cgb__reportResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__reportResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__reportResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__reportResponse, 0, sizeof(struct cgb__reportResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchDelta(struct soap *soap, struct cgb__fetchDelta *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_int(soap, &a->_pageSize);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchDelta(struct soap *soap, const struct cgb__fetchDelta *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_embedded(soap, &a->_pageSize, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchDelta(struct soap *soap, const struct cgb__fetchDelta *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchDelta);
	if (soap_out_cgb__fetchDelta(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchDelta(struct soap *soap, const char *tag, int id, const struct cgb__fetchDelta *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchDelta), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_int(soap, "pageSize", -1, &a->_pageSize, "xsd:int"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchDelta * SOAP_FMAC4 soap_get_cgb__fetchDelta(struct soap *soap, struct cgb__fetchDelta *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchDelta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchDelta * SOAP_FMAC4 soap_in_cgb__fetchDelta(struct soap *soap, const char *tag, struct cgb__fetchDelta *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__pageSize = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchDelta *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchDelta, sizeof(struct cgb__fetchDelta), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchDelta(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__pageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_pageSize, "xsd:int"))
				{	soap_flag__pageSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchDelta *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchDelta, 0, sizeof(struct cgb__fetchDelta), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__pageSize > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchDeltaResponse(struct soap *soap, struct cgb__fetchDeltaResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_chargebacks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchDeltaResponse(struct soap *soap, const struct cgb__fetchDeltaResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfChargebacks(soap, &a->_chargebacks);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchDeltaResponse(struct soap *soap, const struct cgb__fetchDeltaResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchDeltaResponse);
	if (soap_out_cgb__fetchDeltaResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchDeltaResponse(struct soap *soap, const char *tag, int id, const struct cgb__fetchDeltaResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchDeltaResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfChargebacks(soap, "chargebacks", -1, &a->_chargebacks, "vin:Chargeback"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchDeltaResponse * SOAP_FMAC4 soap_get_cgb__fetchDeltaResponse(struct soap *soap, struct cgb__fetchDeltaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchDeltaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchDeltaResponse * SOAP_FMAC4 soap_in_cgb__fetchDeltaResponse(struct soap *soap, const char *tag, struct cgb__fetchDeltaResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__chargebacks = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchDeltaResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchDeltaResponse, sizeof(struct cgb__fetchDeltaResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchDeltaResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__chargebacks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfChargebacks(soap, NULL, &a->_chargebacks, "vin:Chargeback"))
				{	soap_flag__chargebacks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchDeltaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchDeltaResponse, 0, sizeof(struct cgb__fetchDeltaResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchDeltaSince(struct soap *soap, struct cgb__fetchDeltaSince *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_time(soap, &a->_timestamp);
	soap_default_time(soap, &a->_endTimestamp);
	soap_default_int(soap, &a->_page);
	soap_default_int(soap, &a->_pageSize);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchDeltaSince(struct soap *soap, const struct cgb__fetchDeltaSince *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_embedded(soap, &a->_timestamp, SOAP_TYPE_time);
	soap_embedded(soap, &a->_endTimestamp, SOAP_TYPE_time);
	soap_embedded(soap, &a->_page, SOAP_TYPE_int);
	soap_embedded(soap, &a->_pageSize, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchDeltaSince(struct soap *soap, const struct cgb__fetchDeltaSince *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchDeltaSince);
	if (soap_out_cgb__fetchDeltaSince(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchDeltaSince(struct soap *soap, const char *tag, int id, const struct cgb__fetchDeltaSince *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchDeltaSince), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_time(soap, "timestamp", -1, &a->_timestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_time(soap, "endTimestamp", -1, &a->_endTimestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_int(soap, "page", -1, &a->_page, "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "pageSize", -1, &a->_pageSize, "xsd:int"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchDeltaSince * SOAP_FMAC4 soap_get_cgb__fetchDeltaSince(struct soap *soap, struct cgb__fetchDeltaSince *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchDeltaSince(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchDeltaSince * SOAP_FMAC4 soap_in_cgb__fetchDeltaSince(struct soap *soap, const char *tag, struct cgb__fetchDeltaSince *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__timestamp = 1;
	size_t soap_flag__endTimestamp = 1;
	size_t soap_flag__page = 1;
	size_t soap_flag__pageSize = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchDeltaSince *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchDeltaSince, sizeof(struct cgb__fetchDeltaSince), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchDeltaSince(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_timestamp, "xsd:dateTime"))
				{	soap_flag__timestamp--;
					continue;
				}
			if (soap_flag__endTimestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_endTimestamp, "xsd:dateTime"))
				{	soap_flag__endTimestamp--;
					continue;
				}
			if (soap_flag__page && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_page, "xsd:int"))
				{	soap_flag__page--;
					continue;
				}
			if (soap_flag__pageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_pageSize, "xsd:int"))
				{	soap_flag__pageSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchDeltaSince *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchDeltaSince, 0, sizeof(struct cgb__fetchDeltaSince), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__timestamp > 0 || soap_flag__endTimestamp > 0 || soap_flag__page > 0 || soap_flag__pageSize > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchDeltaSinceResponse(struct soap *soap, struct cgb__fetchDeltaSinceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_chargebacks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchDeltaSinceResponse(struct soap *soap, const struct cgb__fetchDeltaSinceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfChargebacks(soap, &a->_chargebacks);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchDeltaSinceResponse(struct soap *soap, const struct cgb__fetchDeltaSinceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchDeltaSinceResponse);
	if (soap_out_cgb__fetchDeltaSinceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchDeltaSinceResponse(struct soap *soap, const char *tag, int id, const struct cgb__fetchDeltaSinceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchDeltaSinceResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfChargebacks(soap, "chargebacks", -1, &a->_chargebacks, "vin:Chargeback"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchDeltaSinceResponse * SOAP_FMAC4 soap_get_cgb__fetchDeltaSinceResponse(struct soap *soap, struct cgb__fetchDeltaSinceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchDeltaSinceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchDeltaSinceResponse * SOAP_FMAC4 soap_in_cgb__fetchDeltaSinceResponse(struct soap *soap, const char *tag, struct cgb__fetchDeltaSinceResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__chargebacks = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchDeltaSinceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchDeltaSinceResponse, sizeof(struct cgb__fetchDeltaSinceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchDeltaSinceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__chargebacks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfChargebacks(soap, NULL, &a->_chargebacks, "vin:Chargeback"))
				{	soap_flag__chargebacks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchDeltaSinceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchDeltaSinceResponse, 0, sizeof(struct cgb__fetchDeltaSinceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchByMerchantTransactionId(struct soap *soap, struct cgb__fetchByMerchantTransactionId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_merchantTransactionId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchByMerchantTransactionId(struct soap *soap, const struct cgb__fetchByMerchantTransactionId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_merchantTransactionId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchByMerchantTransactionId(struct soap *soap, const struct cgb__fetchByMerchantTransactionId *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchByMerchantTransactionId);
	if (soap_out_cgb__fetchByMerchantTransactionId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchByMerchantTransactionId(struct soap *soap, const char *tag, int id, const struct cgb__fetchByMerchantTransactionId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchByMerchantTransactionId), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "merchantTransactionId", -1, &a->_merchantTransactionId, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchByMerchantTransactionId * SOAP_FMAC4 soap_get_cgb__fetchByMerchantTransactionId(struct soap *soap, struct cgb__fetchByMerchantTransactionId *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchByMerchantTransactionId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByMerchantTransactionId * SOAP_FMAC4 soap_in_cgb__fetchByMerchantTransactionId(struct soap *soap, const char *tag, struct cgb__fetchByMerchantTransactionId *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__merchantTransactionId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchByMerchantTransactionId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchByMerchantTransactionId, sizeof(struct cgb__fetchByMerchantTransactionId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchByMerchantTransactionId(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__merchantTransactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_merchantTransactionId, "xsd:string"))
				{	soap_flag__merchantTransactionId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByMerchantTransactionId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchByMerchantTransactionId, 0, sizeof(struct cgb__fetchByMerchantTransactionId), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchByMerchantTransactionIdResponse(struct soap *soap, struct cgb__fetchByMerchantTransactionIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_chargebacks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchByMerchantTransactionIdResponse(struct soap *soap, const struct cgb__fetchByMerchantTransactionIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfChargebacks(soap, &a->_chargebacks);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchByMerchantTransactionIdResponse(struct soap *soap, const struct cgb__fetchByMerchantTransactionIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchByMerchantTransactionIdResponse);
	if (soap_out_cgb__fetchByMerchantTransactionIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchByMerchantTransactionIdResponse(struct soap *soap, const char *tag, int id, const struct cgb__fetchByMerchantTransactionIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchByMerchantTransactionIdResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfChargebacks(soap, "chargebacks", -1, &a->_chargebacks, "vin:Chargeback"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchByMerchantTransactionIdResponse * SOAP_FMAC4 soap_get_cgb__fetchByMerchantTransactionIdResponse(struct soap *soap, struct cgb__fetchByMerchantTransactionIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchByMerchantTransactionIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByMerchantTransactionIdResponse * SOAP_FMAC4 soap_in_cgb__fetchByMerchantTransactionIdResponse(struct soap *soap, const char *tag, struct cgb__fetchByMerchantTransactionIdResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__chargebacks = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchByMerchantTransactionIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchByMerchantTransactionIdResponse, sizeof(struct cgb__fetchByMerchantTransactionIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchByMerchantTransactionIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__chargebacks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfChargebacks(soap, NULL, &a->_chargebacks, "vin:Chargeback"))
				{	soap_flag__chargebacks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByMerchantTransactionIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchByMerchantTransactionIdResponse, 0, sizeof(struct cgb__fetchByMerchantTransactionIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchByStatusSince(struct soap *soap, struct cgb__fetchByStatusSince *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_vin__ChargebackStatus(soap, &a->_status);
	soap_default_time(soap, &a->_timestamp);
	soap_default_int(soap, &a->_page);
	soap_default_int(soap, &a->_pageSize);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchByStatusSince(struct soap *soap, const struct cgb__fetchByStatusSince *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_embedded(soap, &a->_timestamp, SOAP_TYPE_time);
	soap_embedded(soap, &a->_page, SOAP_TYPE_int);
	soap_embedded(soap, &a->_pageSize, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchByStatusSince(struct soap *soap, const struct cgb__fetchByStatusSince *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchByStatusSince);
	if (soap_out_cgb__fetchByStatusSince(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchByStatusSince(struct soap *soap, const char *tag, int id, const struct cgb__fetchByStatusSince *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchByStatusSince), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_vin__ChargebackStatus(soap, "status", -1, &a->_status, "vin:ChargebackStatus"))
		return soap->error;
	if (soap_out_time(soap, "timestamp", -1, &a->_timestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_int(soap, "page", -1, &a->_page, "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "pageSize", -1, &a->_pageSize, "xsd:int"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchByStatusSince * SOAP_FMAC4 soap_get_cgb__fetchByStatusSince(struct soap *soap, struct cgb__fetchByStatusSince *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchByStatusSince(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByStatusSince * SOAP_FMAC4 soap_in_cgb__fetchByStatusSince(struct soap *soap, const char *tag, struct cgb__fetchByStatusSince *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__status = 1;
	size_t soap_flag__timestamp = 1;
	size_t soap_flag__page = 1;
	size_t soap_flag__pageSize = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchByStatusSince *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchByStatusSince, sizeof(struct cgb__fetchByStatusSince), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchByStatusSince(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_vin__ChargebackStatus(soap, NULL, &a->_status, "vin:ChargebackStatus"))
				{	soap_flag__status--;
					continue;
				}
			if (soap_flag__timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_timestamp, "xsd:dateTime"))
				{	soap_flag__timestamp--;
					continue;
				}
			if (soap_flag__page && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_page, "xsd:int"))
				{	soap_flag__page--;
					continue;
				}
			if (soap_flag__pageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_pageSize, "xsd:int"))
				{	soap_flag__pageSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByStatusSince *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchByStatusSince, 0, sizeof(struct cgb__fetchByStatusSince), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__status > 0 || soap_flag__timestamp > 0 || soap_flag__page > 0 || soap_flag__pageSize > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchByStatusSinceResponse(struct soap *soap, struct cgb__fetchByStatusSinceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_chargebacks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchByStatusSinceResponse(struct soap *soap, const struct cgb__fetchByStatusSinceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfChargebacks(soap, &a->_chargebacks);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchByStatusSinceResponse(struct soap *soap, const struct cgb__fetchByStatusSinceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchByStatusSinceResponse);
	if (soap_out_cgb__fetchByStatusSinceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchByStatusSinceResponse(struct soap *soap, const char *tag, int id, const struct cgb__fetchByStatusSinceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchByStatusSinceResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfChargebacks(soap, "chargebacks", -1, &a->_chargebacks, "vin:Chargeback"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchByStatusSinceResponse * SOAP_FMAC4 soap_get_cgb__fetchByStatusSinceResponse(struct soap *soap, struct cgb__fetchByStatusSinceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchByStatusSinceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByStatusSinceResponse * SOAP_FMAC4 soap_in_cgb__fetchByStatusSinceResponse(struct soap *soap, const char *tag, struct cgb__fetchByStatusSinceResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__chargebacks = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchByStatusSinceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchByStatusSinceResponse, sizeof(struct cgb__fetchByStatusSinceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchByStatusSinceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__chargebacks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfChargebacks(soap, NULL, &a->_chargebacks, "vin:Chargeback"))
				{	soap_flag__chargebacks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByStatusSinceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchByStatusSinceResponse, 0, sizeof(struct cgb__fetchByStatusSinceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchByStatus(struct soap *soap, struct cgb__fetchByStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_vin__ChargebackStatus(soap, &a->_status);
	soap_default_int(soap, &a->_page);
	soap_default_int(soap, &a->_pageSize);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchByStatus(struct soap *soap, const struct cgb__fetchByStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_embedded(soap, &a->_page, SOAP_TYPE_int);
	soap_embedded(soap, &a->_pageSize, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchByStatus(struct soap *soap, const struct cgb__fetchByStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchByStatus);
	if (soap_out_cgb__fetchByStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchByStatus(struct soap *soap, const char *tag, int id, const struct cgb__fetchByStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchByStatus), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_vin__ChargebackStatus(soap, "status", -1, &a->_status, "vin:ChargebackStatus"))
		return soap->error;
	if (soap_out_int(soap, "page", -1, &a->_page, "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "pageSize", -1, &a->_pageSize, "xsd:int"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchByStatus * SOAP_FMAC4 soap_get_cgb__fetchByStatus(struct soap *soap, struct cgb__fetchByStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchByStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByStatus * SOAP_FMAC4 soap_in_cgb__fetchByStatus(struct soap *soap, const char *tag, struct cgb__fetchByStatus *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__status = 1;
	size_t soap_flag__page = 1;
	size_t soap_flag__pageSize = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchByStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchByStatus, sizeof(struct cgb__fetchByStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchByStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_vin__ChargebackStatus(soap, NULL, &a->_status, "vin:ChargebackStatus"))
				{	soap_flag__status--;
					continue;
				}
			if (soap_flag__page && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_page, "xsd:int"))
				{	soap_flag__page--;
					continue;
				}
			if (soap_flag__pageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_pageSize, "xsd:int"))
				{	soap_flag__pageSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchByStatus, 0, sizeof(struct cgb__fetchByStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__status > 0 || soap_flag__page > 0 || soap_flag__pageSize > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchByStatusResponse(struct soap *soap, struct cgb__fetchByStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_chargebacks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchByStatusResponse(struct soap *soap, const struct cgb__fetchByStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfChargebacks(soap, &a->_chargebacks);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchByStatusResponse(struct soap *soap, const struct cgb__fetchByStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchByStatusResponse);
	if (soap_out_cgb__fetchByStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchByStatusResponse(struct soap *soap, const char *tag, int id, const struct cgb__fetchByStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchByStatusResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfChargebacks(soap, "chargebacks", -1, &a->_chargebacks, "vin:Chargeback"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchByStatusResponse * SOAP_FMAC4 soap_get_cgb__fetchByStatusResponse(struct soap *soap, struct cgb__fetchByStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchByStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByStatusResponse * SOAP_FMAC4 soap_in_cgb__fetchByStatusResponse(struct soap *soap, const char *tag, struct cgb__fetchByStatusResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__chargebacks = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchByStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchByStatusResponse, sizeof(struct cgb__fetchByStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchByStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__chargebacks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfChargebacks(soap, NULL, &a->_chargebacks, "vin:Chargeback"))
				{	soap_flag__chargebacks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchByStatusResponse, 0, sizeof(struct cgb__fetchByStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchByReferenceNumber(struct soap *soap, struct cgb__fetchByReferenceNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_referenceNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchByReferenceNumber(struct soap *soap, const struct cgb__fetchByReferenceNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_referenceNumber);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchByReferenceNumber(struct soap *soap, const struct cgb__fetchByReferenceNumber *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchByReferenceNumber);
	if (soap_out_cgb__fetchByReferenceNumber(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchByReferenceNumber(struct soap *soap, const char *tag, int id, const struct cgb__fetchByReferenceNumber *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchByReferenceNumber), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "referenceNumber", -1, &a->_referenceNumber, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchByReferenceNumber * SOAP_FMAC4 soap_get_cgb__fetchByReferenceNumber(struct soap *soap, struct cgb__fetchByReferenceNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchByReferenceNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByReferenceNumber * SOAP_FMAC4 soap_in_cgb__fetchByReferenceNumber(struct soap *soap, const char *tag, struct cgb__fetchByReferenceNumber *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__referenceNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchByReferenceNumber *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchByReferenceNumber, sizeof(struct cgb__fetchByReferenceNumber), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchByReferenceNumber(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__referenceNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_referenceNumber, "xsd:string"))
				{	soap_flag__referenceNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByReferenceNumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchByReferenceNumber, 0, sizeof(struct cgb__fetchByReferenceNumber), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchByReferenceNumberResponse(struct soap *soap, struct cgb__fetchByReferenceNumberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_chargebacks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchByReferenceNumberResponse(struct soap *soap, const struct cgb__fetchByReferenceNumberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfChargebacks(soap, &a->_chargebacks);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchByReferenceNumberResponse(struct soap *soap, const struct cgb__fetchByReferenceNumberResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchByReferenceNumberResponse);
	if (soap_out_cgb__fetchByReferenceNumberResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchByReferenceNumberResponse(struct soap *soap, const char *tag, int id, const struct cgb__fetchByReferenceNumberResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchByReferenceNumberResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfChargebacks(soap, "chargebacks", -1, &a->_chargebacks, "vin:Chargeback"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchByReferenceNumberResponse * SOAP_FMAC4 soap_get_cgb__fetchByReferenceNumberResponse(struct soap *soap, struct cgb__fetchByReferenceNumberResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchByReferenceNumberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByReferenceNumberResponse * SOAP_FMAC4 soap_in_cgb__fetchByReferenceNumberResponse(struct soap *soap, const char *tag, struct cgb__fetchByReferenceNumberResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__chargebacks = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchByReferenceNumberResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchByReferenceNumberResponse, sizeof(struct cgb__fetchByReferenceNumberResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchByReferenceNumberResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__chargebacks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfChargebacks(soap, NULL, &a->_chargebacks, "vin:Chargeback"))
				{	soap_flag__chargebacks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByReferenceNumberResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchByReferenceNumberResponse, 0, sizeof(struct cgb__fetchByReferenceNumberResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchByCaseNumber(struct soap *soap, struct cgb__fetchByCaseNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_caseNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchByCaseNumber(struct soap *soap, const struct cgb__fetchByCaseNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_caseNumber);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchByCaseNumber(struct soap *soap, const struct cgb__fetchByCaseNumber *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchByCaseNumber);
	if (soap_out_cgb__fetchByCaseNumber(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchByCaseNumber(struct soap *soap, const char *tag, int id, const struct cgb__fetchByCaseNumber *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchByCaseNumber), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "caseNumber", -1, &a->_caseNumber, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchByCaseNumber * SOAP_FMAC4 soap_get_cgb__fetchByCaseNumber(struct soap *soap, struct cgb__fetchByCaseNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchByCaseNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByCaseNumber * SOAP_FMAC4 soap_in_cgb__fetchByCaseNumber(struct soap *soap, const char *tag, struct cgb__fetchByCaseNumber *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__caseNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchByCaseNumber *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchByCaseNumber, sizeof(struct cgb__fetchByCaseNumber), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchByCaseNumber(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__caseNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_caseNumber, "xsd:string"))
				{	soap_flag__caseNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByCaseNumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchByCaseNumber, 0, sizeof(struct cgb__fetchByCaseNumber), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchByCaseNumberResponse(struct soap *soap, struct cgb__fetchByCaseNumberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_chargebacks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchByCaseNumberResponse(struct soap *soap, const struct cgb__fetchByCaseNumberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfChargebacks(soap, &a->_chargebacks);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchByCaseNumberResponse(struct soap *soap, const struct cgb__fetchByCaseNumberResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchByCaseNumberResponse);
	if (soap_out_cgb__fetchByCaseNumberResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchByCaseNumberResponse(struct soap *soap, const char *tag, int id, const struct cgb__fetchByCaseNumberResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchByCaseNumberResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfChargebacks(soap, "chargebacks", -1, &a->_chargebacks, "vin:Chargeback"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchByCaseNumberResponse * SOAP_FMAC4 soap_get_cgb__fetchByCaseNumberResponse(struct soap *soap, struct cgb__fetchByCaseNumberResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchByCaseNumberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByCaseNumberResponse * SOAP_FMAC4 soap_in_cgb__fetchByCaseNumberResponse(struct soap *soap, const char *tag, struct cgb__fetchByCaseNumberResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__chargebacks = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchByCaseNumberResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchByCaseNumberResponse, sizeof(struct cgb__fetchByCaseNumberResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchByCaseNumberResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__chargebacks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfChargebacks(soap, NULL, &a->_chargebacks, "vin:Chargeback"))
				{	soap_flag__chargebacks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByCaseNumberResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchByCaseNumberResponse, 0, sizeof(struct cgb__fetchByCaseNumberResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchByAccount(struct soap *soap, struct cgb__fetchByAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_account = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchByAccount(struct soap *soap, const struct cgb__fetchByAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchByAccount(struct soap *soap, const struct cgb__fetchByAccount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchByAccount);
	if (soap_out_cgb__fetchByAccount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchByAccount(struct soap *soap, const char *tag, int id, const struct cgb__fetchByAccount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchByAccount), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchByAccount * SOAP_FMAC4 soap_get_cgb__fetchByAccount(struct soap *soap, struct cgb__fetchByAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchByAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByAccount * SOAP_FMAC4 soap_in_cgb__fetchByAccount(struct soap *soap, const char *tag, struct cgb__fetchByAccount *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__account = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchByAccount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchByAccount, sizeof(struct cgb__fetchByAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchByAccount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByAccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchByAccount, 0, sizeof(struct cgb__fetchByAccount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchByAccountResponse(struct soap *soap, struct cgb__fetchByAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_chargebacks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchByAccountResponse(struct soap *soap, const struct cgb__fetchByAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfChargebacks(soap, &a->_chargebacks);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchByAccountResponse(struct soap *soap, const struct cgb__fetchByAccountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchByAccountResponse);
	if (soap_out_cgb__fetchByAccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchByAccountResponse(struct soap *soap, const char *tag, int id, const struct cgb__fetchByAccountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchByAccountResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfChargebacks(soap, "chargebacks", -1, &a->_chargebacks, "vin:Chargeback"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchByAccountResponse * SOAP_FMAC4 soap_get_cgb__fetchByAccountResponse(struct soap *soap, struct cgb__fetchByAccountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchByAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByAccountResponse * SOAP_FMAC4 soap_in_cgb__fetchByAccountResponse(struct soap *soap, const char *tag, struct cgb__fetchByAccountResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__chargebacks = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchByAccountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchByAccountResponse, sizeof(struct cgb__fetchByAccountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchByAccountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__chargebacks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfChargebacks(soap, NULL, &a->_chargebacks, "vin:Chargeback"))
				{	soap_flag__chargebacks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByAccountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchByAccountResponse, 0, sizeof(struct cgb__fetchByAccountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchByVid(struct soap *soap, struct cgb__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_vid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchByVid(struct soap *soap, const struct cgb__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_vid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchByVid(struct soap *soap, const struct cgb__fetchByVid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchByVid);
	if (soap_out_cgb__fetchByVid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchByVid(struct soap *soap, const char *tag, int id, const struct cgb__fetchByVid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchByVid), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "vid", -1, &a->_vid, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchByVid * SOAP_FMAC4 soap_get_cgb__fetchByVid(struct soap *soap, struct cgb__fetchByVid *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchByVid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByVid * SOAP_FMAC4 soap_in_cgb__fetchByVid(struct soap *soap, const char *tag, struct cgb__fetchByVid *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__vid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchByVid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchByVid, sizeof(struct cgb__fetchByVid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchByVid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__vid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_vid, "xsd:string"))
				{	soap_flag__vid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByVid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchByVid, 0, sizeof(struct cgb__fetchByVid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__fetchByVidResponse(struct soap *soap, struct cgb__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_chargeback = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__fetchByVidResponse(struct soap *soap, const struct cgb__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Chargeback(soap, &a->_chargeback);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__fetchByVidResponse(struct soap *soap, const struct cgb__fetchByVidResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__fetchByVidResponse);
	if (soap_out_cgb__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__fetchByVidResponse(struct soap *soap, const char *tag, int id, const struct cgb__fetchByVidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__fetchByVidResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Chargeback(soap, "chargeback", -1, &a->_chargeback, "vin:Chargeback"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__fetchByVidResponse * SOAP_FMAC4 soap_get_cgb__fetchByVidResponse(struct soap *soap, struct cgb__fetchByVidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByVidResponse * SOAP_FMAC4 soap_in_cgb__fetchByVidResponse(struct soap *soap, const char *tag, struct cgb__fetchByVidResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__chargeback = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__fetchByVidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__fetchByVidResponse, sizeof(struct cgb__fetchByVidResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__fetchByVidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__chargeback && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Chargeback(soap, NULL, &a->_chargeback, "vin:Chargeback"))
				{	soap_flag__chargeback--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByVidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__fetchByVidResponse, 0, sizeof(struct cgb__fetchByVidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__update(struct soap *soap, struct cgb__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_chargeback = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__update(struct soap *soap, const struct cgb__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Chargeback(soap, &a->_chargeback);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__update(struct soap *soap, const struct cgb__update *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__update);
	if (soap_out_cgb__update(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__update(struct soap *soap, const char *tag, int id, const struct cgb__update *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__update), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Chargeback(soap, "chargeback", -1, &a->_chargeback, "vin:Chargeback"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__update * SOAP_FMAC4 soap_get_cgb__update(struct soap *soap, struct cgb__update *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__update(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__update * SOAP_FMAC4 soap_in_cgb__update(struct soap *soap, const char *tag, struct cgb__update *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__chargeback = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__update *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__update, sizeof(struct cgb__update), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__update(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__chargeback && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Chargeback(soap, NULL, &a->_chargeback, "vin:Chargeback"))
				{	soap_flag__chargeback--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__update *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__update, 0, sizeof(struct cgb__update), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cgb__updateResponse(struct soap *soap, struct cgb__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_chargeback = NULL;
	soap_default_xsd__boolean(soap, &a->_created);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cgb__updateResponse(struct soap *soap, const struct cgb__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Chargeback(soap, &a->_chargeback);
	soap_embedded(soap, &a->_created, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cgb__updateResponse(struct soap *soap, const struct cgb__updateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cgb__updateResponse);
	if (soap_out_cgb__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cgb__updateResponse(struct soap *soap, const char *tag, int id, const struct cgb__updateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cgb__updateResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Chargeback(soap, "chargeback", -1, &a->_chargeback, "vin:Chargeback"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "created", -1, &a->_created, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cgb__updateResponse * SOAP_FMAC4 soap_get_cgb__updateResponse(struct soap *soap, struct cgb__updateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cgb__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__updateResponse * SOAP_FMAC4 soap_in_cgb__updateResponse(struct soap *soap, const char *tag, struct cgb__updateResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__chargeback = 1;
	size_t soap_flag__created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cgb__updateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cgb__updateResponse, sizeof(struct cgb__updateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cgb__updateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__chargeback && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Chargeback(soap, NULL, &a->_chargeback, "vin:Chargeback"))
				{	soap_flag__chargeback--;
					continue;
				}
			if (soap_flag__created && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_created, "xsd:boolean"))
				{	soap_flag__created--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cgb__updateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cgb__updateResponse, 0, sizeof(struct cgb__updateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__created > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bpl__fetchByMerchantEntitlementId(struct soap *soap, struct bpl__fetchByMerchantEntitlementId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_merchantEntitlementId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bpl__fetchByMerchantEntitlementId(struct soap *soap, const struct bpl__fetchByMerchantEntitlementId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_merchantEntitlementId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bpl__fetchByMerchantEntitlementId(struct soap *soap, const struct bpl__fetchByMerchantEntitlementId *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bpl__fetchByMerchantEntitlementId);
	if (soap_out_bpl__fetchByMerchantEntitlementId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bpl__fetchByMerchantEntitlementId(struct soap *soap, const char *tag, int id, const struct bpl__fetchByMerchantEntitlementId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bpl__fetchByMerchantEntitlementId), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "merchantEntitlementId", -1, &a->_merchantEntitlementId, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bpl__fetchByMerchantEntitlementId * SOAP_FMAC4 soap_get_bpl__fetchByMerchantEntitlementId(struct soap *soap, struct bpl__fetchByMerchantEntitlementId *p, const char *tag, const char *type)
{
	if ((p = soap_in_bpl__fetchByMerchantEntitlementId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__fetchByMerchantEntitlementId * SOAP_FMAC4 soap_in_bpl__fetchByMerchantEntitlementId(struct soap *soap, const char *tag, struct bpl__fetchByMerchantEntitlementId *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__merchantEntitlementId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bpl__fetchByMerchantEntitlementId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bpl__fetchByMerchantEntitlementId, sizeof(struct bpl__fetchByMerchantEntitlementId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bpl__fetchByMerchantEntitlementId(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__merchantEntitlementId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_merchantEntitlementId, "xsd:string"))
				{	soap_flag__merchantEntitlementId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bpl__fetchByMerchantEntitlementId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bpl__fetchByMerchantEntitlementId, 0, sizeof(struct bpl__fetchByMerchantEntitlementId), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bpl__fetchByMerchantEntitlementIdResponse(struct soap *soap, struct bpl__fetchByMerchantEntitlementIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_billingPlans = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bpl__fetchByMerchantEntitlementIdResponse(struct soap *soap, const struct bpl__fetchByMerchantEntitlementIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfBillingPlans(soap, &a->_billingPlans);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bpl__fetchByMerchantEntitlementIdResponse(struct soap *soap, const struct bpl__fetchByMerchantEntitlementIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bpl__fetchByMerchantEntitlementIdResponse);
	if (soap_out_bpl__fetchByMerchantEntitlementIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bpl__fetchByMerchantEntitlementIdResponse(struct soap *soap, const char *tag, int id, const struct bpl__fetchByMerchantEntitlementIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bpl__fetchByMerchantEntitlementIdResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfBillingPlans(soap, "billingPlans", -1, &a->_billingPlans, "vin:BillingPlan"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bpl__fetchByMerchantEntitlementIdResponse * SOAP_FMAC4 soap_get_bpl__fetchByMerchantEntitlementIdResponse(struct soap *soap, struct bpl__fetchByMerchantEntitlementIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bpl__fetchByMerchantEntitlementIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__fetchByMerchantEntitlementIdResponse * SOAP_FMAC4 soap_in_bpl__fetchByMerchantEntitlementIdResponse(struct soap *soap, const char *tag, struct bpl__fetchByMerchantEntitlementIdResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__billingPlans = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bpl__fetchByMerchantEntitlementIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bpl__fetchByMerchantEntitlementIdResponse, sizeof(struct bpl__fetchByMerchantEntitlementIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bpl__fetchByMerchantEntitlementIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__billingPlans && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfBillingPlans(soap, NULL, &a->_billingPlans, "vin:BillingPlan"))
				{	soap_flag__billingPlans--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bpl__fetchByMerchantEntitlementIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bpl__fetchByMerchantEntitlementIdResponse, 0, sizeof(struct bpl__fetchByMerchantEntitlementIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bpl__fetchAll(struct soap *soap, struct bpl__fetchAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_int(soap, &a->_page);
	soap_default_int(soap, &a->_pageSize);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bpl__fetchAll(struct soap *soap, const struct bpl__fetchAll *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_embedded(soap, &a->_page, SOAP_TYPE_int);
	soap_embedded(soap, &a->_pageSize, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bpl__fetchAll(struct soap *soap, const struct bpl__fetchAll *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bpl__fetchAll);
	if (soap_out_bpl__fetchAll(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bpl__fetchAll(struct soap *soap, const char *tag, int id, const struct bpl__fetchAll *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bpl__fetchAll), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_int(soap, "page", -1, &a->_page, "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "pageSize", -1, &a->_pageSize, "xsd:int"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bpl__fetchAll * SOAP_FMAC4 soap_get_bpl__fetchAll(struct soap *soap, struct bpl__fetchAll *p, const char *tag, const char *type)
{
	if ((p = soap_in_bpl__fetchAll(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__fetchAll * SOAP_FMAC4 soap_in_bpl__fetchAll(struct soap *soap, const char *tag, struct bpl__fetchAll *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__page = 1;
	size_t soap_flag__pageSize = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bpl__fetchAll *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bpl__fetchAll, sizeof(struct bpl__fetchAll), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bpl__fetchAll(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__page && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_page, "xsd:int"))
				{	soap_flag__page--;
					continue;
				}
			if (soap_flag__pageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_pageSize, "xsd:int"))
				{	soap_flag__pageSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bpl__fetchAll *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bpl__fetchAll, 0, sizeof(struct bpl__fetchAll), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__page > 0 || soap_flag__pageSize > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bpl__fetchAllResponse(struct soap *soap, struct bpl__fetchAllResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_billingPlans = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bpl__fetchAllResponse(struct soap *soap, const struct bpl__fetchAllResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfBillingPlans(soap, &a->_billingPlans);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bpl__fetchAllResponse(struct soap *soap, const struct bpl__fetchAllResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bpl__fetchAllResponse);
	if (soap_out_bpl__fetchAllResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bpl__fetchAllResponse(struct soap *soap, const char *tag, int id, const struct bpl__fetchAllResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bpl__fetchAllResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfBillingPlans(soap, "billingPlans", -1, &a->_billingPlans, "vin:BillingPlan"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bpl__fetchAllResponse * SOAP_FMAC4 soap_get_bpl__fetchAllResponse(struct soap *soap, struct bpl__fetchAllResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bpl__fetchAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__fetchAllResponse * SOAP_FMAC4 soap_in_bpl__fetchAllResponse(struct soap *soap, const char *tag, struct bpl__fetchAllResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__billingPlans = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bpl__fetchAllResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bpl__fetchAllResponse, sizeof(struct bpl__fetchAllResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bpl__fetchAllResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__billingPlans && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfBillingPlans(soap, NULL, &a->_billingPlans, "vin:BillingPlan"))
				{	soap_flag__billingPlans--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bpl__fetchAllResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bpl__fetchAllResponse, 0, sizeof(struct bpl__fetchAllResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bpl__fetchByBillingPlanStatus(struct soap *soap, struct bpl__fetchByBillingPlanStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_vin__BillingPlanStatus(soap, &a->_status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bpl__fetchByBillingPlanStatus(struct soap *soap, const struct bpl__fetchByBillingPlanStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_embedded(soap, &a->_status, SOAP_TYPE_vin__BillingPlanStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bpl__fetchByBillingPlanStatus(struct soap *soap, const struct bpl__fetchByBillingPlanStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bpl__fetchByBillingPlanStatus);
	if (soap_out_bpl__fetchByBillingPlanStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bpl__fetchByBillingPlanStatus(struct soap *soap, const char *tag, int id, const struct bpl__fetchByBillingPlanStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bpl__fetchByBillingPlanStatus), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_vin__BillingPlanStatus(soap, "status", -1, &a->_status, "vin:BillingPlanStatus"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bpl__fetchByBillingPlanStatus * SOAP_FMAC4 soap_get_bpl__fetchByBillingPlanStatus(struct soap *soap, struct bpl__fetchByBillingPlanStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_bpl__fetchByBillingPlanStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__fetchByBillingPlanStatus * SOAP_FMAC4 soap_in_bpl__fetchByBillingPlanStatus(struct soap *soap, const char *tag, struct bpl__fetchByBillingPlanStatus *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bpl__fetchByBillingPlanStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bpl__fetchByBillingPlanStatus, sizeof(struct bpl__fetchByBillingPlanStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bpl__fetchByBillingPlanStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_vin__BillingPlanStatus(soap, NULL, &a->_status, "vin:BillingPlanStatus"))
				{	soap_flag__status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bpl__fetchByBillingPlanStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bpl__fetchByBillingPlanStatus, 0, sizeof(struct bpl__fetchByBillingPlanStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bpl__fetchByBillingPlanStatusResponse(struct soap *soap, struct bpl__fetchByBillingPlanStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_billingPlans = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bpl__fetchByBillingPlanStatusResponse(struct soap *soap, const struct bpl__fetchByBillingPlanStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfBillingPlans(soap, &a->_billingPlans);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bpl__fetchByBillingPlanStatusResponse(struct soap *soap, const struct bpl__fetchByBillingPlanStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bpl__fetchByBillingPlanStatusResponse);
	if (soap_out_bpl__fetchByBillingPlanStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bpl__fetchByBillingPlanStatusResponse(struct soap *soap, const char *tag, int id, const struct bpl__fetchByBillingPlanStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bpl__fetchByBillingPlanStatusResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfBillingPlans(soap, "billingPlans", -1, &a->_billingPlans, "vin:BillingPlan"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bpl__fetchByBillingPlanStatusResponse * SOAP_FMAC4 soap_get_bpl__fetchByBillingPlanStatusResponse(struct soap *soap, struct bpl__fetchByBillingPlanStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bpl__fetchByBillingPlanStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__fetchByBillingPlanStatusResponse * SOAP_FMAC4 soap_in_bpl__fetchByBillingPlanStatusResponse(struct soap *soap, const char *tag, struct bpl__fetchByBillingPlanStatusResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__billingPlans = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bpl__fetchByBillingPlanStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bpl__fetchByBillingPlanStatusResponse, sizeof(struct bpl__fetchByBillingPlanStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bpl__fetchByBillingPlanStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__billingPlans && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfBillingPlans(soap, NULL, &a->_billingPlans, "vin:BillingPlan"))
				{	soap_flag__billingPlans--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bpl__fetchByBillingPlanStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bpl__fetchByBillingPlanStatusResponse, 0, sizeof(struct bpl__fetchByBillingPlanStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bpl__fetchByMerchantBillingPlanId(struct soap *soap, struct bpl__fetchByMerchantBillingPlanId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_merchantBillingPlanId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bpl__fetchByMerchantBillingPlanId(struct soap *soap, const struct bpl__fetchByMerchantBillingPlanId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_merchantBillingPlanId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bpl__fetchByMerchantBillingPlanId(struct soap *soap, const struct bpl__fetchByMerchantBillingPlanId *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bpl__fetchByMerchantBillingPlanId);
	if (soap_out_bpl__fetchByMerchantBillingPlanId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bpl__fetchByMerchantBillingPlanId(struct soap *soap, const char *tag, int id, const struct bpl__fetchByMerchantBillingPlanId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bpl__fetchByMerchantBillingPlanId), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "merchantBillingPlanId", -1, &a->_merchantBillingPlanId, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bpl__fetchByMerchantBillingPlanId * SOAP_FMAC4 soap_get_bpl__fetchByMerchantBillingPlanId(struct soap *soap, struct bpl__fetchByMerchantBillingPlanId *p, const char *tag, const char *type)
{
	if ((p = soap_in_bpl__fetchByMerchantBillingPlanId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__fetchByMerchantBillingPlanId * SOAP_FMAC4 soap_in_bpl__fetchByMerchantBillingPlanId(struct soap *soap, const char *tag, struct bpl__fetchByMerchantBillingPlanId *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__merchantBillingPlanId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bpl__fetchByMerchantBillingPlanId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bpl__fetchByMerchantBillingPlanId, sizeof(struct bpl__fetchByMerchantBillingPlanId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bpl__fetchByMerchantBillingPlanId(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__merchantBillingPlanId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_merchantBillingPlanId, "xsd:string"))
				{	soap_flag__merchantBillingPlanId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bpl__fetchByMerchantBillingPlanId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bpl__fetchByMerchantBillingPlanId, 0, sizeof(struct bpl__fetchByMerchantBillingPlanId), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bpl__fetchByMerchantBillingPlanIdResponse(struct soap *soap, struct bpl__fetchByMerchantBillingPlanIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_billingPlan = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bpl__fetchByMerchantBillingPlanIdResponse(struct soap *soap, const struct bpl__fetchByMerchantBillingPlanIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__BillingPlan(soap, &a->_billingPlan);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bpl__fetchByMerchantBillingPlanIdResponse(struct soap *soap, const struct bpl__fetchByMerchantBillingPlanIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bpl__fetchByMerchantBillingPlanIdResponse);
	if (soap_out_bpl__fetchByMerchantBillingPlanIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bpl__fetchByMerchantBillingPlanIdResponse(struct soap *soap, const char *tag, int id, const struct bpl__fetchByMerchantBillingPlanIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bpl__fetchByMerchantBillingPlanIdResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__BillingPlan(soap, "billingPlan", -1, &a->_billingPlan, "vin:BillingPlan"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bpl__fetchByMerchantBillingPlanIdResponse * SOAP_FMAC4 soap_get_bpl__fetchByMerchantBillingPlanIdResponse(struct soap *soap, struct bpl__fetchByMerchantBillingPlanIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bpl__fetchByMerchantBillingPlanIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__fetchByMerchantBillingPlanIdResponse * SOAP_FMAC4 soap_in_bpl__fetchByMerchantBillingPlanIdResponse(struct soap *soap, const char *tag, struct bpl__fetchByMerchantBillingPlanIdResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__billingPlan = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bpl__fetchByMerchantBillingPlanIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bpl__fetchByMerchantBillingPlanIdResponse, sizeof(struct bpl__fetchByMerchantBillingPlanIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bpl__fetchByMerchantBillingPlanIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__billingPlan && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__BillingPlan(soap, NULL, &a->_billingPlan, "vin:BillingPlan"))
				{	soap_flag__billingPlan--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bpl__fetchByMerchantBillingPlanIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bpl__fetchByMerchantBillingPlanIdResponse, 0, sizeof(struct bpl__fetchByMerchantBillingPlanIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bpl__fetchByVid(struct soap *soap, struct bpl__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_vid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bpl__fetchByVid(struct soap *soap, const struct bpl__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_vid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bpl__fetchByVid(struct soap *soap, const struct bpl__fetchByVid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bpl__fetchByVid);
	if (soap_out_bpl__fetchByVid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bpl__fetchByVid(struct soap *soap, const char *tag, int id, const struct bpl__fetchByVid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bpl__fetchByVid), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "vid", -1, &a->_vid, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bpl__fetchByVid * SOAP_FMAC4 soap_get_bpl__fetchByVid(struct soap *soap, struct bpl__fetchByVid *p, const char *tag, const char *type)
{
	if ((p = soap_in_bpl__fetchByVid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__fetchByVid * SOAP_FMAC4 soap_in_bpl__fetchByVid(struct soap *soap, const char *tag, struct bpl__fetchByVid *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__vid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bpl__fetchByVid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bpl__fetchByVid, sizeof(struct bpl__fetchByVid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bpl__fetchByVid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__vid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_vid, "xsd:string"))
				{	soap_flag__vid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bpl__fetchByVid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bpl__fetchByVid, 0, sizeof(struct bpl__fetchByVid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bpl__fetchByVidResponse(struct soap *soap, struct bpl__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_billingPlan = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bpl__fetchByVidResponse(struct soap *soap, const struct bpl__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__BillingPlan(soap, &a->_billingPlan);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bpl__fetchByVidResponse(struct soap *soap, const struct bpl__fetchByVidResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bpl__fetchByVidResponse);
	if (soap_out_bpl__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bpl__fetchByVidResponse(struct soap *soap, const char *tag, int id, const struct bpl__fetchByVidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bpl__fetchByVidResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__BillingPlan(soap, "billingPlan", -1, &a->_billingPlan, "vin:BillingPlan"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bpl__fetchByVidResponse * SOAP_FMAC4 soap_get_bpl__fetchByVidResponse(struct soap *soap, struct bpl__fetchByVidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bpl__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__fetchByVidResponse * SOAP_FMAC4 soap_in_bpl__fetchByVidResponse(struct soap *soap, const char *tag, struct bpl__fetchByVidResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__billingPlan = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bpl__fetchByVidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bpl__fetchByVidResponse, sizeof(struct bpl__fetchByVidResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bpl__fetchByVidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__billingPlan && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__BillingPlan(soap, NULL, &a->_billingPlan, "vin:BillingPlan"))
				{	soap_flag__billingPlan--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bpl__fetchByVidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bpl__fetchByVidResponse, 0, sizeof(struct bpl__fetchByVidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bpl__update(struct soap *soap, struct bpl__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_billingPlan = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bpl__update(struct soap *soap, const struct bpl__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__BillingPlan(soap, &a->_billingPlan);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bpl__update(struct soap *soap, const struct bpl__update *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bpl__update);
	if (soap_out_bpl__update(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bpl__update(struct soap *soap, const char *tag, int id, const struct bpl__update *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bpl__update), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__BillingPlan(soap, "billingPlan", -1, &a->_billingPlan, "vin:BillingPlan"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bpl__update * SOAP_FMAC4 soap_get_bpl__update(struct soap *soap, struct bpl__update *p, const char *tag, const char *type)
{
	if ((p = soap_in_bpl__update(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__update * SOAP_FMAC4 soap_in_bpl__update(struct soap *soap, const char *tag, struct bpl__update *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__billingPlan = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bpl__update *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bpl__update, sizeof(struct bpl__update), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bpl__update(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__billingPlan && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__BillingPlan(soap, NULL, &a->_billingPlan, "vin:BillingPlan"))
				{	soap_flag__billingPlan--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bpl__update *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bpl__update, 0, sizeof(struct bpl__update), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bpl__updateResponse(struct soap *soap, struct bpl__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_billingPlan = NULL;
	soap_default_xsd__boolean(soap, &a->_created);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bpl__updateResponse(struct soap *soap, const struct bpl__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__BillingPlan(soap, &a->_billingPlan);
	soap_embedded(soap, &a->_created, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bpl__updateResponse(struct soap *soap, const struct bpl__updateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bpl__updateResponse);
	if (soap_out_bpl__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bpl__updateResponse(struct soap *soap, const char *tag, int id, const struct bpl__updateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bpl__updateResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__BillingPlan(soap, "billingPlan", -1, &a->_billingPlan, "vin:BillingPlan"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "created", -1, &a->_created, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bpl__updateResponse * SOAP_FMAC4 soap_get_bpl__updateResponse(struct soap *soap, struct bpl__updateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bpl__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__updateResponse * SOAP_FMAC4 soap_in_bpl__updateResponse(struct soap *soap, const char *tag, struct bpl__updateResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__billingPlan = 1;
	size_t soap_flag__created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bpl__updateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bpl__updateResponse, sizeof(struct bpl__updateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bpl__updateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__billingPlan && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__BillingPlan(soap, NULL, &a->_billingPlan, "vin:BillingPlan"))
				{	soap_flag__billingPlan--;
					continue;
				}
			if (soap_flag__created && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_created, "xsd:boolean"))
				{	soap_flag__created--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bpl__updateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bpl__updateResponse, 0, sizeof(struct bpl__updateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__created > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_add__fetchByVid(struct soap *soap, struct add__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_vid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_add__fetchByVid(struct soap *soap, const struct add__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_vid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_add__fetchByVid(struct soap *soap, const struct add__fetchByVid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_add__fetchByVid);
	if (soap_out_add__fetchByVid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_add__fetchByVid(struct soap *soap, const char *tag, int id, const struct add__fetchByVid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_add__fetchByVid), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "vid", -1, &a->_vid, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct add__fetchByVid * SOAP_FMAC4 soap_get_add__fetchByVid(struct soap *soap, struct add__fetchByVid *p, const char *tag, const char *type)
{
	if ((p = soap_in_add__fetchByVid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct add__fetchByVid * SOAP_FMAC4 soap_in_add__fetchByVid(struct soap *soap, const char *tag, struct add__fetchByVid *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__vid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct add__fetchByVid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_add__fetchByVid, sizeof(struct add__fetchByVid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_add__fetchByVid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__vid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_vid, "xsd:string"))
				{	soap_flag__vid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct add__fetchByVid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_add__fetchByVid, 0, sizeof(struct add__fetchByVid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_add__fetchByVidResponse(struct soap *soap, struct add__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_address = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_add__fetchByVidResponse(struct soap *soap, const struct add__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Address(soap, &a->_address);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_add__fetchByVidResponse(struct soap *soap, const struct add__fetchByVidResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_add__fetchByVidResponse);
	if (soap_out_add__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_add__fetchByVidResponse(struct soap *soap, const char *tag, int id, const struct add__fetchByVidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_add__fetchByVidResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Address(soap, "address", -1, &a->_address, "vin:Address"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct add__fetchByVidResponse * SOAP_FMAC4 soap_get_add__fetchByVidResponse(struct soap *soap, struct add__fetchByVidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_add__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct add__fetchByVidResponse * SOAP_FMAC4 soap_in_add__fetchByVidResponse(struct soap *soap, const char *tag, struct add__fetchByVidResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__address = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct add__fetchByVidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_add__fetchByVidResponse, sizeof(struct add__fetchByVidResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_add__fetchByVidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Address(soap, NULL, &a->_address, "vin:Address"))
				{	soap_flag__address--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct add__fetchByVidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_add__fetchByVidResponse, 0, sizeof(struct add__fetchByVidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_add__update(struct soap *soap, struct add__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_address = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_add__update(struct soap *soap, const struct add__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Address(soap, &a->_address);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_add__update(struct soap *soap, const struct add__update *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_add__update);
	if (soap_out_add__update(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_add__update(struct soap *soap, const char *tag, int id, const struct add__update *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_add__update), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Address(soap, "address", -1, &a->_address, "vin:Address"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct add__update * SOAP_FMAC4 soap_get_add__update(struct soap *soap, struct add__update *p, const char *tag, const char *type)
{
	if ((p = soap_in_add__update(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct add__update * SOAP_FMAC4 soap_in_add__update(struct soap *soap, const char *tag, struct add__update *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__address = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct add__update *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_add__update, sizeof(struct add__update), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_add__update(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Address(soap, NULL, &a->_address, "vin:Address"))
				{	soap_flag__address--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct add__update *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_add__update, 0, sizeof(struct add__update), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_add__updateResponse(struct soap *soap, struct add__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_address = NULL;
	soap_default_xsd__boolean(soap, &a->_created);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_add__updateResponse(struct soap *soap, const struct add__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Address(soap, &a->_address);
	soap_embedded(soap, &a->_created, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_add__updateResponse(struct soap *soap, const struct add__updateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_add__updateResponse);
	if (soap_out_add__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_add__updateResponse(struct soap *soap, const char *tag, int id, const struct add__updateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_add__updateResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Address(soap, "address", -1, &a->_address, "vin:Address"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "created", -1, &a->_created, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct add__updateResponse * SOAP_FMAC4 soap_get_add__updateResponse(struct soap *soap, struct add__updateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_add__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct add__updateResponse * SOAP_FMAC4 soap_in_add__updateResponse(struct soap *soap, const char *tag, struct add__updateResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__address = 1;
	size_t soap_flag__created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct add__updateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_add__updateResponse, sizeof(struct add__updateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_add__updateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__address && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Address(soap, NULL, &a->_address, "vin:Address"))
				{	soap_flag__address--;
					continue;
				}
			if (soap_flag__created && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_created, "xsd:boolean"))
				{	soap_flag__created--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct add__updateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_add__updateResponse, 0, sizeof(struct add__updateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__created > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_act__record(struct soap *soap, struct act__record *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_activities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_act__record(struct soap *soap, const struct act__record *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerToArrayOfActivities(soap, &a->_activities);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_act__record(struct soap *soap, const struct act__record *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_act__record);
	if (soap_out_act__record(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_act__record(struct soap *soap, const char *tag, int id, const struct act__record *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_act__record), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerToArrayOfActivities(soap, "activities", -1, &a->_activities, "vin:Activity"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct act__record * SOAP_FMAC4 soap_get_act__record(struct soap *soap, struct act__record *p, const char *tag, const char *type)
{
	if ((p = soap_in_act__record(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct act__record * SOAP_FMAC4 soap_in_act__record(struct soap *soap, const char *tag, struct act__record *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__activities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct act__record *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_act__record, sizeof(struct act__record), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_act__record(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__activities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfActivities(soap, NULL, &a->_activities, "vin:Activity"))
				{	soap_flag__activities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct act__record *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_act__record, 0, sizeof(struct act__record), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_act__recordResponse(struct soap *soap, struct act__recordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_act__recordResponse(struct soap *soap, const struct act__recordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_act__recordResponse(struct soap *soap, const struct act__recordResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_act__recordResponse);
	if (soap_out_act__recordResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_act__recordResponse(struct soap *soap, const char *tag, int id, const struct act__recordResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_act__recordResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct act__recordResponse * SOAP_FMAC4 soap_get_act__recordResponse(struct soap *soap, struct act__recordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_act__recordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct act__recordResponse * SOAP_FMAC4 soap_in_act__recordResponse(struct soap *soap, const char *tag, struct act__recordResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct act__recordResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_act__recordResponse, sizeof(struct act__recordResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_act__recordResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct act__recordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_act__recordResponse, 0, sizeof(struct act__recordResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__transfer(struct soap *soap, struct acc__transfer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_targetAccount = NULL;
	a->_sourceAccount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__transfer(struct soap *soap, const struct acc__transfer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Account(soap, &a->_targetAccount);
	soap_serialize_PointerTovin__Account(soap, &a->_sourceAccount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__transfer(struct soap *soap, const struct acc__transfer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__transfer);
	if (soap_out_acc__transfer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__transfer(struct soap *soap, const char *tag, int id, const struct acc__transfer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__transfer), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "targetAccount", -1, &a->_targetAccount, "vin:Account"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "sourceAccount", -1, &a->_sourceAccount, "vin:Account"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__transfer * SOAP_FMAC4 soap_get_acc__transfer(struct soap *soap, struct acc__transfer *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__transfer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__transfer * SOAP_FMAC4 soap_in_acc__transfer(struct soap *soap, const char *tag, struct acc__transfer *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__targetAccount = 1;
	size_t soap_flag__sourceAccount = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__transfer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__transfer, sizeof(struct acc__transfer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__transfer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__targetAccount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_targetAccount, "vin:Account"))
				{	soap_flag__targetAccount--;
					continue;
				}
			if (soap_flag__sourceAccount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_sourceAccount, "vin:Account"))
				{	soap_flag__sourceAccount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__transfer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__transfer, 0, sizeof(struct acc__transfer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__transferResponse(struct soap *soap, struct acc__transferResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_mergedAccount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__transferResponse(struct soap *soap, const struct acc__transferResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Account(soap, &a->_mergedAccount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__transferResponse(struct soap *soap, const struct acc__transferResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__transferResponse);
	if (soap_out_acc__transferResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__transferResponse(struct soap *soap, const char *tag, int id, const struct acc__transferResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__transferResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "mergedAccount", -1, &a->_mergedAccount, "vin:Account"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__transferResponse * SOAP_FMAC4 soap_get_acc__transferResponse(struct soap *soap, struct acc__transferResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__transferResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__transferResponse * SOAP_FMAC4 soap_in_acc__transferResponse(struct soap *soap, const char *tag, struct acc__transferResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__mergedAccount = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__transferResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__transferResponse, sizeof(struct acc__transferResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__transferResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__mergedAccount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_mergedAccount, "vin:Account"))
				{	soap_flag__mergedAccount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__transferResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__transferResponse, 0, sizeof(struct acc__transferResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__decrementTokens(struct soap *soap, struct acc__decrementTokens *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_account = NULL;
	a->_tokenAmounts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__decrementTokens(struct soap *soap, const struct acc__decrementTokens *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
	soap_serialize_PointerToArrayOfTokenAmounts(soap, &a->_tokenAmounts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__decrementTokens(struct soap *soap, const struct acc__decrementTokens *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__decrementTokens);
	if (soap_out_acc__decrementTokens(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__decrementTokens(struct soap *soap, const char *tag, int id, const struct acc__decrementTokens *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__decrementTokens), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	if (soap_out_PointerToArrayOfTokenAmounts(soap, "tokenAmounts", -1, &a->_tokenAmounts, "vin:TokenAmount"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__decrementTokens * SOAP_FMAC4 soap_get_acc__decrementTokens(struct soap *soap, struct acc__decrementTokens *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__decrementTokens(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__decrementTokens * SOAP_FMAC4 soap_in_acc__decrementTokens(struct soap *soap, const char *tag, struct acc__decrementTokens *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__account = 1;
	size_t soap_flag__tokenAmounts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__decrementTokens *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__decrementTokens, sizeof(struct acc__decrementTokens), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__decrementTokens(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap_flag__tokenAmounts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTokenAmounts(soap, NULL, &a->_tokenAmounts, "vin:TokenAmount"))
				{	soap_flag__tokenAmounts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__decrementTokens *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__decrementTokens, 0, sizeof(struct acc__decrementTokens), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__decrementTokensResponse(struct soap *soap, struct acc__decrementTokensResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_tokenAmounts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__decrementTokensResponse(struct soap *soap, const struct acc__decrementTokensResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfTokenAmounts(soap, &a->_tokenAmounts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__decrementTokensResponse(struct soap *soap, const struct acc__decrementTokensResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__decrementTokensResponse);
	if (soap_out_acc__decrementTokensResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__decrementTokensResponse(struct soap *soap, const char *tag, int id, const struct acc__decrementTokensResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__decrementTokensResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfTokenAmounts(soap, "tokenAmounts", -1, &a->_tokenAmounts, "vin:TokenAmount"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__decrementTokensResponse * SOAP_FMAC4 soap_get_acc__decrementTokensResponse(struct soap *soap, struct acc__decrementTokensResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__decrementTokensResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__decrementTokensResponse * SOAP_FMAC4 soap_in_acc__decrementTokensResponse(struct soap *soap, const char *tag, struct acc__decrementTokensResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__tokenAmounts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__decrementTokensResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__decrementTokensResponse, sizeof(struct acc__decrementTokensResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__decrementTokensResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__tokenAmounts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTokenAmounts(soap, NULL, &a->_tokenAmounts, "vin:TokenAmount"))
				{	soap_flag__tokenAmounts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__decrementTokensResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__decrementTokensResponse, 0, sizeof(struct acc__decrementTokensResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__incrementTokens(struct soap *soap, struct acc__incrementTokens *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_account = NULL;
	a->_tokenAmounts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__incrementTokens(struct soap *soap, const struct acc__incrementTokens *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
	soap_serialize_PointerToArrayOfTokenAmounts(soap, &a->_tokenAmounts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__incrementTokens(struct soap *soap, const struct acc__incrementTokens *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__incrementTokens);
	if (soap_out_acc__incrementTokens(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__incrementTokens(struct soap *soap, const char *tag, int id, const struct acc__incrementTokens *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__incrementTokens), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	if (soap_out_PointerToArrayOfTokenAmounts(soap, "tokenAmounts", -1, &a->_tokenAmounts, "vin:TokenAmount"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__incrementTokens * SOAP_FMAC4 soap_get_acc__incrementTokens(struct soap *soap, struct acc__incrementTokens *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__incrementTokens(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__incrementTokens * SOAP_FMAC4 soap_in_acc__incrementTokens(struct soap *soap, const char *tag, struct acc__incrementTokens *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__account = 1;
	size_t soap_flag__tokenAmounts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__incrementTokens *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__incrementTokens, sizeof(struct acc__incrementTokens), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__incrementTokens(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap_flag__tokenAmounts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTokenAmounts(soap, NULL, &a->_tokenAmounts, "vin:TokenAmount"))
				{	soap_flag__tokenAmounts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__incrementTokens *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__incrementTokens, 0, sizeof(struct acc__incrementTokens), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__incrementTokensResponse(struct soap *soap, struct acc__incrementTokensResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_tokenAmounts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__incrementTokensResponse(struct soap *soap, const struct acc__incrementTokensResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfTokenAmounts(soap, &a->_tokenAmounts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__incrementTokensResponse(struct soap *soap, const struct acc__incrementTokensResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__incrementTokensResponse);
	if (soap_out_acc__incrementTokensResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__incrementTokensResponse(struct soap *soap, const char *tag, int id, const struct acc__incrementTokensResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__incrementTokensResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfTokenAmounts(soap, "tokenAmounts", -1, &a->_tokenAmounts, "vin:TokenAmount"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__incrementTokensResponse * SOAP_FMAC4 soap_get_acc__incrementTokensResponse(struct soap *soap, struct acc__incrementTokensResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__incrementTokensResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__incrementTokensResponse * SOAP_FMAC4 soap_in_acc__incrementTokensResponse(struct soap *soap, const char *tag, struct acc__incrementTokensResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__tokenAmounts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__incrementTokensResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__incrementTokensResponse, sizeof(struct acc__incrementTokensResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__incrementTokensResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__tokenAmounts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTokenAmounts(soap, NULL, &a->_tokenAmounts, "vin:TokenAmount"))
				{	soap_flag__tokenAmounts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__incrementTokensResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__incrementTokensResponse, 0, sizeof(struct acc__incrementTokensResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__tokenTransaction(struct soap *soap, struct acc__tokenTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_account = NULL;
	a->_transactions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__tokenTransaction(struct soap *soap, const struct acc__tokenTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
	soap_serialize_PointerToArrayOfTokenTransactions(soap, &a->_transactions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__tokenTransaction(struct soap *soap, const struct acc__tokenTransaction *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__tokenTransaction);
	if (soap_out_acc__tokenTransaction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__tokenTransaction(struct soap *soap, const char *tag, int id, const struct acc__tokenTransaction *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__tokenTransaction), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	if (soap_out_PointerToArrayOfTokenTransactions(soap, "transactions", -1, &a->_transactions, "vin:TokenTransaction"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__tokenTransaction * SOAP_FMAC4 soap_get_acc__tokenTransaction(struct soap *soap, struct acc__tokenTransaction *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__tokenTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__tokenTransaction * SOAP_FMAC4 soap_in_acc__tokenTransaction(struct soap *soap, const char *tag, struct acc__tokenTransaction *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__account = 1;
	size_t soap_flag__transactions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__tokenTransaction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__tokenTransaction, sizeof(struct acc__tokenTransaction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__tokenTransaction(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap_flag__transactions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTokenTransactions(soap, NULL, &a->_transactions, "vin:TokenTransaction"))
				{	soap_flag__transactions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__tokenTransaction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__tokenTransaction, 0, sizeof(struct acc__tokenTransaction), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__tokenTransactionResponse(struct soap *soap, struct acc__tokenTransactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_tokenAmounts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__tokenTransactionResponse(struct soap *soap, const struct acc__tokenTransactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfTokenAmounts(soap, &a->_tokenAmounts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__tokenTransactionResponse(struct soap *soap, const struct acc__tokenTransactionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__tokenTransactionResponse);
	if (soap_out_acc__tokenTransactionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__tokenTransactionResponse(struct soap *soap, const char *tag, int id, const struct acc__tokenTransactionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__tokenTransactionResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfTokenAmounts(soap, "tokenAmounts", -1, &a->_tokenAmounts, "vin:TokenAmount"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__tokenTransactionResponse * SOAP_FMAC4 soap_get_acc__tokenTransactionResponse(struct soap *soap, struct acc__tokenTransactionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__tokenTransactionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__tokenTransactionResponse * SOAP_FMAC4 soap_in_acc__tokenTransactionResponse(struct soap *soap, const char *tag, struct acc__tokenTransactionResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__tokenAmounts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__tokenTransactionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__tokenTransactionResponse, sizeof(struct acc__tokenTransactionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__tokenTransactionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__tokenAmounts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTokenAmounts(soap, NULL, &a->_tokenAmounts, "vin:TokenAmount"))
				{	soap_flag__tokenAmounts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__tokenTransactionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__tokenTransactionResponse, 0, sizeof(struct acc__tokenTransactionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__tokenBalance(struct soap *soap, struct acc__tokenBalance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_account = NULL;
	a->_tokens = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__tokenBalance(struct soap *soap, const struct acc__tokenBalance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
	soap_serialize_PointerToArrayOfTokens(soap, &a->_tokens);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__tokenBalance(struct soap *soap, const struct acc__tokenBalance *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__tokenBalance);
	if (soap_out_acc__tokenBalance(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__tokenBalance(struct soap *soap, const char *tag, int id, const struct acc__tokenBalance *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__tokenBalance), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	if (soap_out_PointerToArrayOfTokens(soap, "tokens", -1, &a->_tokens, "vin:Token"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__tokenBalance * SOAP_FMAC4 soap_get_acc__tokenBalance(struct soap *soap, struct acc__tokenBalance *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__tokenBalance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__tokenBalance * SOAP_FMAC4 soap_in_acc__tokenBalance(struct soap *soap, const char *tag, struct acc__tokenBalance *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__account = 1;
	size_t soap_flag__tokens = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__tokenBalance *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__tokenBalance, sizeof(struct acc__tokenBalance), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__tokenBalance(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap_flag__tokens && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTokens(soap, NULL, &a->_tokens, "vin:Token"))
				{	soap_flag__tokens--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__tokenBalance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__tokenBalance, 0, sizeof(struct acc__tokenBalance), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__tokenBalanceResponse(struct soap *soap, struct acc__tokenBalanceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_tokenAmounts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__tokenBalanceResponse(struct soap *soap, const struct acc__tokenBalanceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfTokenAmounts(soap, &a->_tokenAmounts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__tokenBalanceResponse(struct soap *soap, const struct acc__tokenBalanceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__tokenBalanceResponse);
	if (soap_out_acc__tokenBalanceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__tokenBalanceResponse(struct soap *soap, const char *tag, int id, const struct acc__tokenBalanceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__tokenBalanceResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfTokenAmounts(soap, "tokenAmounts", -1, &a->_tokenAmounts, "vin:TokenAmount"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__tokenBalanceResponse * SOAP_FMAC4 soap_get_acc__tokenBalanceResponse(struct soap *soap, struct acc__tokenBalanceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__tokenBalanceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__tokenBalanceResponse * SOAP_FMAC4 soap_in_acc__tokenBalanceResponse(struct soap *soap, const char *tag, struct acc__tokenBalanceResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__tokenAmounts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__tokenBalanceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__tokenBalanceResponse, sizeof(struct acc__tokenBalanceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__tokenBalanceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__tokenAmounts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTokenAmounts(soap, NULL, &a->_tokenAmounts, "vin:TokenAmount"))
				{	soap_flag__tokenAmounts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__tokenBalanceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__tokenBalanceResponse, 0, sizeof(struct acc__tokenBalanceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__fetchByPaymentMethod(struct soap *soap, struct acc__fetchByPaymentMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_paymentMethod = NULL;
	soap_default_int(soap, &a->_page);
	soap_default_int(soap, &a->_pageSize);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__fetchByPaymentMethod(struct soap *soap, const struct acc__fetchByPaymentMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__PaymentMethod(soap, &a->_paymentMethod);
	soap_embedded(soap, &a->_page, SOAP_TYPE_int);
	soap_embedded(soap, &a->_pageSize, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__fetchByPaymentMethod(struct soap *soap, const struct acc__fetchByPaymentMethod *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__fetchByPaymentMethod);
	if (soap_out_acc__fetchByPaymentMethod(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__fetchByPaymentMethod(struct soap *soap, const char *tag, int id, const struct acc__fetchByPaymentMethod *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__fetchByPaymentMethod), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentMethod(soap, "paymentMethod", -1, &a->_paymentMethod, "vin:PaymentMethod"))
		return soap->error;
	if (soap_out_int(soap, "page", -1, &a->_page, "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "pageSize", -1, &a->_pageSize, "xsd:int"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__fetchByPaymentMethod * SOAP_FMAC4 soap_get_acc__fetchByPaymentMethod(struct soap *soap, struct acc__fetchByPaymentMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__fetchByPaymentMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__fetchByPaymentMethod * SOAP_FMAC4 soap_in_acc__fetchByPaymentMethod(struct soap *soap, const char *tag, struct acc__fetchByPaymentMethod *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__paymentMethod = 1;
	size_t soap_flag__page = 1;
	size_t soap_flag__pageSize = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__fetchByPaymentMethod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__fetchByPaymentMethod, sizeof(struct acc__fetchByPaymentMethod), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__fetchByPaymentMethod(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__paymentMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentMethod(soap, NULL, &a->_paymentMethod, "vin:PaymentMethod"))
				{	soap_flag__paymentMethod--;
					continue;
				}
			if (soap_flag__page && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_page, "xsd:int"))
				{	soap_flag__page--;
					continue;
				}
			if (soap_flag__pageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_pageSize, "xsd:int"))
				{	soap_flag__pageSize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__fetchByPaymentMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__fetchByPaymentMethod, 0, sizeof(struct acc__fetchByPaymentMethod), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__page > 0 || soap_flag__pageSize > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__fetchByPaymentMethodResponse(struct soap *soap, struct acc__fetchByPaymentMethodResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_accounts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__fetchByPaymentMethodResponse(struct soap *soap, const struct acc__fetchByPaymentMethodResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfAccounts(soap, &a->_accounts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__fetchByPaymentMethodResponse(struct soap *soap, const struct acc__fetchByPaymentMethodResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__fetchByPaymentMethodResponse);
	if (soap_out_acc__fetchByPaymentMethodResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__fetchByPaymentMethodResponse(struct soap *soap, const char *tag, int id, const struct acc__fetchByPaymentMethodResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__fetchByPaymentMethodResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfAccounts(soap, "accounts", -1, &a->_accounts, "vin:Account"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__fetchByPaymentMethodResponse * SOAP_FMAC4 soap_get_acc__fetchByPaymentMethodResponse(struct soap *soap, struct acc__fetchByPaymentMethodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__fetchByPaymentMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__fetchByPaymentMethodResponse * SOAP_FMAC4 soap_in_acc__fetchByPaymentMethodResponse(struct soap *soap, const char *tag, struct acc__fetchByPaymentMethodResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__accounts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__fetchByPaymentMethodResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__fetchByPaymentMethodResponse, sizeof(struct acc__fetchByPaymentMethodResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__fetchByPaymentMethodResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__accounts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAccounts(soap, NULL, &a->_accounts, "vin:Account"))
				{	soap_flag__accounts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__fetchByPaymentMethodResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__fetchByPaymentMethodResponse, 0, sizeof(struct acc__fetchByPaymentMethodResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__fetchByEmail(struct soap *soap, struct acc__fetchByEmail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_emailAddress);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__fetchByEmail(struct soap *soap, const struct acc__fetchByEmail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_emailAddress);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__fetchByEmail(struct soap *soap, const struct acc__fetchByEmail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__fetchByEmail);
	if (soap_out_acc__fetchByEmail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__fetchByEmail(struct soap *soap, const char *tag, int id, const struct acc__fetchByEmail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__fetchByEmail), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "emailAddress", -1, &a->_emailAddress, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__fetchByEmail * SOAP_FMAC4 soap_get_acc__fetchByEmail(struct soap *soap, struct acc__fetchByEmail *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__fetchByEmail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__fetchByEmail * SOAP_FMAC4 soap_in_acc__fetchByEmail(struct soap *soap, const char *tag, struct acc__fetchByEmail *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__emailAddress = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__fetchByEmail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__fetchByEmail, sizeof(struct acc__fetchByEmail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__fetchByEmail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__emailAddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_emailAddress, "xsd:string"))
				{	soap_flag__emailAddress--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__fetchByEmail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__fetchByEmail, 0, sizeof(struct acc__fetchByEmail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__fetchByEmailResponse(struct soap *soap, struct acc__fetchByEmailResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_accounts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__fetchByEmailResponse(struct soap *soap, const struct acc__fetchByEmailResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfAccounts(soap, &a->_accounts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__fetchByEmailResponse(struct soap *soap, const struct acc__fetchByEmailResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__fetchByEmailResponse);
	if (soap_out_acc__fetchByEmailResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__fetchByEmailResponse(struct soap *soap, const char *tag, int id, const struct acc__fetchByEmailResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__fetchByEmailResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfAccounts(soap, "accounts", -1, &a->_accounts, "vin:Account"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__fetchByEmailResponse * SOAP_FMAC4 soap_get_acc__fetchByEmailResponse(struct soap *soap, struct acc__fetchByEmailResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__fetchByEmailResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__fetchByEmailResponse * SOAP_FMAC4 soap_in_acc__fetchByEmailResponse(struct soap *soap, const char *tag, struct acc__fetchByEmailResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__accounts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__fetchByEmailResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__fetchByEmailResponse, sizeof(struct acc__fetchByEmailResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__fetchByEmailResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__accounts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAccounts(soap, NULL, &a->_accounts, "vin:Account"))
				{	soap_flag__accounts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__fetchByEmailResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__fetchByEmailResponse, 0, sizeof(struct acc__fetchByEmailResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__fetchByVid(struct soap *soap, struct acc__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_vid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__fetchByVid(struct soap *soap, const struct acc__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_vid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__fetchByVid(struct soap *soap, const struct acc__fetchByVid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__fetchByVid);
	if (soap_out_acc__fetchByVid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__fetchByVid(struct soap *soap, const char *tag, int id, const struct acc__fetchByVid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__fetchByVid), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "vid", -1, &a->_vid, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__fetchByVid * SOAP_FMAC4 soap_get_acc__fetchByVid(struct soap *soap, struct acc__fetchByVid *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__fetchByVid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__fetchByVid * SOAP_FMAC4 soap_in_acc__fetchByVid(struct soap *soap, const char *tag, struct acc__fetchByVid *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__vid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__fetchByVid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__fetchByVid, sizeof(struct acc__fetchByVid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__fetchByVid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__vid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_vid, "xsd:string"))
				{	soap_flag__vid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__fetchByVid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__fetchByVid, 0, sizeof(struct acc__fetchByVid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__fetchByVidResponse(struct soap *soap, struct acc__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_account = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__fetchByVidResponse(struct soap *soap, const struct acc__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__fetchByVidResponse(struct soap *soap, const struct acc__fetchByVidResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__fetchByVidResponse);
	if (soap_out_acc__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__fetchByVidResponse(struct soap *soap, const char *tag, int id, const struct acc__fetchByVidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__fetchByVidResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__fetchByVidResponse * SOAP_FMAC4 soap_get_acc__fetchByVidResponse(struct soap *soap, struct acc__fetchByVidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__fetchByVidResponse * SOAP_FMAC4 soap_in_acc__fetchByVidResponse(struct soap *soap, const char *tag, struct acc__fetchByVidResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__account = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__fetchByVidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__fetchByVidResponse, sizeof(struct acc__fetchByVidResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__fetchByVidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__fetchByVidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__fetchByVidResponse, 0, sizeof(struct acc__fetchByVidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__fetchByMerchantAccountId(struct soap *soap, struct acc__fetchByMerchantAccountId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_merchantAccountId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__fetchByMerchantAccountId(struct soap *soap, const struct acc__fetchByMerchantAccountId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_merchantAccountId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__fetchByMerchantAccountId(struct soap *soap, const struct acc__fetchByMerchantAccountId *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__fetchByMerchantAccountId);
	if (soap_out_acc__fetchByMerchantAccountId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__fetchByMerchantAccountId(struct soap *soap, const char *tag, int id, const struct acc__fetchByMerchantAccountId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__fetchByMerchantAccountId), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "merchantAccountId", -1, &a->_merchantAccountId, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__fetchByMerchantAccountId * SOAP_FMAC4 soap_get_acc__fetchByMerchantAccountId(struct soap *soap, struct acc__fetchByMerchantAccountId *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__fetchByMerchantAccountId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__fetchByMerchantAccountId * SOAP_FMAC4 soap_in_acc__fetchByMerchantAccountId(struct soap *soap, const char *tag, struct acc__fetchByMerchantAccountId *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__merchantAccountId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__fetchByMerchantAccountId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__fetchByMerchantAccountId, sizeof(struct acc__fetchByMerchantAccountId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__fetchByMerchantAccountId(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__merchantAccountId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_merchantAccountId, "xsd:string"))
				{	soap_flag__merchantAccountId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__fetchByMerchantAccountId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__fetchByMerchantAccountId, 0, sizeof(struct acc__fetchByMerchantAccountId), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__fetchByMerchantAccountIdResponse(struct soap *soap, struct acc__fetchByMerchantAccountIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_account = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__fetchByMerchantAccountIdResponse(struct soap *soap, const struct acc__fetchByMerchantAccountIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__fetchByMerchantAccountIdResponse(struct soap *soap, const struct acc__fetchByMerchantAccountIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__fetchByMerchantAccountIdResponse);
	if (soap_out_acc__fetchByMerchantAccountIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__fetchByMerchantAccountIdResponse(struct soap *soap, const char *tag, int id, const struct acc__fetchByMerchantAccountIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__fetchByMerchantAccountIdResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__fetchByMerchantAccountIdResponse * SOAP_FMAC4 soap_get_acc__fetchByMerchantAccountIdResponse(struct soap *soap, struct acc__fetchByMerchantAccountIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__fetchByMerchantAccountIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__fetchByMerchantAccountIdResponse * SOAP_FMAC4 soap_in_acc__fetchByMerchantAccountIdResponse(struct soap *soap, const char *tag, struct acc__fetchByMerchantAccountIdResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__account = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__fetchByMerchantAccountIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__fetchByMerchantAccountIdResponse, sizeof(struct acc__fetchByMerchantAccountIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__fetchByMerchantAccountIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__fetchByMerchantAccountIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__fetchByMerchantAccountIdResponse, 0, sizeof(struct acc__fetchByMerchantAccountIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__updatePaymentMethod(struct soap *soap, struct acc__updatePaymentMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_account = NULL;
	a->_paymentMethod = NULL;
	soap_default_xsd__boolean(soap, &a->_replaceOnAllAutoBills);
	soap_default_vin__PaymentUpdateBehavior(soap, &a->_updateBehavior);
	soap_default_int(soap, &a->_numCycles);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__updatePaymentMethod(struct soap *soap, const struct acc__updatePaymentMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
	soap_serialize_PointerTovin__PaymentMethod(soap, &a->_paymentMethod);
	soap_embedded(soap, &a->_replaceOnAllAutoBills, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->_numCycles, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__updatePaymentMethod(struct soap *soap, const struct acc__updatePaymentMethod *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__updatePaymentMethod);
	if (soap_out_acc__updatePaymentMethod(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__updatePaymentMethod(struct soap *soap, const char *tag, int id, const struct acc__updatePaymentMethod *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__updatePaymentMethod), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentMethod(soap, "paymentMethod", -1, &a->_paymentMethod, "vin:PaymentMethod"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "replaceOnAllAutoBills", -1, &a->_replaceOnAllAutoBills, "xsd:boolean"))
		return soap->error;
	if (soap_out_vin__PaymentUpdateBehavior(soap, "updateBehavior", -1, &a->_updateBehavior, "vin:PaymentUpdateBehavior"))
		return soap->error;
	if (soap_out_int(soap, "numCycles", -1, &a->_numCycles, "xsd:int"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__updatePaymentMethod * SOAP_FMAC4 soap_get_acc__updatePaymentMethod(struct soap *soap, struct acc__updatePaymentMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__updatePaymentMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__updatePaymentMethod * SOAP_FMAC4 soap_in_acc__updatePaymentMethod(struct soap *soap, const char *tag, struct acc__updatePaymentMethod *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__account = 1;
	size_t soap_flag__paymentMethod = 1;
	size_t soap_flag__replaceOnAllAutoBills = 1;
	size_t soap_flag__updateBehavior = 1;
	size_t soap_flag__numCycles = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__updatePaymentMethod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__updatePaymentMethod, sizeof(struct acc__updatePaymentMethod), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__updatePaymentMethod(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap_flag__paymentMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentMethod(soap, NULL, &a->_paymentMethod, "vin:PaymentMethod"))
				{	soap_flag__paymentMethod--;
					continue;
				}
			if (soap_flag__replaceOnAllAutoBills && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_replaceOnAllAutoBills, "xsd:boolean"))
				{	soap_flag__replaceOnAllAutoBills--;
					continue;
				}
			if (soap_flag__updateBehavior && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_vin__PaymentUpdateBehavior(soap, NULL, &a->_updateBehavior, "vin:PaymentUpdateBehavior"))
				{	soap_flag__updateBehavior--;
					continue;
				}
			if (soap_flag__numCycles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_numCycles, "xsd:int"))
				{	soap_flag__numCycles--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__updatePaymentMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__updatePaymentMethod, 0, sizeof(struct acc__updatePaymentMethod), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__replaceOnAllAutoBills > 0 || soap_flag__updateBehavior > 0 || soap_flag__numCycles > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__updatePaymentMethodResponse(struct soap *soap, struct acc__updatePaymentMethodResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_account = NULL;
	soap_default_xsd__boolean(soap, &a->_validated);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__updatePaymentMethodResponse(struct soap *soap, const struct acc__updatePaymentMethodResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
	soap_embedded(soap, &a->_validated, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__updatePaymentMethodResponse(struct soap *soap, const struct acc__updatePaymentMethodResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__updatePaymentMethodResponse);
	if (soap_out_acc__updatePaymentMethodResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__updatePaymentMethodResponse(struct soap *soap, const char *tag, int id, const struct acc__updatePaymentMethodResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__updatePaymentMethodResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "validated", -1, &a->_validated, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__updatePaymentMethodResponse * SOAP_FMAC4 soap_get_acc__updatePaymentMethodResponse(struct soap *soap, struct acc__updatePaymentMethodResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__updatePaymentMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__updatePaymentMethodResponse * SOAP_FMAC4 soap_in_acc__updatePaymentMethodResponse(struct soap *soap, const char *tag, struct acc__updatePaymentMethodResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__account = 1;
	size_t soap_flag__validated = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__updatePaymentMethodResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__updatePaymentMethodResponse, sizeof(struct acc__updatePaymentMethodResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__updatePaymentMethodResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap_flag__validated && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_validated, "xsd:boolean"))
				{	soap_flag__validated--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__updatePaymentMethodResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__updatePaymentMethodResponse, 0, sizeof(struct acc__updatePaymentMethodResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__validated > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__stopAutoBilling(struct soap *soap, struct acc__stopAutoBilling *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_account = NULL;
	a->_autobills = NULL;
	soap_default_xsd__boolean(soap, &a->_disentitle);
	soap_default_xsd__boolean(soap, &a->_force);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__stopAutoBilling(struct soap *soap, const struct acc__stopAutoBilling *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
	soap_serialize_PointerToArrayOfAutoBills(soap, &a->_autobills);
	soap_embedded(soap, &a->_disentitle, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->_force, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__stopAutoBilling(struct soap *soap, const struct acc__stopAutoBilling *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__stopAutoBilling);
	if (soap_out_acc__stopAutoBilling(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__stopAutoBilling(struct soap *soap, const char *tag, int id, const struct acc__stopAutoBilling *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__stopAutoBilling), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	if (soap_out_PointerToArrayOfAutoBills(soap, "autobills", -1, &a->_autobills, "vin:AutoBill"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "disentitle", -1, &a->_disentitle, "xsd:boolean"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "force", -1, &a->_force, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__stopAutoBilling * SOAP_FMAC4 soap_get_acc__stopAutoBilling(struct soap *soap, struct acc__stopAutoBilling *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__stopAutoBilling(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__stopAutoBilling * SOAP_FMAC4 soap_in_acc__stopAutoBilling(struct soap *soap, const char *tag, struct acc__stopAutoBilling *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__account = 1;
	size_t soap_flag__autobills = 1;
	size_t soap_flag__disentitle = 1;
	size_t soap_flag__force = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__stopAutoBilling *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__stopAutoBilling, sizeof(struct acc__stopAutoBilling), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__stopAutoBilling(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap_flag__autobills && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAutoBills(soap, NULL, &a->_autobills, "vin:AutoBill"))
				{	soap_flag__autobills--;
					continue;
				}
			if (soap_flag__disentitle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_disentitle, "xsd:boolean"))
				{	soap_flag__disentitle--;
					continue;
				}
			if (soap_flag__force && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_force, "xsd:boolean"))
				{	soap_flag__force--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__stopAutoBilling *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__stopAutoBilling, 0, sizeof(struct acc__stopAutoBilling), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__disentitle > 0 || soap_flag__force > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__stopAutoBillingResponse(struct soap *soap, struct acc__stopAutoBillingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_account = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__stopAutoBillingResponse(struct soap *soap, const struct acc__stopAutoBillingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__stopAutoBillingResponse(struct soap *soap, const struct acc__stopAutoBillingResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__stopAutoBillingResponse);
	if (soap_out_acc__stopAutoBillingResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__stopAutoBillingResponse(struct soap *soap, const char *tag, int id, const struct acc__stopAutoBillingResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__stopAutoBillingResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__stopAutoBillingResponse * SOAP_FMAC4 soap_get_acc__stopAutoBillingResponse(struct soap *soap, struct acc__stopAutoBillingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__stopAutoBillingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__stopAutoBillingResponse * SOAP_FMAC4 soap_in_acc__stopAutoBillingResponse(struct soap *soap, const char *tag, struct acc__stopAutoBillingResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__account = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__stopAutoBillingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__stopAutoBillingResponse, sizeof(struct acc__stopAutoBillingResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__stopAutoBillingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__stopAutoBillingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__stopAutoBillingResponse, 0, sizeof(struct acc__stopAutoBillingResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__update(struct soap *soap, struct acc__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_account = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__update(struct soap *soap, const struct acc__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__update(struct soap *soap, const struct acc__update *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__update);
	if (soap_out_acc__update(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__update(struct soap *soap, const char *tag, int id, const struct acc__update *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__update), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__update * SOAP_FMAC4 soap_get_acc__update(struct soap *soap, struct acc__update *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__update(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__update * SOAP_FMAC4 soap_in_acc__update(struct soap *soap, const char *tag, struct acc__update *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__account = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__update *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__update, sizeof(struct acc__update), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__update(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__update *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__update, 0, sizeof(struct acc__update), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_acc__updateResponse(struct soap *soap, struct acc__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_account = NULL;
	soap_default_xsd__boolean(soap, &a->_created);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_acc__updateResponse(struct soap *soap, const struct acc__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
	soap_embedded(soap, &a->_created, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_acc__updateResponse(struct soap *soap, const struct acc__updateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_acc__updateResponse);
	if (soap_out_acc__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_acc__updateResponse(struct soap *soap, const char *tag, int id, const struct acc__updateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_acc__updateResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "created", -1, &a->_created, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct acc__updateResponse * SOAP_FMAC4 soap_get_acc__updateResponse(struct soap *soap, struct acc__updateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_acc__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__updateResponse * SOAP_FMAC4 soap_in_acc__updateResponse(struct soap *soap, const char *tag, struct acc__updateResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__account = 1;
	size_t soap_flag__created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct acc__updateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_acc__updateResponse, sizeof(struct acc__updateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_acc__updateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap_flag__created && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_created, "xsd:boolean"))
				{	soap_flag__created--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct acc__updateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_acc__updateResponse, 0, sizeof(struct acc__updateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__created > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__fetchDeltaSince(struct soap *soap, struct abl__fetchDeltaSince *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_time(soap, &a->_timestamp);
	soap_default_int(soap, &a->_page);
	soap_default_int(soap, &a->_pageSize);
	soap_default_time(soap, &a->_endTimestamp);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__fetchDeltaSince(struct soap *soap, const struct abl__fetchDeltaSince *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_embedded(soap, &a->_timestamp, SOAP_TYPE_time);
	soap_embedded(soap, &a->_page, SOAP_TYPE_int);
	soap_embedded(soap, &a->_pageSize, SOAP_TYPE_int);
	soap_embedded(soap, &a->_endTimestamp, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__fetchDeltaSince(struct soap *soap, const struct abl__fetchDeltaSince *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__fetchDeltaSince);
	if (soap_out_abl__fetchDeltaSince(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__fetchDeltaSince(struct soap *soap, const char *tag, int id, const struct abl__fetchDeltaSince *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__fetchDeltaSince), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_time(soap, "timestamp", -1, &a->_timestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_int(soap, "page", -1, &a->_page, "xsd:int"))
		return soap->error;
	if (soap_out_int(soap, "pageSize", -1, &a->_pageSize, "xsd:int"))
		return soap->error;
	if (soap_out_time(soap, "endTimestamp", -1, &a->_endTimestamp, "xsd:dateTime"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__fetchDeltaSince * SOAP_FMAC4 soap_get_abl__fetchDeltaSince(struct soap *soap, struct abl__fetchDeltaSince *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__fetchDeltaSince(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchDeltaSince * SOAP_FMAC4 soap_in_abl__fetchDeltaSince(struct soap *soap, const char *tag, struct abl__fetchDeltaSince *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__timestamp = 1;
	size_t soap_flag__page = 1;
	size_t soap_flag__pageSize = 1;
	size_t soap_flag__endTimestamp = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__fetchDeltaSince *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__fetchDeltaSince, sizeof(struct abl__fetchDeltaSince), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__fetchDeltaSince(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_timestamp, "xsd:dateTime"))
				{	soap_flag__timestamp--;
					continue;
				}
			if (soap_flag__page && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_page, "xsd:int"))
				{	soap_flag__page--;
					continue;
				}
			if (soap_flag__pageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_pageSize, "xsd:int"))
				{	soap_flag__pageSize--;
					continue;
				}
			if (soap_flag__endTimestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_endTimestamp, "xsd:dateTime"))
				{	soap_flag__endTimestamp--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__fetchDeltaSince *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__fetchDeltaSince, 0, sizeof(struct abl__fetchDeltaSince), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__timestamp > 0 || soap_flag__page > 0 || soap_flag__pageSize > 0 || soap_flag__endTimestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__fetchDeltaSinceResponse(struct soap *soap, struct abl__fetchDeltaSinceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_autobills = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__fetchDeltaSinceResponse(struct soap *soap, const struct abl__fetchDeltaSinceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfAutoBills(soap, &a->_autobills);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__fetchDeltaSinceResponse(struct soap *soap, const struct abl__fetchDeltaSinceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__fetchDeltaSinceResponse);
	if (soap_out_abl__fetchDeltaSinceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__fetchDeltaSinceResponse(struct soap *soap, const char *tag, int id, const struct abl__fetchDeltaSinceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__fetchDeltaSinceResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfAutoBills(soap, "autobills", -1, &a->_autobills, "vin:AutoBill"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__fetchDeltaSinceResponse * SOAP_FMAC4 soap_get_abl__fetchDeltaSinceResponse(struct soap *soap, struct abl__fetchDeltaSinceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__fetchDeltaSinceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchDeltaSinceResponse * SOAP_FMAC4 soap_in_abl__fetchDeltaSinceResponse(struct soap *soap, const char *tag, struct abl__fetchDeltaSinceResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__autobills = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__fetchDeltaSinceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__fetchDeltaSinceResponse, sizeof(struct abl__fetchDeltaSinceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__fetchDeltaSinceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__autobills && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAutoBills(soap, NULL, &a->_autobills, "vin:AutoBill"))
				{	soap_flag__autobills--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__fetchDeltaSinceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__fetchDeltaSinceResponse, 0, sizeof(struct abl__fetchDeltaSinceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__futureRebills(struct soap *soap, struct abl__futureRebills *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_autobill = NULL;
	soap_default_int(soap, &a->_quantity);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__futureRebills(struct soap *soap, const struct abl__futureRebills *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__AutoBill(soap, &a->_autobill);
	soap_embedded(soap, &a->_quantity, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__futureRebills(struct soap *soap, const struct abl__futureRebills *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__futureRebills);
	if (soap_out_abl__futureRebills(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__futureRebills(struct soap *soap, const char *tag, int id, const struct abl__futureRebills *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__futureRebills), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__AutoBill(soap, "autobill", -1, &a->_autobill, "vin:AutoBill"))
		return soap->error;
	if (soap_out_int(soap, "quantity", -1, &a->_quantity, "xsd:int"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__futureRebills * SOAP_FMAC4 soap_get_abl__futureRebills(struct soap *soap, struct abl__futureRebills *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__futureRebills(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__futureRebills * SOAP_FMAC4 soap_in_abl__futureRebills(struct soap *soap, const char *tag, struct abl__futureRebills *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__autobill = 1;
	size_t soap_flag__quantity = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__futureRebills *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__futureRebills, sizeof(struct abl__futureRebills), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__futureRebills(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__autobill && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__AutoBill(soap, NULL, &a->_autobill, "vin:AutoBill"))
				{	soap_flag__autobill--;
					continue;
				}
			if (soap_flag__quantity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_quantity, "xsd:int"))
				{	soap_flag__quantity--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__futureRebills *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__futureRebills, 0, sizeof(struct abl__futureRebills), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__quantity > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__futureRebillsResponse(struct soap *soap, struct abl__futureRebillsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_transactions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__futureRebillsResponse(struct soap *soap, const struct abl__futureRebillsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfTransactions(soap, &a->_transactions);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__futureRebillsResponse(struct soap *soap, const struct abl__futureRebillsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__futureRebillsResponse);
	if (soap_out_abl__futureRebillsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__futureRebillsResponse(struct soap *soap, const char *tag, int id, const struct abl__futureRebillsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__futureRebillsResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfTransactions(soap, "transactions", -1, &a->_transactions, "vin:Transaction"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__futureRebillsResponse * SOAP_FMAC4 soap_get_abl__futureRebillsResponse(struct soap *soap, struct abl__futureRebillsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__futureRebillsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__futureRebillsResponse * SOAP_FMAC4 soap_in_abl__futureRebillsResponse(struct soap *soap, const char *tag, struct abl__futureRebillsResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__transactions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__futureRebillsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__futureRebillsResponse, sizeof(struct abl__futureRebillsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__futureRebillsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__transactions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTransactions(soap, NULL, &a->_transactions, "vin:Transaction"))
				{	soap_flag__transactions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__futureRebillsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__futureRebillsResponse, 0, sizeof(struct abl__futureRebillsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__fetchByAccount(struct soap *soap, struct abl__fetchByAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_account = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__fetchByAccount(struct soap *soap, const struct abl__fetchByAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__fetchByAccount(struct soap *soap, const struct abl__fetchByAccount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__fetchByAccount);
	if (soap_out_abl__fetchByAccount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__fetchByAccount(struct soap *soap, const char *tag, int id, const struct abl__fetchByAccount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__fetchByAccount), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__fetchByAccount * SOAP_FMAC4 soap_get_abl__fetchByAccount(struct soap *soap, struct abl__fetchByAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__fetchByAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchByAccount * SOAP_FMAC4 soap_in_abl__fetchByAccount(struct soap *soap, const char *tag, struct abl__fetchByAccount *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__account = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__fetchByAccount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__fetchByAccount, sizeof(struct abl__fetchByAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__fetchByAccount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__fetchByAccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__fetchByAccount, 0, sizeof(struct abl__fetchByAccount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__fetchByAccountResponse(struct soap *soap, struct abl__fetchByAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_autobills = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__fetchByAccountResponse(struct soap *soap, const struct abl__fetchByAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfAutoBills(soap, &a->_autobills);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__fetchByAccountResponse(struct soap *soap, const struct abl__fetchByAccountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__fetchByAccountResponse);
	if (soap_out_abl__fetchByAccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__fetchByAccountResponse(struct soap *soap, const char *tag, int id, const struct abl__fetchByAccountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__fetchByAccountResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfAutoBills(soap, "autobills", -1, &a->_autobills, "vin:AutoBill"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__fetchByAccountResponse * SOAP_FMAC4 soap_get_abl__fetchByAccountResponse(struct soap *soap, struct abl__fetchByAccountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__fetchByAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchByAccountResponse * SOAP_FMAC4 soap_in_abl__fetchByAccountResponse(struct soap *soap, const char *tag, struct abl__fetchByAccountResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__autobills = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__fetchByAccountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__fetchByAccountResponse, sizeof(struct abl__fetchByAccountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__fetchByAccountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__autobills && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAutoBills(soap, NULL, &a->_autobills, "vin:AutoBill"))
				{	soap_flag__autobills--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__fetchByAccountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__fetchByAccountResponse, 0, sizeof(struct abl__fetchByAccountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__fetchByEmail(struct soap *soap, struct abl__fetchByEmail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_email);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__fetchByEmail(struct soap *soap, const struct abl__fetchByEmail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_email);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__fetchByEmail(struct soap *soap, const struct abl__fetchByEmail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__fetchByEmail);
	if (soap_out_abl__fetchByEmail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__fetchByEmail(struct soap *soap, const char *tag, int id, const struct abl__fetchByEmail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__fetchByEmail), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "email", -1, &a->_email, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__fetchByEmail * SOAP_FMAC4 soap_get_abl__fetchByEmail(struct soap *soap, struct abl__fetchByEmail *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__fetchByEmail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchByEmail * SOAP_FMAC4 soap_in_abl__fetchByEmail(struct soap *soap, const char *tag, struct abl__fetchByEmail *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__email = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__fetchByEmail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__fetchByEmail, sizeof(struct abl__fetchByEmail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__fetchByEmail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__email && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_email, "xsd:string"))
				{	soap_flag__email--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__fetchByEmail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__fetchByEmail, 0, sizeof(struct abl__fetchByEmail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__fetchByEmailResponse(struct soap *soap, struct abl__fetchByEmailResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_autobills = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__fetchByEmailResponse(struct soap *soap, const struct abl__fetchByEmailResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfAutoBills(soap, &a->_autobills);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__fetchByEmailResponse(struct soap *soap, const struct abl__fetchByEmailResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__fetchByEmailResponse);
	if (soap_out_abl__fetchByEmailResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__fetchByEmailResponse(struct soap *soap, const char *tag, int id, const struct abl__fetchByEmailResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__fetchByEmailResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfAutoBills(soap, "autobills", -1, &a->_autobills, "vin:AutoBill"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__fetchByEmailResponse * SOAP_FMAC4 soap_get_abl__fetchByEmailResponse(struct soap *soap, struct abl__fetchByEmailResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__fetchByEmailResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchByEmailResponse * SOAP_FMAC4 soap_in_abl__fetchByEmailResponse(struct soap *soap, const char *tag, struct abl__fetchByEmailResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__autobills = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__fetchByEmailResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__fetchByEmailResponse, sizeof(struct abl__fetchByEmailResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__fetchByEmailResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__autobills && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAutoBills(soap, NULL, &a->_autobills, "vin:AutoBill"))
				{	soap_flag__autobills--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__fetchByEmailResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__fetchByEmailResponse, 0, sizeof(struct abl__fetchByEmailResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__fetchByVid(struct soap *soap, struct abl__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_vid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__fetchByVid(struct soap *soap, const struct abl__fetchByVid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_vid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__fetchByVid(struct soap *soap, const struct abl__fetchByVid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__fetchByVid);
	if (soap_out_abl__fetchByVid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__fetchByVid(struct soap *soap, const char *tag, int id, const struct abl__fetchByVid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__fetchByVid), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "vid", -1, &a->_vid, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__fetchByVid * SOAP_FMAC4 soap_get_abl__fetchByVid(struct soap *soap, struct abl__fetchByVid *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__fetchByVid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchByVid * SOAP_FMAC4 soap_in_abl__fetchByVid(struct soap *soap, const char *tag, struct abl__fetchByVid *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__vid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__fetchByVid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__fetchByVid, sizeof(struct abl__fetchByVid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__fetchByVid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__vid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_vid, "xsd:string"))
				{	soap_flag__vid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__fetchByVid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__fetchByVid, 0, sizeof(struct abl__fetchByVid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__fetchByVidResponse(struct soap *soap, struct abl__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_autobill = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__fetchByVidResponse(struct soap *soap, const struct abl__fetchByVidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__AutoBill(soap, &a->_autobill);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__fetchByVidResponse(struct soap *soap, const struct abl__fetchByVidResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__fetchByVidResponse);
	if (soap_out_abl__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__fetchByVidResponse(struct soap *soap, const char *tag, int id, const struct abl__fetchByVidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__fetchByVidResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__AutoBill(soap, "autobill", -1, &a->_autobill, "vin:AutoBill"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__fetchByVidResponse * SOAP_FMAC4 soap_get_abl__fetchByVidResponse(struct soap *soap, struct abl__fetchByVidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchByVidResponse * SOAP_FMAC4 soap_in_abl__fetchByVidResponse(struct soap *soap, const char *tag, struct abl__fetchByVidResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__autobill = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__fetchByVidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__fetchByVidResponse, sizeof(struct abl__fetchByVidResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__fetchByVidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__autobill && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__AutoBill(soap, NULL, &a->_autobill, "vin:AutoBill"))
				{	soap_flag__autobill--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__fetchByVidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__fetchByVidResponse, 0, sizeof(struct abl__fetchByVidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__fetchByMerchantAutoBillId(struct soap *soap, struct abl__fetchByMerchantAutoBillId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	soap_default_string(soap, &a->_merchantAutoBillId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__fetchByMerchantAutoBillId(struct soap *soap, const struct abl__fetchByMerchantAutoBillId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_string(soap, &a->_merchantAutoBillId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__fetchByMerchantAutoBillId(struct soap *soap, const struct abl__fetchByMerchantAutoBillId *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__fetchByMerchantAutoBillId);
	if (soap_out_abl__fetchByMerchantAutoBillId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__fetchByMerchantAutoBillId(struct soap *soap, const char *tag, int id, const struct abl__fetchByMerchantAutoBillId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__fetchByMerchantAutoBillId), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_string(soap, "merchantAutoBillId", -1, &a->_merchantAutoBillId, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__fetchByMerchantAutoBillId * SOAP_FMAC4 soap_get_abl__fetchByMerchantAutoBillId(struct soap *soap, struct abl__fetchByMerchantAutoBillId *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__fetchByMerchantAutoBillId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchByMerchantAutoBillId * SOAP_FMAC4 soap_in_abl__fetchByMerchantAutoBillId(struct soap *soap, const char *tag, struct abl__fetchByMerchantAutoBillId *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__merchantAutoBillId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__fetchByMerchantAutoBillId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__fetchByMerchantAutoBillId, sizeof(struct abl__fetchByMerchantAutoBillId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__fetchByMerchantAutoBillId(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__merchantAutoBillId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_merchantAutoBillId, "xsd:string"))
				{	soap_flag__merchantAutoBillId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__fetchByMerchantAutoBillId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__fetchByMerchantAutoBillId, 0, sizeof(struct abl__fetchByMerchantAutoBillId), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__fetchByMerchantAutoBillIdResponse(struct soap *soap, struct abl__fetchByMerchantAutoBillIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_autobill = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__fetchByMerchantAutoBillIdResponse(struct soap *soap, const struct abl__fetchByMerchantAutoBillIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__AutoBill(soap, &a->_autobill);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__fetchByMerchantAutoBillIdResponse(struct soap *soap, const struct abl__fetchByMerchantAutoBillIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__fetchByMerchantAutoBillIdResponse);
	if (soap_out_abl__fetchByMerchantAutoBillIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__fetchByMerchantAutoBillIdResponse(struct soap *soap, const char *tag, int id, const struct abl__fetchByMerchantAutoBillIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__fetchByMerchantAutoBillIdResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__AutoBill(soap, "autobill", -1, &a->_autobill, "vin:AutoBill"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__fetchByMerchantAutoBillIdResponse * SOAP_FMAC4 soap_get_abl__fetchByMerchantAutoBillIdResponse(struct soap *soap, struct abl__fetchByMerchantAutoBillIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__fetchByMerchantAutoBillIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchByMerchantAutoBillIdResponse * SOAP_FMAC4 soap_in_abl__fetchByMerchantAutoBillIdResponse(struct soap *soap, const char *tag, struct abl__fetchByMerchantAutoBillIdResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__autobill = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__fetchByMerchantAutoBillIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__fetchByMerchantAutoBillIdResponse, sizeof(struct abl__fetchByMerchantAutoBillIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__fetchByMerchantAutoBillIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__autobill && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__AutoBill(soap, NULL, &a->_autobill, "vin:AutoBill"))
				{	soap_flag__autobill--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__fetchByMerchantAutoBillIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__fetchByMerchantAutoBillIdResponse, 0, sizeof(struct abl__fetchByMerchantAutoBillIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__fetchByAccountAndProduct(struct soap *soap, struct abl__fetchByAccountAndProduct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_account = NULL;
	a->_product = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__fetchByAccountAndProduct(struct soap *soap, const struct abl__fetchByAccountAndProduct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__Account(soap, &a->_account);
	soap_serialize_PointerTovin__Product(soap, &a->_product);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__fetchByAccountAndProduct(struct soap *soap, const struct abl__fetchByAccountAndProduct *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__fetchByAccountAndProduct);
	if (soap_out_abl__fetchByAccountAndProduct(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__fetchByAccountAndProduct(struct soap *soap, const char *tag, int id, const struct abl__fetchByAccountAndProduct *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__fetchByAccountAndProduct), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->_account, "vin:Account"))
		return soap->error;
	if (soap_out_PointerTovin__Product(soap, "product", -1, &a->_product, "vin:Product"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__fetchByAccountAndProduct * SOAP_FMAC4 soap_get_abl__fetchByAccountAndProduct(struct soap *soap, struct abl__fetchByAccountAndProduct *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__fetchByAccountAndProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchByAccountAndProduct * SOAP_FMAC4 soap_in_abl__fetchByAccountAndProduct(struct soap *soap, const char *tag, struct abl__fetchByAccountAndProduct *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__account = 1;
	size_t soap_flag__product = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__fetchByAccountAndProduct *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__fetchByAccountAndProduct, sizeof(struct abl__fetchByAccountAndProduct), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__fetchByAccountAndProduct(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, NULL, &a->_account, "vin:Account"))
				{	soap_flag__account--;
					continue;
				}
			if (soap_flag__product && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Product(soap, NULL, &a->_product, "vin:Product"))
				{	soap_flag__product--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__fetchByAccountAndProduct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__fetchByAccountAndProduct, 0, sizeof(struct abl__fetchByAccountAndProduct), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__fetchByAccountAndProductResponse(struct soap *soap, struct abl__fetchByAccountAndProductResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_autobills = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__fetchByAccountAndProductResponse(struct soap *soap, const struct abl__fetchByAccountAndProductResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerToArrayOfAutoBills(soap, &a->_autobills);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__fetchByAccountAndProductResponse(struct soap *soap, const struct abl__fetchByAccountAndProductResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__fetchByAccountAndProductResponse);
	if (soap_out_abl__fetchByAccountAndProductResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__fetchByAccountAndProductResponse(struct soap *soap, const char *tag, int id, const struct abl__fetchByAccountAndProductResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__fetchByAccountAndProductResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerToArrayOfAutoBills(soap, "autobills", -1, &a->_autobills, "vin:AutoBill"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__fetchByAccountAndProductResponse * SOAP_FMAC4 soap_get_abl__fetchByAccountAndProductResponse(struct soap *soap, struct abl__fetchByAccountAndProductResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__fetchByAccountAndProductResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchByAccountAndProductResponse * SOAP_FMAC4 soap_in_abl__fetchByAccountAndProductResponse(struct soap *soap, const char *tag, struct abl__fetchByAccountAndProductResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__autobills = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__fetchByAccountAndProductResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__fetchByAccountAndProductResponse, sizeof(struct abl__fetchByAccountAndProductResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__fetchByAccountAndProductResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__autobills && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAutoBills(soap, NULL, &a->_autobills, "vin:AutoBill"))
				{	soap_flag__autobills--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__fetchByAccountAndProductResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__fetchByAccountAndProductResponse, 0, sizeof(struct abl__fetchByAccountAndProductResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__changeBillingDayOfMonth(struct soap *soap, struct abl__changeBillingDayOfMonth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_autobill = NULL;
	soap_default_int(soap, &a->_dayOfMonth);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__changeBillingDayOfMonth(struct soap *soap, const struct abl__changeBillingDayOfMonth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__AutoBill(soap, &a->_autobill);
	soap_embedded(soap, &a->_dayOfMonth, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__changeBillingDayOfMonth(struct soap *soap, const struct abl__changeBillingDayOfMonth *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__changeBillingDayOfMonth);
	if (soap_out_abl__changeBillingDayOfMonth(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__changeBillingDayOfMonth(struct soap *soap, const char *tag, int id, const struct abl__changeBillingDayOfMonth *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__changeBillingDayOfMonth), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__AutoBill(soap, "autobill", -1, &a->_autobill, "vin:AutoBill"))
		return soap->error;
	if (soap_out_int(soap, "dayOfMonth", -1, &a->_dayOfMonth, "xsd:int"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__changeBillingDayOfMonth * SOAP_FMAC4 soap_get_abl__changeBillingDayOfMonth(struct soap *soap, struct abl__changeBillingDayOfMonth *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__changeBillingDayOfMonth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__changeBillingDayOfMonth * SOAP_FMAC4 soap_in_abl__changeBillingDayOfMonth(struct soap *soap, const char *tag, struct abl__changeBillingDayOfMonth *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__autobill = 1;
	size_t soap_flag__dayOfMonth = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__changeBillingDayOfMonth *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__changeBillingDayOfMonth, sizeof(struct abl__changeBillingDayOfMonth), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__changeBillingDayOfMonth(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__autobill && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__AutoBill(soap, NULL, &a->_autobill, "vin:AutoBill"))
				{	soap_flag__autobill--;
					continue;
				}
			if (soap_flag__dayOfMonth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_dayOfMonth, "xsd:int"))
				{	soap_flag__dayOfMonth--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__changeBillingDayOfMonth *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__changeBillingDayOfMonth, 0, sizeof(struct abl__changeBillingDayOfMonth), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__dayOfMonth > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__changeBillingDayOfMonthResponse(struct soap *soap, struct abl__changeBillingDayOfMonthResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_autobill = NULL;
	soap_default_xsd__date(soap, &a->_nextBillingDate);
	soap_default_xsd__decimal(soap, &a->_nextBillingAmount);
	soap_default_string(soap, &a->_nextBillingCurrency);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__changeBillingDayOfMonthResponse(struct soap *soap, const struct abl__changeBillingDayOfMonthResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__AutoBill(soap, &a->_autobill);
	soap_serialize_xsd__date(soap, &a->_nextBillingDate);
	soap_serialize_xsd__decimal(soap, &a->_nextBillingAmount);
	soap_serialize_string(soap, &a->_nextBillingCurrency);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__changeBillingDayOfMonthResponse(struct soap *soap, const struct abl__changeBillingDayOfMonthResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__changeBillingDayOfMonthResponse);
	if (soap_out_abl__changeBillingDayOfMonthResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__changeBillingDayOfMonthResponse(struct soap *soap, const char *tag, int id, const struct abl__changeBillingDayOfMonthResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__changeBillingDayOfMonthResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__AutoBill(soap, "autobill", -1, &a->_autobill, "vin:AutoBill"))
		return soap->error;
	if (soap_out_xsd__date(soap, "nextBillingDate", -1, &a->_nextBillingDate, "xsd:date"))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "nextBillingAmount", -1, &a->_nextBillingAmount, "xsd:decimal"))
		return soap->error;
	if (soap_out_string(soap, "nextBillingCurrency", -1, &a->_nextBillingCurrency, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__changeBillingDayOfMonthResponse * SOAP_FMAC4 soap_get_abl__changeBillingDayOfMonthResponse(struct soap *soap, struct abl__changeBillingDayOfMonthResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__changeBillingDayOfMonthResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__changeBillingDayOfMonthResponse * SOAP_FMAC4 soap_in_abl__changeBillingDayOfMonthResponse(struct soap *soap, const char *tag, struct abl__changeBillingDayOfMonthResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__autobill = 1;
	size_t soap_flag__nextBillingDate = 1;
	size_t soap_flag__nextBillingAmount = 1;
	size_t soap_flag__nextBillingCurrency = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__changeBillingDayOfMonthResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__changeBillingDayOfMonthResponse, sizeof(struct abl__changeBillingDayOfMonthResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__changeBillingDayOfMonthResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__autobill && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__AutoBill(soap, NULL, &a->_autobill, "vin:AutoBill"))
				{	soap_flag__autobill--;
					continue;
				}
			if (soap_flag__nextBillingDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, NULL, &a->_nextBillingDate, "xsd:date"))
				{	soap_flag__nextBillingDate--;
					continue;
				}
			if (soap_flag__nextBillingAmount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, NULL, &a->_nextBillingAmount, "xsd:decimal"))
				{	soap_flag__nextBillingAmount--;
					continue;
				}
			if (soap_flag__nextBillingCurrency && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_nextBillingCurrency, "xsd:string"))
				{	soap_flag__nextBillingCurrency--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__changeBillingDayOfMonthResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__changeBillingDayOfMonthResponse, 0, sizeof(struct abl__changeBillingDayOfMonthResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__delayBillingByDays(struct soap *soap, struct abl__delayBillingByDays *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_autobill = NULL;
	soap_default_int(soap, &a->_delayDays);
	soap_default_xsd__boolean(soap, &a->_movePermanently);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__delayBillingByDays(struct soap *soap, const struct abl__delayBillingByDays *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__AutoBill(soap, &a->_autobill);
	soap_embedded(soap, &a->_delayDays, SOAP_TYPE_int);
	soap_embedded(soap, &a->_movePermanently, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__delayBillingByDays(struct soap *soap, const struct abl__delayBillingByDays *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__delayBillingByDays);
	if (soap_out_abl__delayBillingByDays(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__delayBillingByDays(struct soap *soap, const char *tag, int id, const struct abl__delayBillingByDays *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__delayBillingByDays), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__AutoBill(soap, "autobill", -1, &a->_autobill, "vin:AutoBill"))
		return soap->error;
	if (soap_out_int(soap, "delayDays", -1, &a->_delayDays, "xsd:int"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "movePermanently", -1, &a->_movePermanently, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__delayBillingByDays * SOAP_FMAC4 soap_get_abl__delayBillingByDays(struct soap *soap, struct abl__delayBillingByDays *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__delayBillingByDays(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__delayBillingByDays * SOAP_FMAC4 soap_in_abl__delayBillingByDays(struct soap *soap, const char *tag, struct abl__delayBillingByDays *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__autobill = 1;
	size_t soap_flag__delayDays = 1;
	size_t soap_flag__movePermanently = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__delayBillingByDays *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__delayBillingByDays, sizeof(struct abl__delayBillingByDays), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__delayBillingByDays(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__autobill && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__AutoBill(soap, NULL, &a->_autobill, "vin:AutoBill"))
				{	soap_flag__autobill--;
					continue;
				}
			if (soap_flag__delayDays && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_delayDays, "xsd:int"))
				{	soap_flag__delayDays--;
					continue;
				}
			if (soap_flag__movePermanently && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_movePermanently, "xsd:boolean"))
				{	soap_flag__movePermanently--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__delayBillingByDays *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__delayBillingByDays, 0, sizeof(struct abl__delayBillingByDays), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delayDays > 0 || soap_flag__movePermanently > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__delayBillingByDaysResponse(struct soap *soap, struct abl__delayBillingByDaysResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_autobill = NULL;
	soap_default_xsd__date(soap, &a->_nextBillingDate);
	soap_default_xsd__decimal(soap, &a->_nextBillingAmount);
	soap_default_string(soap, &a->_nextBillingCurrency);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__delayBillingByDaysResponse(struct soap *soap, const struct abl__delayBillingByDaysResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__AutoBill(soap, &a->_autobill);
	soap_serialize_xsd__date(soap, &a->_nextBillingDate);
	soap_serialize_xsd__decimal(soap, &a->_nextBillingAmount);
	soap_serialize_string(soap, &a->_nextBillingCurrency);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__delayBillingByDaysResponse(struct soap *soap, const struct abl__delayBillingByDaysResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__delayBillingByDaysResponse);
	if (soap_out_abl__delayBillingByDaysResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__delayBillingByDaysResponse(struct soap *soap, const char *tag, int id, const struct abl__delayBillingByDaysResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__delayBillingByDaysResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__AutoBill(soap, "autobill", -1, &a->_autobill, "vin:AutoBill"))
		return soap->error;
	if (soap_out_xsd__date(soap, "nextBillingDate", -1, &a->_nextBillingDate, "xsd:date"))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "nextBillingAmount", -1, &a->_nextBillingAmount, "xsd:decimal"))
		return soap->error;
	if (soap_out_string(soap, "nextBillingCurrency", -1, &a->_nextBillingCurrency, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__delayBillingByDaysResponse * SOAP_FMAC4 soap_get_abl__delayBillingByDaysResponse(struct soap *soap, struct abl__delayBillingByDaysResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__delayBillingByDaysResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__delayBillingByDaysResponse * SOAP_FMAC4 soap_in_abl__delayBillingByDaysResponse(struct soap *soap, const char *tag, struct abl__delayBillingByDaysResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__autobill = 1;
	size_t soap_flag__nextBillingDate = 1;
	size_t soap_flag__nextBillingAmount = 1;
	size_t soap_flag__nextBillingCurrency = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__delayBillingByDaysResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__delayBillingByDaysResponse, sizeof(struct abl__delayBillingByDaysResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__delayBillingByDaysResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__autobill && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__AutoBill(soap, NULL, &a->_autobill, "vin:AutoBill"))
				{	soap_flag__autobill--;
					continue;
				}
			if (soap_flag__nextBillingDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, NULL, &a->_nextBillingDate, "xsd:date"))
				{	soap_flag__nextBillingDate--;
					continue;
				}
			if (soap_flag__nextBillingAmount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, NULL, &a->_nextBillingAmount, "xsd:decimal"))
				{	soap_flag__nextBillingAmount--;
					continue;
				}
			if (soap_flag__nextBillingCurrency && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_nextBillingCurrency, "xsd:string"))
				{	soap_flag__nextBillingCurrency--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__delayBillingByDaysResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__delayBillingByDaysResponse, 0, sizeof(struct abl__delayBillingByDaysResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__delayBillingToDate(struct soap *soap, struct abl__delayBillingToDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_autobill = NULL;
	soap_default_xsd__date(soap, &a->_newBillingDate);
	soap_default_xsd__boolean(soap, &a->_movePermanently);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__delayBillingToDate(struct soap *soap, const struct abl__delayBillingToDate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__AutoBill(soap, &a->_autobill);
	soap_serialize_xsd__date(soap, &a->_newBillingDate);
	soap_embedded(soap, &a->_movePermanently, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__delayBillingToDate(struct soap *soap, const struct abl__delayBillingToDate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__delayBillingToDate);
	if (soap_out_abl__delayBillingToDate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__delayBillingToDate(struct soap *soap, const char *tag, int id, const struct abl__delayBillingToDate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__delayBillingToDate), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__AutoBill(soap, "autobill", -1, &a->_autobill, "vin:AutoBill"))
		return soap->error;
	if (soap_out_xsd__date(soap, "newBillingDate", -1, &a->_newBillingDate, "xsd:date"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "movePermanently", -1, &a->_movePermanently, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__delayBillingToDate * SOAP_FMAC4 soap_get_abl__delayBillingToDate(struct soap *soap, struct abl__delayBillingToDate *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__delayBillingToDate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__delayBillingToDate * SOAP_FMAC4 soap_in_abl__delayBillingToDate(struct soap *soap, const char *tag, struct abl__delayBillingToDate *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__autobill = 1;
	size_t soap_flag__newBillingDate = 1;
	size_t soap_flag__movePermanently = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__delayBillingToDate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__delayBillingToDate, sizeof(struct abl__delayBillingToDate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__delayBillingToDate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__autobill && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__AutoBill(soap, NULL, &a->_autobill, "vin:AutoBill"))
				{	soap_flag__autobill--;
					continue;
				}
			if (soap_flag__newBillingDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, NULL, &a->_newBillingDate, "xsd:date"))
				{	soap_flag__newBillingDate--;
					continue;
				}
			if (soap_flag__movePermanently && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_movePermanently, "xsd:boolean"))
				{	soap_flag__movePermanently--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__delayBillingToDate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__delayBillingToDate, 0, sizeof(struct abl__delayBillingToDate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__movePermanently > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__delayBillingToDateResponse(struct soap *soap, struct abl__delayBillingToDateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_autobill = NULL;
	soap_default_xsd__date(soap, &a->_nextBillingDate);
	soap_default_xsd__decimal(soap, &a->_nextBillingAmount);
	soap_default_string(soap, &a->_nextBillingCurrency);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__delayBillingToDateResponse(struct soap *soap, const struct abl__delayBillingToDateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__AutoBill(soap, &a->_autobill);
	soap_serialize_xsd__date(soap, &a->_nextBillingDate);
	soap_serialize_xsd__decimal(soap, &a->_nextBillingAmount);
	soap_serialize_string(soap, &a->_nextBillingCurrency);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__delayBillingToDateResponse(struct soap *soap, const struct abl__delayBillingToDateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__delayBillingToDateResponse);
	if (soap_out_abl__delayBillingToDateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__delayBillingToDateResponse(struct soap *soap, const char *tag, int id, const struct abl__delayBillingToDateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__delayBillingToDateResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__AutoBill(soap, "autobill", -1, &a->_autobill, "vin:AutoBill"))
		return soap->error;
	if (soap_out_xsd__date(soap, "nextBillingDate", -1, &a->_nextBillingDate, "xsd:date"))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "nextBillingAmount", -1, &a->_nextBillingAmount, "xsd:decimal"))
		return soap->error;
	if (soap_out_string(soap, "nextBillingCurrency", -1, &a->_nextBillingCurrency, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__delayBillingToDateResponse * SOAP_FMAC4 soap_get_abl__delayBillingToDateResponse(struct soap *soap, struct abl__delayBillingToDateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__delayBillingToDateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__delayBillingToDateResponse * SOAP_FMAC4 soap_in_abl__delayBillingToDateResponse(struct soap *soap, const char *tag, struct abl__delayBillingToDateResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__autobill = 1;
	size_t soap_flag__nextBillingDate = 1;
	size_t soap_flag__nextBillingAmount = 1;
	size_t soap_flag__nextBillingCurrency = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__delayBillingToDateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__delayBillingToDateResponse, sizeof(struct abl__delayBillingToDateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__delayBillingToDateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__autobill && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__AutoBill(soap, NULL, &a->_autobill, "vin:AutoBill"))
				{	soap_flag__autobill--;
					continue;
				}
			if (soap_flag__nextBillingDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, NULL, &a->_nextBillingDate, "xsd:date"))
				{	soap_flag__nextBillingDate--;
					continue;
				}
			if (soap_flag__nextBillingAmount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, NULL, &a->_nextBillingAmount, "xsd:decimal"))
				{	soap_flag__nextBillingAmount--;
					continue;
				}
			if (soap_flag__nextBillingCurrency && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_nextBillingCurrency, "xsd:string"))
				{	soap_flag__nextBillingCurrency--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__delayBillingToDateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__delayBillingToDateResponse, 0, sizeof(struct abl__delayBillingToDateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__cancel(struct soap *soap, struct abl__cancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_autobill = NULL;
	soap_default_xsd__boolean(soap, &a->_disentitle);
	soap_default_xsd__boolean(soap, &a->_force);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__cancel(struct soap *soap, const struct abl__cancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__AutoBill(soap, &a->_autobill);
	soap_embedded(soap, &a->_disentitle, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->_force, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__cancel(struct soap *soap, const struct abl__cancel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__cancel);
	if (soap_out_abl__cancel(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__cancel(struct soap *soap, const char *tag, int id, const struct abl__cancel *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__cancel), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__AutoBill(soap, "autobill", -1, &a->_autobill, "vin:AutoBill"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "disentitle", -1, &a->_disentitle, "xsd:boolean"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "force", -1, &a->_force, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__cancel * SOAP_FMAC4 soap_get_abl__cancel(struct soap *soap, struct abl__cancel *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__cancel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__cancel * SOAP_FMAC4 soap_in_abl__cancel(struct soap *soap, const char *tag, struct abl__cancel *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__autobill = 1;
	size_t soap_flag__disentitle = 1;
	size_t soap_flag__force = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__cancel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__cancel, sizeof(struct abl__cancel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__cancel(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__autobill && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__AutoBill(soap, NULL, &a->_autobill, "vin:AutoBill"))
				{	soap_flag__autobill--;
					continue;
				}
			if (soap_flag__disentitle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_disentitle, "xsd:boolean"))
				{	soap_flag__disentitle--;
					continue;
				}
			if (soap_flag__force && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_force, "xsd:boolean"))
				{	soap_flag__force--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__cancel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__cancel, 0, sizeof(struct abl__cancel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__disentitle > 0 || soap_flag__force > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__cancelResponse(struct soap *soap, struct abl__cancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_autobill = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__cancelResponse(struct soap *soap, const struct abl__cancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__AutoBill(soap, &a->_autobill);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__cancelResponse(struct soap *soap, const struct abl__cancelResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__cancelResponse);
	if (soap_out_abl__cancelResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__cancelResponse(struct soap *soap, const char *tag, int id, const struct abl__cancelResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__cancelResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__AutoBill(soap, "autobill", -1, &a->_autobill, "vin:AutoBill"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__cancelResponse * SOAP_FMAC4 soap_get_abl__cancelResponse(struct soap *soap, struct abl__cancelResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__cancelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__cancelResponse * SOAP_FMAC4 soap_in_abl__cancelResponse(struct soap *soap, const char *tag, struct abl__cancelResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__autobill = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__cancelResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__cancelResponse, sizeof(struct abl__cancelResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__cancelResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__autobill && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__AutoBill(soap, NULL, &a->_autobill, "vin:AutoBill"))
				{	soap_flag__autobill--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__cancelResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__cancelResponse, 0, sizeof(struct abl__cancelResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__update(struct soap *soap, struct abl__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_auth = NULL;
	a->_autobill = NULL;
	soap_default_vin__DuplicateBehavior(soap, &a->_duplicateBehavior);
	soap_default_xsd__boolean(soap, &a->_validatePaymentMethod);
	soap_default_int(soap, &a->_minChargebackProbability);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__update(struct soap *soap, const struct abl__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Authentication(soap, &a->_auth);
	soap_serialize_PointerTovin__AutoBill(soap, &a->_autobill);
	soap_embedded(soap, &a->_validatePaymentMethod, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->_minChargebackProbability, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__update(struct soap *soap, const struct abl__update *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__update);
	if (soap_out_abl__update(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__update(struct soap *soap, const char *tag, int id, const struct abl__update *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__update), type))
		return soap->error;
	if (soap_out_PointerTovin__Authentication(soap, "auth", -1, &a->_auth, "vin:Authentication"))
		return soap->error;
	if (soap_out_PointerTovin__AutoBill(soap, "autobill", -1, &a->_autobill, "vin:AutoBill"))
		return soap->error;
	if (soap_out_vin__DuplicateBehavior(soap, "duplicateBehavior", -1, &a->_duplicateBehavior, "vin:DuplicateBehavior"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "validatePaymentMethod", -1, &a->_validatePaymentMethod, "xsd:boolean"))
		return soap->error;
	if (soap_out_int(soap, "minChargebackProbability", -1, &a->_minChargebackProbability, "xsd:int"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__update * SOAP_FMAC4 soap_get_abl__update(struct soap *soap, struct abl__update *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__update(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__update * SOAP_FMAC4 soap_in_abl__update(struct soap *soap, const char *tag, struct abl__update *a, const char *type)
{
	size_t soap_flag__auth = 1;
	size_t soap_flag__autobill = 1;
	size_t soap_flag__duplicateBehavior = 1;
	size_t soap_flag__validatePaymentMethod = 1;
	size_t soap_flag__minChargebackProbability = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__update *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__update, sizeof(struct abl__update), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__update(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__auth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Authentication(soap, NULL, &a->_auth, "vin:Authentication"))
				{	soap_flag__auth--;
					continue;
				}
			if (soap_flag__autobill && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__AutoBill(soap, NULL, &a->_autobill, "vin:AutoBill"))
				{	soap_flag__autobill--;
					continue;
				}
			if (soap_flag__duplicateBehavior && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_vin__DuplicateBehavior(soap, NULL, &a->_duplicateBehavior, "vin:DuplicateBehavior"))
				{	soap_flag__duplicateBehavior--;
					continue;
				}
			if (soap_flag__validatePaymentMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_validatePaymentMethod, "xsd:boolean"))
				{	soap_flag__validatePaymentMethod--;
					continue;
				}
			if (soap_flag__minChargebackProbability && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_minChargebackProbability, "xsd:int"))
				{	soap_flag__minChargebackProbability--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__update *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__update, 0, sizeof(struct abl__update), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__duplicateBehavior > 0 || soap_flag__validatePaymentMethod > 0 || soap_flag__minChargebackProbability > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_abl__updateResponse(struct soap *soap, struct abl__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_return_ = NULL;
	a->_autobill = NULL;
	soap_default_xsd__boolean(soap, &a->_created);
	a->_authStatus = NULL;
	soap_default_xsd__date(soap, &a->_firstBillDate);
	soap_default_xsd__decimal(soap, &a->_firstBillAmount);
	soap_default_string(soap, &a->_firstBillingCurrency);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_abl__updateResponse(struct soap *soap, const struct abl__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Return(soap, &a->_return_);
	soap_serialize_PointerTovin__AutoBill(soap, &a->_autobill);
	soap_embedded(soap, &a->_created, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTovin__TransactionStatus(soap, &a->_authStatus);
	soap_serialize_xsd__date(soap, &a->_firstBillDate);
	soap_serialize_xsd__decimal(soap, &a->_firstBillAmount);
	soap_serialize_string(soap, &a->_firstBillingCurrency);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_abl__updateResponse(struct soap *soap, const struct abl__updateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_abl__updateResponse);
	if (soap_out_abl__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_abl__updateResponse(struct soap *soap, const char *tag, int id, const struct abl__updateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_abl__updateResponse), type))
		return soap->error;
	if (soap_out_PointerTovin__Return(soap, "return", -1, &a->_return_, "vin:Return"))
		return soap->error;
	if (soap_out_PointerTovin__AutoBill(soap, "autobill", -1, &a->_autobill, "vin:AutoBill"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "created", -1, &a->_created, "xsd:boolean"))
		return soap->error;
	if (soap_out_PointerTovin__TransactionStatus(soap, "authStatus", -1, &a->_authStatus, "vin:TransactionStatus"))
		return soap->error;
	if (soap_out_xsd__date(soap, "firstBillDate", -1, &a->_firstBillDate, "xsd:date"))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "firstBillAmount", -1, &a->_firstBillAmount, "xsd:decimal"))
		return soap->error;
	if (soap_out_string(soap, "firstBillingCurrency", -1, &a->_firstBillingCurrency, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct abl__updateResponse * SOAP_FMAC4 soap_get_abl__updateResponse(struct soap *soap, struct abl__updateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_abl__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__updateResponse * SOAP_FMAC4 soap_in_abl__updateResponse(struct soap *soap, const char *tag, struct abl__updateResponse *a, const char *type)
{
	size_t soap_flag__return_ = 1;
	size_t soap_flag__autobill = 1;
	size_t soap_flag__created = 1;
	size_t soap_flag__authStatus = 1;
	size_t soap_flag__firstBillDate = 1;
	size_t soap_flag__firstBillAmount = 1;
	size_t soap_flag__firstBillingCurrency = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct abl__updateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_abl__updateResponse, sizeof(struct abl__updateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_abl__updateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Return(soap, NULL, &a->_return_, "vin:Return"))
				{	soap_flag__return_--;
					continue;
				}
			if (soap_flag__autobill && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__AutoBill(soap, NULL, &a->_autobill, "vin:AutoBill"))
				{	soap_flag__autobill--;
					continue;
				}
			if (soap_flag__created && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &a->_created, "xsd:boolean"))
				{	soap_flag__created--;
					continue;
				}
			if (soap_flag__authStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__TransactionStatus(soap, NULL, &a->_authStatus, "vin:TransactionStatus"))
				{	soap_flag__authStatus--;
					continue;
				}
			if (soap_flag__firstBillDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, NULL, &a->_firstBillDate, "xsd:date"))
				{	soap_flag__firstBillDate--;
					continue;
				}
			if (soap_flag__firstBillAmount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, NULL, &a->_firstBillAmount, "xsd:decimal"))
				{	soap_flag__firstBillAmount--;
					continue;
				}
			if (soap_flag__firstBillingCurrency && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_firstBillingCurrency, "xsd:string"))
				{	soap_flag__firstBillingCurrency--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct abl__updateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_abl__updateResponse, 0, sizeof(struct abl__updateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__created > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfScoreCodes(struct soap *soap, struct ArrayOfScoreCodes *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfScoreCodes(struct soap *soap, struct ArrayOfScoreCodes const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfScoreCodes))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__ScoreCode(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfScoreCodes(struct soap *soap, const struct ArrayOfScoreCodes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfScoreCodes);
	if (soap_out_ArrayOfScoreCodes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfScoreCodes(struct soap *soap, const char *tag, int id, const struct ArrayOfScoreCodes *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:ScoreCode", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfScoreCodes);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__ScoreCode(soap, "item", -1, &a->__ptr[i], "vin:ScoreCode");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfScoreCodes * SOAP_FMAC4 soap_get_ArrayOfScoreCodes(struct soap *soap, struct ArrayOfScoreCodes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfScoreCodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfScoreCodes * SOAP_FMAC4 soap_in_ArrayOfScoreCodes(struct soap *soap, const char *tag, struct ArrayOfScoreCodes *a, const char *type)
{	int i, j;
	struct vin__ScoreCode **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfScoreCodes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfScoreCodes, sizeof(struct ArrayOfScoreCodes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfScoreCodes(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__ScoreCode **)soap_malloc(soap, sizeof(struct vin__ScoreCode *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__ScoreCode(soap, NULL, a->__ptr + i, "vin:ScoreCode"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__ScoreCode **)soap_push_block(soap, NULL, sizeof(struct vin__ScoreCode *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__ScoreCode(soap, NULL, p, "vin:ScoreCode"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__ScoreCode **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfScoreCodes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfScoreCodes, 0, sizeof(struct ArrayOfScoreCodes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfCancelResults(struct soap *soap, struct ArrayOfCancelResults *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfCancelResults(struct soap *soap, struct ArrayOfCancelResults const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfCancelResults))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__CancelResult(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfCancelResults(struct soap *soap, const struct ArrayOfCancelResults *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfCancelResults);
	if (soap_out_ArrayOfCancelResults(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCancelResults(struct soap *soap, const char *tag, int id, const struct ArrayOfCancelResults *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:CancelResult", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCancelResults);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__CancelResult(soap, "item", -1, &a->__ptr[i], "vin:CancelResult");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfCancelResults * SOAP_FMAC4 soap_get_ArrayOfCancelResults(struct soap *soap, struct ArrayOfCancelResults *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCancelResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfCancelResults * SOAP_FMAC4 soap_in_ArrayOfCancelResults(struct soap *soap, const char *tag, struct ArrayOfCancelResults *a, const char *type)
{	int i, j;
	struct vin__CancelResult **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfCancelResults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCancelResults, sizeof(struct ArrayOfCancelResults), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfCancelResults(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__CancelResult **)soap_malloc(soap, sizeof(struct vin__CancelResult *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__CancelResult(soap, NULL, a->__ptr + i, "vin:CancelResult"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__CancelResult **)soap_push_block(soap, NULL, sizeof(struct vin__CancelResult *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__CancelResult(soap, NULL, p, "vin:CancelResult"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__CancelResult **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfCancelResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCancelResults, 0, sizeof(struct ArrayOfCancelResults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfCaptureResults(struct soap *soap, struct ArrayOfCaptureResults *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfCaptureResults(struct soap *soap, struct ArrayOfCaptureResults const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfCaptureResults))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__CaptureResult(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfCaptureResults(struct soap *soap, const struct ArrayOfCaptureResults *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfCaptureResults);
	if (soap_out_ArrayOfCaptureResults(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCaptureResults(struct soap *soap, const char *tag, int id, const struct ArrayOfCaptureResults *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:CaptureResult", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCaptureResults);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__CaptureResult(soap, "item", -1, &a->__ptr[i], "vin:CaptureResult");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfCaptureResults * SOAP_FMAC4 soap_get_ArrayOfCaptureResults(struct soap *soap, struct ArrayOfCaptureResults *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCaptureResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfCaptureResults * SOAP_FMAC4 soap_in_ArrayOfCaptureResults(struct soap *soap, const char *tag, struct ArrayOfCaptureResults *a, const char *type)
{	int i, j;
	struct vin__CaptureResult **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfCaptureResults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCaptureResults, sizeof(struct ArrayOfCaptureResults), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfCaptureResults(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__CaptureResult **)soap_malloc(soap, sizeof(struct vin__CaptureResult *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__CaptureResult(soap, NULL, a->__ptr + i, "vin:CaptureResult"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__CaptureResult **)soap_push_block(soap, NULL, sizeof(struct vin__CaptureResult *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__CaptureResult(soap, NULL, p, "vin:CaptureResult"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__CaptureResult **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfCaptureResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCaptureResults, 0, sizeof(struct ArrayOfCaptureResults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfTokenTransactions(struct soap *soap, struct ArrayOfTokenTransactions *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfTokenTransactions(struct soap *soap, struct ArrayOfTokenTransactions const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfTokenTransactions))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__TokenTransaction(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfTokenTransactions(struct soap *soap, const struct ArrayOfTokenTransactions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfTokenTransactions);
	if (soap_out_ArrayOfTokenTransactions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfTokenTransactions(struct soap *soap, const char *tag, int id, const struct ArrayOfTokenTransactions *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:TokenTransaction", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfTokenTransactions);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__TokenTransaction(soap, "item", -1, &a->__ptr[i], "vin:TokenTransaction");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfTokenTransactions * SOAP_FMAC4 soap_get_ArrayOfTokenTransactions(struct soap *soap, struct ArrayOfTokenTransactions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfTokenTransactions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfTokenTransactions * SOAP_FMAC4 soap_in_ArrayOfTokenTransactions(struct soap *soap, const char *tag, struct ArrayOfTokenTransactions *a, const char *type)
{	int i, j;
	struct vin__TokenTransaction **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfTokenTransactions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfTokenTransactions, sizeof(struct ArrayOfTokenTransactions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfTokenTransactions(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__TokenTransaction **)soap_malloc(soap, sizeof(struct vin__TokenTransaction *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__TokenTransaction(soap, NULL, a->__ptr + i, "vin:TokenTransaction"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__TokenTransaction **)soap_push_block(soap, NULL, sizeof(struct vin__TokenTransaction *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__TokenTransaction(soap, NULL, p, "vin:TokenTransaction"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__TokenTransaction **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfTokenTransactions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfTokenTransactions, 0, sizeof(struct ArrayOfTokenTransactions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfTokens(struct soap *soap, struct ArrayOfTokens *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfTokens(struct soap *soap, struct ArrayOfTokens const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfTokens))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__Token(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfTokens(struct soap *soap, const struct ArrayOfTokens *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfTokens);
	if (soap_out_ArrayOfTokens(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfTokens(struct soap *soap, const char *tag, int id, const struct ArrayOfTokens *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:Token", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfTokens);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__Token(soap, "item", -1, &a->__ptr[i], "vin:Token");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfTokens * SOAP_FMAC4 soap_get_ArrayOfTokens(struct soap *soap, struct ArrayOfTokens *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfTokens(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfTokens * SOAP_FMAC4 soap_in_ArrayOfTokens(struct soap *soap, const char *tag, struct ArrayOfTokens *a, const char *type)
{	int i, j;
	struct vin__Token **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfTokens *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfTokens, sizeof(struct ArrayOfTokens), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfTokens(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__Token **)soap_malloc(soap, sizeof(struct vin__Token *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__Token(soap, NULL, a->__ptr + i, "vin:Token"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__Token **)soap_push_block(soap, NULL, sizeof(struct vin__Token *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__Token(soap, NULL, p, "vin:Token"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__Token **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfTokens *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfTokens, 0, sizeof(struct ArrayOfTokens), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfTaxExemption(struct soap *soap, struct ArrayOfTaxExemption *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfTaxExemption(struct soap *soap, struct ArrayOfTaxExemption const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfTaxExemption))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__TaxExemption(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfTaxExemption(struct soap *soap, const struct ArrayOfTaxExemption *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfTaxExemption);
	if (soap_out_ArrayOfTaxExemption(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfTaxExemption(struct soap *soap, const char *tag, int id, const struct ArrayOfTaxExemption *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:TaxExemption", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfTaxExemption);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__TaxExemption(soap, "item", -1, &a->__ptr[i], "vin:TaxExemption");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfTaxExemption * SOAP_FMAC4 soap_get_ArrayOfTaxExemption(struct soap *soap, struct ArrayOfTaxExemption *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfTaxExemption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfTaxExemption * SOAP_FMAC4 soap_in_ArrayOfTaxExemption(struct soap *soap, const char *tag, struct ArrayOfTaxExemption *a, const char *type)
{	int i, j;
	struct vin__TaxExemption **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfTaxExemption *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfTaxExemption, sizeof(struct ArrayOfTaxExemption), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfTaxExemption(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__TaxExemption **)soap_malloc(soap, sizeof(struct vin__TaxExemption *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__TaxExemption(soap, NULL, a->__ptr + i, "vin:TaxExemption"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__TaxExemption **)soap_push_block(soap, NULL, sizeof(struct vin__TaxExemption *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__TaxExemption(soap, NULL, p, "vin:TaxExemption"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__TaxExemption **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfTaxExemption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfTaxExemption, 0, sizeof(struct ArrayOfTaxExemption), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfSalesTaxes(struct soap *soap, struct ArrayOfSalesTaxes *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfSalesTaxes(struct soap *soap, struct ArrayOfSalesTaxes const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfSalesTaxes))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__SalesTax(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfSalesTaxes(struct soap *soap, const struct ArrayOfSalesTaxes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfSalesTaxes);
	if (soap_out_ArrayOfSalesTaxes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfSalesTaxes(struct soap *soap, const char *tag, int id, const struct ArrayOfSalesTaxes *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:SalesTax", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfSalesTaxes);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__SalesTax(soap, "item", -1, &a->__ptr[i], "vin:SalesTax");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfSalesTaxes * SOAP_FMAC4 soap_get_ArrayOfSalesTaxes(struct soap *soap, struct ArrayOfSalesTaxes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfSalesTaxes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfSalesTaxes * SOAP_FMAC4 soap_in_ArrayOfSalesTaxes(struct soap *soap, const char *tag, struct ArrayOfSalesTaxes *a, const char *type)
{	int i, j;
	struct vin__SalesTax **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfSalesTaxes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfSalesTaxes, sizeof(struct ArrayOfSalesTaxes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfSalesTaxes(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__SalesTax **)soap_malloc(soap, sizeof(struct vin__SalesTax *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__SalesTax(soap, NULL, a->__ptr + i, "vin:SalesTax"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__SalesTax **)soap_push_block(soap, NULL, sizeof(struct vin__SalesTax *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__SalesTax(soap, NULL, p, "vin:SalesTax"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__SalesTax **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfSalesTaxes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfSalesTaxes, 0, sizeof(struct ArrayOfSalesTaxes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfRefunds(struct soap *soap, struct ArrayOfRefunds *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfRefunds(struct soap *soap, struct ArrayOfRefunds const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfRefunds))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__Refund(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfRefunds(struct soap *soap, const struct ArrayOfRefunds *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfRefunds);
	if (soap_out_ArrayOfRefunds(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfRefunds(struct soap *soap, const char *tag, int id, const struct ArrayOfRefunds *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:Refund", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfRefunds);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__Refund(soap, "item", -1, &a->__ptr[i], "vin:Refund");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfRefunds * SOAP_FMAC4 soap_get_ArrayOfRefunds(struct soap *soap, struct ArrayOfRefunds *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfRefunds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfRefunds * SOAP_FMAC4 soap_in_ArrayOfRefunds(struct soap *soap, const char *tag, struct ArrayOfRefunds *a, const char *type)
{	int i, j;
	struct vin__Refund **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfRefunds *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfRefunds, sizeof(struct ArrayOfRefunds), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfRefunds(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__Refund **)soap_malloc(soap, sizeof(struct vin__Refund *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__Refund(soap, NULL, a->__ptr + i, "vin:Refund"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__Refund **)soap_push_block(soap, NULL, sizeof(struct vin__Refund *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__Refund(soap, NULL, p, "vin:Refund"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__Refund **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfRefunds *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfRefunds, 0, sizeof(struct ArrayOfRefunds), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfProducts(struct soap *soap, struct ArrayOfProducts *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfProducts(struct soap *soap, struct ArrayOfProducts const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfProducts))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__Product(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfProducts(struct soap *soap, const struct ArrayOfProducts *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfProducts);
	if (soap_out_ArrayOfProducts(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfProducts(struct soap *soap, const char *tag, int id, const struct ArrayOfProducts *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:Product", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfProducts);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__Product(soap, "item", -1, &a->__ptr[i], "vin:Product");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfProducts * SOAP_FMAC4 soap_get_ArrayOfProducts(struct soap *soap, struct ArrayOfProducts *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfProducts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfProducts * SOAP_FMAC4 soap_in_ArrayOfProducts(struct soap *soap, const char *tag, struct ArrayOfProducts *a, const char *type)
{	int i, j;
	struct vin__Product **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfProducts *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfProducts, sizeof(struct ArrayOfProducts), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfProducts(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__Product **)soap_malloc(soap, sizeof(struct vin__Product *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__Product(soap, NULL, a->__ptr + i, "vin:Product"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__Product **)soap_push_block(soap, NULL, sizeof(struct vin__Product *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__Product(soap, NULL, p, "vin:Product"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__Product **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfProducts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfProducts, 0, sizeof(struct ArrayOfProducts), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfMetricStats(struct soap *soap, struct ArrayOfMetricStats *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfMetricStats(struct soap *soap, struct ArrayOfMetricStats const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfMetricStats))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__MetricStatistics(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfMetricStats(struct soap *soap, const struct ArrayOfMetricStats *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfMetricStats);
	if (soap_out_ArrayOfMetricStats(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfMetricStats(struct soap *soap, const char *tag, int id, const struct ArrayOfMetricStats *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:MetricStatistics", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfMetricStats);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__MetricStatistics(soap, "item", -1, &a->__ptr[i], "vin:MetricStatistics");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfMetricStats * SOAP_FMAC4 soap_get_ArrayOfMetricStats(struct soap *soap, struct ArrayOfMetricStats *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfMetricStats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfMetricStats * SOAP_FMAC4 soap_in_ArrayOfMetricStats(struct soap *soap, const char *tag, struct ArrayOfMetricStats *a, const char *type)
{	int i, j;
	struct vin__MetricStatistics **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfMetricStats *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfMetricStats, sizeof(struct ArrayOfMetricStats), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfMetricStats(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__MetricStatistics **)soap_malloc(soap, sizeof(struct vin__MetricStatistics *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__MetricStatistics(soap, NULL, a->__ptr + i, "vin:MetricStatistics"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__MetricStatistics **)soap_push_block(soap, NULL, sizeof(struct vin__MetricStatistics *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__MetricStatistics(soap, NULL, p, "vin:MetricStatistics"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__MetricStatistics **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfMetricStats *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfMetricStats, 0, sizeof(struct ArrayOfMetricStats), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfEntitlements(struct soap *soap, struct ArrayOfEntitlements *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfEntitlements(struct soap *soap, struct ArrayOfEntitlements const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfEntitlements))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__Entitlement(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfEntitlements(struct soap *soap, const struct ArrayOfEntitlements *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfEntitlements);
	if (soap_out_ArrayOfEntitlements(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfEntitlements(struct soap *soap, const char *tag, int id, const struct ArrayOfEntitlements *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:Entitlement", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfEntitlements);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__Entitlement(soap, "item", -1, &a->__ptr[i], "vin:Entitlement");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfEntitlements * SOAP_FMAC4 soap_get_ArrayOfEntitlements(struct soap *soap, struct ArrayOfEntitlements *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfEntitlements(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfEntitlements * SOAP_FMAC4 soap_in_ArrayOfEntitlements(struct soap *soap, const char *tag, struct ArrayOfEntitlements *a, const char *type)
{	int i, j;
	struct vin__Entitlement **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfEntitlements *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfEntitlements, sizeof(struct ArrayOfEntitlements), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfEntitlements(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__Entitlement **)soap_malloc(soap, sizeof(struct vin__Entitlement *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__Entitlement(soap, NULL, a->__ptr + i, "vin:Entitlement"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__Entitlement **)soap_push_block(soap, NULL, sizeof(struct vin__Entitlement *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__Entitlement(soap, NULL, p, "vin:Entitlement"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__Entitlement **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfEntitlements *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfEntitlements, 0, sizeof(struct ArrayOfEntitlements), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfEmailTemplates(struct soap *soap, struct ArrayOfEmailTemplates *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfEmailTemplates(struct soap *soap, struct ArrayOfEmailTemplates const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfEmailTemplates))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__EmailTemplate(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfEmailTemplates(struct soap *soap, const struct ArrayOfEmailTemplates *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfEmailTemplates);
	if (soap_out_ArrayOfEmailTemplates(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfEmailTemplates(struct soap *soap, const char *tag, int id, const struct ArrayOfEmailTemplates *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:EmailTemplate", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfEmailTemplates);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__EmailTemplate(soap, "item", -1, &a->__ptr[i], "vin:EmailTemplate");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfEmailTemplates * SOAP_FMAC4 soap_get_ArrayOfEmailTemplates(struct soap *soap, struct ArrayOfEmailTemplates *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfEmailTemplates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfEmailTemplates * SOAP_FMAC4 soap_in_ArrayOfEmailTemplates(struct soap *soap, const char *tag, struct ArrayOfEmailTemplates *a, const char *type)
{	int i, j;
	struct vin__EmailTemplate **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfEmailTemplates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfEmailTemplates, sizeof(struct ArrayOfEmailTemplates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfEmailTemplates(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__EmailTemplate **)soap_malloc(soap, sizeof(struct vin__EmailTemplate *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__EmailTemplate(soap, NULL, a->__ptr + i, "vin:EmailTemplate"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__EmailTemplate **)soap_push_block(soap, NULL, sizeof(struct vin__EmailTemplate *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__EmailTemplate(soap, NULL, p, "vin:EmailTemplate"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__EmailTemplate **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfEmailTemplates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfEmailTemplates, 0, sizeof(struct ArrayOfEmailTemplates), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfChargebacks(struct soap *soap, struct ArrayOfChargebacks *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfChargebacks(struct soap *soap, struct ArrayOfChargebacks const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfChargebacks))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__Chargeback(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfChargebacks(struct soap *soap, const struct ArrayOfChargebacks *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfChargebacks);
	if (soap_out_ArrayOfChargebacks(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfChargebacks(struct soap *soap, const char *tag, int id, const struct ArrayOfChargebacks *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:Chargeback", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfChargebacks);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__Chargeback(soap, "item", -1, &a->__ptr[i], "vin:Chargeback");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfChargebacks * SOAP_FMAC4 soap_get_ArrayOfChargebacks(struct soap *soap, struct ArrayOfChargebacks *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfChargebacks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfChargebacks * SOAP_FMAC4 soap_in_ArrayOfChargebacks(struct soap *soap, const char *tag, struct ArrayOfChargebacks *a, const char *type)
{	int i, j;
	struct vin__Chargeback **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfChargebacks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfChargebacks, sizeof(struct ArrayOfChargebacks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfChargebacks(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__Chargeback **)soap_malloc(soap, sizeof(struct vin__Chargeback *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__Chargeback(soap, NULL, a->__ptr + i, "vin:Chargeback"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__Chargeback **)soap_push_block(soap, NULL, sizeof(struct vin__Chargeback *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__Chargeback(soap, NULL, p, "vin:Chargeback"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__Chargeback **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfChargebacks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfChargebacks, 0, sizeof(struct ArrayOfChargebacks), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfBillingPlans(struct soap *soap, struct ArrayOfBillingPlans *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfBillingPlans(struct soap *soap, struct ArrayOfBillingPlans const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfBillingPlans))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__BillingPlan(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfBillingPlans(struct soap *soap, const struct ArrayOfBillingPlans *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfBillingPlans);
	if (soap_out_ArrayOfBillingPlans(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfBillingPlans(struct soap *soap, const char *tag, int id, const struct ArrayOfBillingPlans *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:BillingPlan", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfBillingPlans);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__BillingPlan(soap, "item", -1, &a->__ptr[i], "vin:BillingPlan");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfBillingPlans * SOAP_FMAC4 soap_get_ArrayOfBillingPlans(struct soap *soap, struct ArrayOfBillingPlans *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfBillingPlans(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfBillingPlans * SOAP_FMAC4 soap_in_ArrayOfBillingPlans(struct soap *soap, const char *tag, struct ArrayOfBillingPlans *a, const char *type)
{	int i, j;
	struct vin__BillingPlan **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfBillingPlans *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfBillingPlans, sizeof(struct ArrayOfBillingPlans), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfBillingPlans(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__BillingPlan **)soap_malloc(soap, sizeof(struct vin__BillingPlan *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__BillingPlan(soap, NULL, a->__ptr + i, "vin:BillingPlan"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__BillingPlan **)soap_push_block(soap, NULL, sizeof(struct vin__BillingPlan *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__BillingPlan(soap, NULL, p, "vin:BillingPlan"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__BillingPlan **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfBillingPlans *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfBillingPlans, 0, sizeof(struct ArrayOfBillingPlans), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfAutoBills(struct soap *soap, struct ArrayOfAutoBills *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfAutoBills(struct soap *soap, struct ArrayOfAutoBills const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfAutoBills))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__AutoBill(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfAutoBills(struct soap *soap, const struct ArrayOfAutoBills *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfAutoBills);
	if (soap_out_ArrayOfAutoBills(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfAutoBills(struct soap *soap, const char *tag, int id, const struct ArrayOfAutoBills *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:AutoBill", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfAutoBills);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__AutoBill(soap, "item", -1, &a->__ptr[i], "vin:AutoBill");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfAutoBills * SOAP_FMAC4 soap_get_ArrayOfAutoBills(struct soap *soap, struct ArrayOfAutoBills *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfAutoBills(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfAutoBills * SOAP_FMAC4 soap_in_ArrayOfAutoBills(struct soap *soap, const char *tag, struct ArrayOfAutoBills *a, const char *type)
{	int i, j;
	struct vin__AutoBill **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfAutoBills *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfAutoBills, sizeof(struct ArrayOfAutoBills), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfAutoBills(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__AutoBill **)soap_malloc(soap, sizeof(struct vin__AutoBill *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__AutoBill(soap, NULL, a->__ptr + i, "vin:AutoBill"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__AutoBill **)soap_push_block(soap, NULL, sizeof(struct vin__AutoBill *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__AutoBill(soap, NULL, p, "vin:AutoBill"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__AutoBill **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfAutoBills *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfAutoBills, 0, sizeof(struct ArrayOfAutoBills), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfActivities(struct soap *soap, struct ArrayOfActivities *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfActivities(struct soap *soap, struct ArrayOfActivities const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfActivities))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__Activity(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfActivities(struct soap *soap, const struct ArrayOfActivities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfActivities);
	if (soap_out_ArrayOfActivities(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfActivities(struct soap *soap, const char *tag, int id, const struct ArrayOfActivities *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:Activity", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfActivities);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__Activity(soap, "item", -1, &a->__ptr[i], "vin:Activity");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfActivities * SOAP_FMAC4 soap_get_ArrayOfActivities(struct soap *soap, struct ArrayOfActivities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfActivities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfActivities * SOAP_FMAC4 soap_in_ArrayOfActivities(struct soap *soap, const char *tag, struct ArrayOfActivities *a, const char *type)
{	int i, j;
	struct vin__Activity **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfActivities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfActivities, sizeof(struct ArrayOfActivities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfActivities(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__Activity **)soap_malloc(soap, sizeof(struct vin__Activity *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__Activity(soap, NULL, a->__ptr + i, "vin:Activity"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__Activity **)soap_push_block(soap, NULL, sizeof(struct vin__Activity *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__Activity(soap, NULL, p, "vin:Activity"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__Activity **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfActivities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfActivities, 0, sizeof(struct ArrayOfActivities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfAccounts(struct soap *soap, struct ArrayOfAccounts *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfAccounts(struct soap *soap, struct ArrayOfAccounts const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfAccounts))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__Account(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfAccounts(struct soap *soap, const struct ArrayOfAccounts *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfAccounts);
	if (soap_out_ArrayOfAccounts(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfAccounts(struct soap *soap, const char *tag, int id, const struct ArrayOfAccounts *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:Account", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfAccounts);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__Account(soap, "item", -1, &a->__ptr[i], "vin:Account");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfAccounts * SOAP_FMAC4 soap_get_ArrayOfAccounts(struct soap *soap, struct ArrayOfAccounts *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfAccounts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfAccounts * SOAP_FMAC4 soap_in_ArrayOfAccounts(struct soap *soap, const char *tag, struct ArrayOfAccounts *a, const char *type)
{	int i, j;
	struct vin__Account **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfAccounts *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfAccounts, sizeof(struct ArrayOfAccounts), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfAccounts(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__Account **)soap_malloc(soap, sizeof(struct vin__Account *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__Account(soap, NULL, a->__ptr + i, "vin:Account"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__Account **)soap_push_block(soap, NULL, sizeof(struct vin__Account *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__Account(soap, NULL, p, "vin:Account"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__Account **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfAccounts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfAccounts, 0, sizeof(struct ArrayOfAccounts), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfTransactionItems(struct soap *soap, struct ArrayOfTransactionItems *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfTransactionItems(struct soap *soap, struct ArrayOfTransactionItems const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfTransactionItems))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__TransactionItem(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfTransactionItems(struct soap *soap, const struct ArrayOfTransactionItems *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfTransactionItems);
	if (soap_out_ArrayOfTransactionItems(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfTransactionItems(struct soap *soap, const char *tag, int id, const struct ArrayOfTransactionItems *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:TransactionItem", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfTransactionItems);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__TransactionItem(soap, "item", -1, &a->__ptr[i], "vin:TransactionItem");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfTransactionItems * SOAP_FMAC4 soap_get_ArrayOfTransactionItems(struct soap *soap, struct ArrayOfTransactionItems *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfTransactionItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfTransactionItems * SOAP_FMAC4 soap_in_ArrayOfTransactionItems(struct soap *soap, const char *tag, struct ArrayOfTransactionItems *a, const char *type)
{	int i, j;
	struct vin__TransactionItem **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfTransactionItems *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfTransactionItems, sizeof(struct ArrayOfTransactionItems), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfTransactionItems(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__TransactionItem **)soap_malloc(soap, sizeof(struct vin__TransactionItem *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__TransactionItem(soap, NULL, a->__ptr + i, "vin:TransactionItem"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__TransactionItem **)soap_push_block(soap, NULL, sizeof(struct vin__TransactionItem *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__TransactionItem(soap, NULL, p, "vin:TransactionItem"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__TransactionItem **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfTransactionItems *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfTransactionItems, 0, sizeof(struct ArrayOfTransactionItems), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfTransactionStatuses(struct soap *soap, struct ArrayOfTransactionStatuses *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfTransactionStatuses(struct soap *soap, struct ArrayOfTransactionStatuses const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfTransactionStatuses))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__TransactionStatus(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfTransactionStatuses(struct soap *soap, const struct ArrayOfTransactionStatuses *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfTransactionStatuses);
	if (soap_out_ArrayOfTransactionStatuses(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfTransactionStatuses(struct soap *soap, const char *tag, int id, const struct ArrayOfTransactionStatuses *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:TransactionStatus", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfTransactionStatuses);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__TransactionStatus(soap, "item", -1, &a->__ptr[i], "vin:TransactionStatus");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfTransactionStatuses * SOAP_FMAC4 soap_get_ArrayOfTransactionStatuses(struct soap *soap, struct ArrayOfTransactionStatuses *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfTransactionStatuses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfTransactionStatuses * SOAP_FMAC4 soap_in_ArrayOfTransactionStatuses(struct soap *soap, const char *tag, struct ArrayOfTransactionStatuses *a, const char *type)
{	int i, j;
	struct vin__TransactionStatus **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfTransactionStatuses *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfTransactionStatuses, sizeof(struct ArrayOfTransactionStatuses), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfTransactionStatuses(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__TransactionStatus **)soap_malloc(soap, sizeof(struct vin__TransactionStatus *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__TransactionStatus(soap, NULL, a->__ptr + i, "vin:TransactionStatus"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__TransactionStatus **)soap_push_block(soap, NULL, sizeof(struct vin__TransactionStatus *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__TransactionStatus(soap, NULL, p, "vin:TransactionStatus"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__TransactionStatus **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfTransactionStatuses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfTransactionStatuses, 0, sizeof(struct ArrayOfTransactionStatuses), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__TransactionStatusDirectDebit(struct soap *soap, struct vin__TransactionStatusDirectDebit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authCode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__TransactionStatusDirectDebit(struct soap *soap, const struct vin__TransactionStatusDirectDebit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authCode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__TransactionStatusDirectDebit(struct soap *soap, const struct vin__TransactionStatusDirectDebit *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__TransactionStatusDirectDebit);
	if (soap_out_vin__TransactionStatusDirectDebit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__TransactionStatusDirectDebit(struct soap *soap, const char *tag, int id, const struct vin__TransactionStatusDirectDebit *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__TransactionStatusDirectDebit), type))
		return soap->error;
	if (soap_out_string(soap, "authCode", -1, &a->authCode, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__TransactionStatusDirectDebit * SOAP_FMAC4 soap_get_vin__TransactionStatusDirectDebit(struct soap *soap, struct vin__TransactionStatusDirectDebit *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__TransactionStatusDirectDebit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TransactionStatusDirectDebit * SOAP_FMAC4 soap_in_vin__TransactionStatusDirectDebit(struct soap *soap, const char *tag, struct vin__TransactionStatusDirectDebit *a, const char *type)
{
	size_t soap_flag_authCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__TransactionStatusDirectDebit *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__TransactionStatusDirectDebit, sizeof(struct vin__TransactionStatusDirectDebit), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__TransactionStatusDirectDebit(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authCode", &a->authCode, "xsd:string"))
				{	soap_flag_authCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__TransactionStatusDirectDebit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__TransactionStatusDirectDebit, 0, sizeof(struct vin__TransactionStatusDirectDebit), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__TransactionStatusPayPal(struct soap *soap, struct vin__TransactionStatusPayPal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->token);
	soap_default_string(soap, &a->authCode);
	soap_default_string(soap, &a->redirectUrl);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__TransactionStatusPayPal(struct soap *soap, const struct vin__TransactionStatusPayPal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->token);
	soap_serialize_string(soap, &a->authCode);
	soap_serialize_string(soap, &a->redirectUrl);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__TransactionStatusPayPal(struct soap *soap, const struct vin__TransactionStatusPayPal *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__TransactionStatusPayPal);
	if (soap_out_vin__TransactionStatusPayPal(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__TransactionStatusPayPal(struct soap *soap, const char *tag, int id, const struct vin__TransactionStatusPayPal *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__TransactionStatusPayPal), type))
		return soap->error;
	if (soap_out_string(soap, "token", -1, &a->token, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "authCode", -1, &a->authCode, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "redirectUrl", -1, &a->redirectUrl, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__TransactionStatusPayPal * SOAP_FMAC4 soap_get_vin__TransactionStatusPayPal(struct soap *soap, struct vin__TransactionStatusPayPal *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__TransactionStatusPayPal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TransactionStatusPayPal * SOAP_FMAC4 soap_in_vin__TransactionStatusPayPal(struct soap *soap, const char *tag, struct vin__TransactionStatusPayPal *a, const char *type)
{
	size_t soap_flag_token = 1;
	size_t soap_flag_authCode = 1;
	size_t soap_flag_redirectUrl = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__TransactionStatusPayPal *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__TransactionStatusPayPal, sizeof(struct vin__TransactionStatusPayPal), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__TransactionStatusPayPal(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "token", &a->token, "xsd:string"))
				{	soap_flag_token--;
					continue;
				}
			if (soap_flag_authCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authCode", &a->authCode, "xsd:string"))
				{	soap_flag_authCode--;
					continue;
				}
			if (soap_flag_redirectUrl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "redirectUrl", &a->redirectUrl, "xsd:string"))
				{	soap_flag_redirectUrl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__TransactionStatusPayPal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__TransactionStatusPayPal, 0, sizeof(struct vin__TransactionStatusPayPal), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__TransactionStatusBoleto(struct soap *soap, struct vin__TransactionStatusBoleto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__TransactionStatusBoleto(struct soap *soap, const struct vin__TransactionStatusBoleto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->uri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__TransactionStatusBoleto(struct soap *soap, const struct vin__TransactionStatusBoleto *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__TransactionStatusBoleto);
	if (soap_out_vin__TransactionStatusBoleto(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__TransactionStatusBoleto(struct soap *soap, const char *tag, int id, const struct vin__TransactionStatusBoleto *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__TransactionStatusBoleto), type))
		return soap->error;
	if (soap_out_string(soap, "uri", -1, &a->uri, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__TransactionStatusBoleto * SOAP_FMAC4 soap_get_vin__TransactionStatusBoleto(struct soap *soap, struct vin__TransactionStatusBoleto *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__TransactionStatusBoleto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TransactionStatusBoleto * SOAP_FMAC4 soap_in_vin__TransactionStatusBoleto(struct soap *soap, const char *tag, struct vin__TransactionStatusBoleto *a, const char *type)
{
	size_t soap_flag_uri = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__TransactionStatusBoleto *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__TransactionStatusBoleto, sizeof(struct vin__TransactionStatusBoleto), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__TransactionStatusBoleto(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "uri", &a->uri, "xsd:string"))
				{	soap_flag_uri--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__TransactionStatusBoleto *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__TransactionStatusBoleto, 0, sizeof(struct vin__TransactionStatusBoleto), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__TransactionStatusECP(struct soap *soap, struct vin__TransactionStatusECP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authCode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__TransactionStatusECP(struct soap *soap, const struct vin__TransactionStatusECP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authCode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__TransactionStatusECP(struct soap *soap, const struct vin__TransactionStatusECP *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__TransactionStatusECP);
	if (soap_out_vin__TransactionStatusECP(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__TransactionStatusECP(struct soap *soap, const char *tag, int id, const struct vin__TransactionStatusECP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__TransactionStatusECP), type))
		return soap->error;
	if (soap_out_string(soap, "authCode", -1, &a->authCode, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__TransactionStatusECP * SOAP_FMAC4 soap_get_vin__TransactionStatusECP(struct soap *soap, struct vin__TransactionStatusECP *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__TransactionStatusECP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TransactionStatusECP * SOAP_FMAC4 soap_in_vin__TransactionStatusECP(struct soap *soap, const char *tag, struct vin__TransactionStatusECP *a, const char *type)
{
	size_t soap_flag_authCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__TransactionStatusECP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__TransactionStatusECP, sizeof(struct vin__TransactionStatusECP), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__TransactionStatusECP(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authCode", &a->authCode, "xsd:string"))
				{	soap_flag_authCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__TransactionStatusECP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__TransactionStatusECP, 0, sizeof(struct vin__TransactionStatusECP), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__TransactionStatusCreditCard(struct soap *soap, struct vin__TransactionStatusCreditCard *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->authCode);
	soap_default_string(soap, &a->avsCode);
	soap_default_string(soap, &a->cvnCode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__TransactionStatusCreditCard(struct soap *soap, const struct vin__TransactionStatusCreditCard *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->authCode);
	soap_serialize_string(soap, &a->avsCode);
	soap_serialize_string(soap, &a->cvnCode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__TransactionStatusCreditCard(struct soap *soap, const struct vin__TransactionStatusCreditCard *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__TransactionStatusCreditCard);
	if (soap_out_vin__TransactionStatusCreditCard(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__TransactionStatusCreditCard(struct soap *soap, const char *tag, int id, const struct vin__TransactionStatusCreditCard *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__TransactionStatusCreditCard), type))
		return soap->error;
	if (soap_out_string(soap, "authCode", -1, &a->authCode, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "avsCode", -1, &a->avsCode, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "cvnCode", -1, &a->cvnCode, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__TransactionStatusCreditCard * SOAP_FMAC4 soap_get_vin__TransactionStatusCreditCard(struct soap *soap, struct vin__TransactionStatusCreditCard *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__TransactionStatusCreditCard(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TransactionStatusCreditCard * SOAP_FMAC4 soap_in_vin__TransactionStatusCreditCard(struct soap *soap, const char *tag, struct vin__TransactionStatusCreditCard *a, const char *type)
{
	size_t soap_flag_authCode = 1;
	size_t soap_flag_avsCode = 1;
	size_t soap_flag_cvnCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__TransactionStatusCreditCard *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__TransactionStatusCreditCard, sizeof(struct vin__TransactionStatusCreditCard), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__TransactionStatusCreditCard(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "authCode", &a->authCode, "xsd:string"))
				{	soap_flag_authCode--;
					continue;
				}
			if (soap_flag_avsCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "avsCode", &a->avsCode, "xsd:string"))
				{	soap_flag_avsCode--;
					continue;
				}
			if (soap_flag_cvnCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cvnCode", &a->cvnCode, "xsd:string"))
				{	soap_flag_cvnCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__TransactionStatusCreditCard *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__TransactionStatusCreditCard, 0, sizeof(struct vin__TransactionStatusCreditCard), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_authCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__TransactionStatus(struct soap *soap, struct vin__TransactionStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_vin__TransactionStatusType(soap, &a->status);
	soap_default_time(soap, &a->timestamp);
	soap_default_vin__PaymentMethodType(soap, &a->paymentMethodType);
	a->creditCardStatus = NULL;
	a->ecpStatus = NULL;
	a->boletoStatus = NULL;
	a->payPalStatus = NULL;
	a->directDebitStatus = NULL;
	a->vinAVS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__TransactionStatus(struct soap *soap, const struct vin__TransactionStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->timestamp, SOAP_TYPE_time);
	soap_embedded(soap, &a->paymentMethodType, SOAP_TYPE_vin__PaymentMethodType);
	soap_serialize_PointerTovin__TransactionStatusCreditCard(soap, &a->creditCardStatus);
	soap_serialize_PointerTovin__TransactionStatusECP(soap, &a->ecpStatus);
	soap_serialize_PointerTovin__TransactionStatusBoleto(soap, &a->boletoStatus);
	soap_serialize_PointerTovin__TransactionStatusPayPal(soap, &a->payPalStatus);
	soap_serialize_PointerTovin__TransactionStatusDirectDebit(soap, &a->directDebitStatus);
	soap_serialize_PointerTovin__AVSMatchType(soap, &a->vinAVS);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__TransactionStatus(struct soap *soap, const struct vin__TransactionStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__TransactionStatus);
	if (soap_out_vin__TransactionStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__TransactionStatus(struct soap *soap, const char *tag, int id, const struct vin__TransactionStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__TransactionStatus), type))
		return soap->error;
	if (soap_out_vin__TransactionStatusType(soap, "status", -1, &a->status, "vin:TransactionStatusType"))
		return soap->error;
	if (soap_out_time(soap, "timestamp", -1, &a->timestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_vin__PaymentMethodType(soap, "paymentMethodType", -1, &a->paymentMethodType, "vin:PaymentMethodType"))
		return soap->error;
	if (soap_out_PointerTovin__TransactionStatusCreditCard(soap, "creditCardStatus", -1, &a->creditCardStatus, "vin:TransactionStatusCreditCard"))
		return soap->error;
	if (soap_out_PointerTovin__TransactionStatusECP(soap, "ecpStatus", -1, &a->ecpStatus, "vin:TransactionStatusECP"))
		return soap->error;
	if (soap_out_PointerTovin__TransactionStatusBoleto(soap, "boletoStatus", -1, &a->boletoStatus, "vin:TransactionStatusBoleto"))
		return soap->error;
	if (soap_out_PointerTovin__TransactionStatusPayPal(soap, "payPalStatus", -1, &a->payPalStatus, "vin:TransactionStatusPayPal"))
		return soap->error;
	if (soap_out_PointerTovin__TransactionStatusDirectDebit(soap, "directDebitStatus", -1, &a->directDebitStatus, "vin:TransactionStatusDirectDebit"))
		return soap->error;
	if (soap_out_PointerTovin__AVSMatchType(soap, "vinAVS", -1, &a->vinAVS, "vin:AVSMatchType"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__TransactionStatus * SOAP_FMAC4 soap_get_vin__TransactionStatus(struct soap *soap, struct vin__TransactionStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__TransactionStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TransactionStatus * SOAP_FMAC4 soap_in_vin__TransactionStatus(struct soap *soap, const char *tag, struct vin__TransactionStatus *a, const char *type)
{
	size_t soap_flag_status = 1;
	size_t soap_flag_timestamp = 1;
	size_t soap_flag_paymentMethodType = 1;
	size_t soap_flag_creditCardStatus = 1;
	size_t soap_flag_ecpStatus = 1;
	size_t soap_flag_boletoStatus = 1;
	size_t soap_flag_payPalStatus = 1;
	size_t soap_flag_directDebitStatus = 1;
	size_t soap_flag_vinAVS = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__TransactionStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__TransactionStatus, sizeof(struct vin__TransactionStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__TransactionStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_vin__TransactionStatusType(soap, "status", &a->status, "vin:TransactionStatusType"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "timestamp", &a->timestamp, "xsd:dateTime"))
				{	soap_flag_timestamp--;
					continue;
				}
			if (soap_flag_paymentMethodType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_vin__PaymentMethodType(soap, "paymentMethodType", &a->paymentMethodType, "vin:PaymentMethodType"))
				{	soap_flag_paymentMethodType--;
					continue;
				}
			if (soap_flag_creditCardStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__TransactionStatusCreditCard(soap, "creditCardStatus", &a->creditCardStatus, "vin:TransactionStatusCreditCard"))
				{	soap_flag_creditCardStatus--;
					continue;
				}
			if (soap_flag_ecpStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__TransactionStatusECP(soap, "ecpStatus", &a->ecpStatus, "vin:TransactionStatusECP"))
				{	soap_flag_ecpStatus--;
					continue;
				}
			if (soap_flag_boletoStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__TransactionStatusBoleto(soap, "boletoStatus", &a->boletoStatus, "vin:TransactionStatusBoleto"))
				{	soap_flag_boletoStatus--;
					continue;
				}
			if (soap_flag_payPalStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__TransactionStatusPayPal(soap, "payPalStatus", &a->payPalStatus, "vin:TransactionStatusPayPal"))
				{	soap_flag_payPalStatus--;
					continue;
				}
			if (soap_flag_directDebitStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__TransactionStatusDirectDebit(soap, "directDebitStatus", &a->directDebitStatus, "vin:TransactionStatusDirectDebit"))
				{	soap_flag_directDebitStatus--;
					continue;
				}
			if (soap_flag_vinAVS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__AVSMatchType(soap, "vinAVS", &a->vinAVS, "vin:AVSMatchType"))
				{	soap_flag_vinAVS--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__TransactionStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__TransactionStatus, 0, sizeof(struct vin__TransactionStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status > 0 || soap_flag_timestamp > 0 || soap_flag_paymentMethodType > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__TransactionItem(struct soap *soap, struct vin__TransactionItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->sku);
	soap_default_string(soap, &a->name);
	soap_default_xsd__decimal(soap, &a->price);
	soap_default_int(soap, &a->quantity);
	a->taxClassification = NULL;
	a->tokens = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__TransactionItem(struct soap *soap, const struct vin__TransactionItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->sku);
	soap_serialize_string(soap, &a->name);
	soap_serialize_xsd__decimal(soap, &a->price);
	soap_embedded(soap, &a->quantity, SOAP_TYPE_int);
	soap_serialize_PointerTovin__TaxClassification(soap, &a->taxClassification);
	soap_serialize_PointerToArrayOfTokenAmounts(soap, &a->tokens);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__TransactionItem(struct soap *soap, const struct vin__TransactionItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__TransactionItem);
	if (soap_out_vin__TransactionItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__TransactionItem(struct soap *soap, const char *tag, int id, const struct vin__TransactionItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__TransactionItem), type))
		return soap->error;
	if (soap_out_string(soap, "sku", -1, &a->sku, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, "xsd:string"))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "price", -1, &a->price, "xsd:decimal"))
		return soap->error;
	if (soap_out_int(soap, "quantity", -1, &a->quantity, "xsd:int"))
		return soap->error;
	if (soap_out_PointerTovin__TaxClassification(soap, "taxClassification", -1, &a->taxClassification, "vin:TaxClassification"))
		return soap->error;
	if (soap_out_PointerToArrayOfTokenAmounts(soap, "tokens", -1, &a->tokens, "vin:TokenAmount"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__TransactionItem * SOAP_FMAC4 soap_get_vin__TransactionItem(struct soap *soap, struct vin__TransactionItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__TransactionItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TransactionItem * SOAP_FMAC4 soap_in_vin__TransactionItem(struct soap *soap, const char *tag, struct vin__TransactionItem *a, const char *type)
{
	size_t soap_flag_sku = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_price = 1;
	size_t soap_flag_quantity = 1;
	size_t soap_flag_taxClassification = 1;
	size_t soap_flag_tokens = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__TransactionItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__TransactionItem, sizeof(struct vin__TransactionItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__TransactionItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sku && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sku", &a->sku, "xsd:string"))
				{	soap_flag_sku--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_price && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "price", &a->price, "xsd:decimal"))
				{	soap_flag_price--;
					continue;
				}
			if (soap_flag_quantity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "quantity", &a->quantity, "xsd:int"))
				{	soap_flag_quantity--;
					continue;
				}
			if (soap_flag_taxClassification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__TaxClassification(soap, "taxClassification", &a->taxClassification, "vin:TaxClassification"))
				{	soap_flag_taxClassification--;
					continue;
				}
			if (soap_flag_tokens && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTokenAmounts(soap, "tokens", &a->tokens, "vin:TokenAmount"))
				{	soap_flag_tokens--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__TransactionItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__TransactionItem, 0, sizeof(struct vin__TransactionItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_price > 0 || soap_flag_quantity > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ScoreCode(struct soap *soap, struct vin__ScoreCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->description);
	soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__ScoreCode(struct soap *soap, const struct vin__ScoreCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->description);
	soap_serialize_string(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ScoreCode(struct soap *soap, const struct vin__ScoreCode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ScoreCode);
	if (soap_out_vin__ScoreCode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ScoreCode(struct soap *soap, const char *tag, int id, const struct vin__ScoreCode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ScoreCode), type))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__ScoreCode * SOAP_FMAC4 soap_get_vin__ScoreCode(struct soap *soap, struct vin__ScoreCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ScoreCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ScoreCode * SOAP_FMAC4 soap_in_vin__ScoreCode(struct soap *soap, const char *tag, struct vin__ScoreCode *a, const char *type)
{
	size_t soap_flag_description = 1;
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__ScoreCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ScoreCode, sizeof(struct vin__ScoreCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__ScoreCode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__ScoreCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ScoreCode, 0, sizeof(struct vin__ScoreCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__CancelResult(struct soap *soap, struct vin__CancelResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->returnCode);
	soap_default_string(soap, &a->merchantTransactionId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__CancelResult(struct soap *soap, const struct vin__CancelResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->returnCode, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->merchantTransactionId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__CancelResult(struct soap *soap, const struct vin__CancelResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__CancelResult);
	if (soap_out_vin__CancelResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__CancelResult(struct soap *soap, const char *tag, int id, const struct vin__CancelResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__CancelResult), type))
		return soap->error;
	if (soap_out_int(soap, "returnCode", -1, &a->returnCode, "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "merchantTransactionId", -1, &a->merchantTransactionId, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__CancelResult * SOAP_FMAC4 soap_get_vin__CancelResult(struct soap *soap, struct vin__CancelResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__CancelResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__CancelResult * SOAP_FMAC4 soap_in_vin__CancelResult(struct soap *soap, const char *tag, struct vin__CancelResult *a, const char *type)
{
	size_t soap_flag_returnCode = 1;
	size_t soap_flag_merchantTransactionId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__CancelResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__CancelResult, sizeof(struct vin__CancelResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__CancelResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "returnCode", &a->returnCode, "xsd:int"))
				{	soap_flag_returnCode--;
					continue;
				}
			if (soap_flag_merchantTransactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantTransactionId", &a->merchantTransactionId, "xsd:string"))
				{	soap_flag_merchantTransactionId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__CancelResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__CancelResult, 0, sizeof(struct vin__CancelResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnCode > 0 || soap_flag_merchantTransactionId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__CaptureResult(struct soap *soap, struct vin__CaptureResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->returnCode);
	soap_default_string(soap, &a->merchantTransactionId);
	soap_default_string(soap, &a->originaMerchantTransactionId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__CaptureResult(struct soap *soap, const struct vin__CaptureResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->returnCode, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->merchantTransactionId);
	soap_serialize_string(soap, &a->originaMerchantTransactionId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__CaptureResult(struct soap *soap, const struct vin__CaptureResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__CaptureResult);
	if (soap_out_vin__CaptureResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__CaptureResult(struct soap *soap, const char *tag, int id, const struct vin__CaptureResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__CaptureResult), type))
		return soap->error;
	if (soap_out_int(soap, "returnCode", -1, &a->returnCode, "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "merchantTransactionId", -1, &a->merchantTransactionId, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "originaMerchantTransactionId", -1, &a->originaMerchantTransactionId, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__CaptureResult * SOAP_FMAC4 soap_get_vin__CaptureResult(struct soap *soap, struct vin__CaptureResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__CaptureResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__CaptureResult * SOAP_FMAC4 soap_in_vin__CaptureResult(struct soap *soap, const char *tag, struct vin__CaptureResult *a, const char *type)
{
	size_t soap_flag_returnCode = 1;
	size_t soap_flag_merchantTransactionId = 1;
	size_t soap_flag_originaMerchantTransactionId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__CaptureResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__CaptureResult, sizeof(struct vin__CaptureResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__CaptureResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "returnCode", &a->returnCode, "xsd:int"))
				{	soap_flag_returnCode--;
					continue;
				}
			if (soap_flag_merchantTransactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantTransactionId", &a->merchantTransactionId, "xsd:string"))
				{	soap_flag_merchantTransactionId--;
					continue;
				}
			if (soap_flag_originaMerchantTransactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "originaMerchantTransactionId", &a->originaMerchantTransactionId, "xsd:string"))
				{	soap_flag_originaMerchantTransactionId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__CaptureResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__CaptureResult, 0, sizeof(struct vin__CaptureResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnCode > 0 || soap_flag_merchantTransactionId > 0 || soap_flag_originaMerchantTransactionId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__TokenTransaction(struct soap *soap, struct vin__TokenTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->account = NULL;
	a->tokenAmount = NULL;
	soap_default_string(soap, &a->description);
	soap_default_time(soap, &a->authTimestamp);
	a->clearedTimestamp = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__TokenTransaction(struct soap *soap, const struct vin__TokenTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Account(soap, &a->account);
	soap_serialize_PointerTovin__TokenAmount(soap, &a->tokenAmount);
	soap_serialize_string(soap, &a->description);
	soap_embedded(soap, &a->authTimestamp, SOAP_TYPE_time);
	soap_serialize_PointerTotime(soap, &a->clearedTimestamp);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__TokenTransaction(struct soap *soap, const struct vin__TokenTransaction *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__TokenTransaction);
	if (soap_out_vin__TokenTransaction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__TokenTransaction(struct soap *soap, const char *tag, int id, const struct vin__TokenTransaction *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__TokenTransaction), type))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->account, "vin:Account"))
		return soap->error;
	if (soap_out_PointerTovin__TokenAmount(soap, "tokenAmount", -1, &a->tokenAmount, "vin:TokenAmount"))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "authTimestamp", -1, &a->authTimestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_PointerTotime(soap, "clearedTimestamp", -1, &a->clearedTimestamp, "xsd:dateTime"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__TokenTransaction * SOAP_FMAC4 soap_get_vin__TokenTransaction(struct soap *soap, struct vin__TokenTransaction *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__TokenTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TokenTransaction * SOAP_FMAC4 soap_in_vin__TokenTransaction(struct soap *soap, const char *tag, struct vin__TokenTransaction *a, const char *type)
{
	size_t soap_flag_account = 1;
	size_t soap_flag_tokenAmount = 1;
	size_t soap_flag_description = 1;
	size_t soap_flag_authTimestamp = 1;
	size_t soap_flag_clearedTimestamp = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__TokenTransaction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__TokenTransaction, sizeof(struct vin__TokenTransaction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__TokenTransaction(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, "account", &a->account, "vin:Account"))
				{	soap_flag_account--;
					continue;
				}
			if (soap_flag_tokenAmount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__TokenAmount(soap, "tokenAmount", &a->tokenAmount, "vin:TokenAmount"))
				{	soap_flag_tokenAmount--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_authTimestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "authTimestamp", &a->authTimestamp, "xsd:dateTime"))
				{	soap_flag_authTimestamp--;
					continue;
				}
			if (soap_flag_clearedTimestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "clearedTimestamp", &a->clearedTimestamp, "xsd:dateTime"))
				{	soap_flag_clearedTimestamp--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__TokenTransaction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__TokenTransaction, 0, sizeof(struct vin__TokenTransaction), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_account > 0 || soap_flag_tokenAmount > 0 || soap_flag_authTimestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__SalesTax(struct soap *soap, struct vin__SalesTax *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->description);
	soap_default_xsd__decimal(soap, &a->tax);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__SalesTax(struct soap *soap, const struct vin__SalesTax *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->description);
	soap_serialize_xsd__decimal(soap, &a->tax);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__SalesTax(struct soap *soap, const struct vin__SalesTax *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__SalesTax);
	if (soap_out_vin__SalesTax(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__SalesTax(struct soap *soap, const char *tag, int id, const struct vin__SalesTax *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__SalesTax), type))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, "xsd:string"))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "tax", -1, &a->tax, "xsd:decimal"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__SalesTax * SOAP_FMAC4 soap_get_vin__SalesTax(struct soap *soap, struct vin__SalesTax *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__SalesTax(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__SalesTax * SOAP_FMAC4 soap_in_vin__SalesTax(struct soap *soap, const char *tag, struct vin__SalesTax *a, const char *type)
{
	size_t soap_flag_description = 1;
	size_t soap_flag_tax = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__SalesTax *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__SalesTax, sizeof(struct vin__SalesTax), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__SalesTax(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_tax && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "tax", &a->tax, "xsd:decimal"))
				{	soap_flag_tax--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__SalesTax *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__SalesTax, 0, sizeof(struct vin__SalesTax), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_description > 0 || soap_flag_tax > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__TaxExemption(struct soap *soap, struct vin__TaxExemption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->region = NULL;
	soap_default_string(soap, &a->exemptionId);
	soap_default_xsd__boolean(soap, &a->active);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__TaxExemption(struct soap *soap, const struct vin__TaxExemption *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__TaxRegion(soap, &a->region);
	soap_serialize_string(soap, &a->exemptionId);
	soap_embedded(soap, &a->active, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__TaxExemption(struct soap *soap, const struct vin__TaxExemption *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__TaxExemption);
	if (soap_out_vin__TaxExemption(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__TaxExemption(struct soap *soap, const char *tag, int id, const struct vin__TaxExemption *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__TaxExemption), type))
		return soap->error;
	if (soap_out_PointerTovin__TaxRegion(soap, "region", -1, &a->region, "vin:TaxRegion"))
		return soap->error;
	if (soap_out_string(soap, "exemptionId", -1, &a->exemptionId, "xsd:string"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "active", -1, &a->active, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__TaxExemption * SOAP_FMAC4 soap_get_vin__TaxExemption(struct soap *soap, struct vin__TaxExemption *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__TaxExemption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TaxExemption * SOAP_FMAC4 soap_in_vin__TaxExemption(struct soap *soap, const char *tag, struct vin__TaxExemption *a, const char *type)
{
	size_t soap_flag_region = 1;
	size_t soap_flag_exemptionId = 1;
	size_t soap_flag_active = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__TaxExemption *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__TaxExemption, sizeof(struct vin__TaxExemption), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__TaxExemption(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_region && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__TaxRegion(soap, "region", &a->region, "vin:TaxRegion"))
				{	soap_flag_region--;
					continue;
				}
			if (soap_flag_exemptionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "exemptionId", &a->exemptionId, "xsd:string"))
				{	soap_flag_exemptionId--;
					continue;
				}
			if (soap_flag_active && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "active", &a->active, "xsd:boolean"))
				{	soap_flag_active--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__TaxExemption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__TaxExemption, 0, sizeof(struct vin__TaxExemption), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_active > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__Return(struct soap *soap, struct vin__Return *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_vin__ReturnCode(soap, &a->returnCode);
	soap_default_string(soap, &a->returnString);
	soap_default_string(soap, &a->soapId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__Return(struct soap *soap, const struct vin__Return *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->returnString);
	soap_serialize_string(soap, &a->soapId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__Return(struct soap *soap, const struct vin__Return *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__Return);
	if (soap_out_vin__Return(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__Return(struct soap *soap, const char *tag, int id, const struct vin__Return *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__Return), type))
		return soap->error;
	if (soap_out_vin__ReturnCode(soap, "returnCode", -1, &a->returnCode, "vin:ReturnCode"))
		return soap->error;
	if (soap_out_string(soap, "returnString", -1, &a->returnString, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "soapId", -1, &a->soapId, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__Return * SOAP_FMAC4 soap_get_vin__Return(struct soap *soap, struct vin__Return *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__Return(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Return * SOAP_FMAC4 soap_in_vin__Return(struct soap *soap, const char *tag, struct vin__Return *a, const char *type)
{
	size_t soap_flag_returnCode = 1;
	size_t soap_flag_returnString = 1;
	size_t soap_flag_soapId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__Return *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__Return, sizeof(struct vin__Return), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__Return(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_vin__ReturnCode(soap, "returnCode", &a->returnCode, "vin:ReturnCode"))
				{	soap_flag_returnCode--;
					continue;
				}
			if (soap_flag_returnString && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "returnString", &a->returnString, "xsd:string"))
				{	soap_flag_returnString--;
					continue;
				}
			if (soap_flag_soapId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "soapId", &a->soapId, "xsd:string"))
				{	soap_flag_soapId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__Return *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__Return, 0, sizeof(struct vin__Return), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__Refund(struct soap *soap, struct vin__Refund *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->VID);
	soap_default_string(soap, &a->merchantRefundId);
	a->transaction = NULL;
	soap_default_xsd__decimal(soap, &a->amount);
	soap_default_string(soap, &a->currency);
	a->timestamp = NULL;
	soap_default_string(soap, &a->referenceString);
	soap_default_string(soap, &a->note);
	a->tokenAction = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__Refund(struct soap *soap, const struct vin__Refund *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->VID);
	soap_serialize_string(soap, &a->merchantRefundId);
	soap_serialize_PointerTovin__Transaction(soap, &a->transaction);
	soap_serialize_xsd__decimal(soap, &a->amount);
	soap_serialize_string(soap, &a->currency);
	soap_serialize_PointerTotime(soap, &a->timestamp);
	soap_serialize_string(soap, &a->referenceString);
	soap_serialize_string(soap, &a->note);
	soap_serialize_PointerTovin__RefundTokenAction(soap, &a->tokenAction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__Refund(struct soap *soap, const struct vin__Refund *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__Refund);
	if (soap_out_vin__Refund(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__Refund(struct soap *soap, const char *tag, int id, const struct vin__Refund *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__Refund), type))
		return soap->error;
	if (soap_out_string(soap, "VID", -1, &a->VID, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "merchantRefundId", -1, &a->merchantRefundId, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__Transaction(soap, "transaction", -1, &a->transaction, "vin:Transaction"))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "amount", -1, &a->amount, "xsd:decimal"))
		return soap->error;
	if (soap_out_string(soap, "currency", -1, &a->currency, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTotime(soap, "timestamp", -1, &a->timestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_string(soap, "referenceString", -1, &a->referenceString, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "note", -1, &a->note, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__RefundTokenAction(soap, "tokenAction", -1, &a->tokenAction, "vin:RefundTokenAction"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__Refund * SOAP_FMAC4 soap_get_vin__Refund(struct soap *soap, struct vin__Refund *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__Refund(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Refund * SOAP_FMAC4 soap_in_vin__Refund(struct soap *soap, const char *tag, struct vin__Refund *a, const char *type)
{
	size_t soap_flag_VID = 1;
	size_t soap_flag_merchantRefundId = 1;
	size_t soap_flag_transaction = 1;
	size_t soap_flag_amount = 1;
	size_t soap_flag_currency = 1;
	size_t soap_flag_timestamp = 1;
	size_t soap_flag_referenceString = 1;
	size_t soap_flag_note = 1;
	size_t soap_flag_tokenAction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__Refund *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__Refund, sizeof(struct vin__Refund), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__Refund(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "VID", &a->VID, "xsd:string"))
				{	soap_flag_VID--;
					continue;
				}
			if (soap_flag_merchantRefundId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantRefundId", &a->merchantRefundId, "xsd:string"))
				{	soap_flag_merchantRefundId--;
					continue;
				}
			if (soap_flag_transaction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Transaction(soap, "transaction", &a->transaction, "vin:Transaction"))
				{	soap_flag_transaction--;
					continue;
				}
			if (soap_flag_amount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "amount", &a->amount, "xsd:decimal"))
				{	soap_flag_amount--;
					continue;
				}
			if (soap_flag_currency && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "currency", &a->currency, "xsd:string"))
				{	soap_flag_currency--;
					continue;
				}
			if (soap_flag_timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "timestamp", &a->timestamp, "xsd:dateTime"))
				{	soap_flag_timestamp--;
					continue;
				}
			if (soap_flag_referenceString && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "referenceString", &a->referenceString, "xsd:string"))
				{	soap_flag_referenceString--;
					continue;
				}
			if (soap_flag_note && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "note", &a->note, "xsd:string"))
				{	soap_flag_note--;
					continue;
				}
			if (soap_flag_tokenAction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__RefundTokenAction(soap, "tokenAction", &a->tokenAction, "vin:RefundTokenAction"))
				{	soap_flag_tokenAction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__Refund *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__Refund, 0, sizeof(struct vin__Refund), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_amount > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__NameValuePair(struct soap *soap, struct vin__NameValuePair *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__NameValuePair(struct soap *soap, const struct vin__NameValuePair *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__NameValuePair(struct soap *soap, const struct vin__NameValuePair *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__NameValuePair);
	if (soap_out_vin__NameValuePair(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__NameValuePair(struct soap *soap, const char *tag, int id, const struct vin__NameValuePair *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__NameValuePair), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &a->value, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__NameValuePair * SOAP_FMAC4 soap_get_vin__NameValuePair(struct soap *soap, struct vin__NameValuePair *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__NameValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__NameValuePair * SOAP_FMAC4 soap_in_vin__NameValuePair(struct soap *soap, const char *tag, struct vin__NameValuePair *a, const char *type)
{
	size_t soap_flag_name = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__NameValuePair *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__NameValuePair, sizeof(struct vin__NameValuePair), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__NameValuePair(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__NameValuePair *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__NameValuePair, 0, sizeof(struct vin__NameValuePair), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__MerchantEntitlementId(struct soap *soap, struct vin__MerchantEntitlementId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->description);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__MerchantEntitlementId(struct soap *soap, const struct vin__MerchantEntitlementId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->description);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__MerchantEntitlementId(struct soap *soap, const struct vin__MerchantEntitlementId *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__MerchantEntitlementId);
	if (soap_out_vin__MerchantEntitlementId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__MerchantEntitlementId(struct soap *soap, const char *tag, int id, const struct vin__MerchantEntitlementId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__MerchantEntitlementId), type))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__MerchantEntitlementId * SOAP_FMAC4 soap_get_vin__MerchantEntitlementId(struct soap *soap, struct vin__MerchantEntitlementId *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__MerchantEntitlementId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__MerchantEntitlementId * SOAP_FMAC4 soap_in_vin__MerchantEntitlementId(struct soap *soap, const char *tag, struct vin__MerchantEntitlementId *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_description = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__MerchantEntitlementId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__MerchantEntitlementId, sizeof(struct vin__MerchantEntitlementId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__MerchantEntitlementId(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__MerchantEntitlementId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__MerchantEntitlementId, 0, sizeof(struct vin__MerchantEntitlementId), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_description > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__PaymentProvider(struct soap *soap, struct vin__PaymentProvider *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->VID);
	soap_default_string(soap, &a->description);
	a->paymentType = NULL;
	soap_default_string(soap, &a->account);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__PaymentProvider(struct soap *soap, const struct vin__PaymentProvider *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->VID);
	soap_serialize_string(soap, &a->description);
	soap_serialize_PointerTovin__PaymentMethodType(soap, &a->paymentType);
	soap_serialize_string(soap, &a->account);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__PaymentProvider(struct soap *soap, const struct vin__PaymentProvider *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__PaymentProvider);
	if (soap_out_vin__PaymentProvider(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__PaymentProvider(struct soap *soap, const char *tag, int id, const struct vin__PaymentProvider *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__PaymentProvider), type))
		return soap->error;
	if (soap_out_string(soap, "VID", -1, &a->VID, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentMethodType(soap, "paymentType", -1, &a->paymentType, "vin:PaymentMethodType"))
		return soap->error;
	if (soap_out_string(soap, "account", -1, &a->account, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__PaymentProvider * SOAP_FMAC4 soap_get_vin__PaymentProvider(struct soap *soap, struct vin__PaymentProvider *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__PaymentProvider(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__PaymentProvider * SOAP_FMAC4 soap_in_vin__PaymentProvider(struct soap *soap, const char *tag, struct vin__PaymentProvider *a, const char *type)
{
	size_t soap_flag_VID = 1;
	size_t soap_flag_description = 1;
	size_t soap_flag_paymentType = 1;
	size_t soap_flag_account = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__PaymentProvider *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__PaymentProvider, sizeof(struct vin__PaymentProvider), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__PaymentProvider(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "VID", &a->VID, "xsd:string"))
				{	soap_flag_VID--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_paymentType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentMethodType(soap, "paymentType", &a->paymentType, "vin:PaymentMethodType"))
				{	soap_flag_paymentType--;
					continue;
				}
			if (soap_flag_account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "account", &a->account, "xsd:string"))
				{	soap_flag_account--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__PaymentProvider *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__PaymentProvider, 0, sizeof(struct vin__PaymentProvider), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__Token(struct soap *soap, struct vin__Token *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->VID);
	soap_default_string(soap, &a->merchantTokenId);
	soap_default_string(soap, &a->description);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__Token(struct soap *soap, const struct vin__Token *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->VID);
	soap_serialize_string(soap, &a->merchantTokenId);
	soap_serialize_string(soap, &a->description);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__Token(struct soap *soap, const struct vin__Token *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__Token);
	if (soap_out_vin__Token(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__Token(struct soap *soap, const char *tag, int id, const struct vin__Token *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__Token), type))
		return soap->error;
	if (soap_out_string(soap, "VID", -1, &a->VID, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "merchantTokenId", -1, &a->merchantTokenId, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__Token * SOAP_FMAC4 soap_get_vin__Token(struct soap *soap, struct vin__Token *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__Token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Token * SOAP_FMAC4 soap_in_vin__Token(struct soap *soap, const char *tag, struct vin__Token *a, const char *type)
{
	size_t soap_flag_VID = 1;
	size_t soap_flag_merchantTokenId = 1;
	size_t soap_flag_description = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__Token *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__Token, sizeof(struct vin__Token), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__Token(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "VID", &a->VID, "xsd:string"))
				{	soap_flag_VID--;
					continue;
				}
			if (soap_flag_merchantTokenId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantTokenId", &a->merchantTokenId, "xsd:string"))
				{	soap_flag_merchantTokenId--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__Token *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__Token, 0, sizeof(struct vin__Token), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__Boleto(struct soap *soap, struct vin__Boleto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->fiscalNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__Boleto(struct soap *soap, const struct vin__Boleto *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->fiscalNumber);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__Boleto(struct soap *soap, const struct vin__Boleto *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__Boleto);
	if (soap_out_vin__Boleto(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__Boleto(struct soap *soap, const char *tag, int id, const struct vin__Boleto *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__Boleto), type))
		return soap->error;
	if (soap_out_string(soap, "fiscalNumber", -1, &a->fiscalNumber, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__Boleto * SOAP_FMAC4 soap_get_vin__Boleto(struct soap *soap, struct vin__Boleto *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__Boleto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Boleto * SOAP_FMAC4 soap_in_vin__Boleto(struct soap *soap, const char *tag, struct vin__Boleto *a, const char *type)
{
	size_t soap_flag_fiscalNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__Boleto *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__Boleto, sizeof(struct vin__Boleto), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__Boleto(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fiscalNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fiscalNumber", &a->fiscalNumber, "xsd:string"))
				{	soap_flag_fiscalNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__Boleto *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__Boleto, 0, sizeof(struct vin__Boleto), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__PayPal(struct soap *soap, struct vin__PayPal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->emailAddress);
	a->hashType = NULL;
	soap_default_string(soap, &a->passwordHash);
	soap_default_string(soap, &a->returnUrl);
	soap_default_string(soap, &a->cancelUrl);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__PayPal(struct soap *soap, const struct vin__PayPal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->emailAddress);
	soap_serialize_PointerTovin__HashType(soap, &a->hashType);
	soap_serialize_string(soap, &a->passwordHash);
	soap_serialize_string(soap, &a->returnUrl);
	soap_serialize_string(soap, &a->cancelUrl);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__PayPal(struct soap *soap, const struct vin__PayPal *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__PayPal);
	if (soap_out_vin__PayPal(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__PayPal(struct soap *soap, const char *tag, int id, const struct vin__PayPal *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__PayPal), type))
		return soap->error;
	if (soap_out_string(soap, "emailAddress", -1, &a->emailAddress, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__HashType(soap, "hashType", -1, &a->hashType, "vin:HashType"))
		return soap->error;
	if (soap_out_string(soap, "passwordHash", -1, &a->passwordHash, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "returnUrl", -1, &a->returnUrl, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "cancelUrl", -1, &a->cancelUrl, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__PayPal * SOAP_FMAC4 soap_get_vin__PayPal(struct soap *soap, struct vin__PayPal *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__PayPal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__PayPal * SOAP_FMAC4 soap_in_vin__PayPal(struct soap *soap, const char *tag, struct vin__PayPal *a, const char *type)
{
	size_t soap_flag_emailAddress = 1;
	size_t soap_flag_hashType = 1;
	size_t soap_flag_passwordHash = 1;
	size_t soap_flag_returnUrl = 1;
	size_t soap_flag_cancelUrl = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__PayPal *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__PayPal, sizeof(struct vin__PayPal), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__PayPal(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_emailAddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "emailAddress", &a->emailAddress, "xsd:string"))
				{	soap_flag_emailAddress--;
					continue;
				}
			if (soap_flag_hashType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__HashType(soap, "hashType", &a->hashType, "vin:HashType"))
				{	soap_flag_hashType--;
					continue;
				}
			if (soap_flag_passwordHash && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "passwordHash", &a->passwordHash, "xsd:string"))
				{	soap_flag_passwordHash--;
					continue;
				}
			if (soap_flag_returnUrl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "returnUrl", &a->returnUrl, "xsd:string"))
				{	soap_flag_returnUrl--;
					continue;
				}
			if (soap_flag_cancelUrl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cancelUrl", &a->cancelUrl, "xsd:string"))
				{	soap_flag_cancelUrl--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__PayPal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__PayPal, 0, sizeof(struct vin__PayPal), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__DirectDebit(struct soap *soap, struct vin__DirectDebit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->account);
	soap_default_string(soap, &a->lastDigits);
	a->accountLength = NULL;
	a->hashType = NULL;
	soap_default_string(soap, &a->accountHash);
	soap_default_string(soap, &a->countryCode);
	soap_default_string(soap, &a->bankSortCode);
	soap_default_string(soap, &a->ribCode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__DirectDebit(struct soap *soap, const struct vin__DirectDebit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->account);
	soap_serialize_string(soap, &a->lastDigits);
	soap_serialize_PointerToint(soap, &a->accountLength);
	soap_serialize_PointerTovin__HashType(soap, &a->hashType);
	soap_serialize_string(soap, &a->accountHash);
	soap_serialize_string(soap, &a->countryCode);
	soap_serialize_string(soap, &a->bankSortCode);
	soap_serialize_string(soap, &a->ribCode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__DirectDebit(struct soap *soap, const struct vin__DirectDebit *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__DirectDebit);
	if (soap_out_vin__DirectDebit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__DirectDebit(struct soap *soap, const char *tag, int id, const struct vin__DirectDebit *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__DirectDebit), type))
		return soap->error;
	if (soap_out_string(soap, "account", -1, &a->account, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "lastDigits", -1, &a->lastDigits, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToint(soap, "accountLength", -1, &a->accountLength, "xsd:int"))
		return soap->error;
	if (soap_out_PointerTovin__HashType(soap, "hashType", -1, &a->hashType, "vin:HashType"))
		return soap->error;
	if (soap_out_string(soap, "accountHash", -1, &a->accountHash, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "countryCode", -1, &a->countryCode, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "bankSortCode", -1, &a->bankSortCode, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "ribCode", -1, &a->ribCode, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__DirectDebit * SOAP_FMAC4 soap_get_vin__DirectDebit(struct soap *soap, struct vin__DirectDebit *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__DirectDebit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__DirectDebit * SOAP_FMAC4 soap_in_vin__DirectDebit(struct soap *soap, const char *tag, struct vin__DirectDebit *a, const char *type)
{
	size_t soap_flag_account = 1;
	size_t soap_flag_lastDigits = 1;
	size_t soap_flag_accountLength = 1;
	size_t soap_flag_hashType = 1;
	size_t soap_flag_accountHash = 1;
	size_t soap_flag_countryCode = 1;
	size_t soap_flag_bankSortCode = 1;
	size_t soap_flag_ribCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__DirectDebit *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__DirectDebit, sizeof(struct vin__DirectDebit), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__DirectDebit(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "account", &a->account, "xsd:string"))
				{	soap_flag_account--;
					continue;
				}
			if (soap_flag_lastDigits && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastDigits", &a->lastDigits, "xsd:string"))
				{	soap_flag_lastDigits--;
					continue;
				}
			if (soap_flag_accountLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "accountLength", &a->accountLength, "xsd:int"))
				{	soap_flag_accountLength--;
					continue;
				}
			if (soap_flag_hashType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__HashType(soap, "hashType", &a->hashType, "vin:HashType"))
				{	soap_flag_hashType--;
					continue;
				}
			if (soap_flag_accountHash && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "accountHash", &a->accountHash, "xsd:string"))
				{	soap_flag_accountHash--;
					continue;
				}
			if (soap_flag_countryCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "countryCode", &a->countryCode, "xsd:string"))
				{	soap_flag_countryCode--;
					continue;
				}
			if (soap_flag_bankSortCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bankSortCode", &a->bankSortCode, "xsd:string"))
				{	soap_flag_bankSortCode--;
					continue;
				}
			if (soap_flag_ribCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ribCode", &a->ribCode, "xsd:string"))
				{	soap_flag_ribCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__DirectDebit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__DirectDebit, 0, sizeof(struct vin__DirectDebit), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ECP(struct soap *soap, struct vin__ECP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->account);
	a->hashType = NULL;
	soap_default_string(soap, &a->accountHash);
	soap_default_string(soap, &a->routingNumber);
	a->accountType = NULL;
	soap_default_string(soap, &a->lastDigits);
	a->accountLength = NULL;
	a->allowedTransactionType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__ECP(struct soap *soap, const struct vin__ECP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->account);
	soap_serialize_PointerTovin__HashType(soap, &a->hashType);
	soap_serialize_string(soap, &a->accountHash);
	soap_serialize_string(soap, &a->routingNumber);
	soap_serialize_PointerTovin__AccountType(soap, &a->accountType);
	soap_serialize_string(soap, &a->lastDigits);
	soap_serialize_PointerToint(soap, &a->accountLength);
	soap_serialize_PointerTovin__ECPTransactionType(soap, &a->allowedTransactionType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ECP(struct soap *soap, const struct vin__ECP *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ECP);
	if (soap_out_vin__ECP(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ECP(struct soap *soap, const char *tag, int id, const struct vin__ECP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ECP), type))
		return soap->error;
	if (soap_out_string(soap, "account", -1, &a->account, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__HashType(soap, "hashType", -1, &a->hashType, "vin:HashType"))
		return soap->error;
	if (soap_out_string(soap, "accountHash", -1, &a->accountHash, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "routingNumber", -1, &a->routingNumber, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__AccountType(soap, "accountType", -1, &a->accountType, "vin:AccountType"))
		return soap->error;
	if (soap_out_string(soap, "lastDigits", -1, &a->lastDigits, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToint(soap, "accountLength", -1, &a->accountLength, "xsd:int"))
		return soap->error;
	if (soap_out_PointerTovin__ECPTransactionType(soap, "allowedTransactionType", -1, &a->allowedTransactionType, "vin:ECPTransactionType"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__ECP * SOAP_FMAC4 soap_get_vin__ECP(struct soap *soap, struct vin__ECP *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ECP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ECP * SOAP_FMAC4 soap_in_vin__ECP(struct soap *soap, const char *tag, struct vin__ECP *a, const char *type)
{
	size_t soap_flag_account = 1;
	size_t soap_flag_hashType = 1;
	size_t soap_flag_accountHash = 1;
	size_t soap_flag_routingNumber = 1;
	size_t soap_flag_accountType = 1;
	size_t soap_flag_lastDigits = 1;
	size_t soap_flag_accountLength = 1;
	size_t soap_flag_allowedTransactionType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__ECP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ECP, sizeof(struct vin__ECP), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__ECP(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "account", &a->account, "xsd:string"))
				{	soap_flag_account--;
					continue;
				}
			if (soap_flag_hashType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__HashType(soap, "hashType", &a->hashType, "vin:HashType"))
				{	soap_flag_hashType--;
					continue;
				}
			if (soap_flag_accountHash && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "accountHash", &a->accountHash, "xsd:string"))
				{	soap_flag_accountHash--;
					continue;
				}
			if (soap_flag_routingNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "routingNumber", &a->routingNumber, "xsd:string"))
				{	soap_flag_routingNumber--;
					continue;
				}
			if (soap_flag_accountType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__AccountType(soap, "accountType", &a->accountType, "vin:AccountType"))
				{	soap_flag_accountType--;
					continue;
				}
			if (soap_flag_lastDigits && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastDigits", &a->lastDigits, "xsd:string"))
				{	soap_flag_lastDigits--;
					continue;
				}
			if (soap_flag_accountLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "accountLength", &a->accountLength, "xsd:int"))
				{	soap_flag_accountLength--;
					continue;
				}
			if (soap_flag_allowedTransactionType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__ECPTransactionType(soap, "allowedTransactionType", &a->allowedTransactionType, "vin:ECPTransactionType"))
				{	soap_flag_allowedTransactionType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__ECP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ECP, 0, sizeof(struct vin__ECP), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__CreditCard(struct soap *soap, struct vin__CreditCard *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->account);
	soap_default_string(soap, &a->bin);
	soap_default_string(soap, &a->lastDigits);
	a->accountLength = NULL;
	a->hashType = NULL;
	soap_default_string(soap, &a->accountHash);
	soap_default_string(soap, &a->expirationDate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__CreditCard(struct soap *soap, const struct vin__CreditCard *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->account);
	soap_serialize_string(soap, &a->bin);
	soap_serialize_string(soap, &a->lastDigits);
	soap_serialize_PointerToint(soap, &a->accountLength);
	soap_serialize_PointerTovin__HashType(soap, &a->hashType);
	soap_serialize_string(soap, &a->accountHash);
	soap_serialize_string(soap, &a->expirationDate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__CreditCard(struct soap *soap, const struct vin__CreditCard *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__CreditCard);
	if (soap_out_vin__CreditCard(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__CreditCard(struct soap *soap, const char *tag, int id, const struct vin__CreditCard *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__CreditCard), type))
		return soap->error;
	if (soap_out_string(soap, "account", -1, &a->account, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "bin", -1, &a->bin, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "lastDigits", -1, &a->lastDigits, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToint(soap, "accountLength", -1, &a->accountLength, "xsd:int"))
		return soap->error;
	if (soap_out_PointerTovin__HashType(soap, "hashType", -1, &a->hashType, "vin:HashType"))
		return soap->error;
	if (soap_out_string(soap, "accountHash", -1, &a->accountHash, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "expirationDate", -1, &a->expirationDate, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__CreditCard * SOAP_FMAC4 soap_get_vin__CreditCard(struct soap *soap, struct vin__CreditCard *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__CreditCard(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__CreditCard * SOAP_FMAC4 soap_in_vin__CreditCard(struct soap *soap, const char *tag, struct vin__CreditCard *a, const char *type)
{
	size_t soap_flag_account = 1;
	size_t soap_flag_bin = 1;
	size_t soap_flag_lastDigits = 1;
	size_t soap_flag_accountLength = 1;
	size_t soap_flag_hashType = 1;
	size_t soap_flag_accountHash = 1;
	size_t soap_flag_expirationDate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__CreditCard *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__CreditCard, sizeof(struct vin__CreditCard), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__CreditCard(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_account && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "account", &a->account, "xsd:string"))
				{	soap_flag_account--;
					continue;
				}
			if (soap_flag_bin && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bin", &a->bin, "xsd:string"))
				{	soap_flag_bin--;
					continue;
				}
			if (soap_flag_lastDigits && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastDigits", &a->lastDigits, "xsd:string"))
				{	soap_flag_lastDigits--;
					continue;
				}
			if (soap_flag_accountLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "accountLength", &a->accountLength, "xsd:int"))
				{	soap_flag_accountLength--;
					continue;
				}
			if (soap_flag_hashType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__HashType(soap, "hashType", &a->hashType, "vin:HashType"))
				{	soap_flag_hashType--;
					continue;
				}
			if (soap_flag_accountHash && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "accountHash", &a->accountHash, "xsd:string"))
				{	soap_flag_accountHash--;
					continue;
				}
			if (soap_flag_expirationDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "expirationDate", &a->expirationDate, "xsd:string"))
				{	soap_flag_expirationDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__CreditCard *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__CreditCard, 0, sizeof(struct vin__CreditCard), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__MetricStatistics(struct soap *soap, struct vin__MetricStatistics *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_vin__MetricStatusType(soap, &a->type);
	soap_default_int(soap, &a->numTransactions);
	soap_default_LONG64(soap, &a->minMs);
	soap_default_LONG64(soap, &a->avgMs);
	soap_default_LONG64(soap, &a->maxMs);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__MetricStatistics(struct soap *soap, const struct vin__MetricStatistics *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->numTransactions, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__MetricStatistics(struct soap *soap, const struct vin__MetricStatistics *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__MetricStatistics);
	if (soap_out_vin__MetricStatistics(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__MetricStatistics(struct soap *soap, const char *tag, int id, const struct vin__MetricStatistics *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__MetricStatistics), type))
		return soap->error;
	if (soap_out_vin__MetricStatusType(soap, "type", -1, &a->type, "vin:MetricStatusType"))
		return soap->error;
	if (soap_out_int(soap, "numTransactions", -1, &a->numTransactions, "xsd:int"))
		return soap->error;
	if (soap_out_LONG64(soap, "minMs", -1, &a->minMs, "xsd:long"))
		return soap->error;
	if (soap_out_LONG64(soap, "avgMs", -1, &a->avgMs, "xsd:long"))
		return soap->error;
	if (soap_out_LONG64(soap, "maxMs", -1, &a->maxMs, "xsd:long"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__MetricStatistics * SOAP_FMAC4 soap_get_vin__MetricStatistics(struct soap *soap, struct vin__MetricStatistics *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__MetricStatistics(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__MetricStatistics * SOAP_FMAC4 soap_in_vin__MetricStatistics(struct soap *soap, const char *tag, struct vin__MetricStatistics *a, const char *type)
{
	size_t soap_flag_type = 1;
	size_t soap_flag_numTransactions = 1;
	size_t soap_flag_minMs = 1;
	size_t soap_flag_avgMs = 1;
	size_t soap_flag_maxMs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__MetricStatistics *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__MetricStatistics, sizeof(struct vin__MetricStatistics), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__MetricStatistics(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_vin__MetricStatusType(soap, "type", &a->type, "vin:MetricStatusType"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_numTransactions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "numTransactions", &a->numTransactions, "xsd:int"))
				{	soap_flag_numTransactions--;
					continue;
				}
			if (soap_flag_minMs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "minMs", &a->minMs, "xsd:long"))
				{	soap_flag_minMs--;
					continue;
				}
			if (soap_flag_avgMs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "avgMs", &a->avgMs, "xsd:long"))
				{	soap_flag_avgMs--;
					continue;
				}
			if (soap_flag_maxMs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "maxMs", &a->maxMs, "xsd:long"))
				{	soap_flag_maxMs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__MetricStatistics *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__MetricStatistics, 0, sizeof(struct vin__MetricStatistics), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type > 0 || soap_flag_numTransactions > 0 || soap_flag_minMs > 0 || soap_flag_avgMs > 0 || soap_flag_maxMs > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__Entitlement(struct soap *soap, struct vin__Entitlement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->merchantEntitlementId);
	a->account = NULL;
	a->startTimestamp = NULL;
	a->endTimestamp = NULL;
	a->active = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__Entitlement(struct soap *soap, const struct vin__Entitlement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->merchantEntitlementId);
	soap_serialize_PointerTovin__Account(soap, &a->account);
	soap_serialize_PointerTotime(soap, &a->startTimestamp);
	soap_serialize_PointerTotime(soap, &a->endTimestamp);
	soap_serialize_PointerToxsd__boolean(soap, &a->active);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__Entitlement(struct soap *soap, const struct vin__Entitlement *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__Entitlement);
	if (soap_out_vin__Entitlement(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__Entitlement(struct soap *soap, const char *tag, int id, const struct vin__Entitlement *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__Entitlement), type))
		return soap->error;
	if (soap_out_string(soap, "merchantEntitlementId", -1, &a->merchantEntitlementId, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->account, "vin:Account"))
		return soap->error;
	if (soap_out_PointerTotime(soap, "startTimestamp", -1, &a->startTimestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endTimestamp", -1, &a->endTimestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "active", -1, &a->active, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__Entitlement * SOAP_FMAC4 soap_get_vin__Entitlement(struct soap *soap, struct vin__Entitlement *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__Entitlement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Entitlement * SOAP_FMAC4 soap_in_vin__Entitlement(struct soap *soap, const char *tag, struct vin__Entitlement *a, const char *type)
{
	size_t soap_flag_merchantEntitlementId = 1;
	size_t soap_flag_account = 1;
	size_t soap_flag_startTimestamp = 1;
	size_t soap_flag_endTimestamp = 1;
	size_t soap_flag_active = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__Entitlement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__Entitlement, sizeof(struct vin__Entitlement), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__Entitlement(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_merchantEntitlementId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantEntitlementId", &a->merchantEntitlementId, "xsd:string"))
				{	soap_flag_merchantEntitlementId--;
					continue;
				}
			if (soap_flag_account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, "account", &a->account, "vin:Account"))
				{	soap_flag_account--;
					continue;
				}
			if (soap_flag_startTimestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startTimestamp", &a->startTimestamp, "xsd:dateTime"))
				{	soap_flag_startTimestamp--;
					continue;
				}
			if (soap_flag_endTimestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endTimestamp", &a->endTimestamp, "xsd:dateTime"))
				{	soap_flag_endTimestamp--;
					continue;
				}
			if (soap_flag_active && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "active", &a->active, "xsd:boolean"))
				{	soap_flag_active--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__Entitlement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__Entitlement, 0, sizeof(struct vin__Entitlement), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__EmailTemplate(struct soap *soap, struct vin__EmailTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->vid);
	a->product = NULL;
	a->templateType = NULL;
	soap_default_string(soap, &a->version);
	soap_default_string(soap, &a->from);
	soap_default_string(soap, &a->replyTo);
	soap_default_string(soap, &a->htmlMessage);
	soap_default_string(soap, &a->textMessage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__EmailTemplate(struct soap *soap, const struct vin__EmailTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->vid);
	soap_serialize_PointerTovin__Product(soap, &a->product);
	soap_serialize_PointerTovin__EmailTemplateType(soap, &a->templateType);
	soap_serialize_string(soap, &a->version);
	soap_serialize_string(soap, &a->from);
	soap_serialize_string(soap, &a->replyTo);
	soap_serialize_string(soap, &a->htmlMessage);
	soap_serialize_string(soap, &a->textMessage);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__EmailTemplate(struct soap *soap, const struct vin__EmailTemplate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__EmailTemplate);
	if (soap_out_vin__EmailTemplate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__EmailTemplate(struct soap *soap, const char *tag, int id, const struct vin__EmailTemplate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__EmailTemplate), type))
		return soap->error;
	if (soap_out_string(soap, "vid", -1, &a->vid, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__Product(soap, "product", -1, &a->product, "vin:Product"))
		return soap->error;
	if (soap_out_PointerTovin__EmailTemplateType(soap, "templateType", -1, &a->templateType, "vin:EmailTemplateType"))
		return soap->error;
	if (soap_out_string(soap, "version", -1, &a->version, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "from", -1, &a->from, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "replyTo", -1, &a->replyTo, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "htmlMessage", -1, &a->htmlMessage, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "textMessage", -1, &a->textMessage, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__EmailTemplate * SOAP_FMAC4 soap_get_vin__EmailTemplate(struct soap *soap, struct vin__EmailTemplate *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__EmailTemplate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__EmailTemplate * SOAP_FMAC4 soap_in_vin__EmailTemplate(struct soap *soap, const char *tag, struct vin__EmailTemplate *a, const char *type)
{
	size_t soap_flag_vid = 1;
	size_t soap_flag_product = 1;
	size_t soap_flag_templateType = 1;
	size_t soap_flag_version = 1;
	size_t soap_flag_from = 1;
	size_t soap_flag_replyTo = 1;
	size_t soap_flag_htmlMessage = 1;
	size_t soap_flag_textMessage = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__EmailTemplate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__EmailTemplate, sizeof(struct vin__EmailTemplate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__EmailTemplate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_vid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "vid", &a->vid, "xsd:string"))
				{	soap_flag_vid--;
					continue;
				}
			if (soap_flag_product && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Product(soap, "product", &a->product, "vin:Product"))
				{	soap_flag_product--;
					continue;
				}
			if (soap_flag_templateType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__EmailTemplateType(soap, "templateType", &a->templateType, "vin:EmailTemplateType"))
				{	soap_flag_templateType--;
					continue;
				}
			if (soap_flag_version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "version", &a->version, "xsd:string"))
				{	soap_flag_version--;
					continue;
				}
			if (soap_flag_from && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "from", &a->from, "xsd:string"))
				{	soap_flag_from--;
					continue;
				}
			if (soap_flag_replyTo && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "replyTo", &a->replyTo, "xsd:string"))
				{	soap_flag_replyTo--;
					continue;
				}
			if (soap_flag_htmlMessage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "htmlMessage", &a->htmlMessage, "xsd:string"))
				{	soap_flag_htmlMessage--;
					continue;
				}
			if (soap_flag_textMessage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "textMessage", &a->textMessage, "xsd:string"))
				{	soap_flag_textMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__EmailTemplate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__EmailTemplate, 0, sizeof(struct vin__EmailTemplate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_product > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__Transaction(struct soap *soap, struct vin__Transaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->VID);
	soap_default_xsd__decimal(soap, &a->amount);
	soap_default_string(soap, &a->currency);
	soap_default_string(soap, &a->divisionNumber);
	soap_default_string(soap, &a->merchantTransactionId);
	soap_default_string(soap, &a->previousMerchantTransactionId);
	a->timestamp = NULL;
	a->account = NULL;
	a->sourcePaymentMethod = NULL;
	a->destPaymentMethod = NULL;
	a->ecpTransactionType = NULL;
	a->statusLog = NULL;
	soap_default_string(soap, &a->paymentProcessor);
	soap_default_string(soap, &a->sourcePhoneNumber);
	a->shippingAddress = NULL;
	a->nameValues = NULL;
	a->transactionItems = NULL;
	soap_default_string(soap, &a->merchantAffiliateId);
	soap_default_string(soap, &a->merchantAffiliateSubId);
	soap_default_string(soap, &a->userAgent);
	soap_default_string(soap, &a->note);
	soap_default_string(soap, &a->preferredNotificationLanguage);
	soap_default_string(soap, &a->sourceMacAddress);
	soap_default_string(soap, &a->sourceIp);
	soap_default_string(soap, &a->billingStatementIdentifier);
	a->taxExemptions = NULL;
	a->salesTaxAddress = NULL;
	soap_default_string(soap, &a->verificationCode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__Transaction(struct soap *soap, const struct vin__Transaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->VID);
	soap_serialize_xsd__decimal(soap, &a->amount);
	soap_serialize_string(soap, &a->currency);
	soap_serialize_string(soap, &a->divisionNumber);
	soap_serialize_string(soap, &a->merchantTransactionId);
	soap_serialize_string(soap, &a->previousMerchantTransactionId);
	soap_serialize_PointerTotime(soap, &a->timestamp);
	soap_serialize_PointerTovin__Account(soap, &a->account);
	soap_serialize_PointerTovin__PaymentMethod(soap, &a->sourcePaymentMethod);
	soap_serialize_PointerTovin__PaymentMethod(soap, &a->destPaymentMethod);
	soap_serialize_PointerTovin__ECPTransactionType(soap, &a->ecpTransactionType);
	soap_serialize_PointerToArrayOfTransactionStatuses(soap, &a->statusLog);
	soap_serialize_string(soap, &a->paymentProcessor);
	soap_serialize_string(soap, &a->sourcePhoneNumber);
	soap_serialize_PointerTovin__Address(soap, &a->shippingAddress);
	soap_serialize_PointerToArrayOfNameValuePairs(soap, &a->nameValues);
	soap_serialize_PointerToArrayOfTransactionItems(soap, &a->transactionItems);
	soap_serialize_string(soap, &a->merchantAffiliateId);
	soap_serialize_string(soap, &a->merchantAffiliateSubId);
	soap_serialize_string(soap, &a->userAgent);
	soap_serialize_string(soap, &a->note);
	soap_serialize_string(soap, &a->preferredNotificationLanguage);
	soap_serialize_string(soap, &a->sourceMacAddress);
	soap_serialize_string(soap, &a->sourceIp);
	soap_serialize_string(soap, &a->billingStatementIdentifier);
	soap_serialize_PointerToArrayOfTaxExemptions(soap, &a->taxExemptions);
	soap_serialize_PointerTovin__Address(soap, &a->salesTaxAddress);
	soap_serialize_string(soap, &a->verificationCode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__Transaction(struct soap *soap, const struct vin__Transaction *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__Transaction);
	if (soap_out_vin__Transaction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__Transaction(struct soap *soap, const char *tag, int id, const struct vin__Transaction *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__Transaction), type))
		return soap->error;
	if (soap_out_string(soap, "VID", -1, &a->VID, "xsd:string"))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "amount", -1, &a->amount, "xsd:decimal"))
		return soap->error;
	if (soap_out_string(soap, "currency", -1, &a->currency, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "divisionNumber", -1, &a->divisionNumber, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "merchantTransactionId", -1, &a->merchantTransactionId, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "previousMerchantTransactionId", -1, &a->previousMerchantTransactionId, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTotime(soap, "timestamp", -1, &a->timestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->account, "vin:Account"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentMethod(soap, "sourcePaymentMethod", -1, &a->sourcePaymentMethod, "vin:PaymentMethod"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentMethod(soap, "destPaymentMethod", -1, &a->destPaymentMethod, "vin:PaymentMethod"))
		return soap->error;
	if (soap_out_PointerTovin__ECPTransactionType(soap, "ecpTransactionType", -1, &a->ecpTransactionType, "vin:ECPTransactionType"))
		return soap->error;
	if (soap_out_PointerToArrayOfTransactionStatuses(soap, "statusLog", -1, &a->statusLog, "vin:TransactionStatus"))
		return soap->error;
	if (soap_out_string(soap, "paymentProcessor", -1, &a->paymentProcessor, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "sourcePhoneNumber", -1, &a->sourcePhoneNumber, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__Address(soap, "shippingAddress", -1, &a->shippingAddress, "vin:Address"))
		return soap->error;
	if (soap_out_PointerToArrayOfNameValuePairs(soap, "nameValues", -1, &a->nameValues, "vin:NameValuePair"))
		return soap->error;
	if (soap_out_PointerToArrayOfTransactionItems(soap, "transactionItems", -1, &a->transactionItems, "vin:TransactionItem"))
		return soap->error;
	if (soap_out_string(soap, "merchantAffiliateId", -1, &a->merchantAffiliateId, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "merchantAffiliateSubId", -1, &a->merchantAffiliateSubId, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "userAgent", -1, &a->userAgent, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "note", -1, &a->note, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "preferredNotificationLanguage", -1, &a->preferredNotificationLanguage, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "sourceMacAddress", -1, &a->sourceMacAddress, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "sourceIp", -1, &a->sourceIp, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "billingStatementIdentifier", -1, &a->billingStatementIdentifier, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToArrayOfTaxExemptions(soap, "taxExemptions", -1, &a->taxExemptions, "vin:TaxExemption"))
		return soap->error;
	if (soap_out_PointerTovin__Address(soap, "salesTaxAddress", -1, &a->salesTaxAddress, "vin:Address"))
		return soap->error;
	if (soap_out_string(soap, "verificationCode", -1, &a->verificationCode, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__Transaction * SOAP_FMAC4 soap_get_vin__Transaction(struct soap *soap, struct vin__Transaction *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__Transaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Transaction * SOAP_FMAC4 soap_in_vin__Transaction(struct soap *soap, const char *tag, struct vin__Transaction *a, const char *type)
{
	size_t soap_flag_VID = 1;
	size_t soap_flag_amount = 1;
	size_t soap_flag_currency = 1;
	size_t soap_flag_divisionNumber = 1;
	size_t soap_flag_merchantTransactionId = 1;
	size_t soap_flag_previousMerchantTransactionId = 1;
	size_t soap_flag_timestamp = 1;
	size_t soap_flag_account = 1;
	size_t soap_flag_sourcePaymentMethod = 1;
	size_t soap_flag_destPaymentMethod = 1;
	size_t soap_flag_ecpTransactionType = 1;
	size_t soap_flag_statusLog = 1;
	size_t soap_flag_paymentProcessor = 1;
	size_t soap_flag_sourcePhoneNumber = 1;
	size_t soap_flag_shippingAddress = 1;
	size_t soap_flag_nameValues = 1;
	size_t soap_flag_transactionItems = 1;
	size_t soap_flag_merchantAffiliateId = 1;
	size_t soap_flag_merchantAffiliateSubId = 1;
	size_t soap_flag_userAgent = 1;
	size_t soap_flag_note = 1;
	size_t soap_flag_preferredNotificationLanguage = 1;
	size_t soap_flag_sourceMacAddress = 1;
	size_t soap_flag_sourceIp = 1;
	size_t soap_flag_billingStatementIdentifier = 1;
	size_t soap_flag_taxExemptions = 1;
	size_t soap_flag_salesTaxAddress = 1;
	size_t soap_flag_verificationCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__Transaction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__Transaction, sizeof(struct vin__Transaction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__Transaction(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "VID", &a->VID, "xsd:string"))
				{	soap_flag_VID--;
					continue;
				}
			if (soap_flag_amount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "amount", &a->amount, "xsd:decimal"))
				{	soap_flag_amount--;
					continue;
				}
			if (soap_flag_currency && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "currency", &a->currency, "xsd:string"))
				{	soap_flag_currency--;
					continue;
				}
			if (soap_flag_divisionNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "divisionNumber", &a->divisionNumber, "xsd:string"))
				{	soap_flag_divisionNumber--;
					continue;
				}
			if (soap_flag_merchantTransactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantTransactionId", &a->merchantTransactionId, "xsd:string"))
				{	soap_flag_merchantTransactionId--;
					continue;
				}
			if (soap_flag_previousMerchantTransactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "previousMerchantTransactionId", &a->previousMerchantTransactionId, "xsd:string"))
				{	soap_flag_previousMerchantTransactionId--;
					continue;
				}
			if (soap_flag_timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "timestamp", &a->timestamp, "xsd:dateTime"))
				{	soap_flag_timestamp--;
					continue;
				}
			if (soap_flag_account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, "account", &a->account, "vin:Account"))
				{	soap_flag_account--;
					continue;
				}
			if (soap_flag_sourcePaymentMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentMethod(soap, "sourcePaymentMethod", &a->sourcePaymentMethod, "vin:PaymentMethod"))
				{	soap_flag_sourcePaymentMethod--;
					continue;
				}
			if (soap_flag_destPaymentMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentMethod(soap, "destPaymentMethod", &a->destPaymentMethod, "vin:PaymentMethod"))
				{	soap_flag_destPaymentMethod--;
					continue;
				}
			if (soap_flag_ecpTransactionType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__ECPTransactionType(soap, "ecpTransactionType", &a->ecpTransactionType, "vin:ECPTransactionType"))
				{	soap_flag_ecpTransactionType--;
					continue;
				}
			if (soap_flag_statusLog && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTransactionStatuses(soap, "statusLog", &a->statusLog, "vin:TransactionStatus"))
				{	soap_flag_statusLog--;
					continue;
				}
			if (soap_flag_paymentProcessor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "paymentProcessor", &a->paymentProcessor, "xsd:string"))
				{	soap_flag_paymentProcessor--;
					continue;
				}
			if (soap_flag_sourcePhoneNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sourcePhoneNumber", &a->sourcePhoneNumber, "xsd:string"))
				{	soap_flag_sourcePhoneNumber--;
					continue;
				}
			if (soap_flag_shippingAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Address(soap, "shippingAddress", &a->shippingAddress, "vin:Address"))
				{	soap_flag_shippingAddress--;
					continue;
				}
			if (soap_flag_nameValues && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfNameValuePairs(soap, "nameValues", &a->nameValues, "vin:NameValuePair"))
				{	soap_flag_nameValues--;
					continue;
				}
			if (soap_flag_transactionItems && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTransactionItems(soap, "transactionItems", &a->transactionItems, "vin:TransactionItem"))
				{	soap_flag_transactionItems--;
					continue;
				}
			if (soap_flag_merchantAffiliateId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantAffiliateId", &a->merchantAffiliateId, "xsd:string"))
				{	soap_flag_merchantAffiliateId--;
					continue;
				}
			if (soap_flag_merchantAffiliateSubId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantAffiliateSubId", &a->merchantAffiliateSubId, "xsd:string"))
				{	soap_flag_merchantAffiliateSubId--;
					continue;
				}
			if (soap_flag_userAgent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userAgent", &a->userAgent, "xsd:string"))
				{	soap_flag_userAgent--;
					continue;
				}
			if (soap_flag_note && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "note", &a->note, "xsd:string"))
				{	soap_flag_note--;
					continue;
				}
			if (soap_flag_preferredNotificationLanguage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "preferredNotificationLanguage", &a->preferredNotificationLanguage, "xsd:string"))
				{	soap_flag_preferredNotificationLanguage--;
					continue;
				}
			if (soap_flag_sourceMacAddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sourceMacAddress", &a->sourceMacAddress, "xsd:string"))
				{	soap_flag_sourceMacAddress--;
					continue;
				}
			if (soap_flag_sourceIp && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sourceIp", &a->sourceIp, "xsd:string"))
				{	soap_flag_sourceIp--;
					continue;
				}
			if (soap_flag_billingStatementIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "billingStatementIdentifier", &a->billingStatementIdentifier, "xsd:string"))
				{	soap_flag_billingStatementIdentifier--;
					continue;
				}
			if (soap_flag_taxExemptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTaxExemptions(soap, "taxExemptions", &a->taxExemptions, "vin:TaxExemption"))
				{	soap_flag_taxExemptions--;
					continue;
				}
			if (soap_flag_salesTaxAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Address(soap, "salesTaxAddress", &a->salesTaxAddress, "vin:Address"))
				{	soap_flag_salesTaxAddress--;
					continue;
				}
			if (soap_flag_verificationCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "verificationCode", &a->verificationCode, "xsd:string"))
				{	soap_flag_verificationCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__Transaction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__Transaction, 0, sizeof(struct vin__Transaction), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ElectronicSignature(struct soap *soap, struct vin__ElectronicSignature *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->VID);
	soap_default_xsd__anyURI(soap, &a->uri);
	soap_default_string(soap, &a->sourceIp);
	soap_default_time(soap, &a->timestamp);
	a->account = NULL;
	a->transaction = NULL;
	soap_default_string(soap, &a->description);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__ElectronicSignature(struct soap *soap, const struct vin__ElectronicSignature *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->VID);
	soap_serialize_xsd__anyURI(soap, &a->uri);
	soap_serialize_string(soap, &a->sourceIp);
	soap_embedded(soap, &a->timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTovin__Account(soap, &a->account);
	soap_serialize_PointerTovin__Transaction(soap, &a->transaction);
	soap_serialize_string(soap, &a->description);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ElectronicSignature(struct soap *soap, const struct vin__ElectronicSignature *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ElectronicSignature);
	if (soap_out_vin__ElectronicSignature(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ElectronicSignature(struct soap *soap, const char *tag, int id, const struct vin__ElectronicSignature *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ElectronicSignature), type))
		return soap->error;
	if (soap_out_string(soap, "VID", -1, &a->VID, "xsd:string"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "uri", -1, &a->uri, "xsd:anyURI"))
		return soap->error;
	if (soap_out_string(soap, "sourceIp", -1, &a->sourceIp, "xsd:string"))
		return soap->error;
	if (soap_out_time(soap, "timestamp", -1, &a->timestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->account, "vin:Account"))
		return soap->error;
	if (soap_out_PointerTovin__Transaction(soap, "transaction", -1, &a->transaction, "vin:Transaction"))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__ElectronicSignature * SOAP_FMAC4 soap_get_vin__ElectronicSignature(struct soap *soap, struct vin__ElectronicSignature *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ElectronicSignature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ElectronicSignature * SOAP_FMAC4 soap_in_vin__ElectronicSignature(struct soap *soap, const char *tag, struct vin__ElectronicSignature *a, const char *type)
{
	size_t soap_flag_VID = 1;
	size_t soap_flag_uri = 1;
	size_t soap_flag_sourceIp = 1;
	size_t soap_flag_timestamp = 1;
	size_t soap_flag_account = 1;
	size_t soap_flag_transaction = 1;
	size_t soap_flag_description = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__ElectronicSignature *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ElectronicSignature, sizeof(struct vin__ElectronicSignature), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__ElectronicSignature(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "VID", &a->VID, "xsd:string"))
				{	soap_flag_VID--;
					continue;
				}
			if (soap_flag_uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "uri", &a->uri, "xsd:anyURI"))
				{	soap_flag_uri--;
					continue;
				}
			if (soap_flag_sourceIp && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sourceIp", &a->sourceIp, "xsd:string"))
				{	soap_flag_sourceIp--;
					continue;
				}
			if (soap_flag_timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "timestamp", &a->timestamp, "xsd:dateTime"))
				{	soap_flag_timestamp--;
					continue;
				}
			if (soap_flag_account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, "account", &a->account, "vin:Account"))
				{	soap_flag_account--;
					continue;
				}
			if (soap_flag_transaction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Transaction(soap, "transaction", &a->transaction, "vin:Transaction"))
				{	soap_flag_transaction--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__ElectronicSignature *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ElectronicSignature, 0, sizeof(struct vin__ElectronicSignature), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uri > 0 || soap_flag_timestamp > 0 || soap_flag_account > 0 || soap_flag_transaction > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__Chargeback(struct soap *soap, struct vin__Chargeback *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->VID);
	soap_default_xsd__decimal(soap, &a->amount);
	soap_default_string(soap, &a->currency);
	soap_default_xsd__decimal(soap, &a->presentmentAmount);
	soap_default_string(soap, &a->presentmentCurrency);
	soap_default_string(soap, &a->divisionNumber);
	soap_default_string(soap, &a->reasonCode);
	soap_default_string(soap, &a->caseNumber);
	soap_default_string(soap, &a->referenceNumber);
	soap_default_string(soap, &a->merchantNumber);
	soap_default_string(soap, &a->merchantTransactionId);
	a->merchantTransactionTimestamp = NULL;
	soap_default_time(soap, &a->processorReceivedTimestamp);
	soap_default_time(soap, &a->postedTimestamp);
	a->statusChangedTimestamp = NULL;
	soap_default_vin__ChargebackStatus(soap, &a->status);
	soap_default_string(soap, &a->merchantUserId);
	soap_default_string(soap, &a->note);
	a->nameValues = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__Chargeback(struct soap *soap, const struct vin__Chargeback *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->VID);
	soap_serialize_xsd__decimal(soap, &a->amount);
	soap_serialize_string(soap, &a->currency);
	soap_serialize_xsd__decimal(soap, &a->presentmentAmount);
	soap_serialize_string(soap, &a->presentmentCurrency);
	soap_serialize_string(soap, &a->divisionNumber);
	soap_serialize_string(soap, &a->reasonCode);
	soap_serialize_string(soap, &a->caseNumber);
	soap_serialize_string(soap, &a->referenceNumber);
	soap_serialize_string(soap, &a->merchantNumber);
	soap_serialize_string(soap, &a->merchantTransactionId);
	soap_serialize_PointerTotime(soap, &a->merchantTransactionTimestamp);
	soap_embedded(soap, &a->processorReceivedTimestamp, SOAP_TYPE_time);
	soap_embedded(soap, &a->postedTimestamp, SOAP_TYPE_time);
	soap_serialize_PointerTotime(soap, &a->statusChangedTimestamp);
	soap_serialize_string(soap, &a->merchantUserId);
	soap_serialize_string(soap, &a->note);
	soap_serialize_PointerToArrayOfNameValuePairs(soap, &a->nameValues);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__Chargeback(struct soap *soap, const struct vin__Chargeback *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__Chargeback);
	if (soap_out_vin__Chargeback(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__Chargeback(struct soap *soap, const char *tag, int id, const struct vin__Chargeback *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__Chargeback), type))
		return soap->error;
	if (soap_out_string(soap, "VID", -1, &a->VID, "xsd:string"))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "amount", -1, &a->amount, "xsd:decimal"))
		return soap->error;
	if (soap_out_string(soap, "currency", -1, &a->currency, "xsd:string"))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "presentmentAmount", -1, &a->presentmentAmount, "xsd:decimal"))
		return soap->error;
	if (soap_out_string(soap, "presentmentCurrency", -1, &a->presentmentCurrency, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "divisionNumber", -1, &a->divisionNumber, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "reasonCode", -1, &a->reasonCode, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "caseNumber", -1, &a->caseNumber, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "referenceNumber", -1, &a->referenceNumber, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "merchantNumber", -1, &a->merchantNumber, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "merchantTransactionId", -1, &a->merchantTransactionId, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTotime(soap, "merchantTransactionTimestamp", -1, &a->merchantTransactionTimestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_time(soap, "processorReceivedTimestamp", -1, &a->processorReceivedTimestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_time(soap, "postedTimestamp", -1, &a->postedTimestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_PointerTotime(soap, "statusChangedTimestamp", -1, &a->statusChangedTimestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_vin__ChargebackStatus(soap, "status", -1, &a->status, "vin:ChargebackStatus"))
		return soap->error;
	if (soap_out_string(soap, "merchantUserId", -1, &a->merchantUserId, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "note", -1, &a->note, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToArrayOfNameValuePairs(soap, "nameValues", -1, &a->nameValues, "vin:NameValuePair"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__Chargeback * SOAP_FMAC4 soap_get_vin__Chargeback(struct soap *soap, struct vin__Chargeback *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__Chargeback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Chargeback * SOAP_FMAC4 soap_in_vin__Chargeback(struct soap *soap, const char *tag, struct vin__Chargeback *a, const char *type)
{
	size_t soap_flag_VID = 1;
	size_t soap_flag_amount = 1;
	size_t soap_flag_currency = 1;
	size_t soap_flag_presentmentAmount = 1;
	size_t soap_flag_presentmentCurrency = 1;
	size_t soap_flag_divisionNumber = 1;
	size_t soap_flag_reasonCode = 1;
	size_t soap_flag_caseNumber = 1;
	size_t soap_flag_referenceNumber = 1;
	size_t soap_flag_merchantNumber = 1;
	size_t soap_flag_merchantTransactionId = 1;
	size_t soap_flag_merchantTransactionTimestamp = 1;
	size_t soap_flag_processorReceivedTimestamp = 1;
	size_t soap_flag_postedTimestamp = 1;
	size_t soap_flag_statusChangedTimestamp = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_merchantUserId = 1;
	size_t soap_flag_note = 1;
	size_t soap_flag_nameValues = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__Chargeback *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__Chargeback, sizeof(struct vin__Chargeback), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__Chargeback(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "VID", &a->VID, "xsd:string"))
				{	soap_flag_VID--;
					continue;
				}
			if (soap_flag_amount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "amount", &a->amount, "xsd:decimal"))
				{	soap_flag_amount--;
					continue;
				}
			if (soap_flag_currency && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "currency", &a->currency, "xsd:string"))
				{	soap_flag_currency--;
					continue;
				}
			if (soap_flag_presentmentAmount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "presentmentAmount", &a->presentmentAmount, "xsd:decimal"))
				{	soap_flag_presentmentAmount--;
					continue;
				}
			if (soap_flag_presentmentCurrency && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "presentmentCurrency", &a->presentmentCurrency, "xsd:string"))
				{	soap_flag_presentmentCurrency--;
					continue;
				}
			if (soap_flag_divisionNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "divisionNumber", &a->divisionNumber, "xsd:string"))
				{	soap_flag_divisionNumber--;
					continue;
				}
			if (soap_flag_reasonCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "reasonCode", &a->reasonCode, "xsd:string"))
				{	soap_flag_reasonCode--;
					continue;
				}
			if (soap_flag_caseNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "caseNumber", &a->caseNumber, "xsd:string"))
				{	soap_flag_caseNumber--;
					continue;
				}
			if (soap_flag_referenceNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "referenceNumber", &a->referenceNumber, "xsd:string"))
				{	soap_flag_referenceNumber--;
					continue;
				}
			if (soap_flag_merchantNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantNumber", &a->merchantNumber, "xsd:string"))
				{	soap_flag_merchantNumber--;
					continue;
				}
			if (soap_flag_merchantTransactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantTransactionId", &a->merchantTransactionId, "xsd:string"))
				{	soap_flag_merchantTransactionId--;
					continue;
				}
			if (soap_flag_merchantTransactionTimestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "merchantTransactionTimestamp", &a->merchantTransactionTimestamp, "xsd:dateTime"))
				{	soap_flag_merchantTransactionTimestamp--;
					continue;
				}
			if (soap_flag_processorReceivedTimestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "processorReceivedTimestamp", &a->processorReceivedTimestamp, "xsd:dateTime"))
				{	soap_flag_processorReceivedTimestamp--;
					continue;
				}
			if (soap_flag_postedTimestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "postedTimestamp", &a->postedTimestamp, "xsd:dateTime"))
				{	soap_flag_postedTimestamp--;
					continue;
				}
			if (soap_flag_statusChangedTimestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "statusChangedTimestamp", &a->statusChangedTimestamp, "xsd:dateTime"))
				{	soap_flag_statusChangedTimestamp--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_vin__ChargebackStatus(soap, "status", &a->status, "vin:ChargebackStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_merchantUserId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantUserId", &a->merchantUserId, "xsd:string"))
				{	soap_flag_merchantUserId--;
					continue;
				}
			if (soap_flag_note && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "note", &a->note, "xsd:string"))
				{	soap_flag_note--;
					continue;
				}
			if (soap_flag_nameValues && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfNameValuePairs(soap, "nameValues", &a->nameValues, "vin:NameValuePair"))
				{	soap_flag_nameValues--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__Chargeback *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__Chargeback, 0, sizeof(struct vin__Chargeback), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_amount > 0 || soap_flag_reasonCode > 0 || soap_flag_processorReceivedTimestamp > 0 || soap_flag_postedTimestamp > 0 || soap_flag_status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfMerchantEntitlementIds(struct soap *soap, struct ArrayOfMerchantEntitlementIds *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfMerchantEntitlementIds(struct soap *soap, struct ArrayOfMerchantEntitlementIds const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfMerchantEntitlementIds))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__MerchantEntitlementId(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfMerchantEntitlementIds(struct soap *soap, const struct ArrayOfMerchantEntitlementIds *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfMerchantEntitlementIds);
	if (soap_out_ArrayOfMerchantEntitlementIds(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfMerchantEntitlementIds(struct soap *soap, const char *tag, int id, const struct ArrayOfMerchantEntitlementIds *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:MerchantEntitlementId", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfMerchantEntitlementIds);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__MerchantEntitlementId(soap, "item", -1, &a->__ptr[i], "vin:MerchantEntitlementId");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfMerchantEntitlementIds * SOAP_FMAC4 soap_get_ArrayOfMerchantEntitlementIds(struct soap *soap, struct ArrayOfMerchantEntitlementIds *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfMerchantEntitlementIds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfMerchantEntitlementIds * SOAP_FMAC4 soap_in_ArrayOfMerchantEntitlementIds(struct soap *soap, const char *tag, struct ArrayOfMerchantEntitlementIds *a, const char *type)
{	int i, j;
	struct vin__MerchantEntitlementId **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfMerchantEntitlementIds *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfMerchantEntitlementIds, sizeof(struct ArrayOfMerchantEntitlementIds), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfMerchantEntitlementIds(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__MerchantEntitlementId **)soap_malloc(soap, sizeof(struct vin__MerchantEntitlementId *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__MerchantEntitlementId(soap, NULL, a->__ptr + i, "vin:MerchantEntitlementId"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__MerchantEntitlementId **)soap_push_block(soap, NULL, sizeof(struct vin__MerchantEntitlementId *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__MerchantEntitlementId(soap, NULL, p, "vin:MerchantEntitlementId"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__MerchantEntitlementId **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfMerchantEntitlementIds *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfMerchantEntitlementIds, 0, sizeof(struct ArrayOfMerchantEntitlementIds), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfBillingPlanPeriods(struct soap *soap, struct ArrayOfBillingPlanPeriods *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfBillingPlanPeriods(struct soap *soap, struct ArrayOfBillingPlanPeriods const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfBillingPlanPeriods))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__BillingPlanPeriod(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfBillingPlanPeriods(struct soap *soap, const struct ArrayOfBillingPlanPeriods *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfBillingPlanPeriods);
	if (soap_out_ArrayOfBillingPlanPeriods(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfBillingPlanPeriods(struct soap *soap, const char *tag, int id, const struct ArrayOfBillingPlanPeriods *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:BillingPlanPeriod", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfBillingPlanPeriods);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__BillingPlanPeriod(soap, "item", -1, &a->__ptr[i], "vin:BillingPlanPeriod");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfBillingPlanPeriods * SOAP_FMAC4 soap_get_ArrayOfBillingPlanPeriods(struct soap *soap, struct ArrayOfBillingPlanPeriods *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfBillingPlanPeriods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfBillingPlanPeriods * SOAP_FMAC4 soap_in_ArrayOfBillingPlanPeriods(struct soap *soap, const char *tag, struct ArrayOfBillingPlanPeriods *a, const char *type)
{	int i, j;
	struct vin__BillingPlanPeriod **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfBillingPlanPeriods *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfBillingPlanPeriods, sizeof(struct ArrayOfBillingPlanPeriods), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfBillingPlanPeriods(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__BillingPlanPeriod **)soap_malloc(soap, sizeof(struct vin__BillingPlanPeriod *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__BillingPlanPeriod(soap, NULL, a->__ptr + i, "vin:BillingPlanPeriod"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__BillingPlanPeriod **)soap_push_block(soap, NULL, sizeof(struct vin__BillingPlanPeriod *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__BillingPlanPeriod(soap, NULL, p, "vin:BillingPlanPeriod"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__BillingPlanPeriod **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfBillingPlanPeriods *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfBillingPlanPeriods, 0, sizeof(struct ArrayOfBillingPlanPeriods), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfBillingPlanPrices(struct soap *soap, struct ArrayOfBillingPlanPrices *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfBillingPlanPrices(struct soap *soap, struct ArrayOfBillingPlanPrices const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfBillingPlanPrices))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__BillingPlanPrice(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfBillingPlanPrices(struct soap *soap, const struct ArrayOfBillingPlanPrices *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfBillingPlanPrices);
	if (soap_out_ArrayOfBillingPlanPrices(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfBillingPlanPrices(struct soap *soap, const char *tag, int id, const struct ArrayOfBillingPlanPrices *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:BillingPlanPrice", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfBillingPlanPrices);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__BillingPlanPrice(soap, "item", -1, &a->__ptr[i], "vin:BillingPlanPrice");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfBillingPlanPrices * SOAP_FMAC4 soap_get_ArrayOfBillingPlanPrices(struct soap *soap, struct ArrayOfBillingPlanPrices *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfBillingPlanPrices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfBillingPlanPrices * SOAP_FMAC4 soap_in_ArrayOfBillingPlanPrices(struct soap *soap, const char *tag, struct ArrayOfBillingPlanPrices *a, const char *type)
{	int i, j;
	struct vin__BillingPlanPrice **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfBillingPlanPrices *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfBillingPlanPrices, sizeof(struct ArrayOfBillingPlanPrices), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfBillingPlanPrices(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__BillingPlanPrice **)soap_malloc(soap, sizeof(struct vin__BillingPlanPrice *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__BillingPlanPrice(soap, NULL, a->__ptr + i, "vin:BillingPlanPrice"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__BillingPlanPrice **)soap_push_block(soap, NULL, sizeof(struct vin__BillingPlanPrice *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__BillingPlanPrice(soap, NULL, p, "vin:BillingPlanPrice"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__BillingPlanPrice **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfBillingPlanPrices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfBillingPlanPrices, 0, sizeof(struct ArrayOfBillingPlanPrices), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__BillingPlanPeriod(struct soap *soap, struct vin__BillingPlanPeriod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->type = NULL;
	a->quantity = NULL;
	a->cycles = NULL;
	a->prices = NULL;
	a->expireWarningDays = NULL;
	a->doNotNotifyFirstBill = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__BillingPlanPeriod(struct soap *soap, const struct vin__BillingPlanPeriod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__BillingPeriodType(soap, &a->type);
	soap_serialize_PointerToint(soap, &a->quantity);
	soap_serialize_PointerToint(soap, &a->cycles);
	soap_serialize_PointerToArrayOfBillingPlanPrices(soap, &a->prices);
	soap_serialize_PointerToint(soap, &a->expireWarningDays);
	soap_serialize_PointerToxsd__boolean(soap, &a->doNotNotifyFirstBill);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__BillingPlanPeriod(struct soap *soap, const struct vin__BillingPlanPeriod *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__BillingPlanPeriod);
	if (soap_out_vin__BillingPlanPeriod(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__BillingPlanPeriod(struct soap *soap, const char *tag, int id, const struct vin__BillingPlanPeriod *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__BillingPlanPeriod), type))
		return soap->error;
	if (soap_out_PointerTovin__BillingPeriodType(soap, "type", -1, &a->type, "vin:BillingPeriodType"))
		return soap->error;
	if (soap_out_PointerToint(soap, "quantity", -1, &a->quantity, "xsd:int"))
		return soap->error;
	if (soap_out_PointerToint(soap, "cycles", -1, &a->cycles, "xsd:int"))
		return soap->error;
	if (soap_out_PointerToArrayOfBillingPlanPrices(soap, "prices", -1, &a->prices, "vin:BillingPlanPrice"))
		return soap->error;
	if (soap_out_PointerToint(soap, "expireWarningDays", -1, &a->expireWarningDays, "xsd:int"))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "doNotNotifyFirstBill", -1, &a->doNotNotifyFirstBill, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__BillingPlanPeriod * SOAP_FMAC4 soap_get_vin__BillingPlanPeriod(struct soap *soap, struct vin__BillingPlanPeriod *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__BillingPlanPeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__BillingPlanPeriod * SOAP_FMAC4 soap_in_vin__BillingPlanPeriod(struct soap *soap, const char *tag, struct vin__BillingPlanPeriod *a, const char *type)
{
	size_t soap_flag_type = 1;
	size_t soap_flag_quantity = 1;
	size_t soap_flag_cycles = 1;
	size_t soap_flag_prices = 1;
	size_t soap_flag_expireWarningDays = 1;
	size_t soap_flag_doNotNotifyFirstBill = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__BillingPlanPeriod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__BillingPlanPeriod, sizeof(struct vin__BillingPlanPeriod), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__BillingPlanPeriod(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__BillingPeriodType(soap, "type", &a->type, "vin:BillingPeriodType"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_quantity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "quantity", &a->quantity, "xsd:int"))
				{	soap_flag_quantity--;
					continue;
				}
			if (soap_flag_cycles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "cycles", &a->cycles, "xsd:int"))
				{	soap_flag_cycles--;
					continue;
				}
			if (soap_flag_prices && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfBillingPlanPrices(soap, "prices", &a->prices, "vin:BillingPlanPrice"))
				{	soap_flag_prices--;
					continue;
				}
			if (soap_flag_expireWarningDays && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "expireWarningDays", &a->expireWarningDays, "xsd:int"))
				{	soap_flag_expireWarningDays--;
					continue;
				}
			if (soap_flag_doNotNotifyFirstBill && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "doNotNotifyFirstBill", &a->doNotNotifyFirstBill, "xsd:boolean"))
				{	soap_flag_doNotNotifyFirstBill--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__BillingPlanPeriod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__BillingPlanPeriod, 0, sizeof(struct vin__BillingPlanPeriod), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__TokenAmount(struct soap *soap, struct vin__TokenAmount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->token = NULL;
	soap_default_int(soap, &a->amount);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__TokenAmount(struct soap *soap, const struct vin__TokenAmount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Token(soap, &a->token);
	soap_embedded(soap, &a->amount, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__TokenAmount(struct soap *soap, const struct vin__TokenAmount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__TokenAmount);
	if (soap_out_vin__TokenAmount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__TokenAmount(struct soap *soap, const char *tag, int id, const struct vin__TokenAmount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__TokenAmount), type))
		return soap->error;
	if (soap_out_PointerTovin__Token(soap, "token", -1, &a->token, "vin:Token"))
		return soap->error;
	if (soap_out_int(soap, "amount", -1, &a->amount, "xsd:int"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__TokenAmount * SOAP_FMAC4 soap_get_vin__TokenAmount(struct soap *soap, struct vin__TokenAmount *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__TokenAmount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TokenAmount * SOAP_FMAC4 soap_in_vin__TokenAmount(struct soap *soap, const char *tag, struct vin__TokenAmount *a, const char *type)
{
	size_t soap_flag_token = 1;
	size_t soap_flag_amount = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__TokenAmount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__TokenAmount, sizeof(struct vin__TokenAmount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__TokenAmount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Token(soap, "token", &a->token, "vin:Token"))
				{	soap_flag_token--;
					continue;
				}
			if (soap_flag_amount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "amount", &a->amount, "xsd:int"))
				{	soap_flag_amount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__TokenAmount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__TokenAmount, 0, sizeof(struct vin__TokenAmount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_token > 0 || soap_flag_amount > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__BillingPlanPrice(struct soap *soap, struct vin__BillingPlanPrice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__decimal(soap, &a->amount);
	soap_default_string(soap, &a->currency);
	soap_default_string(soap, &a->priceListName);
	a->tokenAmount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__BillingPlanPrice(struct soap *soap, const struct vin__BillingPlanPrice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__decimal(soap, &a->amount);
	soap_serialize_string(soap, &a->currency);
	soap_serialize_string(soap, &a->priceListName);
	soap_serialize_PointerTovin__TokenAmount(soap, &a->tokenAmount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__BillingPlanPrice(struct soap *soap, const struct vin__BillingPlanPrice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__BillingPlanPrice);
	if (soap_out_vin__BillingPlanPrice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__BillingPlanPrice(struct soap *soap, const char *tag, int id, const struct vin__BillingPlanPrice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__BillingPlanPrice), type))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "amount", -1, &a->amount, "xsd:decimal"))
		return soap->error;
	if (soap_out_string(soap, "currency", -1, &a->currency, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "priceListName", -1, &a->priceListName, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__TokenAmount(soap, "tokenAmount", -1, &a->tokenAmount, "vin:TokenAmount"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__BillingPlanPrice * SOAP_FMAC4 soap_get_vin__BillingPlanPrice(struct soap *soap, struct vin__BillingPlanPrice *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__BillingPlanPrice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__BillingPlanPrice * SOAP_FMAC4 soap_in_vin__BillingPlanPrice(struct soap *soap, const char *tag, struct vin__BillingPlanPrice *a, const char *type)
{
	size_t soap_flag_amount = 1;
	size_t soap_flag_currency = 1;
	size_t soap_flag_priceListName = 1;
	size_t soap_flag_tokenAmount = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__BillingPlanPrice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__BillingPlanPrice, sizeof(struct vin__BillingPlanPrice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__BillingPlanPrice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_amount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "amount", &a->amount, "xsd:decimal"))
				{	soap_flag_amount--;
					continue;
				}
			if (soap_flag_currency && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "currency", &a->currency, "xsd:string"))
				{	soap_flag_currency--;
					continue;
				}
			if (soap_flag_priceListName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "priceListName", &a->priceListName, "xsd:string"))
				{	soap_flag_priceListName--;
					continue;
				}
			if (soap_flag_tokenAmount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__TokenAmount(soap, "tokenAmount", &a->tokenAmount, "vin:TokenAmount"))
				{	soap_flag_tokenAmount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__BillingPlanPrice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__BillingPlanPrice, 0, sizeof(struct vin__BillingPlanPrice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfTransactions(struct soap *soap, struct ArrayOfTransactions *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfTransactions(struct soap *soap, struct ArrayOfTransactions const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfTransactions))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__Transaction(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfTransactions(struct soap *soap, const struct ArrayOfTransactions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfTransactions);
	if (soap_out_ArrayOfTransactions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfTransactions(struct soap *soap, const char *tag, int id, const struct ArrayOfTransactions *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:Transaction", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfTransactions);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__Transaction(soap, "item", -1, &a->__ptr[i], "vin:Transaction");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfTransactions * SOAP_FMAC4 soap_get_ArrayOfTransactions(struct soap *soap, struct ArrayOfTransactions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfTransactions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfTransactions * SOAP_FMAC4 soap_in_ArrayOfTransactions(struct soap *soap, const char *tag, struct ArrayOfTransactions *a, const char *type)
{	int i, j;
	struct vin__Transaction **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfTransactions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfTransactions, sizeof(struct ArrayOfTransactions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfTransactions(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__Transaction **)soap_malloc(soap, sizeof(struct vin__Transaction *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__Transaction(soap, NULL, a->__ptr + i, "vin:Transaction"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__Transaction **)soap_push_block(soap, NULL, sizeof(struct vin__Transaction *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__Transaction(soap, NULL, p, "vin:Transaction"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__Transaction **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfTransactions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfTransactions, 0, sizeof(struct ArrayOfTransactions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__PaymentMethod(struct soap *soap, struct vin__PaymentMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->VID);
	a->type = NULL;
	a->creditCard = NULL;
	a->ecp = NULL;
	a->directDebit = NULL;
	a->paypal = NULL;
	a->boleto = NULL;
	a->token = NULL;
	a->nameValues = NULL;
	soap_default_string(soap, &a->accountHolderName);
	a->billingAddress = NULL;
	soap_default_string(soap, &a->customerSpecifiedType);
	soap_default_string(soap, &a->customerDescription);
	soap_default_string(soap, &a->merchantPaymentMethodId);
	soap_default_string(soap, &a->currency);
	a->sortOrder = NULL;
	a->active = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__PaymentMethod(struct soap *soap, const struct vin__PaymentMethod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->VID);
	soap_serialize_PointerTovin__PaymentMethodType(soap, &a->type);
	soap_serialize_PointerTovin__CreditCard(soap, &a->creditCard);
	soap_serialize_PointerTovin__ECP(soap, &a->ecp);
	soap_serialize_PointerTovin__DirectDebit(soap, &a->directDebit);
	soap_serialize_PointerTovin__PayPal(soap, &a->paypal);
	soap_serialize_PointerTovin__Boleto(soap, &a->boleto);
	soap_serialize_PointerTovin__Token(soap, &a->token);
	soap_serialize_PointerToArrayOfNameValuePairs(soap, &a->nameValues);
	soap_serialize_string(soap, &a->accountHolderName);
	soap_serialize_PointerTovin__Address(soap, &a->billingAddress);
	soap_serialize_string(soap, &a->customerSpecifiedType);
	soap_serialize_string(soap, &a->customerDescription);
	soap_serialize_string(soap, &a->merchantPaymentMethodId);
	soap_serialize_string(soap, &a->currency);
	soap_serialize_PointerToint(soap, &a->sortOrder);
	soap_serialize_PointerToxsd__boolean(soap, &a->active);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__PaymentMethod(struct soap *soap, const struct vin__PaymentMethod *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__PaymentMethod);
	if (soap_out_vin__PaymentMethod(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__PaymentMethod(struct soap *soap, const char *tag, int id, const struct vin__PaymentMethod *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__PaymentMethod), type))
		return soap->error;
	if (soap_out_string(soap, "VID", -1, &a->VID, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentMethodType(soap, "type", -1, &a->type, "vin:PaymentMethodType"))
		return soap->error;
	if (soap_out_PointerTovin__CreditCard(soap, "creditCard", -1, &a->creditCard, "vin:CreditCard"))
		return soap->error;
	if (soap_out_PointerTovin__ECP(soap, "ecp", -1, &a->ecp, "vin:ECP"))
		return soap->error;
	if (soap_out_PointerTovin__DirectDebit(soap, "directDebit", -1, &a->directDebit, "vin:DirectDebit"))
		return soap->error;
	if (soap_out_PointerTovin__PayPal(soap, "paypal", -1, &a->paypal, "vin:PayPal"))
		return soap->error;
	if (soap_out_PointerTovin__Boleto(soap, "boleto", -1, &a->boleto, "vin:Boleto"))
		return soap->error;
	if (soap_out_PointerTovin__Token(soap, "token", -1, &a->token, "vin:Token"))
		return soap->error;
	if (soap_out_PointerToArrayOfNameValuePairs(soap, "nameValues", -1, &a->nameValues, "vin:NameValuePair"))
		return soap->error;
	if (soap_out_string(soap, "accountHolderName", -1, &a->accountHolderName, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__Address(soap, "billingAddress", -1, &a->billingAddress, "vin:Address"))
		return soap->error;
	if (soap_out_string(soap, "customerSpecifiedType", -1, &a->customerSpecifiedType, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "customerDescription", -1, &a->customerDescription, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "merchantPaymentMethodId", -1, &a->merchantPaymentMethodId, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "currency", -1, &a->currency, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToint(soap, "sortOrder", -1, &a->sortOrder, "xsd:int"))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "active", -1, &a->active, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__PaymentMethod * SOAP_FMAC4 soap_get_vin__PaymentMethod(struct soap *soap, struct vin__PaymentMethod *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__PaymentMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__PaymentMethod * SOAP_FMAC4 soap_in_vin__PaymentMethod(struct soap *soap, const char *tag, struct vin__PaymentMethod *a, const char *type)
{
	size_t soap_flag_VID = 1;
	size_t soap_flag_type = 1;
	size_t soap_flag_creditCard = 1;
	size_t soap_flag_ecp = 1;
	size_t soap_flag_directDebit = 1;
	size_t soap_flag_paypal = 1;
	size_t soap_flag_boleto = 1;
	size_t soap_flag_token = 1;
	size_t soap_flag_nameValues = 1;
	size_t soap_flag_accountHolderName = 1;
	size_t soap_flag_billingAddress = 1;
	size_t soap_flag_customerSpecifiedType = 1;
	size_t soap_flag_customerDescription = 1;
	size_t soap_flag_merchantPaymentMethodId = 1;
	size_t soap_flag_currency = 1;
	size_t soap_flag_sortOrder = 1;
	size_t soap_flag_active = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__PaymentMethod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__PaymentMethod, sizeof(struct vin__PaymentMethod), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__PaymentMethod(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "VID", &a->VID, "xsd:string"))
				{	soap_flag_VID--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentMethodType(soap, "type", &a->type, "vin:PaymentMethodType"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_creditCard && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__CreditCard(soap, "creditCard", &a->creditCard, "vin:CreditCard"))
				{	soap_flag_creditCard--;
					continue;
				}
			if (soap_flag_ecp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__ECP(soap, "ecp", &a->ecp, "vin:ECP"))
				{	soap_flag_ecp--;
					continue;
				}
			if (soap_flag_directDebit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__DirectDebit(soap, "directDebit", &a->directDebit, "vin:DirectDebit"))
				{	soap_flag_directDebit--;
					continue;
				}
			if (soap_flag_paypal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PayPal(soap, "paypal", &a->paypal, "vin:PayPal"))
				{	soap_flag_paypal--;
					continue;
				}
			if (soap_flag_boleto && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Boleto(soap, "boleto", &a->boleto, "vin:Boleto"))
				{	soap_flag_boleto--;
					continue;
				}
			if (soap_flag_token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Token(soap, "token", &a->token, "vin:Token"))
				{	soap_flag_token--;
					continue;
				}
			if (soap_flag_nameValues && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfNameValuePairs(soap, "nameValues", &a->nameValues, "vin:NameValuePair"))
				{	soap_flag_nameValues--;
					continue;
				}
			if (soap_flag_accountHolderName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "accountHolderName", &a->accountHolderName, "xsd:string"))
				{	soap_flag_accountHolderName--;
					continue;
				}
			if (soap_flag_billingAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Address(soap, "billingAddress", &a->billingAddress, "vin:Address"))
				{	soap_flag_billingAddress--;
					continue;
				}
			if (soap_flag_customerSpecifiedType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "customerSpecifiedType", &a->customerSpecifiedType, "xsd:string"))
				{	soap_flag_customerSpecifiedType--;
					continue;
				}
			if (soap_flag_customerDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "customerDescription", &a->customerDescription, "xsd:string"))
				{	soap_flag_customerDescription--;
					continue;
				}
			if (soap_flag_merchantPaymentMethodId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantPaymentMethodId", &a->merchantPaymentMethodId, "xsd:string"))
				{	soap_flag_merchantPaymentMethodId--;
					continue;
				}
			if (soap_flag_currency && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "currency", &a->currency, "xsd:string"))
				{	soap_flag_currency--;
					continue;
				}
			if (soap_flag_sortOrder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "sortOrder", &a->sortOrder, "xsd:int"))
				{	soap_flag_sortOrder--;
					continue;
				}
			if (soap_flag_active && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "active", &a->active, "xsd:boolean"))
				{	soap_flag_active--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__PaymentMethod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__PaymentMethod, 0, sizeof(struct vin__PaymentMethod), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__BillingPlan(struct soap *soap, struct vin__BillingPlan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->VID);
	soap_default_string(soap, &a->merchantBillingPlanId);
	soap_default_string(soap, &a->description);
	a->status = NULL;
	a->periods = NULL;
	a->prenotifyDays = NULL;
	a->endOfLifeTimestamp = NULL;
	a->nameValues = NULL;
	a->merchantEntitlementIds = NULL;
	soap_default_string(soap, &a->billingStatementIdentifier);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__BillingPlan(struct soap *soap, const struct vin__BillingPlan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->VID);
	soap_serialize_string(soap, &a->merchantBillingPlanId);
	soap_serialize_string(soap, &a->description);
	soap_serialize_PointerTovin__BillingPlanStatus(soap, &a->status);
	soap_serialize_PointerToArrayOfBillingPlanPeriods(soap, &a->periods);
	soap_serialize_PointerToint(soap, &a->prenotifyDays);
	soap_serialize_PointerTotime(soap, &a->endOfLifeTimestamp);
	soap_serialize_PointerToArrayOfNameValuePairs(soap, &a->nameValues);
	soap_serialize_PointerToArrayOfMerchantEntitlementIds(soap, &a->merchantEntitlementIds);
	soap_serialize_string(soap, &a->billingStatementIdentifier);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__BillingPlan(struct soap *soap, const struct vin__BillingPlan *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__BillingPlan);
	if (soap_out_vin__BillingPlan(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__BillingPlan(struct soap *soap, const char *tag, int id, const struct vin__BillingPlan *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__BillingPlan), type))
		return soap->error;
	if (soap_out_string(soap, "VID", -1, &a->VID, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "merchantBillingPlanId", -1, &a->merchantBillingPlanId, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__BillingPlanStatus(soap, "status", -1, &a->status, "vin:BillingPlanStatus"))
		return soap->error;
	if (soap_out_PointerToArrayOfBillingPlanPeriods(soap, "periods", -1, &a->periods, "vin:BillingPlanPeriod"))
		return soap->error;
	if (soap_out_PointerToint(soap, "prenotifyDays", -1, &a->prenotifyDays, "xsd:int"))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endOfLifeTimestamp", -1, &a->endOfLifeTimestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_PointerToArrayOfNameValuePairs(soap, "nameValues", -1, &a->nameValues, "vin:NameValuePair"))
		return soap->error;
	if (soap_out_PointerToArrayOfMerchantEntitlementIds(soap, "merchantEntitlementIds", -1, &a->merchantEntitlementIds, "vin:MerchantEntitlementId"))
		return soap->error;
	if (soap_out_string(soap, "billingStatementIdentifier", -1, &a->billingStatementIdentifier, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__BillingPlan * SOAP_FMAC4 soap_get_vin__BillingPlan(struct soap *soap, struct vin__BillingPlan *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__BillingPlan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__BillingPlan * SOAP_FMAC4 soap_in_vin__BillingPlan(struct soap *soap, const char *tag, struct vin__BillingPlan *a, const char *type)
{
	size_t soap_flag_VID = 1;
	size_t soap_flag_merchantBillingPlanId = 1;
	size_t soap_flag_description = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_periods = 1;
	size_t soap_flag_prenotifyDays = 1;
	size_t soap_flag_endOfLifeTimestamp = 1;
	size_t soap_flag_nameValues = 1;
	size_t soap_flag_merchantEntitlementIds = 1;
	size_t soap_flag_billingStatementIdentifier = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__BillingPlan *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__BillingPlan, sizeof(struct vin__BillingPlan), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__BillingPlan(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "VID", &a->VID, "xsd:string"))
				{	soap_flag_VID--;
					continue;
				}
			if (soap_flag_merchantBillingPlanId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantBillingPlanId", &a->merchantBillingPlanId, "xsd:string"))
				{	soap_flag_merchantBillingPlanId--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__BillingPlanStatus(soap, "status", &a->status, "vin:BillingPlanStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_periods && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfBillingPlanPeriods(soap, "periods", &a->periods, "vin:BillingPlanPeriod"))
				{	soap_flag_periods--;
					continue;
				}
			if (soap_flag_prenotifyDays && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "prenotifyDays", &a->prenotifyDays, "xsd:int"))
				{	soap_flag_prenotifyDays--;
					continue;
				}
			if (soap_flag_endOfLifeTimestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endOfLifeTimestamp", &a->endOfLifeTimestamp, "xsd:dateTime"))
				{	soap_flag_endOfLifeTimestamp--;
					continue;
				}
			if (soap_flag_nameValues && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfNameValuePairs(soap, "nameValues", &a->nameValues, "vin:NameValuePair"))
				{	soap_flag_nameValues--;
					continue;
				}
			if (soap_flag_merchantEntitlementIds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfMerchantEntitlementIds(soap, "merchantEntitlementIds", &a->merchantEntitlementIds, "vin:MerchantEntitlementId"))
				{	soap_flag_merchantEntitlementIds--;
					continue;
				}
			if (soap_flag_billingStatementIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "billingStatementIdentifier", &a->billingStatementIdentifier, "xsd:string"))
				{	soap_flag_billingStatementIdentifier--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__BillingPlan *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__BillingPlan, 0, sizeof(struct vin__BillingPlan), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__Product(struct soap *soap, struct vin__Product *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->VID);
	soap_default_string(soap, &a->merchantProductId);
	soap_default_string(soap, &a->description);
	a->status = NULL;
	a->taxClassification = NULL;
	a->defaultBillingPlan = NULL;
	a->endOfLifeTimestamp = NULL;
	a->nameValues = NULL;
	a->merchantEntitlementIds = NULL;
	soap_default_string(soap, &a->billingStatementIdentifier);
	a->tokensGranted = NULL;
	a->tokenPrice = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__Product(struct soap *soap, const struct vin__Product *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->VID);
	soap_serialize_string(soap, &a->merchantProductId);
	soap_serialize_string(soap, &a->description);
	soap_serialize_PointerTovin__ProductStatus(soap, &a->status);
	soap_serialize_PointerTovin__TaxClassification(soap, &a->taxClassification);
	soap_serialize_PointerTovin__BillingPlan(soap, &a->defaultBillingPlan);
	soap_serialize_PointerTotime(soap, &a->endOfLifeTimestamp);
	soap_serialize_PointerToArrayOfNameValuePairs(soap, &a->nameValues);
	soap_serialize_PointerToArrayOfMerchantEntitlementIds(soap, &a->merchantEntitlementIds);
	soap_serialize_string(soap, &a->billingStatementIdentifier);
	soap_serialize_PointerToArrayOfTokenAmounts(soap, &a->tokensGranted);
	soap_serialize_PointerTovin__TokenAmount(soap, &a->tokenPrice);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__Product(struct soap *soap, const struct vin__Product *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__Product);
	if (soap_out_vin__Product(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__Product(struct soap *soap, const char *tag, int id, const struct vin__Product *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__Product), type))
		return soap->error;
	if (soap_out_string(soap, "VID", -1, &a->VID, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "merchantProductId", -1, &a->merchantProductId, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__ProductStatus(soap, "status", -1, &a->status, "vin:ProductStatus"))
		return soap->error;
	if (soap_out_PointerTovin__TaxClassification(soap, "taxClassification", -1, &a->taxClassification, "vin:TaxClassification"))
		return soap->error;
	if (soap_out_PointerTovin__BillingPlan(soap, "defaultBillingPlan", -1, &a->defaultBillingPlan, "vin:BillingPlan"))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endOfLifeTimestamp", -1, &a->endOfLifeTimestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_PointerToArrayOfNameValuePairs(soap, "nameValues", -1, &a->nameValues, "vin:NameValuePair"))
		return soap->error;
	if (soap_out_PointerToArrayOfMerchantEntitlementIds(soap, "merchantEntitlementIds", -1, &a->merchantEntitlementIds, "vin:MerchantEntitlementId"))
		return soap->error;
	if (soap_out_string(soap, "billingStatementIdentifier", -1, &a->billingStatementIdentifier, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToArrayOfTokenAmounts(soap, "tokensGranted", -1, &a->tokensGranted, "vin:TokenAmount"))
		return soap->error;
	if (soap_out_PointerTovin__TokenAmount(soap, "tokenPrice", -1, &a->tokenPrice, "vin:TokenAmount"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__Product * SOAP_FMAC4 soap_get_vin__Product(struct soap *soap, struct vin__Product *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__Product(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Product * SOAP_FMAC4 soap_in_vin__Product(struct soap *soap, const char *tag, struct vin__Product *a, const char *type)
{
	size_t soap_flag_VID = 1;
	size_t soap_flag_merchantProductId = 1;
	size_t soap_flag_description = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_taxClassification = 1;
	size_t soap_flag_defaultBillingPlan = 1;
	size_t soap_flag_endOfLifeTimestamp = 1;
	size_t soap_flag_nameValues = 1;
	size_t soap_flag_merchantEntitlementIds = 1;
	size_t soap_flag_billingStatementIdentifier = 1;
	size_t soap_flag_tokensGranted = 1;
	size_t soap_flag_tokenPrice = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__Product *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__Product, sizeof(struct vin__Product), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__Product(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "VID", &a->VID, "xsd:string"))
				{	soap_flag_VID--;
					continue;
				}
			if (soap_flag_merchantProductId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantProductId", &a->merchantProductId, "xsd:string"))
				{	soap_flag_merchantProductId--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__ProductStatus(soap, "status", &a->status, "vin:ProductStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_taxClassification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__TaxClassification(soap, "taxClassification", &a->taxClassification, "vin:TaxClassification"))
				{	soap_flag_taxClassification--;
					continue;
				}
			if (soap_flag_defaultBillingPlan && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__BillingPlan(soap, "defaultBillingPlan", &a->defaultBillingPlan, "vin:BillingPlan"))
				{	soap_flag_defaultBillingPlan--;
					continue;
				}
			if (soap_flag_endOfLifeTimestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endOfLifeTimestamp", &a->endOfLifeTimestamp, "xsd:dateTime"))
				{	soap_flag_endOfLifeTimestamp--;
					continue;
				}
			if (soap_flag_nameValues && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfNameValuePairs(soap, "nameValues", &a->nameValues, "vin:NameValuePair"))
				{	soap_flag_nameValues--;
					continue;
				}
			if (soap_flag_merchantEntitlementIds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfMerchantEntitlementIds(soap, "merchantEntitlementIds", &a->merchantEntitlementIds, "vin:MerchantEntitlementId"))
				{	soap_flag_merchantEntitlementIds--;
					continue;
				}
			if (soap_flag_billingStatementIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "billingStatementIdentifier", &a->billingStatementIdentifier, "xsd:string"))
				{	soap_flag_billingStatementIdentifier--;
					continue;
				}
			if (soap_flag_tokensGranted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTokenAmounts(soap, "tokensGranted", &a->tokensGranted, "vin:TokenAmount"))
				{	soap_flag_tokensGranted--;
					continue;
				}
			if (soap_flag_tokenPrice && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__TokenAmount(soap, "tokenPrice", &a->tokenPrice, "vin:TokenAmount"))
				{	soap_flag_tokenPrice--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__Product *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__Product, 0, sizeof(struct vin__Product), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__AutoBill(struct soap *soap, struct vin__AutoBill *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->VID);
	soap_default_string(soap, &a->merchantAutoBillId);
	a->account = NULL;
	a->product = NULL;
	a->billingPlan = NULL;
	a->paymentMethod = NULL;
	soap_default_string(soap, &a->currency);
	soap_default_string(soap, &a->customerAutoBillName);
	a->status = NULL;
	a->startTimestamp = NULL;
	a->endTimestamp = NULL;
	soap_default_string(soap, &a->sourceIp);
	soap_default_string(soap, &a->billingStatementIdentifier);
	a->billingDay = NULL;
	a->minimumCommitment = NULL;
	soap_default_string(soap, &a->merchantAffiliateId);
	soap_default_string(soap, &a->merchantAffiliateSubId);
	a->warnOnExpiration = NULL;
	a->futureRebills = NULL;
	a->nameValues = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__AutoBill(struct soap *soap, const struct vin__AutoBill *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->VID);
	soap_serialize_string(soap, &a->merchantAutoBillId);
	soap_serialize_PointerTovin__Account(soap, &a->account);
	soap_serialize_PointerTovin__Product(soap, &a->product);
	soap_serialize_PointerTovin__BillingPlan(soap, &a->billingPlan);
	soap_serialize_PointerTovin__PaymentMethod(soap, &a->paymentMethod);
	soap_serialize_string(soap, &a->currency);
	soap_serialize_string(soap, &a->customerAutoBillName);
	soap_serialize_PointerTovin__AutoBillStatus(soap, &a->status);
	soap_serialize_PointerTotime(soap, &a->startTimestamp);
	soap_serialize_PointerTotime(soap, &a->endTimestamp);
	soap_serialize_string(soap, &a->sourceIp);
	soap_serialize_string(soap, &a->billingStatementIdentifier);
	soap_serialize_PointerToint(soap, &a->billingDay);
	soap_serialize_PointerToint(soap, &a->minimumCommitment);
	soap_serialize_string(soap, &a->merchantAffiliateId);
	soap_serialize_string(soap, &a->merchantAffiliateSubId);
	soap_serialize_PointerToxsd__boolean(soap, &a->warnOnExpiration);
	soap_serialize_PointerToArrayOfTransactions(soap, &a->futureRebills);
	soap_serialize_PointerToArrayOfNameValuePairs(soap, &a->nameValues);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__AutoBill(struct soap *soap, const struct vin__AutoBill *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__AutoBill);
	if (soap_out_vin__AutoBill(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__AutoBill(struct soap *soap, const char *tag, int id, const struct vin__AutoBill *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__AutoBill), type))
		return soap->error;
	if (soap_out_string(soap, "VID", -1, &a->VID, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "merchantAutoBillId", -1, &a->merchantAutoBillId, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->account, "vin:Account"))
		return soap->error;
	if (soap_out_PointerTovin__Product(soap, "product", -1, &a->product, "vin:Product"))
		return soap->error;
	if (soap_out_PointerTovin__BillingPlan(soap, "billingPlan", -1, &a->billingPlan, "vin:BillingPlan"))
		return soap->error;
	if (soap_out_PointerTovin__PaymentMethod(soap, "paymentMethod", -1, &a->paymentMethod, "vin:PaymentMethod"))
		return soap->error;
	if (soap_out_string(soap, "currency", -1, &a->currency, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "customerAutoBillName", -1, &a->customerAutoBillName, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__AutoBillStatus(soap, "status", -1, &a->status, "vin:AutoBillStatus"))
		return soap->error;
	if (soap_out_PointerTotime(soap, "startTimestamp", -1, &a->startTimestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endTimestamp", -1, &a->endTimestamp, "xsd:dateTime"))
		return soap->error;
	if (soap_out_string(soap, "sourceIp", -1, &a->sourceIp, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "billingStatementIdentifier", -1, &a->billingStatementIdentifier, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToint(soap, "billingDay", -1, &a->billingDay, "xsd:int"))
		return soap->error;
	if (soap_out_PointerToint(soap, "minimumCommitment", -1, &a->minimumCommitment, "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "merchantAffiliateId", -1, &a->merchantAffiliateId, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "merchantAffiliateSubId", -1, &a->merchantAffiliateSubId, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "warnOnExpiration", -1, &a->warnOnExpiration, "xsd:boolean"))
		return soap->error;
	if (soap_out_PointerToArrayOfTransactions(soap, "futureRebills", -1, &a->futureRebills, "vin:Transaction"))
		return soap->error;
	if (soap_out_PointerToArrayOfNameValuePairs(soap, "nameValues", -1, &a->nameValues, "vin:NameValuePair"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__AutoBill * SOAP_FMAC4 soap_get_vin__AutoBill(struct soap *soap, struct vin__AutoBill *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__AutoBill(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__AutoBill * SOAP_FMAC4 soap_in_vin__AutoBill(struct soap *soap, const char *tag, struct vin__AutoBill *a, const char *type)
{
	size_t soap_flag_VID = 1;
	size_t soap_flag_merchantAutoBillId = 1;
	size_t soap_flag_account = 1;
	size_t soap_flag_product = 1;
	size_t soap_flag_billingPlan = 1;
	size_t soap_flag_paymentMethod = 1;
	size_t soap_flag_currency = 1;
	size_t soap_flag_customerAutoBillName = 1;
	size_t soap_flag_status = 1;
	size_t soap_flag_startTimestamp = 1;
	size_t soap_flag_endTimestamp = 1;
	size_t soap_flag_sourceIp = 1;
	size_t soap_flag_billingStatementIdentifier = 1;
	size_t soap_flag_billingDay = 1;
	size_t soap_flag_minimumCommitment = 1;
	size_t soap_flag_merchantAffiliateId = 1;
	size_t soap_flag_merchantAffiliateSubId = 1;
	size_t soap_flag_warnOnExpiration = 1;
	size_t soap_flag_futureRebills = 1;
	size_t soap_flag_nameValues = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__AutoBill *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__AutoBill, sizeof(struct vin__AutoBill), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__AutoBill(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "VID", &a->VID, "xsd:string"))
				{	soap_flag_VID--;
					continue;
				}
			if (soap_flag_merchantAutoBillId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantAutoBillId", &a->merchantAutoBillId, "xsd:string"))
				{	soap_flag_merchantAutoBillId--;
					continue;
				}
			if (soap_flag_account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, "account", &a->account, "vin:Account"))
				{	soap_flag_account--;
					continue;
				}
			if (soap_flag_product && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Product(soap, "product", &a->product, "vin:Product"))
				{	soap_flag_product--;
					continue;
				}
			if (soap_flag_billingPlan && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__BillingPlan(soap, "billingPlan", &a->billingPlan, "vin:BillingPlan"))
				{	soap_flag_billingPlan--;
					continue;
				}
			if (soap_flag_paymentMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__PaymentMethod(soap, "paymentMethod", &a->paymentMethod, "vin:PaymentMethod"))
				{	soap_flag_paymentMethod--;
					continue;
				}
			if (soap_flag_currency && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "currency", &a->currency, "xsd:string"))
				{	soap_flag_currency--;
					continue;
				}
			if (soap_flag_customerAutoBillName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "customerAutoBillName", &a->customerAutoBillName, "xsd:string"))
				{	soap_flag_customerAutoBillName--;
					continue;
				}
			if (soap_flag_status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__AutoBillStatus(soap, "status", &a->status, "vin:AutoBillStatus"))
				{	soap_flag_status--;
					continue;
				}
			if (soap_flag_startTimestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startTimestamp", &a->startTimestamp, "xsd:dateTime"))
				{	soap_flag_startTimestamp--;
					continue;
				}
			if (soap_flag_endTimestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endTimestamp", &a->endTimestamp, "xsd:dateTime"))
				{	soap_flag_endTimestamp--;
					continue;
				}
			if (soap_flag_sourceIp && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sourceIp", &a->sourceIp, "xsd:string"))
				{	soap_flag_sourceIp--;
					continue;
				}
			if (soap_flag_billingStatementIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "billingStatementIdentifier", &a->billingStatementIdentifier, "xsd:string"))
				{	soap_flag_billingStatementIdentifier--;
					continue;
				}
			if (soap_flag_billingDay && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "billingDay", &a->billingDay, "xsd:int"))
				{	soap_flag_billingDay--;
					continue;
				}
			if (soap_flag_minimumCommitment && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "minimumCommitment", &a->minimumCommitment, "xsd:int"))
				{	soap_flag_minimumCommitment--;
					continue;
				}
			if (soap_flag_merchantAffiliateId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantAffiliateId", &a->merchantAffiliateId, "xsd:string"))
				{	soap_flag_merchantAffiliateId--;
					continue;
				}
			if (soap_flag_merchantAffiliateSubId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantAffiliateSubId", &a->merchantAffiliateSubId, "xsd:string"))
				{	soap_flag_merchantAffiliateSubId--;
					continue;
				}
			if (soap_flag_warnOnExpiration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "warnOnExpiration", &a->warnOnExpiration, "xsd:boolean"))
				{	soap_flag_warnOnExpiration--;
					continue;
				}
			if (soap_flag_futureRebills && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTransactions(soap, "futureRebills", &a->futureRebills, "vin:Transaction"))
				{	soap_flag_futureRebills--;
					continue;
				}
			if (soap_flag_nameValues && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfNameValuePairs(soap, "nameValues", &a->nameValues, "vin:NameValuePair"))
				{	soap_flag_nameValues--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__AutoBill *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__AutoBill, 0, sizeof(struct vin__AutoBill), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__Authentication(struct soap *soap, struct vin__Authentication *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->version);
	soap_default_string(soap, &a->login);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->evid);
	soap_default_string(soap, &a->userAgent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__Authentication(struct soap *soap, const struct vin__Authentication *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->version);
	soap_serialize_string(soap, &a->login);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->evid);
	soap_serialize_string(soap, &a->userAgent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__Authentication(struct soap *soap, const struct vin__Authentication *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__Authentication);
	if (soap_out_vin__Authentication(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__Authentication(struct soap *soap, const char *tag, int id, const struct vin__Authentication *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__Authentication), type))
		return soap->error;
	if (soap_out_string(soap, "version", -1, &a->version, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "login", -1, &a->login, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "evid", -1, &a->evid, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "userAgent", -1, &a->userAgent, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__Authentication * SOAP_FMAC4 soap_get_vin__Authentication(struct soap *soap, struct vin__Authentication *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__Authentication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Authentication * SOAP_FMAC4 soap_in_vin__Authentication(struct soap *soap, const char *tag, struct vin__Authentication *a, const char *type)
{
	size_t soap_flag_version = 1;
	size_t soap_flag_login = 1;
	size_t soap_flag_password = 1;
	size_t soap_flag_evid = 1;
	size_t soap_flag_userAgent = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__Authentication *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__Authentication, sizeof(struct vin__Authentication), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__Authentication(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "version", &a->version, "xsd:string"))
				{	soap_flag_version--;
					continue;
				}
			if (soap_flag_login && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "login", &a->login, "xsd:string"))
				{	soap_flag_login--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_evid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "evid", &a->evid, "xsd:string"))
				{	soap_flag_evid--;
					continue;
				}
			if (soap_flag_userAgent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userAgent", &a->userAgent, "xsd:string"))
				{	soap_flag_userAgent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__Authentication *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__Authentication, 0, sizeof(struct vin__Authentication), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_version > 0 || soap_flag_login > 0 || soap_flag_password > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__Activity(struct soap *soap, struct vin__Activity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->account = NULL;
	soap_default_vin__ActivityType(soap, &a->activityType);
	a->activityArgs = NULL;
	soap_default_time(soap, &a->timestamp);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__Activity(struct soap *soap, const struct vin__Activity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__Account(soap, &a->account);
	soap_serialize_PointerTovin__ActivityTypeArg(soap, &a->activityArgs);
	soap_embedded(soap, &a->timestamp, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__Activity(struct soap *soap, const struct vin__Activity *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__Activity);
	if (soap_out_vin__Activity(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__Activity(struct soap *soap, const char *tag, int id, const struct vin__Activity *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__Activity), type))
		return soap->error;
	if (soap_out_PointerTovin__Account(soap, "account", -1, &a->account, "vin:Account"))
		return soap->error;
	if (soap_out_vin__ActivityType(soap, "activityType", -1, &a->activityType, "vin:ActivityType"))
		return soap->error;
	if (soap_out_PointerTovin__ActivityTypeArg(soap, "activityArgs", -1, &a->activityArgs, "vin:ActivityTypeArg"))
		return soap->error;
	if (soap_out_time(soap, "timestamp", -1, &a->timestamp, "xsd:dateTime"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__Activity * SOAP_FMAC4 soap_get_vin__Activity(struct soap *soap, struct vin__Activity *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__Activity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Activity * SOAP_FMAC4 soap_in_vin__Activity(struct soap *soap, const char *tag, struct vin__Activity *a, const char *type)
{
	size_t soap_flag_account = 1;
	size_t soap_flag_activityType = 1;
	size_t soap_flag_activityArgs = 1;
	size_t soap_flag_timestamp = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__Activity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__Activity, sizeof(struct vin__Activity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__Activity(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_account && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Account(soap, "account", &a->account, "vin:Account"))
				{	soap_flag_account--;
					continue;
				}
			if (soap_flag_activityType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_vin__ActivityType(soap, "activityType", &a->activityType, "vin:ActivityType"))
				{	soap_flag_activityType--;
					continue;
				}
			if (soap_flag_activityArgs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__ActivityTypeArg(soap, "activityArgs", &a->activityArgs, "vin:ActivityTypeArg"))
				{	soap_flag_activityArgs--;
					continue;
				}
			if (soap_flag_timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "timestamp", &a->timestamp, "xsd:dateTime"))
				{	soap_flag_timestamp--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__Activity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__Activity, 0, sizeof(struct vin__Activity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_activityType > 0 || soap_flag_timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ActivityNote(struct soap *soap, struct vin__ActivityNote *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->note);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__ActivityNote(struct soap *soap, const struct vin__ActivityNote *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->note);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ActivityNote(struct soap *soap, const struct vin__ActivityNote *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ActivityNote);
	if (soap_out_vin__ActivityNote(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ActivityNote(struct soap *soap, const char *tag, int id, const struct vin__ActivityNote *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ActivityNote), type))
		return soap->error;
	if (soap_out_string(soap, "note", -1, &a->note, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__ActivityNote * SOAP_FMAC4 soap_get_vin__ActivityNote(struct soap *soap, struct vin__ActivityNote *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ActivityNote(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityNote * SOAP_FMAC4 soap_in_vin__ActivityNote(struct soap *soap, const char *tag, struct vin__ActivityNote *a, const char *type)
{
	size_t soap_flag_note = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__ActivityNote *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ActivityNote, sizeof(struct vin__ActivityNote), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__ActivityNote(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_note && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "note", &a->note, "xsd:string"))
				{	soap_flag_note--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityNote *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ActivityNote, 0, sizeof(struct vin__ActivityNote), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ActivityCancellation(struct soap *soap, struct vin__ActivityCancellation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->reason);
	a->confirmationCode = NULL;
	soap_default_vin__ActivityCancelInitType(soap, &a->initiator);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__ActivityCancellation(struct soap *soap, const struct vin__ActivityCancellation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->reason);
	soap_serialize_PointerToint(soap, &a->confirmationCode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ActivityCancellation(struct soap *soap, const struct vin__ActivityCancellation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ActivityCancellation);
	if (soap_out_vin__ActivityCancellation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ActivityCancellation(struct soap *soap, const char *tag, int id, const struct vin__ActivityCancellation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ActivityCancellation), type))
		return soap->error;
	if (soap_out_string(soap, "reason", -1, &a->reason, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToint(soap, "confirmationCode", -1, &a->confirmationCode, "xsd:int"))
		return soap->error;
	if (soap_out_vin__ActivityCancelInitType(soap, "initiator", -1, &a->initiator, "vin:ActivityCancelInitType"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__ActivityCancellation * SOAP_FMAC4 soap_get_vin__ActivityCancellation(struct soap *soap, struct vin__ActivityCancellation *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ActivityCancellation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityCancellation * SOAP_FMAC4 soap_in_vin__ActivityCancellation(struct soap *soap, const char *tag, struct vin__ActivityCancellation *a, const char *type)
{
	size_t soap_flag_reason = 1;
	size_t soap_flag_confirmationCode = 1;
	size_t soap_flag_initiator = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__ActivityCancellation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ActivityCancellation, sizeof(struct vin__ActivityCancellation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__ActivityCancellation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "reason", &a->reason, "xsd:string"))
				{	soap_flag_reason--;
					continue;
				}
			if (soap_flag_confirmationCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "confirmationCode", &a->confirmationCode, "xsd:int"))
				{	soap_flag_confirmationCode--;
					continue;
				}
			if (soap_flag_initiator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_vin__ActivityCancelInitType(soap, "initiator", &a->initiator, "vin:ActivityCancelInitType"))
				{	soap_flag_initiator--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityCancellation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ActivityCancellation, 0, sizeof(struct vin__ActivityCancellation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_initiator > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ActivityNamedValue(struct soap *soap, struct vin__ActivityNamedValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->type);
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__ActivityNamedValue(struct soap *soap, const struct vin__ActivityNamedValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->type);
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ActivityNamedValue(struct soap *soap, const struct vin__ActivityNamedValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ActivityNamedValue);
	if (soap_out_vin__ActivityNamedValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ActivityNamedValue(struct soap *soap, const char *tag, int id, const struct vin__ActivityNamedValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ActivityNamedValue), type))
		return soap->error;
	if (soap_out_string(soap, "type", -1, &a->type, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &a->value, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__ActivityNamedValue * SOAP_FMAC4 soap_get_vin__ActivityNamedValue(struct soap *soap, struct vin__ActivityNamedValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ActivityNamedValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityNamedValue * SOAP_FMAC4 soap_in_vin__ActivityNamedValue(struct soap *soap, const char *tag, struct vin__ActivityNamedValue *a, const char *type)
{
	size_t soap_flag_type = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__ActivityNamedValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ActivityNamedValue, sizeof(struct vin__ActivityNamedValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__ActivityNamedValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "type", &a->type, "xsd:string"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityNamedValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ActivityNamedValue, 0, sizeof(struct vin__ActivityNamedValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type > 0 || soap_flag_name > 0 || soap_flag_value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ActivityUsage(struct soap *soap, struct vin__ActivityUsage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->description);
	a->total = NULL;
	a->lastDay = NULL;
	a->lastWeek = NULL;
	a->lastMonth = NULL;
	a->lastYear = NULL;
	a->lastUsageDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__ActivityUsage(struct soap *soap, const struct vin__ActivityUsage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->description);
	soap_serialize_PointerToint(soap, &a->total);
	soap_serialize_PointerToint(soap, &a->lastDay);
	soap_serialize_PointerToint(soap, &a->lastWeek);
	soap_serialize_PointerToint(soap, &a->lastMonth);
	soap_serialize_PointerToint(soap, &a->lastYear);
	soap_serialize_PointerTotime(soap, &a->lastUsageDate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ActivityUsage(struct soap *soap, const struct vin__ActivityUsage *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ActivityUsage);
	if (soap_out_vin__ActivityUsage(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ActivityUsage(struct soap *soap, const char *tag, int id, const struct vin__ActivityUsage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ActivityUsage), type))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToint(soap, "total", -1, &a->total, "xsd:int"))
		return soap->error;
	if (soap_out_PointerToint(soap, "lastDay", -1, &a->lastDay, "xsd:int"))
		return soap->error;
	if (soap_out_PointerToint(soap, "lastWeek", -1, &a->lastWeek, "xsd:int"))
		return soap->error;
	if (soap_out_PointerToint(soap, "lastMonth", -1, &a->lastMonth, "xsd:int"))
		return soap->error;
	if (soap_out_PointerToint(soap, "lastYear", -1, &a->lastYear, "xsd:int"))
		return soap->error;
	if (soap_out_PointerTotime(soap, "lastUsageDate", -1, &a->lastUsageDate, "xsd:dateTime"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__ActivityUsage * SOAP_FMAC4 soap_get_vin__ActivityUsage(struct soap *soap, struct vin__ActivityUsage *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ActivityUsage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityUsage * SOAP_FMAC4 soap_in_vin__ActivityUsage(struct soap *soap, const char *tag, struct vin__ActivityUsage *a, const char *type)
{
	size_t soap_flag_description = 1;
	size_t soap_flag_total = 1;
	size_t soap_flag_lastDay = 1;
	size_t soap_flag_lastWeek = 1;
	size_t soap_flag_lastMonth = 1;
	size_t soap_flag_lastYear = 1;
	size_t soap_flag_lastUsageDate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__ActivityUsage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ActivityUsage, sizeof(struct vin__ActivityUsage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__ActivityUsage(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_total && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "total", &a->total, "xsd:int"))
				{	soap_flag_total--;
					continue;
				}
			if (soap_flag_lastDay && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lastDay", &a->lastDay, "xsd:int"))
				{	soap_flag_lastDay--;
					continue;
				}
			if (soap_flag_lastWeek && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lastWeek", &a->lastWeek, "xsd:int"))
				{	soap_flag_lastWeek--;
					continue;
				}
			if (soap_flag_lastMonth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lastMonth", &a->lastMonth, "xsd:int"))
				{	soap_flag_lastMonth--;
					continue;
				}
			if (soap_flag_lastYear && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "lastYear", &a->lastYear, "xsd:int"))
				{	soap_flag_lastYear--;
					continue;
				}
			if (soap_flag_lastUsageDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "lastUsageDate", &a->lastUsageDate, "xsd:dateTime"))
				{	soap_flag_lastUsageDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityUsage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ActivityUsage, 0, sizeof(struct vin__ActivityUsage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ActivityFulfillment(struct soap *soap, struct vin__ActivityFulfillment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->merchantTransactionId);
	soap_default_string(soap, &a->shipper);
	soap_default_string(soap, &a->trackingString);
	a->shippingAddress = NULL;
	a->delivered = NULL;
	a->receivedTs = NULL;
	soap_default_string(soap, &a->receiptName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__ActivityFulfillment(struct soap *soap, const struct vin__ActivityFulfillment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->merchantTransactionId);
	soap_serialize_string(soap, &a->shipper);
	soap_serialize_string(soap, &a->trackingString);
	soap_serialize_PointerTovin__Address(soap, &a->shippingAddress);
	soap_serialize_PointerToxsd__boolean(soap, &a->delivered);
	soap_serialize_PointerTotime(soap, &a->receivedTs);
	soap_serialize_string(soap, &a->receiptName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ActivityFulfillment(struct soap *soap, const struct vin__ActivityFulfillment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ActivityFulfillment);
	if (soap_out_vin__ActivityFulfillment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ActivityFulfillment(struct soap *soap, const char *tag, int id, const struct vin__ActivityFulfillment *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ActivityFulfillment), type))
		return soap->error;
	if (soap_out_string(soap, "merchantTransactionId", -1, &a->merchantTransactionId, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "shipper", -1, &a->shipper, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "trackingString", -1, &a->trackingString, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__Address(soap, "shippingAddress", -1, &a->shippingAddress, "vin:Address"))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "delivered", -1, &a->delivered, "xsd:boolean"))
		return soap->error;
	if (soap_out_PointerTotime(soap, "receivedTs", -1, &a->receivedTs, "xsd:dateTime"))
		return soap->error;
	if (soap_out_string(soap, "receiptName", -1, &a->receiptName, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__ActivityFulfillment * SOAP_FMAC4 soap_get_vin__ActivityFulfillment(struct soap *soap, struct vin__ActivityFulfillment *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ActivityFulfillment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityFulfillment * SOAP_FMAC4 soap_in_vin__ActivityFulfillment(struct soap *soap, const char *tag, struct vin__ActivityFulfillment *a, const char *type)
{
	size_t soap_flag_merchantTransactionId = 1;
	size_t soap_flag_shipper = 1;
	size_t soap_flag_trackingString = 1;
	size_t soap_flag_shippingAddress = 1;
	size_t soap_flag_delivered = 1;
	size_t soap_flag_receivedTs = 1;
	size_t soap_flag_receiptName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__ActivityFulfillment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ActivityFulfillment, sizeof(struct vin__ActivityFulfillment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__ActivityFulfillment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_merchantTransactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantTransactionId", &a->merchantTransactionId, "xsd:string"))
				{	soap_flag_merchantTransactionId--;
					continue;
				}
			if (soap_flag_shipper && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "shipper", &a->shipper, "xsd:string"))
				{	soap_flag_shipper--;
					continue;
				}
			if (soap_flag_trackingString && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "trackingString", &a->trackingString, "xsd:string"))
				{	soap_flag_trackingString--;
					continue;
				}
			if (soap_flag_shippingAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Address(soap, "shippingAddress", &a->shippingAddress, "vin:Address"))
				{	soap_flag_shippingAddress--;
					continue;
				}
			if (soap_flag_delivered && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "delivered", &a->delivered, "xsd:boolean"))
				{	soap_flag_delivered--;
					continue;
				}
			if (soap_flag_receivedTs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "receivedTs", &a->receivedTs, "xsd:dateTime"))
				{	soap_flag_receivedTs--;
					continue;
				}
			if (soap_flag_receiptName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "receiptName", &a->receiptName, "xsd:string"))
				{	soap_flag_receiptName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityFulfillment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ActivityFulfillment, 0, sizeof(struct vin__ActivityFulfillment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ActivityEmailContact(struct soap *soap, struct vin__ActivityEmailContact *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->srcEmail);
	soap_default_string(soap, &a->destEmail);
	soap_default_string(soap, &a->note);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__ActivityEmailContact(struct soap *soap, const struct vin__ActivityEmailContact *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->srcEmail);
	soap_serialize_string(soap, &a->destEmail);
	soap_serialize_string(soap, &a->note);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ActivityEmailContact(struct soap *soap, const struct vin__ActivityEmailContact *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ActivityEmailContact);
	if (soap_out_vin__ActivityEmailContact(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ActivityEmailContact(struct soap *soap, const char *tag, int id, const struct vin__ActivityEmailContact *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ActivityEmailContact), type))
		return soap->error;
	if (soap_out_string(soap, "srcEmail", -1, &a->srcEmail, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "destEmail", -1, &a->destEmail, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "note", -1, &a->note, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__ActivityEmailContact * SOAP_FMAC4 soap_get_vin__ActivityEmailContact(struct soap *soap, struct vin__ActivityEmailContact *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ActivityEmailContact(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityEmailContact * SOAP_FMAC4 soap_in_vin__ActivityEmailContact(struct soap *soap, const char *tag, struct vin__ActivityEmailContact *a, const char *type)
{
	size_t soap_flag_srcEmail = 1;
	size_t soap_flag_destEmail = 1;
	size_t soap_flag_note = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__ActivityEmailContact *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ActivityEmailContact, sizeof(struct vin__ActivityEmailContact), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__ActivityEmailContact(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srcEmail && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "srcEmail", &a->srcEmail, "xsd:string"))
				{	soap_flag_srcEmail--;
					continue;
				}
			if (soap_flag_destEmail && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "destEmail", &a->destEmail, "xsd:string"))
				{	soap_flag_destEmail--;
					continue;
				}
			if (soap_flag_note && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "note", &a->note, "xsd:string"))
				{	soap_flag_note--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityEmailContact *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ActivityEmailContact, 0, sizeof(struct vin__ActivityEmailContact), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ActivityPhoneContact(struct soap *soap, struct vin__ActivityPhoneContact *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->srcPhoneNumber);
	soap_default_string(soap, &a->destPhoneNumber);
	soap_default_string(soap, &a->cidPhoneNumber);
	soap_default_string(soap, &a->aniPhoneNumber);
	a->durationSeconds = NULL;
	soap_default_string(soap, &a->note);
	soap_default_vin__ActivityCallType(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__ActivityPhoneContact(struct soap *soap, const struct vin__ActivityPhoneContact *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->srcPhoneNumber);
	soap_serialize_string(soap, &a->destPhoneNumber);
	soap_serialize_string(soap, &a->cidPhoneNumber);
	soap_serialize_string(soap, &a->aniPhoneNumber);
	soap_serialize_PointerToint(soap, &a->durationSeconds);
	soap_serialize_string(soap, &a->note);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ActivityPhoneContact(struct soap *soap, const struct vin__ActivityPhoneContact *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ActivityPhoneContact);
	if (soap_out_vin__ActivityPhoneContact(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ActivityPhoneContact(struct soap *soap, const char *tag, int id, const struct vin__ActivityPhoneContact *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ActivityPhoneContact), type))
		return soap->error;
	if (soap_out_string(soap, "srcPhoneNumber", -1, &a->srcPhoneNumber, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "destPhoneNumber", -1, &a->destPhoneNumber, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "cidPhoneNumber", -1, &a->cidPhoneNumber, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "aniPhoneNumber", -1, &a->aniPhoneNumber, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToint(soap, "durationSeconds", -1, &a->durationSeconds, "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "note", -1, &a->note, "xsd:string"))
		return soap->error;
	if (soap_out_vin__ActivityCallType(soap, "type", -1, &a->type, "vin:ActivityCallType"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__ActivityPhoneContact * SOAP_FMAC4 soap_get_vin__ActivityPhoneContact(struct soap *soap, struct vin__ActivityPhoneContact *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ActivityPhoneContact(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityPhoneContact * SOAP_FMAC4 soap_in_vin__ActivityPhoneContact(struct soap *soap, const char *tag, struct vin__ActivityPhoneContact *a, const char *type)
{
	size_t soap_flag_srcPhoneNumber = 1;
	size_t soap_flag_destPhoneNumber = 1;
	size_t soap_flag_cidPhoneNumber = 1;
	size_t soap_flag_aniPhoneNumber = 1;
	size_t soap_flag_durationSeconds = 1;
	size_t soap_flag_note = 1;
	size_t soap_flag_type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__ActivityPhoneContact *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ActivityPhoneContact, sizeof(struct vin__ActivityPhoneContact), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__ActivityPhoneContact(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_srcPhoneNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "srcPhoneNumber", &a->srcPhoneNumber, "xsd:string"))
				{	soap_flag_srcPhoneNumber--;
					continue;
				}
			if (soap_flag_destPhoneNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "destPhoneNumber", &a->destPhoneNumber, "xsd:string"))
				{	soap_flag_destPhoneNumber--;
					continue;
				}
			if (soap_flag_cidPhoneNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cidPhoneNumber", &a->cidPhoneNumber, "xsd:string"))
				{	soap_flag_cidPhoneNumber--;
					continue;
				}
			if (soap_flag_aniPhoneNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "aniPhoneNumber", &a->aniPhoneNumber, "xsd:string"))
				{	soap_flag_aniPhoneNumber--;
					continue;
				}
			if (soap_flag_durationSeconds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "durationSeconds", &a->durationSeconds, "xsd:int"))
				{	soap_flag_durationSeconds--;
					continue;
				}
			if (soap_flag_note && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "note", &a->note, "xsd:string"))
				{	soap_flag_note--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_vin__ActivityCallType(soap, "type", &a->type, "vin:ActivityCallType"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityPhoneContact *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ActivityPhoneContact, 0, sizeof(struct vin__ActivityPhoneContact), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ActivityURIView(struct soap *soap, struct vin__ActivityURIView *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->ip);
	soap_default_xsd__anyURI(soap, &a->uri);
	a->size = NULL;
	a->bytesTransferred = NULL;
	a->transferTime = NULL;
	soap_default_string(soap, &a->description);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__ActivityURIView(struct soap *soap, const struct vin__ActivityURIView *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->ip);
	soap_serialize_xsd__anyURI(soap, &a->uri);
	soap_serialize_PointerToint(soap, &a->size);
	soap_serialize_PointerToint(soap, &a->bytesTransferred);
	soap_serialize_PointerToint(soap, &a->transferTime);
	soap_serialize_string(soap, &a->description);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ActivityURIView(struct soap *soap, const struct vin__ActivityURIView *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ActivityURIView);
	if (soap_out_vin__ActivityURIView(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ActivityURIView(struct soap *soap, const char *tag, int id, const struct vin__ActivityURIView *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ActivityURIView), type))
		return soap->error;
	if (soap_out_string(soap, "ip", -1, &a->ip, "xsd:string"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "uri", -1, &a->uri, "xsd:anyURI"))
		return soap->error;
	if (soap_out_PointerToint(soap, "size", -1, &a->size, "xsd:int"))
		return soap->error;
	if (soap_out_PointerToint(soap, "bytesTransferred", -1, &a->bytesTransferred, "xsd:int"))
		return soap->error;
	if (soap_out_PointerToint(soap, "transferTime", -1, &a->transferTime, "xsd:int"))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__ActivityURIView * SOAP_FMAC4 soap_get_vin__ActivityURIView(struct soap *soap, struct vin__ActivityURIView *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ActivityURIView(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityURIView * SOAP_FMAC4 soap_in_vin__ActivityURIView(struct soap *soap, const char *tag, struct vin__ActivityURIView *a, const char *type)
{
	size_t soap_flag_ip = 1;
	size_t soap_flag_uri = 1;
	size_t soap_flag_size = 1;
	size_t soap_flag_bytesTransferred = 1;
	size_t soap_flag_transferTime = 1;
	size_t soap_flag_description = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__ActivityURIView *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ActivityURIView, sizeof(struct vin__ActivityURIView), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__ActivityURIView(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ip && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ip", &a->ip, "xsd:string"))
				{	soap_flag_ip--;
					continue;
				}
			if (soap_flag_uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "uri", &a->uri, "xsd:anyURI"))
				{	soap_flag_uri--;
					continue;
				}
			if (soap_flag_size && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "size", &a->size, "xsd:int"))
				{	soap_flag_size--;
					continue;
				}
			if (soap_flag_bytesTransferred && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "bytesTransferred", &a->bytesTransferred, "xsd:int"))
				{	soap_flag_bytesTransferred--;
					continue;
				}
			if (soap_flag_transferTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "transferTime", &a->transferTime, "xsd:int"))
				{	soap_flag_transferTime--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityURIView *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ActivityURIView, 0, sizeof(struct vin__ActivityURIView), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uri > 0 || soap_flag_description > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ActivityLogout(struct soap *soap, struct vin__ActivityLogout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->ip);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__ActivityLogout(struct soap *soap, const struct vin__ActivityLogout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->ip);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ActivityLogout(struct soap *soap, const struct vin__ActivityLogout *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ActivityLogout);
	if (soap_out_vin__ActivityLogout(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ActivityLogout(struct soap *soap, const char *tag, int id, const struct vin__ActivityLogout *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ActivityLogout), type))
		return soap->error;
	if (soap_out_string(soap, "ip", -1, &a->ip, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__ActivityLogout * SOAP_FMAC4 soap_get_vin__ActivityLogout(struct soap *soap, struct vin__ActivityLogout *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ActivityLogout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityLogout * SOAP_FMAC4 soap_in_vin__ActivityLogout(struct soap *soap, const char *tag, struct vin__ActivityLogout *a, const char *type)
{
	size_t soap_flag_ip = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__ActivityLogout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ActivityLogout, sizeof(struct vin__ActivityLogout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__ActivityLogout(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ip && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ip", &a->ip, "xsd:string"))
				{	soap_flag_ip--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityLogout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ActivityLogout, 0, sizeof(struct vin__ActivityLogout), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ActivityLogin(struct soap *soap, struct vin__ActivityLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->ip);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__ActivityLogin(struct soap *soap, const struct vin__ActivityLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->ip);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ActivityLogin(struct soap *soap, const struct vin__ActivityLogin *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ActivityLogin);
	if (soap_out_vin__ActivityLogin(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ActivityLogin(struct soap *soap, const char *tag, int id, const struct vin__ActivityLogin *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ActivityLogin), type))
		return soap->error;
	if (soap_out_string(soap, "ip", -1, &a->ip, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__ActivityLogin * SOAP_FMAC4 soap_get_vin__ActivityLogin(struct soap *soap, struct vin__ActivityLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ActivityLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityLogin * SOAP_FMAC4 soap_in_vin__ActivityLogin(struct soap *soap, const char *tag, struct vin__ActivityLogin *a, const char *type)
{
	size_t soap_flag_ip = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__ActivityLogin *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ActivityLogin, sizeof(struct vin__ActivityLogin), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__ActivityLogin(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ip && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ip", &a->ip, "xsd:string"))
				{	soap_flag_ip--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityLogin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ActivityLogin, 0, sizeof(struct vin__ActivityLogin), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__ActivityTypeArg(struct soap *soap, struct vin__ActivityTypeArg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->loginArgs = NULL;
	a->logoutArgs = NULL;
	a->uriviewArgs = NULL;
	a->phoneArgs = NULL;
	a->emailArgs = NULL;
	a->fulfillmentArgs = NULL;
	a->usageArgs = NULL;
	a->namedvalueArgs = NULL;
	a->cancellationArgs = NULL;
	a->noteArgs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__ActivityTypeArg(struct soap *soap, const struct vin__ActivityTypeArg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTovin__ActivityLogin(soap, &a->loginArgs);
	soap_serialize_PointerTovin__ActivityLogout(soap, &a->logoutArgs);
	soap_serialize_PointerTovin__ActivityURIView(soap, &a->uriviewArgs);
	soap_serialize_PointerTovin__ActivityPhoneContact(soap, &a->phoneArgs);
	soap_serialize_PointerTovin__ActivityEmailContact(soap, &a->emailArgs);
	soap_serialize_PointerTovin__ActivityFulfillment(soap, &a->fulfillmentArgs);
	soap_serialize_PointerTovin__ActivityUsage(soap, &a->usageArgs);
	soap_serialize_PointerTovin__ActivityNamedValue(soap, &a->namedvalueArgs);
	soap_serialize_PointerTovin__ActivityCancellation(soap, &a->cancellationArgs);
	soap_serialize_PointerTovin__ActivityNote(soap, &a->noteArgs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__ActivityTypeArg(struct soap *soap, const struct vin__ActivityTypeArg *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__ActivityTypeArg);
	if (soap_out_vin__ActivityTypeArg(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__ActivityTypeArg(struct soap *soap, const char *tag, int id, const struct vin__ActivityTypeArg *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__ActivityTypeArg), type))
		return soap->error;
	if (soap_out_PointerTovin__ActivityLogin(soap, "loginArgs", -1, &a->loginArgs, "vin:ActivityLogin"))
		return soap->error;
	if (soap_out_PointerTovin__ActivityLogout(soap, "logoutArgs", -1, &a->logoutArgs, "vin:ActivityLogout"))
		return soap->error;
	if (soap_out_PointerTovin__ActivityURIView(soap, "uriviewArgs", -1, &a->uriviewArgs, "vin:ActivityURIView"))
		return soap->error;
	if (soap_out_PointerTovin__ActivityPhoneContact(soap, "phoneArgs", -1, &a->phoneArgs, "vin:ActivityPhoneContact"))
		return soap->error;
	if (soap_out_PointerTovin__ActivityEmailContact(soap, "emailArgs", -1, &a->emailArgs, "vin:ActivityEmailContact"))
		return soap->error;
	if (soap_out_PointerTovin__ActivityFulfillment(soap, "fulfillmentArgs", -1, &a->fulfillmentArgs, "vin:ActivityFulfillment"))
		return soap->error;
	if (soap_out_PointerTovin__ActivityUsage(soap, "usageArgs", -1, &a->usageArgs, "vin:ActivityUsage"))
		return soap->error;
	if (soap_out_PointerTovin__ActivityNamedValue(soap, "namedvalueArgs", -1, &a->namedvalueArgs, "vin:ActivityNamedValue"))
		return soap->error;
	if (soap_out_PointerTovin__ActivityCancellation(soap, "cancellationArgs", -1, &a->cancellationArgs, "vin:ActivityCancellation"))
		return soap->error;
	if (soap_out_PointerTovin__ActivityNote(soap, "noteArgs", -1, &a->noteArgs, "vin:ActivityNote"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__ActivityTypeArg * SOAP_FMAC4 soap_get_vin__ActivityTypeArg(struct soap *soap, struct vin__ActivityTypeArg *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__ActivityTypeArg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityTypeArg * SOAP_FMAC4 soap_in_vin__ActivityTypeArg(struct soap *soap, const char *tag, struct vin__ActivityTypeArg *a, const char *type)
{
	size_t soap_flag_loginArgs = 1;
	size_t soap_flag_logoutArgs = 1;
	size_t soap_flag_uriviewArgs = 1;
	size_t soap_flag_phoneArgs = 1;
	size_t soap_flag_emailArgs = 1;
	size_t soap_flag_fulfillmentArgs = 1;
	size_t soap_flag_usageArgs = 1;
	size_t soap_flag_namedvalueArgs = 1;
	size_t soap_flag_cancellationArgs = 1;
	size_t soap_flag_noteArgs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__ActivityTypeArg *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__ActivityTypeArg, sizeof(struct vin__ActivityTypeArg), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__ActivityTypeArg(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loginArgs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__ActivityLogin(soap, "loginArgs", &a->loginArgs, "vin:ActivityLogin"))
				{	soap_flag_loginArgs--;
					continue;
				}
			if (soap_flag_logoutArgs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__ActivityLogout(soap, "logoutArgs", &a->logoutArgs, "vin:ActivityLogout"))
				{	soap_flag_logoutArgs--;
					continue;
				}
			if (soap_flag_uriviewArgs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__ActivityURIView(soap, "uriviewArgs", &a->uriviewArgs, "vin:ActivityURIView"))
				{	soap_flag_uriviewArgs--;
					continue;
				}
			if (soap_flag_phoneArgs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__ActivityPhoneContact(soap, "phoneArgs", &a->phoneArgs, "vin:ActivityPhoneContact"))
				{	soap_flag_phoneArgs--;
					continue;
				}
			if (soap_flag_emailArgs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__ActivityEmailContact(soap, "emailArgs", &a->emailArgs, "vin:ActivityEmailContact"))
				{	soap_flag_emailArgs--;
					continue;
				}
			if (soap_flag_fulfillmentArgs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__ActivityFulfillment(soap, "fulfillmentArgs", &a->fulfillmentArgs, "vin:ActivityFulfillment"))
				{	soap_flag_fulfillmentArgs--;
					continue;
				}
			if (soap_flag_usageArgs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__ActivityUsage(soap, "usageArgs", &a->usageArgs, "vin:ActivityUsage"))
				{	soap_flag_usageArgs--;
					continue;
				}
			if (soap_flag_namedvalueArgs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__ActivityNamedValue(soap, "namedvalueArgs", &a->namedvalueArgs, "vin:ActivityNamedValue"))
				{	soap_flag_namedvalueArgs--;
					continue;
				}
			if (soap_flag_cancellationArgs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__ActivityCancellation(soap, "cancellationArgs", &a->cancellationArgs, "vin:ActivityCancellation"))
				{	soap_flag_cancellationArgs--;
					continue;
				}
			if (soap_flag_noteArgs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__ActivityNote(soap, "noteArgs", &a->noteArgs, "vin:ActivityNote"))
				{	soap_flag_noteArgs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityTypeArg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__ActivityTypeArg, 0, sizeof(struct vin__ActivityTypeArg), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfTokenAmounts(struct soap *soap, struct ArrayOfTokenAmounts *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfTokenAmounts(struct soap *soap, struct ArrayOfTokenAmounts const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfTokenAmounts))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__TokenAmount(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfTokenAmounts(struct soap *soap, const struct ArrayOfTokenAmounts *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfTokenAmounts);
	if (soap_out_ArrayOfTokenAmounts(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfTokenAmounts(struct soap *soap, const char *tag, int id, const struct ArrayOfTokenAmounts *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:TokenAmount", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfTokenAmounts);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__TokenAmount(soap, "item", -1, &a->__ptr[i], "vin:TokenAmount");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfTokenAmounts * SOAP_FMAC4 soap_get_ArrayOfTokenAmounts(struct soap *soap, struct ArrayOfTokenAmounts *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfTokenAmounts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfTokenAmounts * SOAP_FMAC4 soap_in_ArrayOfTokenAmounts(struct soap *soap, const char *tag, struct ArrayOfTokenAmounts *a, const char *type)
{	int i, j;
	struct vin__TokenAmount **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfTokenAmounts *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfTokenAmounts, sizeof(struct ArrayOfTokenAmounts), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfTokenAmounts(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__TokenAmount **)soap_malloc(soap, sizeof(struct vin__TokenAmount *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__TokenAmount(soap, NULL, a->__ptr + i, "vin:TokenAmount"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__TokenAmount **)soap_push_block(soap, NULL, sizeof(struct vin__TokenAmount *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__TokenAmount(soap, NULL, p, "vin:TokenAmount"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__TokenAmount **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfTokenAmounts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfTokenAmounts, 0, sizeof(struct ArrayOfTokenAmounts), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfTaxExemptions(struct soap *soap, struct ArrayOfTaxExemptions *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfTaxExemptions(struct soap *soap, struct ArrayOfTaxExemptions const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfTaxExemptions))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__TaxExemption(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfTaxExemptions(struct soap *soap, const struct ArrayOfTaxExemptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfTaxExemptions);
	if (soap_out_ArrayOfTaxExemptions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfTaxExemptions(struct soap *soap, const char *tag, int id, const struct ArrayOfTaxExemptions *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:TaxExemption", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfTaxExemptions);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__TaxExemption(soap, "item", -1, &a->__ptr[i], "vin:TaxExemption");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfTaxExemptions * SOAP_FMAC4 soap_get_ArrayOfTaxExemptions(struct soap *soap, struct ArrayOfTaxExemptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfTaxExemptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfTaxExemptions * SOAP_FMAC4 soap_in_ArrayOfTaxExemptions(struct soap *soap, const char *tag, struct ArrayOfTaxExemptions *a, const char *type)
{	int i, j;
	struct vin__TaxExemption **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfTaxExemptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfTaxExemptions, sizeof(struct ArrayOfTaxExemptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfTaxExemptions(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__TaxExemption **)soap_malloc(soap, sizeof(struct vin__TaxExemption *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__TaxExemption(soap, NULL, a->__ptr + i, "vin:TaxExemption"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__TaxExemption **)soap_push_block(soap, NULL, sizeof(struct vin__TaxExemption *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__TaxExemption(soap, NULL, p, "vin:TaxExemption"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__TaxExemption **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfTaxExemptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfTaxExemptions, 0, sizeof(struct ArrayOfTaxExemptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfNameValuePairs(struct soap *soap, struct ArrayOfNameValuePairs *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfNameValuePairs(struct soap *soap, struct ArrayOfNameValuePairs const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfNameValuePairs))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__NameValuePair(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfNameValuePairs(struct soap *soap, const struct ArrayOfNameValuePairs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfNameValuePairs);
	if (soap_out_ArrayOfNameValuePairs(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfNameValuePairs(struct soap *soap, const char *tag, int id, const struct ArrayOfNameValuePairs *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:NameValuePair", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfNameValuePairs);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__NameValuePair(soap, "item", -1, &a->__ptr[i], "vin:NameValuePair");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfNameValuePairs * SOAP_FMAC4 soap_get_ArrayOfNameValuePairs(struct soap *soap, struct ArrayOfNameValuePairs *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfNameValuePairs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfNameValuePairs * SOAP_FMAC4 soap_in_ArrayOfNameValuePairs(struct soap *soap, const char *tag, struct ArrayOfNameValuePairs *a, const char *type)
{	int i, j;
	struct vin__NameValuePair **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfNameValuePairs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfNameValuePairs, sizeof(struct ArrayOfNameValuePairs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfNameValuePairs(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__NameValuePair **)soap_malloc(soap, sizeof(struct vin__NameValuePair *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__NameValuePair(soap, NULL, a->__ptr + i, "vin:NameValuePair"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__NameValuePair **)soap_push_block(soap, NULL, sizeof(struct vin__NameValuePair *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__NameValuePair(soap, NULL, p, "vin:NameValuePair"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__NameValuePair **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfNameValuePairs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfNameValuePairs, 0, sizeof(struct ArrayOfNameValuePairs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ArrayOfPaymentMethods(struct soap *soap, struct ArrayOfPaymentMethods *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ArrayOfPaymentMethods(struct soap *soap, struct ArrayOfPaymentMethods const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ArrayOfPaymentMethods))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTovin__PaymentMethod(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ArrayOfPaymentMethods(struct soap *soap, const struct ArrayOfPaymentMethods *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ArrayOfPaymentMethods);
	if (soap_out_ArrayOfPaymentMethods(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfPaymentMethods(struct soap *soap, const char *tag, int id, const struct ArrayOfPaymentMethods *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "vin:PaymentMethod", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfPaymentMethods);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTovin__PaymentMethod(soap, "item", -1, &a->__ptr[i], "vin:PaymentMethod");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ArrayOfPaymentMethods * SOAP_FMAC4 soap_get_ArrayOfPaymentMethods(struct soap *soap, struct ArrayOfPaymentMethods *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfPaymentMethods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfPaymentMethods * SOAP_FMAC4 soap_in_ArrayOfPaymentMethods(struct soap *soap, const char *tag, struct ArrayOfPaymentMethods *a, const char *type)
{	int i, j;
	struct vin__PaymentMethod **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ArrayOfPaymentMethods *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfPaymentMethods, sizeof(struct ArrayOfPaymentMethods), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ArrayOfPaymentMethods(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct vin__PaymentMethod **)soap_malloc(soap, sizeof(struct vin__PaymentMethod *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTovin__PaymentMethod(soap, NULL, a->__ptr + i, "vin:PaymentMethod"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct vin__PaymentMethod **)soap_push_block(soap, NULL, sizeof(struct vin__PaymentMethod *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTovin__PaymentMethod(soap, NULL, p, "vin:PaymentMethod"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct vin__PaymentMethod **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ArrayOfPaymentMethods *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfPaymentMethods, 0, sizeof(struct ArrayOfPaymentMethods), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__Address(struct soap *soap, struct vin__Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->VID);
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->addr1);
	soap_default_string(soap, &a->addr2);
	soap_default_string(soap, &a->addr3);
	soap_default_string(soap, &a->city);
	soap_default_string(soap, &a->county);
	soap_default_string(soap, &a->district);
	soap_default_string(soap, &a->postalCode);
	soap_default_string(soap, &a->country);
	soap_default_string(soap, &a->phone);
	soap_default_string(soap, &a->fax);
	soap_default_xsd__decimal(soap, &a->latitude);
	soap_default_xsd__decimal(soap, &a->longitude);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__Address(struct soap *soap, const struct vin__Address *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->VID);
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->addr1);
	soap_serialize_string(soap, &a->addr2);
	soap_serialize_string(soap, &a->addr3);
	soap_serialize_string(soap, &a->city);
	soap_serialize_string(soap, &a->county);
	soap_serialize_string(soap, &a->district);
	soap_serialize_string(soap, &a->postalCode);
	soap_serialize_string(soap, &a->country);
	soap_serialize_string(soap, &a->phone);
	soap_serialize_string(soap, &a->fax);
	soap_serialize_xsd__decimal(soap, &a->latitude);
	soap_serialize_xsd__decimal(soap, &a->longitude);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__Address(struct soap *soap, const struct vin__Address *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__Address);
	if (soap_out_vin__Address(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__Address(struct soap *soap, const char *tag, int id, const struct vin__Address *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__Address), type))
		return soap->error;
	if (soap_out_string(soap, "VID", -1, &a->VID, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "addr1", -1, &a->addr1, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "addr2", -1, &a->addr2, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "addr3", -1, &a->addr3, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "city", -1, &a->city, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "county", -1, &a->county, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "district", -1, &a->district, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "postalCode", -1, &a->postalCode, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "country", -1, &a->country, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "phone", -1, &a->phone, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "fax", -1, &a->fax, "xsd:string"))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "latitude", -1, &a->latitude, "xsd:decimal"))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "longitude", -1, &a->longitude, "xsd:decimal"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__Address * SOAP_FMAC4 soap_get_vin__Address(struct soap *soap, struct vin__Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Address * SOAP_FMAC4 soap_in_vin__Address(struct soap *soap, const char *tag, struct vin__Address *a, const char *type)
{
	size_t soap_flag_VID = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_addr1 = 1;
	size_t soap_flag_addr2 = 1;
	size_t soap_flag_addr3 = 1;
	size_t soap_flag_city = 1;
	size_t soap_flag_county = 1;
	size_t soap_flag_district = 1;
	size_t soap_flag_postalCode = 1;
	size_t soap_flag_country = 1;
	size_t soap_flag_phone = 1;
	size_t soap_flag_fax = 1;
	size_t soap_flag_latitude = 1;
	size_t soap_flag_longitude = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__Address *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__Address, sizeof(struct vin__Address), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__Address(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "VID", &a->VID, "xsd:string"))
				{	soap_flag_VID--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_addr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "addr1", &a->addr1, "xsd:string"))
				{	soap_flag_addr1--;
					continue;
				}
			if (soap_flag_addr2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "addr2", &a->addr2, "xsd:string"))
				{	soap_flag_addr2--;
					continue;
				}
			if (soap_flag_addr3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "addr3", &a->addr3, "xsd:string"))
				{	soap_flag_addr3--;
					continue;
				}
			if (soap_flag_city && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "city", &a->city, "xsd:string"))
				{	soap_flag_city--;
					continue;
				}
			if (soap_flag_county && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "county", &a->county, "xsd:string"))
				{	soap_flag_county--;
					continue;
				}
			if (soap_flag_district && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "district", &a->district, "xsd:string"))
				{	soap_flag_district--;
					continue;
				}
			if (soap_flag_postalCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "postalCode", &a->postalCode, "xsd:string"))
				{	soap_flag_postalCode--;
					continue;
				}
			if (soap_flag_country && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "country", &a->country, "xsd:string"))
				{	soap_flag_country--;
					continue;
				}
			if (soap_flag_phone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "phone", &a->phone, "xsd:string"))
				{	soap_flag_phone--;
					continue;
				}
			if (soap_flag_fax && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fax", &a->fax, "xsd:string"))
				{	soap_flag_fax--;
					continue;
				}
			if (soap_flag_latitude && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "latitude", &a->latitude, "xsd:decimal"))
				{	soap_flag_latitude--;
					continue;
				}
			if (soap_flag_longitude && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__decimal(soap, "longitude", &a->longitude, "xsd:decimal"))
				{	soap_flag_longitude--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__Address, 0, sizeof(struct vin__Address), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_vin__Account(struct soap *soap, struct vin__Account *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->VID);
	soap_default_string(soap, &a->merchantAccountId);
	soap_default_string(soap, &a->emailAddress);
	a->emailTypePreference = NULL;
	soap_default_string(soap, &a->preferredLanguage);
	a->warnBeforeAutobilling = NULL;
	soap_default_string(soap, &a->company);
	soap_default_string(soap, &a->name);
	a->shippingAddress = NULL;
	a->paymentMethods = NULL;
	a->nameValues = NULL;
	a->taxExemptions = NULL;
	a->tokenBalances = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_vin__Account(struct soap *soap, const struct vin__Account *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->VID);
	soap_serialize_string(soap, &a->merchantAccountId);
	soap_serialize_string(soap, &a->emailAddress);
	soap_serialize_PointerTovin__EmailPreference(soap, &a->emailTypePreference);
	soap_serialize_string(soap, &a->preferredLanguage);
	soap_serialize_PointerToxsd__boolean(soap, &a->warnBeforeAutobilling);
	soap_serialize_string(soap, &a->company);
	soap_serialize_string(soap, &a->name);
	soap_serialize_PointerTovin__Address(soap, &a->shippingAddress);
	soap_serialize_PointerToArrayOfPaymentMethods(soap, &a->paymentMethods);
	soap_serialize_PointerToArrayOfNameValuePairs(soap, &a->nameValues);
	soap_serialize_PointerToArrayOfTaxExemptions(soap, &a->taxExemptions);
	soap_serialize_PointerToArrayOfTokenAmounts(soap, &a->tokenBalances);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_vin__Account(struct soap *soap, const struct vin__Account *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_vin__Account);
	if (soap_out_vin__Account(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_vin__Account(struct soap *soap, const char *tag, int id, const struct vin__Account *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_vin__Account), type))
		return soap->error;
	if (soap_out_string(soap, "VID", -1, &a->VID, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "merchantAccountId", -1, &a->merchantAccountId, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "emailAddress", -1, &a->emailAddress, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__EmailPreference(soap, "emailTypePreference", -1, &a->emailTypePreference, "vin:EmailPreference"))
		return soap->error;
	if (soap_out_string(soap, "preferredLanguage", -1, &a->preferredLanguage, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "warnBeforeAutobilling", -1, &a->warnBeforeAutobilling, "xsd:boolean"))
		return soap->error;
	if (soap_out_string(soap, "company", -1, &a->company, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, "xsd:string"))
		return soap->error;
	if (soap_out_PointerTovin__Address(soap, "shippingAddress", -1, &a->shippingAddress, "vin:Address"))
		return soap->error;
	if (soap_out_PointerToArrayOfPaymentMethods(soap, "paymentMethods", -1, &a->paymentMethods, "vin:PaymentMethod"))
		return soap->error;
	if (soap_out_PointerToArrayOfNameValuePairs(soap, "nameValues", -1, &a->nameValues, "vin:NameValuePair"))
		return soap->error;
	if (soap_out_PointerToArrayOfTaxExemptions(soap, "taxExemptions", -1, &a->taxExemptions, "vin:TaxExemption"))
		return soap->error;
	if (soap_out_PointerToArrayOfTokenAmounts(soap, "tokenBalances", -1, &a->tokenBalances, "vin:TokenAmount"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct vin__Account * SOAP_FMAC4 soap_get_vin__Account(struct soap *soap, struct vin__Account *p, const char *tag, const char *type)
{
	if ((p = soap_in_vin__Account(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Account * SOAP_FMAC4 soap_in_vin__Account(struct soap *soap, const char *tag, struct vin__Account *a, const char *type)
{
	size_t soap_flag_VID = 1;
	size_t soap_flag_merchantAccountId = 1;
	size_t soap_flag_emailAddress = 1;
	size_t soap_flag_emailTypePreference = 1;
	size_t soap_flag_preferredLanguage = 1;
	size_t soap_flag_warnBeforeAutobilling = 1;
	size_t soap_flag_company = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_shippingAddress = 1;
	size_t soap_flag_paymentMethods = 1;
	size_t soap_flag_nameValues = 1;
	size_t soap_flag_taxExemptions = 1;
	size_t soap_flag_tokenBalances = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct vin__Account *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_vin__Account, sizeof(struct vin__Account), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_vin__Account(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "VID", &a->VID, "xsd:string"))
				{	soap_flag_VID--;
					continue;
				}
			if (soap_flag_merchantAccountId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "merchantAccountId", &a->merchantAccountId, "xsd:string"))
				{	soap_flag_merchantAccountId--;
					continue;
				}
			if (soap_flag_emailAddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "emailAddress", &a->emailAddress, "xsd:string"))
				{	soap_flag_emailAddress--;
					continue;
				}
			if (soap_flag_emailTypePreference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__EmailPreference(soap, "emailTypePreference", &a->emailTypePreference, "vin:EmailPreference"))
				{	soap_flag_emailTypePreference--;
					continue;
				}
			if (soap_flag_preferredLanguage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "preferredLanguage", &a->preferredLanguage, "xsd:string"))
				{	soap_flag_preferredLanguage--;
					continue;
				}
			if (soap_flag_warnBeforeAutobilling && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "warnBeforeAutobilling", &a->warnBeforeAutobilling, "xsd:boolean"))
				{	soap_flag_warnBeforeAutobilling--;
					continue;
				}
			if (soap_flag_company && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "company", &a->company, "xsd:string"))
				{	soap_flag_company--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_shippingAddress && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTovin__Address(soap, "shippingAddress", &a->shippingAddress, "vin:Address"))
				{	soap_flag_shippingAddress--;
					continue;
				}
			if (soap_flag_paymentMethods && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfPaymentMethods(soap, "paymentMethods", &a->paymentMethods, "vin:PaymentMethod"))
				{	soap_flag_paymentMethods--;
					continue;
				}
			if (soap_flag_nameValues && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfNameValuePairs(soap, "nameValues", &a->nameValues, "vin:NameValuePair"))
				{	soap_flag_nameValues--;
					continue;
				}
			if (soap_flag_taxExemptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTaxExemptions(soap, "taxExemptions", &a->taxExemptions, "vin:TaxExemption"))
				{	soap_flag_taxExemptions--;
					continue;
				}
			if (soap_flag_tokenBalances && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfTokenAmounts(soap, "tokenBalances", &a->tokenBalances, "vin:TokenAmount"))
				{	soap_flag_tokenBalances--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct vin__Account *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_vin__Account, 0, sizeof(struct vin__Account), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrn__scoreResponse(struct soap *soap, struct trn__scoreResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_trn__scoreResponse))
		soap_serialize_trn__scoreResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrn__scoreResponse(struct soap *soap, struct trn__scoreResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrn__scoreResponse);
	if (soap_out_PointerTotrn__scoreResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrn__scoreResponse(struct soap *soap, const char *tag, int id, struct trn__scoreResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trn__scoreResponse);
	if (id < 0)
		return soap->error;
	return soap_out_trn__scoreResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trn__scoreResponse ** SOAP_FMAC4 soap_get_PointerTotrn__scoreResponse(struct soap *soap, struct trn__scoreResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrn__scoreResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__scoreResponse ** SOAP_FMAC4 soap_in_PointerTotrn__scoreResponse(struct soap *soap, const char *tag, struct trn__scoreResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trn__scoreResponse **)soap_malloc(soap, sizeof(struct trn__scoreResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trn__scoreResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trn__scoreResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trn__scoreResponse, sizeof(struct trn__scoreResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfScoreCodes(struct soap *soap, struct ArrayOfScoreCodes *const*a)
{
	if (*a)
		soap_serialize_ArrayOfScoreCodes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfScoreCodes(struct soap *soap, struct ArrayOfScoreCodes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfScoreCodes);
	if (soap_out_PointerToArrayOfScoreCodes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfScoreCodes(struct soap *soap, const char *tag, int id, struct ArrayOfScoreCodes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfScoreCodes);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfScoreCodes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfScoreCodes ** SOAP_FMAC4 soap_get_PointerToArrayOfScoreCodes(struct soap *soap, struct ArrayOfScoreCodes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfScoreCodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfScoreCodes ** SOAP_FMAC4 soap_in_PointerToArrayOfScoreCodes(struct soap *soap, const char *tag, struct ArrayOfScoreCodes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfScoreCodes **)soap_malloc(soap, sizeof(struct ArrayOfScoreCodes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfScoreCodes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfScoreCodes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfScoreCodes, sizeof(struct ArrayOfScoreCodes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrn__reportResponse(struct soap *soap, struct trn__reportResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_trn__reportResponse))
		soap_serialize_trn__reportResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrn__reportResponse(struct soap *soap, struct trn__reportResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrn__reportResponse);
	if (soap_out_PointerTotrn__reportResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrn__reportResponse(struct soap *soap, const char *tag, int id, struct trn__reportResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trn__reportResponse);
	if (id < 0)
		return soap->error;
	return soap_out_trn__reportResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trn__reportResponse ** SOAP_FMAC4 soap_get_PointerTotrn__reportResponse(struct soap *soap, struct trn__reportResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrn__reportResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__reportResponse ** SOAP_FMAC4 soap_in_PointerTotrn__reportResponse(struct soap *soap, const char *tag, struct trn__reportResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trn__reportResponse **)soap_malloc(soap, sizeof(struct trn__reportResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trn__reportResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trn__reportResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trn__reportResponse, sizeof(struct trn__reportResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrn__authCaptureResponse(struct soap *soap, struct trn__authCaptureResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_trn__authCaptureResponse))
		soap_serialize_trn__authCaptureResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrn__authCaptureResponse(struct soap *soap, struct trn__authCaptureResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrn__authCaptureResponse);
	if (soap_out_PointerTotrn__authCaptureResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrn__authCaptureResponse(struct soap *soap, const char *tag, int id, struct trn__authCaptureResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trn__authCaptureResponse);
	if (id < 0)
		return soap->error;
	return soap_out_trn__authCaptureResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trn__authCaptureResponse ** SOAP_FMAC4 soap_get_PointerTotrn__authCaptureResponse(struct soap *soap, struct trn__authCaptureResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrn__authCaptureResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__authCaptureResponse ** SOAP_FMAC4 soap_in_PointerTotrn__authCaptureResponse(struct soap *soap, const char *tag, struct trn__authCaptureResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trn__authCaptureResponse **)soap_malloc(soap, sizeof(struct trn__authCaptureResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trn__authCaptureResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trn__authCaptureResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trn__authCaptureResponse, sizeof(struct trn__authCaptureResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrn__cancelResponse(struct soap *soap, struct trn__cancelResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_trn__cancelResponse))
		soap_serialize_trn__cancelResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrn__cancelResponse(struct soap *soap, struct trn__cancelResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrn__cancelResponse);
	if (soap_out_PointerTotrn__cancelResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrn__cancelResponse(struct soap *soap, const char *tag, int id, struct trn__cancelResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trn__cancelResponse);
	if (id < 0)
		return soap->error;
	return soap_out_trn__cancelResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trn__cancelResponse ** SOAP_FMAC4 soap_get_PointerTotrn__cancelResponse(struct soap *soap, struct trn__cancelResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrn__cancelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__cancelResponse ** SOAP_FMAC4 soap_in_PointerTotrn__cancelResponse(struct soap *soap, const char *tag, struct trn__cancelResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trn__cancelResponse **)soap_malloc(soap, sizeof(struct trn__cancelResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trn__cancelResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trn__cancelResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trn__cancelResponse, sizeof(struct trn__cancelResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCancelResults(struct soap *soap, struct ArrayOfCancelResults *const*a)
{
	if (*a)
		soap_serialize_ArrayOfCancelResults(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCancelResults(struct soap *soap, struct ArrayOfCancelResults *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCancelResults);
	if (soap_out_PointerToArrayOfCancelResults(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCancelResults(struct soap *soap, const char *tag, int id, struct ArrayOfCancelResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfCancelResults);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfCancelResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfCancelResults ** SOAP_FMAC4 soap_get_PointerToArrayOfCancelResults(struct soap *soap, struct ArrayOfCancelResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCancelResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfCancelResults ** SOAP_FMAC4 soap_in_PointerToArrayOfCancelResults(struct soap *soap, const char *tag, struct ArrayOfCancelResults **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfCancelResults **)soap_malloc(soap, sizeof(struct ArrayOfCancelResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfCancelResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfCancelResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCancelResults, sizeof(struct ArrayOfCancelResults), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrn__captureResponse(struct soap *soap, struct trn__captureResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_trn__captureResponse))
		soap_serialize_trn__captureResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrn__captureResponse(struct soap *soap, struct trn__captureResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrn__captureResponse);
	if (soap_out_PointerTotrn__captureResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrn__captureResponse(struct soap *soap, const char *tag, int id, struct trn__captureResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trn__captureResponse);
	if (id < 0)
		return soap->error;
	return soap_out_trn__captureResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trn__captureResponse ** SOAP_FMAC4 soap_get_PointerTotrn__captureResponse(struct soap *soap, struct trn__captureResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrn__captureResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__captureResponse ** SOAP_FMAC4 soap_in_PointerTotrn__captureResponse(struct soap *soap, const char *tag, struct trn__captureResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trn__captureResponse **)soap_malloc(soap, sizeof(struct trn__captureResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trn__captureResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trn__captureResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trn__captureResponse, sizeof(struct trn__captureResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCaptureResults(struct soap *soap, struct ArrayOfCaptureResults *const*a)
{
	if (*a)
		soap_serialize_ArrayOfCaptureResults(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCaptureResults(struct soap *soap, struct ArrayOfCaptureResults *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCaptureResults);
	if (soap_out_PointerToArrayOfCaptureResults(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCaptureResults(struct soap *soap, const char *tag, int id, struct ArrayOfCaptureResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfCaptureResults);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfCaptureResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfCaptureResults ** SOAP_FMAC4 soap_get_PointerToArrayOfCaptureResults(struct soap *soap, struct ArrayOfCaptureResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCaptureResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfCaptureResults ** SOAP_FMAC4 soap_in_PointerToArrayOfCaptureResults(struct soap *soap, const char *tag, struct ArrayOfCaptureResults **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfCaptureResults **)soap_malloc(soap, sizeof(struct ArrayOfCaptureResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfCaptureResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfCaptureResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCaptureResults, sizeof(struct ArrayOfCaptureResults), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrn__calculateSalesTaxResponse(struct soap *soap, struct trn__calculateSalesTaxResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_trn__calculateSalesTaxResponse))
		soap_serialize_trn__calculateSalesTaxResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrn__calculateSalesTaxResponse(struct soap *soap, struct trn__calculateSalesTaxResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrn__calculateSalesTaxResponse);
	if (soap_out_PointerTotrn__calculateSalesTaxResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrn__calculateSalesTaxResponse(struct soap *soap, const char *tag, int id, struct trn__calculateSalesTaxResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trn__calculateSalesTaxResponse);
	if (id < 0)
		return soap->error;
	return soap_out_trn__calculateSalesTaxResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trn__calculateSalesTaxResponse ** SOAP_FMAC4 soap_get_PointerTotrn__calculateSalesTaxResponse(struct soap *soap, struct trn__calculateSalesTaxResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrn__calculateSalesTaxResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__calculateSalesTaxResponse ** SOAP_FMAC4 soap_in_PointerTotrn__calculateSalesTaxResponse(struct soap *soap, const char *tag, struct trn__calculateSalesTaxResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trn__calculateSalesTaxResponse **)soap_malloc(soap, sizeof(struct trn__calculateSalesTaxResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trn__calculateSalesTaxResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trn__calculateSalesTaxResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trn__calculateSalesTaxResponse, sizeof(struct trn__calculateSalesTaxResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfSalesTaxes(struct soap *soap, struct ArrayOfSalesTaxes *const*a)
{
	if (*a)
		soap_serialize_ArrayOfSalesTaxes(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfSalesTaxes(struct soap *soap, struct ArrayOfSalesTaxes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfSalesTaxes);
	if (soap_out_PointerToArrayOfSalesTaxes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfSalesTaxes(struct soap *soap, const char *tag, int id, struct ArrayOfSalesTaxes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfSalesTaxes);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfSalesTaxes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfSalesTaxes ** SOAP_FMAC4 soap_get_PointerToArrayOfSalesTaxes(struct soap *soap, struct ArrayOfSalesTaxes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfSalesTaxes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfSalesTaxes ** SOAP_FMAC4 soap_in_PointerToArrayOfSalesTaxes(struct soap *soap, const char *tag, struct ArrayOfSalesTaxes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfSalesTaxes **)soap_malloc(soap, sizeof(struct ArrayOfSalesTaxes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfSalesTaxes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfSalesTaxes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfSalesTaxes, sizeof(struct ArrayOfSalesTaxes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrn__authResponse(struct soap *soap, struct trn__authResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_trn__authResponse))
		soap_serialize_trn__authResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrn__authResponse(struct soap *soap, struct trn__authResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrn__authResponse);
	if (soap_out_PointerTotrn__authResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrn__authResponse(struct soap *soap, const char *tag, int id, struct trn__authResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trn__authResponse);
	if (id < 0)
		return soap->error;
	return soap_out_trn__authResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trn__authResponse ** SOAP_FMAC4 soap_get_PointerTotrn__authResponse(struct soap *soap, struct trn__authResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrn__authResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__authResponse ** SOAP_FMAC4 soap_in_PointerTotrn__authResponse(struct soap *soap, const char *tag, struct trn__authResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trn__authResponse **)soap_malloc(soap, sizeof(struct trn__authResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trn__authResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trn__authResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trn__authResponse, sizeof(struct trn__authResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrn__fetchByPaymentMethodResponse(struct soap *soap, struct trn__fetchByPaymentMethodResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_trn__fetchByPaymentMethodResponse))
		soap_serialize_trn__fetchByPaymentMethodResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrn__fetchByPaymentMethodResponse(struct soap *soap, struct trn__fetchByPaymentMethodResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrn__fetchByPaymentMethodResponse);
	if (soap_out_PointerTotrn__fetchByPaymentMethodResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrn__fetchByPaymentMethodResponse(struct soap *soap, const char *tag, int id, struct trn__fetchByPaymentMethodResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trn__fetchByPaymentMethodResponse);
	if (id < 0)
		return soap->error;
	return soap_out_trn__fetchByPaymentMethodResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trn__fetchByPaymentMethodResponse ** SOAP_FMAC4 soap_get_PointerTotrn__fetchByPaymentMethodResponse(struct soap *soap, struct trn__fetchByPaymentMethodResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrn__fetchByPaymentMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchByPaymentMethodResponse ** SOAP_FMAC4 soap_in_PointerTotrn__fetchByPaymentMethodResponse(struct soap *soap, const char *tag, struct trn__fetchByPaymentMethodResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trn__fetchByPaymentMethodResponse **)soap_malloc(soap, sizeof(struct trn__fetchByPaymentMethodResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trn__fetchByPaymentMethodResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trn__fetchByPaymentMethodResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trn__fetchByPaymentMethodResponse, sizeof(struct trn__fetchByPaymentMethodResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrn__fetchSearchPageResponse(struct soap *soap, struct trn__fetchSearchPageResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_trn__fetchSearchPageResponse))
		soap_serialize_trn__fetchSearchPageResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrn__fetchSearchPageResponse(struct soap *soap, struct trn__fetchSearchPageResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrn__fetchSearchPageResponse);
	if (soap_out_PointerTotrn__fetchSearchPageResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrn__fetchSearchPageResponse(struct soap *soap, const char *tag, int id, struct trn__fetchSearchPageResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trn__fetchSearchPageResponse);
	if (id < 0)
		return soap->error;
	return soap_out_trn__fetchSearchPageResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trn__fetchSearchPageResponse ** SOAP_FMAC4 soap_get_PointerTotrn__fetchSearchPageResponse(struct soap *soap, struct trn__fetchSearchPageResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrn__fetchSearchPageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchSearchPageResponse ** SOAP_FMAC4 soap_in_PointerTotrn__fetchSearchPageResponse(struct soap *soap, const char *tag, struct trn__fetchSearchPageResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trn__fetchSearchPageResponse **)soap_malloc(soap, sizeof(struct trn__fetchSearchPageResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trn__fetchSearchPageResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trn__fetchSearchPageResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trn__fetchSearchPageResponse, sizeof(struct trn__fetchSearchPageResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrn__fetchByAutobillResponse(struct soap *soap, struct trn__fetchByAutobillResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_trn__fetchByAutobillResponse))
		soap_serialize_trn__fetchByAutobillResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrn__fetchByAutobillResponse(struct soap *soap, struct trn__fetchByAutobillResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrn__fetchByAutobillResponse);
	if (soap_out_PointerTotrn__fetchByAutobillResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrn__fetchByAutobillResponse(struct soap *soap, const char *tag, int id, struct trn__fetchByAutobillResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trn__fetchByAutobillResponse);
	if (id < 0)
		return soap->error;
	return soap_out_trn__fetchByAutobillResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trn__fetchByAutobillResponse ** SOAP_FMAC4 soap_get_PointerTotrn__fetchByAutobillResponse(struct soap *soap, struct trn__fetchByAutobillResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrn__fetchByAutobillResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchByAutobillResponse ** SOAP_FMAC4 soap_in_PointerTotrn__fetchByAutobillResponse(struct soap *soap, const char *tag, struct trn__fetchByAutobillResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trn__fetchByAutobillResponse **)soap_malloc(soap, sizeof(struct trn__fetchByAutobillResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trn__fetchByAutobillResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trn__fetchByAutobillResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trn__fetchByAutobillResponse, sizeof(struct trn__fetchByAutobillResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrn__fetchDeltaResponse(struct soap *soap, struct trn__fetchDeltaResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_trn__fetchDeltaResponse))
		soap_serialize_trn__fetchDeltaResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrn__fetchDeltaResponse(struct soap *soap, struct trn__fetchDeltaResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrn__fetchDeltaResponse);
	if (soap_out_PointerTotrn__fetchDeltaResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrn__fetchDeltaResponse(struct soap *soap, const char *tag, int id, struct trn__fetchDeltaResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trn__fetchDeltaResponse);
	if (id < 0)
		return soap->error;
	return soap_out_trn__fetchDeltaResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trn__fetchDeltaResponse ** SOAP_FMAC4 soap_get_PointerTotrn__fetchDeltaResponse(struct soap *soap, struct trn__fetchDeltaResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrn__fetchDeltaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchDeltaResponse ** SOAP_FMAC4 soap_in_PointerTotrn__fetchDeltaResponse(struct soap *soap, const char *tag, struct trn__fetchDeltaResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trn__fetchDeltaResponse **)soap_malloc(soap, sizeof(struct trn__fetchDeltaResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trn__fetchDeltaResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trn__fetchDeltaResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trn__fetchDeltaResponse, sizeof(struct trn__fetchDeltaResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrn__fetchDeltaSinceResponse(struct soap *soap, struct trn__fetchDeltaSinceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_trn__fetchDeltaSinceResponse))
		soap_serialize_trn__fetchDeltaSinceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrn__fetchDeltaSinceResponse(struct soap *soap, struct trn__fetchDeltaSinceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrn__fetchDeltaSinceResponse);
	if (soap_out_PointerTotrn__fetchDeltaSinceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrn__fetchDeltaSinceResponse(struct soap *soap, const char *tag, int id, struct trn__fetchDeltaSinceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trn__fetchDeltaSinceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_trn__fetchDeltaSinceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trn__fetchDeltaSinceResponse ** SOAP_FMAC4 soap_get_PointerTotrn__fetchDeltaSinceResponse(struct soap *soap, struct trn__fetchDeltaSinceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrn__fetchDeltaSinceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchDeltaSinceResponse ** SOAP_FMAC4 soap_in_PointerTotrn__fetchDeltaSinceResponse(struct soap *soap, const char *tag, struct trn__fetchDeltaSinceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trn__fetchDeltaSinceResponse **)soap_malloc(soap, sizeof(struct trn__fetchDeltaSinceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trn__fetchDeltaSinceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trn__fetchDeltaSinceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trn__fetchDeltaSinceResponse, sizeof(struct trn__fetchDeltaSinceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrn__fetchByMerchantTransactionIdResponse(struct soap *soap, struct trn__fetchByMerchantTransactionIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_trn__fetchByMerchantTransactionIdResponse))
		soap_serialize_trn__fetchByMerchantTransactionIdResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrn__fetchByMerchantTransactionIdResponse(struct soap *soap, struct trn__fetchByMerchantTransactionIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrn__fetchByMerchantTransactionIdResponse);
	if (soap_out_PointerTotrn__fetchByMerchantTransactionIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrn__fetchByMerchantTransactionIdResponse(struct soap *soap, const char *tag, int id, struct trn__fetchByMerchantTransactionIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trn__fetchByMerchantTransactionIdResponse);
	if (id < 0)
		return soap->error;
	return soap_out_trn__fetchByMerchantTransactionIdResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trn__fetchByMerchantTransactionIdResponse ** SOAP_FMAC4 soap_get_PointerTotrn__fetchByMerchantTransactionIdResponse(struct soap *soap, struct trn__fetchByMerchantTransactionIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrn__fetchByMerchantTransactionIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchByMerchantTransactionIdResponse ** SOAP_FMAC4 soap_in_PointerTotrn__fetchByMerchantTransactionIdResponse(struct soap *soap, const char *tag, struct trn__fetchByMerchantTransactionIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trn__fetchByMerchantTransactionIdResponse **)soap_malloc(soap, sizeof(struct trn__fetchByMerchantTransactionIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trn__fetchByMerchantTransactionIdResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trn__fetchByMerchantTransactionIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trn__fetchByMerchantTransactionIdResponse, sizeof(struct trn__fetchByMerchantTransactionIdResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrn__fetchByAccountResponse(struct soap *soap, struct trn__fetchByAccountResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_trn__fetchByAccountResponse))
		soap_serialize_trn__fetchByAccountResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrn__fetchByAccountResponse(struct soap *soap, struct trn__fetchByAccountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrn__fetchByAccountResponse);
	if (soap_out_PointerTotrn__fetchByAccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrn__fetchByAccountResponse(struct soap *soap, const char *tag, int id, struct trn__fetchByAccountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trn__fetchByAccountResponse);
	if (id < 0)
		return soap->error;
	return soap_out_trn__fetchByAccountResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trn__fetchByAccountResponse ** SOAP_FMAC4 soap_get_PointerTotrn__fetchByAccountResponse(struct soap *soap, struct trn__fetchByAccountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrn__fetchByAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchByAccountResponse ** SOAP_FMAC4 soap_in_PointerTotrn__fetchByAccountResponse(struct soap *soap, const char *tag, struct trn__fetchByAccountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trn__fetchByAccountResponse **)soap_malloc(soap, sizeof(struct trn__fetchByAccountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trn__fetchByAccountResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trn__fetchByAccountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trn__fetchByAccountResponse, sizeof(struct trn__fetchByAccountResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrn__fetchByVidResponse(struct soap *soap, struct trn__fetchByVidResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_trn__fetchByVidResponse))
		soap_serialize_trn__fetchByVidResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrn__fetchByVidResponse(struct soap *soap, struct trn__fetchByVidResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrn__fetchByVidResponse);
	if (soap_out_PointerTotrn__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrn__fetchByVidResponse(struct soap *soap, const char *tag, int id, struct trn__fetchByVidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trn__fetchByVidResponse);
	if (id < 0)
		return soap->error;
	return soap_out_trn__fetchByVidResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trn__fetchByVidResponse ** SOAP_FMAC4 soap_get_PointerTotrn__fetchByVidResponse(struct soap *soap, struct trn__fetchByVidResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrn__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct trn__fetchByVidResponse ** SOAP_FMAC4 soap_in_PointerTotrn__fetchByVidResponse(struct soap *soap, const char *tag, struct trn__fetchByVidResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trn__fetchByVidResponse **)soap_malloc(soap, sizeof(struct trn__fetchByVidResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trn__fetchByVidResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trn__fetchByVidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trn__fetchByVidResponse, sizeof(struct trn__fetchByVidResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorfd__performResponse(struct soap *soap, struct rfd__performResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rfd__performResponse))
		soap_serialize_rfd__performResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorfd__performResponse(struct soap *soap, struct rfd__performResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorfd__performResponse);
	if (soap_out_PointerTorfd__performResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorfd__performResponse(struct soap *soap, const char *tag, int id, struct rfd__performResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rfd__performResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rfd__performResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rfd__performResponse ** SOAP_FMAC4 soap_get_PointerTorfd__performResponse(struct soap *soap, struct rfd__performResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorfd__performResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__performResponse ** SOAP_FMAC4 soap_in_PointerTorfd__performResponse(struct soap *soap, const char *tag, struct rfd__performResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct rfd__performResponse **)soap_malloc(soap, sizeof(struct rfd__performResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rfd__performResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rfd__performResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rfd__performResponse, sizeof(struct rfd__performResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorfd__reportResponse(struct soap *soap, struct rfd__reportResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rfd__reportResponse))
		soap_serialize_rfd__reportResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorfd__reportResponse(struct soap *soap, struct rfd__reportResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorfd__reportResponse);
	if (soap_out_PointerTorfd__reportResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorfd__reportResponse(struct soap *soap, const char *tag, int id, struct rfd__reportResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rfd__reportResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rfd__reportResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rfd__reportResponse ** SOAP_FMAC4 soap_get_PointerTorfd__reportResponse(struct soap *soap, struct rfd__reportResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorfd__reportResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__reportResponse ** SOAP_FMAC4 soap_in_PointerTorfd__reportResponse(struct soap *soap, const char *tag, struct rfd__reportResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct rfd__reportResponse **)soap_malloc(soap, sizeof(struct rfd__reportResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rfd__reportResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rfd__reportResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rfd__reportResponse, sizeof(struct rfd__reportResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorfd__fetchDeltaSinceResponse(struct soap *soap, struct rfd__fetchDeltaSinceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rfd__fetchDeltaSinceResponse))
		soap_serialize_rfd__fetchDeltaSinceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorfd__fetchDeltaSinceResponse(struct soap *soap, struct rfd__fetchDeltaSinceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorfd__fetchDeltaSinceResponse);
	if (soap_out_PointerTorfd__fetchDeltaSinceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorfd__fetchDeltaSinceResponse(struct soap *soap, const char *tag, int id, struct rfd__fetchDeltaSinceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rfd__fetchDeltaSinceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rfd__fetchDeltaSinceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rfd__fetchDeltaSinceResponse ** SOAP_FMAC4 soap_get_PointerTorfd__fetchDeltaSinceResponse(struct soap *soap, struct rfd__fetchDeltaSinceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorfd__fetchDeltaSinceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__fetchDeltaSinceResponse ** SOAP_FMAC4 soap_in_PointerTorfd__fetchDeltaSinceResponse(struct soap *soap, const char *tag, struct rfd__fetchDeltaSinceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct rfd__fetchDeltaSinceResponse **)soap_malloc(soap, sizeof(struct rfd__fetchDeltaSinceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rfd__fetchDeltaSinceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rfd__fetchDeltaSinceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rfd__fetchDeltaSinceResponse, sizeof(struct rfd__fetchDeltaSinceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorfd__fetchByTransactionResponse(struct soap *soap, struct rfd__fetchByTransactionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rfd__fetchByTransactionResponse))
		soap_serialize_rfd__fetchByTransactionResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorfd__fetchByTransactionResponse(struct soap *soap, struct rfd__fetchByTransactionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorfd__fetchByTransactionResponse);
	if (soap_out_PointerTorfd__fetchByTransactionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorfd__fetchByTransactionResponse(struct soap *soap, const char *tag, int id, struct rfd__fetchByTransactionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rfd__fetchByTransactionResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rfd__fetchByTransactionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rfd__fetchByTransactionResponse ** SOAP_FMAC4 soap_get_PointerTorfd__fetchByTransactionResponse(struct soap *soap, struct rfd__fetchByTransactionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorfd__fetchByTransactionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__fetchByTransactionResponse ** SOAP_FMAC4 soap_in_PointerTorfd__fetchByTransactionResponse(struct soap *soap, const char *tag, struct rfd__fetchByTransactionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct rfd__fetchByTransactionResponse **)soap_malloc(soap, sizeof(struct rfd__fetchByTransactionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rfd__fetchByTransactionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rfd__fetchByTransactionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rfd__fetchByTransactionResponse, sizeof(struct rfd__fetchByTransactionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorfd__fetchByAccountResponse(struct soap *soap, struct rfd__fetchByAccountResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rfd__fetchByAccountResponse))
		soap_serialize_rfd__fetchByAccountResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorfd__fetchByAccountResponse(struct soap *soap, struct rfd__fetchByAccountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorfd__fetchByAccountResponse);
	if (soap_out_PointerTorfd__fetchByAccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorfd__fetchByAccountResponse(struct soap *soap, const char *tag, int id, struct rfd__fetchByAccountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rfd__fetchByAccountResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rfd__fetchByAccountResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rfd__fetchByAccountResponse ** SOAP_FMAC4 soap_get_PointerTorfd__fetchByAccountResponse(struct soap *soap, struct rfd__fetchByAccountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorfd__fetchByAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__fetchByAccountResponse ** SOAP_FMAC4 soap_in_PointerTorfd__fetchByAccountResponse(struct soap *soap, const char *tag, struct rfd__fetchByAccountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct rfd__fetchByAccountResponse **)soap_malloc(soap, sizeof(struct rfd__fetchByAccountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rfd__fetchByAccountResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rfd__fetchByAccountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rfd__fetchByAccountResponse, sizeof(struct rfd__fetchByAccountResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfRefunds(struct soap *soap, struct ArrayOfRefunds *const*a)
{
	if (*a)
		soap_serialize_ArrayOfRefunds(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfRefunds(struct soap *soap, struct ArrayOfRefunds *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfRefunds);
	if (soap_out_PointerToArrayOfRefunds(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfRefunds(struct soap *soap, const char *tag, int id, struct ArrayOfRefunds *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfRefunds);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfRefunds(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfRefunds ** SOAP_FMAC4 soap_get_PointerToArrayOfRefunds(struct soap *soap, struct ArrayOfRefunds **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfRefunds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfRefunds ** SOAP_FMAC4 soap_in_PointerToArrayOfRefunds(struct soap *soap, const char *tag, struct ArrayOfRefunds **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfRefunds **)soap_malloc(soap, sizeof(struct ArrayOfRefunds *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfRefunds(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfRefunds **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfRefunds, sizeof(struct ArrayOfRefunds), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTorfd__fetchByVidResponse(struct soap *soap, struct rfd__fetchByVidResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_rfd__fetchByVidResponse))
		soap_serialize_rfd__fetchByVidResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTorfd__fetchByVidResponse(struct soap *soap, struct rfd__fetchByVidResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTorfd__fetchByVidResponse);
	if (soap_out_PointerTorfd__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTorfd__fetchByVidResponse(struct soap *soap, const char *tag, int id, struct rfd__fetchByVidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_rfd__fetchByVidResponse);
	if (id < 0)
		return soap->error;
	return soap_out_rfd__fetchByVidResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct rfd__fetchByVidResponse ** SOAP_FMAC4 soap_get_PointerTorfd__fetchByVidResponse(struct soap *soap, struct rfd__fetchByVidResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTorfd__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct rfd__fetchByVidResponse ** SOAP_FMAC4 soap_in_PointerTorfd__fetchByVidResponse(struct soap *soap, const char *tag, struct rfd__fetchByVidResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct rfd__fetchByVidResponse **)soap_malloc(soap, sizeof(struct rfd__fetchByVidResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_rfd__fetchByVidResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct rfd__fetchByVidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_rfd__fetchByVidResponse, sizeof(struct rfd__fetchByVidResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTopyp__fetchByVidResponse(struct soap *soap, struct pyp__fetchByVidResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_pyp__fetchByVidResponse))
		soap_serialize_pyp__fetchByVidResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTopyp__fetchByVidResponse(struct soap *soap, struct pyp__fetchByVidResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTopyp__fetchByVidResponse);
	if (soap_out_PointerTopyp__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTopyp__fetchByVidResponse(struct soap *soap, const char *tag, int id, struct pyp__fetchByVidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_pyp__fetchByVidResponse);
	if (id < 0)
		return soap->error;
	return soap_out_pyp__fetchByVidResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct pyp__fetchByVidResponse ** SOAP_FMAC4 soap_get_PointerTopyp__fetchByVidResponse(struct soap *soap, struct pyp__fetchByVidResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTopyp__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pyp__fetchByVidResponse ** SOAP_FMAC4 soap_in_PointerTopyp__fetchByVidResponse(struct soap *soap, const char *tag, struct pyp__fetchByVidResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct pyp__fetchByVidResponse **)soap_malloc(soap, sizeof(struct pyp__fetchByVidResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_pyp__fetchByVidResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct pyp__fetchByVidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_pyp__fetchByVidResponse, sizeof(struct pyp__fetchByVidResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTopyp__updateResponse(struct soap *soap, struct pyp__updateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_pyp__updateResponse))
		soap_serialize_pyp__updateResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTopyp__updateResponse(struct soap *soap, struct pyp__updateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTopyp__updateResponse);
	if (soap_out_PointerTopyp__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTopyp__updateResponse(struct soap *soap, const char *tag, int id, struct pyp__updateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_pyp__updateResponse);
	if (id < 0)
		return soap->error;
	return soap_out_pyp__updateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct pyp__updateResponse ** SOAP_FMAC4 soap_get_PointerTopyp__updateResponse(struct soap *soap, struct pyp__updateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTopyp__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pyp__updateResponse ** SOAP_FMAC4 soap_in_PointerTopyp__updateResponse(struct soap *soap, const char *tag, struct pyp__updateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct pyp__updateResponse **)soap_malloc(soap, sizeof(struct pyp__updateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_pyp__updateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct pyp__updateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_pyp__updateResponse, sizeof(struct pyp__updateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__PaymentProvider(struct soap *soap, struct vin__PaymentProvider *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__PaymentProvider))
		soap_serialize_vin__PaymentProvider(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__PaymentProvider(struct soap *soap, struct vin__PaymentProvider *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__PaymentProvider);
	if (soap_out_PointerTovin__PaymentProvider(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__PaymentProvider(struct soap *soap, const char *tag, int id, struct vin__PaymentProvider *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__PaymentProvider);
	if (id < 0)
		return soap->error;
	return soap_out_vin__PaymentProvider(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__PaymentProvider ** SOAP_FMAC4 soap_get_PointerTovin__PaymentProvider(struct soap *soap, struct vin__PaymentProvider **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__PaymentProvider(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__PaymentProvider ** SOAP_FMAC4 soap_in_PointerTovin__PaymentProvider(struct soap *soap, const char *tag, struct vin__PaymentProvider **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__PaymentProvider **)soap_malloc(soap, sizeof(struct vin__PaymentProvider *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__PaymentProvider(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__PaymentProvider **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__PaymentProvider, sizeof(struct vin__PaymentProvider), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTopym__validateResponse(struct soap *soap, struct pym__validateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_pym__validateResponse))
		soap_serialize_pym__validateResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTopym__validateResponse(struct soap *soap, struct pym__validateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTopym__validateResponse);
	if (soap_out_PointerTopym__validateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTopym__validateResponse(struct soap *soap, const char *tag, int id, struct pym__validateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_pym__validateResponse);
	if (id < 0)
		return soap->error;
	return soap_out_pym__validateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct pym__validateResponse ** SOAP_FMAC4 soap_get_PointerTopym__validateResponse(struct soap *soap, struct pym__validateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTopym__validateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pym__validateResponse ** SOAP_FMAC4 soap_in_PointerTopym__validateResponse(struct soap *soap, const char *tag, struct pym__validateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct pym__validateResponse **)soap_malloc(soap, sizeof(struct pym__validateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_pym__validateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct pym__validateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_pym__validateResponse, sizeof(struct pym__validateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTopym__fetchByMerchantPaymentMethodIdResponse(struct soap *soap, struct pym__fetchByMerchantPaymentMethodIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_pym__fetchByMerchantPaymentMethodIdResponse))
		soap_serialize_pym__fetchByMerchantPaymentMethodIdResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTopym__fetchByMerchantPaymentMethodIdResponse(struct soap *soap, struct pym__fetchByMerchantPaymentMethodIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTopym__fetchByMerchantPaymentMethodIdResponse);
	if (soap_out_PointerTopym__fetchByMerchantPaymentMethodIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTopym__fetchByMerchantPaymentMethodIdResponse(struct soap *soap, const char *tag, int id, struct pym__fetchByMerchantPaymentMethodIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_pym__fetchByMerchantPaymentMethodIdResponse);
	if (id < 0)
		return soap->error;
	return soap_out_pym__fetchByMerchantPaymentMethodIdResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct pym__fetchByMerchantPaymentMethodIdResponse ** SOAP_FMAC4 soap_get_PointerTopym__fetchByMerchantPaymentMethodIdResponse(struct soap *soap, struct pym__fetchByMerchantPaymentMethodIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTopym__fetchByMerchantPaymentMethodIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pym__fetchByMerchantPaymentMethodIdResponse ** SOAP_FMAC4 soap_in_PointerTopym__fetchByMerchantPaymentMethodIdResponse(struct soap *soap, const char *tag, struct pym__fetchByMerchantPaymentMethodIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct pym__fetchByMerchantPaymentMethodIdResponse **)soap_malloc(soap, sizeof(struct pym__fetchByMerchantPaymentMethodIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_pym__fetchByMerchantPaymentMethodIdResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct pym__fetchByMerchantPaymentMethodIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_pym__fetchByMerchantPaymentMethodIdResponse, sizeof(struct pym__fetchByMerchantPaymentMethodIdResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTopym__fetchByAccountResponse(struct soap *soap, struct pym__fetchByAccountResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_pym__fetchByAccountResponse))
		soap_serialize_pym__fetchByAccountResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTopym__fetchByAccountResponse(struct soap *soap, struct pym__fetchByAccountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTopym__fetchByAccountResponse);
	if (soap_out_PointerTopym__fetchByAccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTopym__fetchByAccountResponse(struct soap *soap, const char *tag, int id, struct pym__fetchByAccountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_pym__fetchByAccountResponse);
	if (id < 0)
		return soap->error;
	return soap_out_pym__fetchByAccountResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct pym__fetchByAccountResponse ** SOAP_FMAC4 soap_get_PointerTopym__fetchByAccountResponse(struct soap *soap, struct pym__fetchByAccountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTopym__fetchByAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pym__fetchByAccountResponse ** SOAP_FMAC4 soap_in_PointerTopym__fetchByAccountResponse(struct soap *soap, const char *tag, struct pym__fetchByAccountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct pym__fetchByAccountResponse **)soap_malloc(soap, sizeof(struct pym__fetchByAccountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_pym__fetchByAccountResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct pym__fetchByAccountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_pym__fetchByAccountResponse, sizeof(struct pym__fetchByAccountResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTopym__fetchByVidResponse(struct soap *soap, struct pym__fetchByVidResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_pym__fetchByVidResponse))
		soap_serialize_pym__fetchByVidResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTopym__fetchByVidResponse(struct soap *soap, struct pym__fetchByVidResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTopym__fetchByVidResponse);
	if (soap_out_PointerTopym__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTopym__fetchByVidResponse(struct soap *soap, const char *tag, int id, struct pym__fetchByVidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_pym__fetchByVidResponse);
	if (id < 0)
		return soap->error;
	return soap_out_pym__fetchByVidResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct pym__fetchByVidResponse ** SOAP_FMAC4 soap_get_PointerTopym__fetchByVidResponse(struct soap *soap, struct pym__fetchByVidResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTopym__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pym__fetchByVidResponse ** SOAP_FMAC4 soap_in_PointerTopym__fetchByVidResponse(struct soap *soap, const char *tag, struct pym__fetchByVidResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct pym__fetchByVidResponse **)soap_malloc(soap, sizeof(struct pym__fetchByVidResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_pym__fetchByVidResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct pym__fetchByVidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_pym__fetchByVidResponse, sizeof(struct pym__fetchByVidResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTopym__updateResponse(struct soap *soap, struct pym__updateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_pym__updateResponse))
		soap_serialize_pym__updateResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTopym__updateResponse(struct soap *soap, struct pym__updateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTopym__updateResponse);
	if (soap_out_PointerTopym__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTopym__updateResponse(struct soap *soap, const char *tag, int id, struct pym__updateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_pym__updateResponse);
	if (id < 0)
		return soap->error;
	return soap_out_pym__updateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct pym__updateResponse ** SOAP_FMAC4 soap_get_PointerTopym__updateResponse(struct soap *soap, struct pym__updateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTopym__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct pym__updateResponse ** SOAP_FMAC4 soap_in_PointerTopym__updateResponse(struct soap *soap, const char *tag, struct pym__updateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct pym__updateResponse **)soap_malloc(soap, sizeof(struct pym__updateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_pym__updateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct pym__updateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_pym__updateResponse, sizeof(struct pym__updateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToprd__fetchByMerchantEntitlementIdResponse(struct soap *soap, struct prd__fetchByMerchantEntitlementIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_prd__fetchByMerchantEntitlementIdResponse))
		soap_serialize_prd__fetchByMerchantEntitlementIdResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToprd__fetchByMerchantEntitlementIdResponse(struct soap *soap, struct prd__fetchByMerchantEntitlementIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToprd__fetchByMerchantEntitlementIdResponse);
	if (soap_out_PointerToprd__fetchByMerchantEntitlementIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToprd__fetchByMerchantEntitlementIdResponse(struct soap *soap, const char *tag, int id, struct prd__fetchByMerchantEntitlementIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_prd__fetchByMerchantEntitlementIdResponse);
	if (id < 0)
		return soap->error;
	return soap_out_prd__fetchByMerchantEntitlementIdResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct prd__fetchByMerchantEntitlementIdResponse ** SOAP_FMAC4 soap_get_PointerToprd__fetchByMerchantEntitlementIdResponse(struct soap *soap, struct prd__fetchByMerchantEntitlementIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToprd__fetchByMerchantEntitlementIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__fetchByMerchantEntitlementIdResponse ** SOAP_FMAC4 soap_in_PointerToprd__fetchByMerchantEntitlementIdResponse(struct soap *soap, const char *tag, struct prd__fetchByMerchantEntitlementIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct prd__fetchByMerchantEntitlementIdResponse **)soap_malloc(soap, sizeof(struct prd__fetchByMerchantEntitlementIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_prd__fetchByMerchantEntitlementIdResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct prd__fetchByMerchantEntitlementIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_prd__fetchByMerchantEntitlementIdResponse, sizeof(struct prd__fetchByMerchantEntitlementIdResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToprd__fetchAllResponse(struct soap *soap, struct prd__fetchAllResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_prd__fetchAllResponse))
		soap_serialize_prd__fetchAllResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToprd__fetchAllResponse(struct soap *soap, struct prd__fetchAllResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToprd__fetchAllResponse);
	if (soap_out_PointerToprd__fetchAllResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToprd__fetchAllResponse(struct soap *soap, const char *tag, int id, struct prd__fetchAllResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_prd__fetchAllResponse);
	if (id < 0)
		return soap->error;
	return soap_out_prd__fetchAllResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct prd__fetchAllResponse ** SOAP_FMAC4 soap_get_PointerToprd__fetchAllResponse(struct soap *soap, struct prd__fetchAllResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToprd__fetchAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__fetchAllResponse ** SOAP_FMAC4 soap_in_PointerToprd__fetchAllResponse(struct soap *soap, const char *tag, struct prd__fetchAllResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct prd__fetchAllResponse **)soap_malloc(soap, sizeof(struct prd__fetchAllResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_prd__fetchAllResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct prd__fetchAllResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_prd__fetchAllResponse, sizeof(struct prd__fetchAllResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToprd__fetchByAccountResponse(struct soap *soap, struct prd__fetchByAccountResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_prd__fetchByAccountResponse))
		soap_serialize_prd__fetchByAccountResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToprd__fetchByAccountResponse(struct soap *soap, struct prd__fetchByAccountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToprd__fetchByAccountResponse);
	if (soap_out_PointerToprd__fetchByAccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToprd__fetchByAccountResponse(struct soap *soap, const char *tag, int id, struct prd__fetchByAccountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_prd__fetchByAccountResponse);
	if (id < 0)
		return soap->error;
	return soap_out_prd__fetchByAccountResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct prd__fetchByAccountResponse ** SOAP_FMAC4 soap_get_PointerToprd__fetchByAccountResponse(struct soap *soap, struct prd__fetchByAccountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToprd__fetchByAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__fetchByAccountResponse ** SOAP_FMAC4 soap_in_PointerToprd__fetchByAccountResponse(struct soap *soap, const char *tag, struct prd__fetchByAccountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct prd__fetchByAccountResponse **)soap_malloc(soap, sizeof(struct prd__fetchByAccountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_prd__fetchByAccountResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct prd__fetchByAccountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_prd__fetchByAccountResponse, sizeof(struct prd__fetchByAccountResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfProducts(struct soap *soap, struct ArrayOfProducts *const*a)
{
	if (*a)
		soap_serialize_ArrayOfProducts(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfProducts(struct soap *soap, struct ArrayOfProducts *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfProducts);
	if (soap_out_PointerToArrayOfProducts(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfProducts(struct soap *soap, const char *tag, int id, struct ArrayOfProducts *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfProducts);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfProducts(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfProducts ** SOAP_FMAC4 soap_get_PointerToArrayOfProducts(struct soap *soap, struct ArrayOfProducts **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfProducts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfProducts ** SOAP_FMAC4 soap_in_PointerToArrayOfProducts(struct soap *soap, const char *tag, struct ArrayOfProducts **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfProducts **)soap_malloc(soap, sizeof(struct ArrayOfProducts *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfProducts(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfProducts **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfProducts, sizeof(struct ArrayOfProducts), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToprd__fetchByMerchantProductIdResponse(struct soap *soap, struct prd__fetchByMerchantProductIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_prd__fetchByMerchantProductIdResponse))
		soap_serialize_prd__fetchByMerchantProductIdResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToprd__fetchByMerchantProductIdResponse(struct soap *soap, struct prd__fetchByMerchantProductIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToprd__fetchByMerchantProductIdResponse);
	if (soap_out_PointerToprd__fetchByMerchantProductIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToprd__fetchByMerchantProductIdResponse(struct soap *soap, const char *tag, int id, struct prd__fetchByMerchantProductIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_prd__fetchByMerchantProductIdResponse);
	if (id < 0)
		return soap->error;
	return soap_out_prd__fetchByMerchantProductIdResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct prd__fetchByMerchantProductIdResponse ** SOAP_FMAC4 soap_get_PointerToprd__fetchByMerchantProductIdResponse(struct soap *soap, struct prd__fetchByMerchantProductIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToprd__fetchByMerchantProductIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__fetchByMerchantProductIdResponse ** SOAP_FMAC4 soap_in_PointerToprd__fetchByMerchantProductIdResponse(struct soap *soap, const char *tag, struct prd__fetchByMerchantProductIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct prd__fetchByMerchantProductIdResponse **)soap_malloc(soap, sizeof(struct prd__fetchByMerchantProductIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_prd__fetchByMerchantProductIdResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct prd__fetchByMerchantProductIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_prd__fetchByMerchantProductIdResponse, sizeof(struct prd__fetchByMerchantProductIdResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToprd__fetchByVidResponse(struct soap *soap, struct prd__fetchByVidResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_prd__fetchByVidResponse))
		soap_serialize_prd__fetchByVidResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToprd__fetchByVidResponse(struct soap *soap, struct prd__fetchByVidResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToprd__fetchByVidResponse);
	if (soap_out_PointerToprd__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToprd__fetchByVidResponse(struct soap *soap, const char *tag, int id, struct prd__fetchByVidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_prd__fetchByVidResponse);
	if (id < 0)
		return soap->error;
	return soap_out_prd__fetchByVidResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct prd__fetchByVidResponse ** SOAP_FMAC4 soap_get_PointerToprd__fetchByVidResponse(struct soap *soap, struct prd__fetchByVidResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToprd__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__fetchByVidResponse ** SOAP_FMAC4 soap_in_PointerToprd__fetchByVidResponse(struct soap *soap, const char *tag, struct prd__fetchByVidResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct prd__fetchByVidResponse **)soap_malloc(soap, sizeof(struct prd__fetchByVidResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_prd__fetchByVidResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct prd__fetchByVidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_prd__fetchByVidResponse, sizeof(struct prd__fetchByVidResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToprd__updateResponse(struct soap *soap, struct prd__updateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_prd__updateResponse))
		soap_serialize_prd__updateResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToprd__updateResponse(struct soap *soap, struct prd__updateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToprd__updateResponse);
	if (soap_out_PointerToprd__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToprd__updateResponse(struct soap *soap, const char *tag, int id, struct prd__updateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_prd__updateResponse);
	if (id < 0)
		return soap->error;
	return soap_out_prd__updateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct prd__updateResponse ** SOAP_FMAC4 soap_get_PointerToprd__updateResponse(struct soap *soap, struct prd__updateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToprd__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct prd__updateResponse ** SOAP_FMAC4 soap_in_PointerToprd__updateResponse(struct soap *soap, const char *tag, struct prd__updateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct prd__updateResponse **)soap_malloc(soap, sizeof(struct prd__updateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_prd__updateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct prd__updateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_prd__updateResponse, sizeof(struct prd__updateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomet__reportResponse(struct soap *soap, struct met__reportResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_met__reportResponse))
		soap_serialize_met__reportResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomet__reportResponse(struct soap *soap, struct met__reportResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTomet__reportResponse);
	if (soap_out_PointerTomet__reportResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomet__reportResponse(struct soap *soap, const char *tag, int id, struct met__reportResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_met__reportResponse);
	if (id < 0)
		return soap->error;
	return soap_out_met__reportResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct met__reportResponse ** SOAP_FMAC4 soap_get_PointerTomet__reportResponse(struct soap *soap, struct met__reportResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomet__reportResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct met__reportResponse ** SOAP_FMAC4 soap_in_PointerTomet__reportResponse(struct soap *soap, const char *tag, struct met__reportResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct met__reportResponse **)soap_malloc(soap, sizeof(struct met__reportResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_met__reportResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct met__reportResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_met__reportResponse, sizeof(struct met__reportResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfMetricStats(struct soap *soap, struct ArrayOfMetricStats *const*a)
{
	if (*a)
		soap_serialize_ArrayOfMetricStats(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfMetricStats(struct soap *soap, struct ArrayOfMetricStats *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfMetricStats);
	if (soap_out_PointerToArrayOfMetricStats(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfMetricStats(struct soap *soap, const char *tag, int id, struct ArrayOfMetricStats *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfMetricStats);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfMetricStats(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfMetricStats ** SOAP_FMAC4 soap_get_PointerToArrayOfMetricStats(struct soap *soap, struct ArrayOfMetricStats **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfMetricStats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfMetricStats ** SOAP_FMAC4 soap_in_PointerToArrayOfMetricStats(struct soap *soap, const char *tag, struct ArrayOfMetricStats **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfMetricStats **)soap_malloc(soap, sizeof(struct ArrayOfMetricStats *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfMetricStats(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfMetricStats **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfMetricStats, sizeof(struct ArrayOfMetricStats), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToetp__fetchByTypeAndVersionResponse(struct soap *soap, struct etp__fetchByTypeAndVersionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_etp__fetchByTypeAndVersionResponse))
		soap_serialize_etp__fetchByTypeAndVersionResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToetp__fetchByTypeAndVersionResponse(struct soap *soap, struct etp__fetchByTypeAndVersionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToetp__fetchByTypeAndVersionResponse);
	if (soap_out_PointerToetp__fetchByTypeAndVersionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToetp__fetchByTypeAndVersionResponse(struct soap *soap, const char *tag, int id, struct etp__fetchByTypeAndVersionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_etp__fetchByTypeAndVersionResponse);
	if (id < 0)
		return soap->error;
	return soap_out_etp__fetchByTypeAndVersionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct etp__fetchByTypeAndVersionResponse ** SOAP_FMAC4 soap_get_PointerToetp__fetchByTypeAndVersionResponse(struct soap *soap, struct etp__fetchByTypeAndVersionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToetp__fetchByTypeAndVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct etp__fetchByTypeAndVersionResponse ** SOAP_FMAC4 soap_in_PointerToetp__fetchByTypeAndVersionResponse(struct soap *soap, const char *tag, struct etp__fetchByTypeAndVersionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct etp__fetchByTypeAndVersionResponse **)soap_malloc(soap, sizeof(struct etp__fetchByTypeAndVersionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_etp__fetchByTypeAndVersionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct etp__fetchByTypeAndVersionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_etp__fetchByTypeAndVersionResponse, sizeof(struct etp__fetchByTypeAndVersionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToetp__fetchByTypeResponse(struct soap *soap, struct etp__fetchByTypeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_etp__fetchByTypeResponse))
		soap_serialize_etp__fetchByTypeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToetp__fetchByTypeResponse(struct soap *soap, struct etp__fetchByTypeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToetp__fetchByTypeResponse);
	if (soap_out_PointerToetp__fetchByTypeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToetp__fetchByTypeResponse(struct soap *soap, const char *tag, int id, struct etp__fetchByTypeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_etp__fetchByTypeResponse);
	if (id < 0)
		return soap->error;
	return soap_out_etp__fetchByTypeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct etp__fetchByTypeResponse ** SOAP_FMAC4 soap_get_PointerToetp__fetchByTypeResponse(struct soap *soap, struct etp__fetchByTypeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToetp__fetchByTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct etp__fetchByTypeResponse ** SOAP_FMAC4 soap_in_PointerToetp__fetchByTypeResponse(struct soap *soap, const char *tag, struct etp__fetchByTypeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct etp__fetchByTypeResponse **)soap_malloc(soap, sizeof(struct etp__fetchByTypeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_etp__fetchByTypeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct etp__fetchByTypeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_etp__fetchByTypeResponse, sizeof(struct etp__fetchByTypeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToetp__fetchByProductResponse(struct soap *soap, struct etp__fetchByProductResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_etp__fetchByProductResponse))
		soap_serialize_etp__fetchByProductResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToetp__fetchByProductResponse(struct soap *soap, struct etp__fetchByProductResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToetp__fetchByProductResponse);
	if (soap_out_PointerToetp__fetchByProductResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToetp__fetchByProductResponse(struct soap *soap, const char *tag, int id, struct etp__fetchByProductResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_etp__fetchByProductResponse);
	if (id < 0)
		return soap->error;
	return soap_out_etp__fetchByProductResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct etp__fetchByProductResponse ** SOAP_FMAC4 soap_get_PointerToetp__fetchByProductResponse(struct soap *soap, struct etp__fetchByProductResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToetp__fetchByProductResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct etp__fetchByProductResponse ** SOAP_FMAC4 soap_in_PointerToetp__fetchByProductResponse(struct soap *soap, const char *tag, struct etp__fetchByProductResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct etp__fetchByProductResponse **)soap_malloc(soap, sizeof(struct etp__fetchByProductResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_etp__fetchByProductResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct etp__fetchByProductResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_etp__fetchByProductResponse, sizeof(struct etp__fetchByProductResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfEmailTemplates(struct soap *soap, struct ArrayOfEmailTemplates *const*a)
{
	if (*a)
		soap_serialize_ArrayOfEmailTemplates(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfEmailTemplates(struct soap *soap, struct ArrayOfEmailTemplates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfEmailTemplates);
	if (soap_out_PointerToArrayOfEmailTemplates(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfEmailTemplates(struct soap *soap, const char *tag, int id, struct ArrayOfEmailTemplates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfEmailTemplates);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfEmailTemplates(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfEmailTemplates ** SOAP_FMAC4 soap_get_PointerToArrayOfEmailTemplates(struct soap *soap, struct ArrayOfEmailTemplates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfEmailTemplates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfEmailTemplates ** SOAP_FMAC4 soap_in_PointerToArrayOfEmailTemplates(struct soap *soap, const char *tag, struct ArrayOfEmailTemplates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfEmailTemplates **)soap_malloc(soap, sizeof(struct ArrayOfEmailTemplates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfEmailTemplates(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfEmailTemplates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfEmailTemplates, sizeof(struct ArrayOfEmailTemplates), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToetp__fetchByVidResponse(struct soap *soap, struct etp__fetchByVidResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_etp__fetchByVidResponse))
		soap_serialize_etp__fetchByVidResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToetp__fetchByVidResponse(struct soap *soap, struct etp__fetchByVidResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToetp__fetchByVidResponse);
	if (soap_out_PointerToetp__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToetp__fetchByVidResponse(struct soap *soap, const char *tag, int id, struct etp__fetchByVidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_etp__fetchByVidResponse);
	if (id < 0)
		return soap->error;
	return soap_out_etp__fetchByVidResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct etp__fetchByVidResponse ** SOAP_FMAC4 soap_get_PointerToetp__fetchByVidResponse(struct soap *soap, struct etp__fetchByVidResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToetp__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct etp__fetchByVidResponse ** SOAP_FMAC4 soap_in_PointerToetp__fetchByVidResponse(struct soap *soap, const char *tag, struct etp__fetchByVidResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct etp__fetchByVidResponse **)soap_malloc(soap, sizeof(struct etp__fetchByVidResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_etp__fetchByVidResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct etp__fetchByVidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_etp__fetchByVidResponse, sizeof(struct etp__fetchByVidResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToetp__updateResponse(struct soap *soap, struct etp__updateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_etp__updateResponse))
		soap_serialize_etp__updateResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToetp__updateResponse(struct soap *soap, struct etp__updateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToetp__updateResponse);
	if (soap_out_PointerToetp__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToetp__updateResponse(struct soap *soap, const char *tag, int id, struct etp__updateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_etp__updateResponse);
	if (id < 0)
		return soap->error;
	return soap_out_etp__updateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct etp__updateResponse ** SOAP_FMAC4 soap_get_PointerToetp__updateResponse(struct soap *soap, struct etp__updateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToetp__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct etp__updateResponse ** SOAP_FMAC4 soap_in_PointerToetp__updateResponse(struct soap *soap, const char *tag, struct etp__updateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct etp__updateResponse **)soap_malloc(soap, sizeof(struct etp__updateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_etp__updateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct etp__updateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_etp__updateResponse, sizeof(struct etp__updateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__fetchDeltaSinceResponse(struct soap *soap, struct ent__fetchDeltaSinceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ent__fetchDeltaSinceResponse))
		soap_serialize_ent__fetchDeltaSinceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__fetchDeltaSinceResponse(struct soap *soap, struct ent__fetchDeltaSinceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__fetchDeltaSinceResponse);
	if (soap_out_PointerToent__fetchDeltaSinceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToent__fetchDeltaSinceResponse(struct soap *soap, const char *tag, int id, struct ent__fetchDeltaSinceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__fetchDeltaSinceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ent__fetchDeltaSinceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ent__fetchDeltaSinceResponse ** SOAP_FMAC4 soap_get_PointerToent__fetchDeltaSinceResponse(struct soap *soap, struct ent__fetchDeltaSinceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToent__fetchDeltaSinceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ent__fetchDeltaSinceResponse ** SOAP_FMAC4 soap_in_PointerToent__fetchDeltaSinceResponse(struct soap *soap, const char *tag, struct ent__fetchDeltaSinceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ent__fetchDeltaSinceResponse **)soap_malloc(soap, sizeof(struct ent__fetchDeltaSinceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ent__fetchDeltaSinceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ent__fetchDeltaSinceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__fetchDeltaSinceResponse, sizeof(struct ent__fetchDeltaSinceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__fetchByAccountResponse(struct soap *soap, struct ent__fetchByAccountResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ent__fetchByAccountResponse))
		soap_serialize_ent__fetchByAccountResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__fetchByAccountResponse(struct soap *soap, struct ent__fetchByAccountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__fetchByAccountResponse);
	if (soap_out_PointerToent__fetchByAccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToent__fetchByAccountResponse(struct soap *soap, const char *tag, int id, struct ent__fetchByAccountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__fetchByAccountResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ent__fetchByAccountResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ent__fetchByAccountResponse ** SOAP_FMAC4 soap_get_PointerToent__fetchByAccountResponse(struct soap *soap, struct ent__fetchByAccountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToent__fetchByAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ent__fetchByAccountResponse ** SOAP_FMAC4 soap_in_PointerToent__fetchByAccountResponse(struct soap *soap, const char *tag, struct ent__fetchByAccountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ent__fetchByAccountResponse **)soap_malloc(soap, sizeof(struct ent__fetchByAccountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ent__fetchByAccountResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ent__fetchByAccountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__fetchByAccountResponse, sizeof(struct ent__fetchByAccountResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfEntitlements(struct soap *soap, struct ArrayOfEntitlements *const*a)
{
	if (*a)
		soap_serialize_ArrayOfEntitlements(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfEntitlements(struct soap *soap, struct ArrayOfEntitlements *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfEntitlements);
	if (soap_out_PointerToArrayOfEntitlements(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfEntitlements(struct soap *soap, const char *tag, int id, struct ArrayOfEntitlements *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfEntitlements);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfEntitlements(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfEntitlements ** SOAP_FMAC4 soap_get_PointerToArrayOfEntitlements(struct soap *soap, struct ArrayOfEntitlements **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfEntitlements(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfEntitlements ** SOAP_FMAC4 soap_in_PointerToArrayOfEntitlements(struct soap *soap, const char *tag, struct ArrayOfEntitlements **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfEntitlements **)soap_malloc(soap, sizeof(struct ArrayOfEntitlements *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfEntitlements(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfEntitlements **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfEntitlements, sizeof(struct ArrayOfEntitlements), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToent__fetchByEntitlementIdAndAccountResponse(struct soap *soap, struct ent__fetchByEntitlementIdAndAccountResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ent__fetchByEntitlementIdAndAccountResponse))
		soap_serialize_ent__fetchByEntitlementIdAndAccountResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToent__fetchByEntitlementIdAndAccountResponse(struct soap *soap, struct ent__fetchByEntitlementIdAndAccountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToent__fetchByEntitlementIdAndAccountResponse);
	if (soap_out_PointerToent__fetchByEntitlementIdAndAccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToent__fetchByEntitlementIdAndAccountResponse(struct soap *soap, const char *tag, int id, struct ent__fetchByEntitlementIdAndAccountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ent__fetchByEntitlementIdAndAccountResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ent__fetchByEntitlementIdAndAccountResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ent__fetchByEntitlementIdAndAccountResponse ** SOAP_FMAC4 soap_get_PointerToent__fetchByEntitlementIdAndAccountResponse(struct soap *soap, struct ent__fetchByEntitlementIdAndAccountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToent__fetchByEntitlementIdAndAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ent__fetchByEntitlementIdAndAccountResponse ** SOAP_FMAC4 soap_in_PointerToent__fetchByEntitlementIdAndAccountResponse(struct soap *soap, const char *tag, struct ent__fetchByEntitlementIdAndAccountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ent__fetchByEntitlementIdAndAccountResponse **)soap_malloc(soap, sizeof(struct ent__fetchByEntitlementIdAndAccountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ent__fetchByEntitlementIdAndAccountResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ent__fetchByEntitlementIdAndAccountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ent__fetchByEntitlementIdAndAccountResponse, sizeof(struct ent__fetchByEntitlementIdAndAccountResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToecs__getSignatureBlockResponse(struct soap *soap, struct ecs__getSignatureBlockResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ecs__getSignatureBlockResponse))
		soap_serialize_ecs__getSignatureBlockResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToecs__getSignatureBlockResponse(struct soap *soap, struct ecs__getSignatureBlockResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToecs__getSignatureBlockResponse);
	if (soap_out_PointerToecs__getSignatureBlockResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToecs__getSignatureBlockResponse(struct soap *soap, const char *tag, int id, struct ecs__getSignatureBlockResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ecs__getSignatureBlockResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ecs__getSignatureBlockResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ecs__getSignatureBlockResponse ** SOAP_FMAC4 soap_get_PointerToecs__getSignatureBlockResponse(struct soap *soap, struct ecs__getSignatureBlockResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToecs__getSignatureBlockResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ecs__getSignatureBlockResponse ** SOAP_FMAC4 soap_in_PointerToecs__getSignatureBlockResponse(struct soap *soap, const char *tag, struct ecs__getSignatureBlockResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ecs__getSignatureBlockResponse **)soap_malloc(soap, sizeof(struct ecs__getSignatureBlockResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ecs__getSignatureBlockResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ecs__getSignatureBlockResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ecs__getSignatureBlockResponse, sizeof(struct ecs__getSignatureBlockResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToecs__signResponse(struct soap *soap, struct ecs__signResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ecs__signResponse))
		soap_serialize_ecs__signResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToecs__signResponse(struct soap *soap, struct ecs__signResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToecs__signResponse);
	if (soap_out_PointerToecs__signResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToecs__signResponse(struct soap *soap, const char *tag, int id, struct ecs__signResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ecs__signResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ecs__signResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ecs__signResponse ** SOAP_FMAC4 soap_get_PointerToecs__signResponse(struct soap *soap, struct ecs__signResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToecs__signResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ecs__signResponse ** SOAP_FMAC4 soap_in_PointerToecs__signResponse(struct soap *soap, const char *tag, struct ecs__signResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ecs__signResponse **)soap_malloc(soap, sizeof(struct ecs__signResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ecs__signResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ecs__signResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ecs__signResponse, sizeof(struct ecs__signResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__ElectronicSignature(struct soap *soap, struct vin__ElectronicSignature *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__ElectronicSignature))
		soap_serialize_vin__ElectronicSignature(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__ElectronicSignature(struct soap *soap, struct vin__ElectronicSignature *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__ElectronicSignature);
	if (soap_out_PointerTovin__ElectronicSignature(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__ElectronicSignature(struct soap *soap, const char *tag, int id, struct vin__ElectronicSignature *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__ElectronicSignature);
	if (id < 0)
		return soap->error;
	return soap_out_vin__ElectronicSignature(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__ElectronicSignature ** SOAP_FMAC4 soap_get_PointerTovin__ElectronicSignature(struct soap *soap, struct vin__ElectronicSignature **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__ElectronicSignature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ElectronicSignature ** SOAP_FMAC4 soap_in_PointerTovin__ElectronicSignature(struct soap *soap, const char *tag, struct vin__ElectronicSignature **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__ElectronicSignature **)soap_malloc(soap, sizeof(struct vin__ElectronicSignature *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__ElectronicSignature(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__ElectronicSignature **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__ElectronicSignature, sizeof(struct vin__ElectronicSignature), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocgb__reportResponse(struct soap *soap, struct cgb__reportResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cgb__reportResponse))
		soap_serialize_cgb__reportResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocgb__reportResponse(struct soap *soap, struct cgb__reportResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocgb__reportResponse);
	if (soap_out_PointerTocgb__reportResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocgb__reportResponse(struct soap *soap, const char *tag, int id, struct cgb__reportResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cgb__reportResponse);
	if (id < 0)
		return soap->error;
	return soap_out_cgb__reportResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cgb__reportResponse ** SOAP_FMAC4 soap_get_PointerTocgb__reportResponse(struct soap *soap, struct cgb__reportResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocgb__reportResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__reportResponse ** SOAP_FMAC4 soap_in_PointerTocgb__reportResponse(struct soap *soap, const char *tag, struct cgb__reportResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cgb__reportResponse **)soap_malloc(soap, sizeof(struct cgb__reportResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cgb__reportResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cgb__reportResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cgb__reportResponse, sizeof(struct cgb__reportResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocgb__fetchDeltaResponse(struct soap *soap, struct cgb__fetchDeltaResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cgb__fetchDeltaResponse))
		soap_serialize_cgb__fetchDeltaResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocgb__fetchDeltaResponse(struct soap *soap, struct cgb__fetchDeltaResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocgb__fetchDeltaResponse);
	if (soap_out_PointerTocgb__fetchDeltaResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocgb__fetchDeltaResponse(struct soap *soap, const char *tag, int id, struct cgb__fetchDeltaResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cgb__fetchDeltaResponse);
	if (id < 0)
		return soap->error;
	return soap_out_cgb__fetchDeltaResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cgb__fetchDeltaResponse ** SOAP_FMAC4 soap_get_PointerTocgb__fetchDeltaResponse(struct soap *soap, struct cgb__fetchDeltaResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocgb__fetchDeltaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchDeltaResponse ** SOAP_FMAC4 soap_in_PointerTocgb__fetchDeltaResponse(struct soap *soap, const char *tag, struct cgb__fetchDeltaResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cgb__fetchDeltaResponse **)soap_malloc(soap, sizeof(struct cgb__fetchDeltaResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cgb__fetchDeltaResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchDeltaResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cgb__fetchDeltaResponse, sizeof(struct cgb__fetchDeltaResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocgb__fetchDeltaSinceResponse(struct soap *soap, struct cgb__fetchDeltaSinceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cgb__fetchDeltaSinceResponse))
		soap_serialize_cgb__fetchDeltaSinceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocgb__fetchDeltaSinceResponse(struct soap *soap, struct cgb__fetchDeltaSinceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocgb__fetchDeltaSinceResponse);
	if (soap_out_PointerTocgb__fetchDeltaSinceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocgb__fetchDeltaSinceResponse(struct soap *soap, const char *tag, int id, struct cgb__fetchDeltaSinceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cgb__fetchDeltaSinceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_cgb__fetchDeltaSinceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cgb__fetchDeltaSinceResponse ** SOAP_FMAC4 soap_get_PointerTocgb__fetchDeltaSinceResponse(struct soap *soap, struct cgb__fetchDeltaSinceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocgb__fetchDeltaSinceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchDeltaSinceResponse ** SOAP_FMAC4 soap_in_PointerTocgb__fetchDeltaSinceResponse(struct soap *soap, const char *tag, struct cgb__fetchDeltaSinceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cgb__fetchDeltaSinceResponse **)soap_malloc(soap, sizeof(struct cgb__fetchDeltaSinceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cgb__fetchDeltaSinceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchDeltaSinceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cgb__fetchDeltaSinceResponse, sizeof(struct cgb__fetchDeltaSinceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocgb__fetchByMerchantTransactionIdResponse(struct soap *soap, struct cgb__fetchByMerchantTransactionIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cgb__fetchByMerchantTransactionIdResponse))
		soap_serialize_cgb__fetchByMerchantTransactionIdResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocgb__fetchByMerchantTransactionIdResponse(struct soap *soap, struct cgb__fetchByMerchantTransactionIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocgb__fetchByMerchantTransactionIdResponse);
	if (soap_out_PointerTocgb__fetchByMerchantTransactionIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocgb__fetchByMerchantTransactionIdResponse(struct soap *soap, const char *tag, int id, struct cgb__fetchByMerchantTransactionIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cgb__fetchByMerchantTransactionIdResponse);
	if (id < 0)
		return soap->error;
	return soap_out_cgb__fetchByMerchantTransactionIdResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cgb__fetchByMerchantTransactionIdResponse ** SOAP_FMAC4 soap_get_PointerTocgb__fetchByMerchantTransactionIdResponse(struct soap *soap, struct cgb__fetchByMerchantTransactionIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocgb__fetchByMerchantTransactionIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByMerchantTransactionIdResponse ** SOAP_FMAC4 soap_in_PointerTocgb__fetchByMerchantTransactionIdResponse(struct soap *soap, const char *tag, struct cgb__fetchByMerchantTransactionIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cgb__fetchByMerchantTransactionIdResponse **)soap_malloc(soap, sizeof(struct cgb__fetchByMerchantTransactionIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cgb__fetchByMerchantTransactionIdResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByMerchantTransactionIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cgb__fetchByMerchantTransactionIdResponse, sizeof(struct cgb__fetchByMerchantTransactionIdResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocgb__fetchByStatusSinceResponse(struct soap *soap, struct cgb__fetchByStatusSinceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cgb__fetchByStatusSinceResponse))
		soap_serialize_cgb__fetchByStatusSinceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocgb__fetchByStatusSinceResponse(struct soap *soap, struct cgb__fetchByStatusSinceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocgb__fetchByStatusSinceResponse);
	if (soap_out_PointerTocgb__fetchByStatusSinceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocgb__fetchByStatusSinceResponse(struct soap *soap, const char *tag, int id, struct cgb__fetchByStatusSinceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cgb__fetchByStatusSinceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_cgb__fetchByStatusSinceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cgb__fetchByStatusSinceResponse ** SOAP_FMAC4 soap_get_PointerTocgb__fetchByStatusSinceResponse(struct soap *soap, struct cgb__fetchByStatusSinceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocgb__fetchByStatusSinceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByStatusSinceResponse ** SOAP_FMAC4 soap_in_PointerTocgb__fetchByStatusSinceResponse(struct soap *soap, const char *tag, struct cgb__fetchByStatusSinceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cgb__fetchByStatusSinceResponse **)soap_malloc(soap, sizeof(struct cgb__fetchByStatusSinceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cgb__fetchByStatusSinceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByStatusSinceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cgb__fetchByStatusSinceResponse, sizeof(struct cgb__fetchByStatusSinceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocgb__fetchByStatusResponse(struct soap *soap, struct cgb__fetchByStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cgb__fetchByStatusResponse))
		soap_serialize_cgb__fetchByStatusResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocgb__fetchByStatusResponse(struct soap *soap, struct cgb__fetchByStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocgb__fetchByStatusResponse);
	if (soap_out_PointerTocgb__fetchByStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocgb__fetchByStatusResponse(struct soap *soap, const char *tag, int id, struct cgb__fetchByStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cgb__fetchByStatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out_cgb__fetchByStatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cgb__fetchByStatusResponse ** SOAP_FMAC4 soap_get_PointerTocgb__fetchByStatusResponse(struct soap *soap, struct cgb__fetchByStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocgb__fetchByStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByStatusResponse ** SOAP_FMAC4 soap_in_PointerTocgb__fetchByStatusResponse(struct soap *soap, const char *tag, struct cgb__fetchByStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cgb__fetchByStatusResponse **)soap_malloc(soap, sizeof(struct cgb__fetchByStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cgb__fetchByStatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cgb__fetchByStatusResponse, sizeof(struct cgb__fetchByStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocgb__fetchByReferenceNumberResponse(struct soap *soap, struct cgb__fetchByReferenceNumberResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cgb__fetchByReferenceNumberResponse))
		soap_serialize_cgb__fetchByReferenceNumberResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocgb__fetchByReferenceNumberResponse(struct soap *soap, struct cgb__fetchByReferenceNumberResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocgb__fetchByReferenceNumberResponse);
	if (soap_out_PointerTocgb__fetchByReferenceNumberResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocgb__fetchByReferenceNumberResponse(struct soap *soap, const char *tag, int id, struct cgb__fetchByReferenceNumberResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cgb__fetchByReferenceNumberResponse);
	if (id < 0)
		return soap->error;
	return soap_out_cgb__fetchByReferenceNumberResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cgb__fetchByReferenceNumberResponse ** SOAP_FMAC4 soap_get_PointerTocgb__fetchByReferenceNumberResponse(struct soap *soap, struct cgb__fetchByReferenceNumberResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocgb__fetchByReferenceNumberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByReferenceNumberResponse ** SOAP_FMAC4 soap_in_PointerTocgb__fetchByReferenceNumberResponse(struct soap *soap, const char *tag, struct cgb__fetchByReferenceNumberResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cgb__fetchByReferenceNumberResponse **)soap_malloc(soap, sizeof(struct cgb__fetchByReferenceNumberResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cgb__fetchByReferenceNumberResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByReferenceNumberResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cgb__fetchByReferenceNumberResponse, sizeof(struct cgb__fetchByReferenceNumberResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocgb__fetchByCaseNumberResponse(struct soap *soap, struct cgb__fetchByCaseNumberResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cgb__fetchByCaseNumberResponse))
		soap_serialize_cgb__fetchByCaseNumberResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocgb__fetchByCaseNumberResponse(struct soap *soap, struct cgb__fetchByCaseNumberResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocgb__fetchByCaseNumberResponse);
	if (soap_out_PointerTocgb__fetchByCaseNumberResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocgb__fetchByCaseNumberResponse(struct soap *soap, const char *tag, int id, struct cgb__fetchByCaseNumberResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cgb__fetchByCaseNumberResponse);
	if (id < 0)
		return soap->error;
	return soap_out_cgb__fetchByCaseNumberResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cgb__fetchByCaseNumberResponse ** SOAP_FMAC4 soap_get_PointerTocgb__fetchByCaseNumberResponse(struct soap *soap, struct cgb__fetchByCaseNumberResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocgb__fetchByCaseNumberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByCaseNumberResponse ** SOAP_FMAC4 soap_in_PointerTocgb__fetchByCaseNumberResponse(struct soap *soap, const char *tag, struct cgb__fetchByCaseNumberResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cgb__fetchByCaseNumberResponse **)soap_malloc(soap, sizeof(struct cgb__fetchByCaseNumberResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cgb__fetchByCaseNumberResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByCaseNumberResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cgb__fetchByCaseNumberResponse, sizeof(struct cgb__fetchByCaseNumberResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocgb__fetchByAccountResponse(struct soap *soap, struct cgb__fetchByAccountResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cgb__fetchByAccountResponse))
		soap_serialize_cgb__fetchByAccountResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocgb__fetchByAccountResponse(struct soap *soap, struct cgb__fetchByAccountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocgb__fetchByAccountResponse);
	if (soap_out_PointerTocgb__fetchByAccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocgb__fetchByAccountResponse(struct soap *soap, const char *tag, int id, struct cgb__fetchByAccountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cgb__fetchByAccountResponse);
	if (id < 0)
		return soap->error;
	return soap_out_cgb__fetchByAccountResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cgb__fetchByAccountResponse ** SOAP_FMAC4 soap_get_PointerTocgb__fetchByAccountResponse(struct soap *soap, struct cgb__fetchByAccountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocgb__fetchByAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByAccountResponse ** SOAP_FMAC4 soap_in_PointerTocgb__fetchByAccountResponse(struct soap *soap, const char *tag, struct cgb__fetchByAccountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cgb__fetchByAccountResponse **)soap_malloc(soap, sizeof(struct cgb__fetchByAccountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cgb__fetchByAccountResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByAccountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cgb__fetchByAccountResponse, sizeof(struct cgb__fetchByAccountResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfChargebacks(struct soap *soap, struct ArrayOfChargebacks *const*a)
{
	if (*a)
		soap_serialize_ArrayOfChargebacks(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfChargebacks(struct soap *soap, struct ArrayOfChargebacks *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfChargebacks);
	if (soap_out_PointerToArrayOfChargebacks(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfChargebacks(struct soap *soap, const char *tag, int id, struct ArrayOfChargebacks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfChargebacks);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfChargebacks(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfChargebacks ** SOAP_FMAC4 soap_get_PointerToArrayOfChargebacks(struct soap *soap, struct ArrayOfChargebacks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfChargebacks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfChargebacks ** SOAP_FMAC4 soap_in_PointerToArrayOfChargebacks(struct soap *soap, const char *tag, struct ArrayOfChargebacks **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfChargebacks **)soap_malloc(soap, sizeof(struct ArrayOfChargebacks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfChargebacks(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfChargebacks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfChargebacks, sizeof(struct ArrayOfChargebacks), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocgb__fetchByVidResponse(struct soap *soap, struct cgb__fetchByVidResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cgb__fetchByVidResponse))
		soap_serialize_cgb__fetchByVidResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocgb__fetchByVidResponse(struct soap *soap, struct cgb__fetchByVidResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocgb__fetchByVidResponse);
	if (soap_out_PointerTocgb__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocgb__fetchByVidResponse(struct soap *soap, const char *tag, int id, struct cgb__fetchByVidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cgb__fetchByVidResponse);
	if (id < 0)
		return soap->error;
	return soap_out_cgb__fetchByVidResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cgb__fetchByVidResponse ** SOAP_FMAC4 soap_get_PointerTocgb__fetchByVidResponse(struct soap *soap, struct cgb__fetchByVidResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocgb__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__fetchByVidResponse ** SOAP_FMAC4 soap_in_PointerTocgb__fetchByVidResponse(struct soap *soap, const char *tag, struct cgb__fetchByVidResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cgb__fetchByVidResponse **)soap_malloc(soap, sizeof(struct cgb__fetchByVidResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cgb__fetchByVidResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cgb__fetchByVidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cgb__fetchByVidResponse, sizeof(struct cgb__fetchByVidResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocgb__updateResponse(struct soap *soap, struct cgb__updateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_cgb__updateResponse))
		soap_serialize_cgb__updateResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocgb__updateResponse(struct soap *soap, struct cgb__updateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocgb__updateResponse);
	if (soap_out_PointerTocgb__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocgb__updateResponse(struct soap *soap, const char *tag, int id, struct cgb__updateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cgb__updateResponse);
	if (id < 0)
		return soap->error;
	return soap_out_cgb__updateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cgb__updateResponse ** SOAP_FMAC4 soap_get_PointerTocgb__updateResponse(struct soap *soap, struct cgb__updateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocgb__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct cgb__updateResponse ** SOAP_FMAC4 soap_in_PointerTocgb__updateResponse(struct soap *soap, const char *tag, struct cgb__updateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cgb__updateResponse **)soap_malloc(soap, sizeof(struct cgb__updateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cgb__updateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cgb__updateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cgb__updateResponse, sizeof(struct cgb__updateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobpl__fetchByMerchantEntitlementIdResponse(struct soap *soap, struct bpl__fetchByMerchantEntitlementIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bpl__fetchByMerchantEntitlementIdResponse))
		soap_serialize_bpl__fetchByMerchantEntitlementIdResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobpl__fetchByMerchantEntitlementIdResponse(struct soap *soap, struct bpl__fetchByMerchantEntitlementIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobpl__fetchByMerchantEntitlementIdResponse);
	if (soap_out_PointerTobpl__fetchByMerchantEntitlementIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobpl__fetchByMerchantEntitlementIdResponse(struct soap *soap, const char *tag, int id, struct bpl__fetchByMerchantEntitlementIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bpl__fetchByMerchantEntitlementIdResponse);
	if (id < 0)
		return soap->error;
	return soap_out_bpl__fetchByMerchantEntitlementIdResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bpl__fetchByMerchantEntitlementIdResponse ** SOAP_FMAC4 soap_get_PointerTobpl__fetchByMerchantEntitlementIdResponse(struct soap *soap, struct bpl__fetchByMerchantEntitlementIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobpl__fetchByMerchantEntitlementIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__fetchByMerchantEntitlementIdResponse ** SOAP_FMAC4 soap_in_PointerTobpl__fetchByMerchantEntitlementIdResponse(struct soap *soap, const char *tag, struct bpl__fetchByMerchantEntitlementIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bpl__fetchByMerchantEntitlementIdResponse **)soap_malloc(soap, sizeof(struct bpl__fetchByMerchantEntitlementIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bpl__fetchByMerchantEntitlementIdResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bpl__fetchByMerchantEntitlementIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bpl__fetchByMerchantEntitlementIdResponse, sizeof(struct bpl__fetchByMerchantEntitlementIdResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobpl__fetchAllResponse(struct soap *soap, struct bpl__fetchAllResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bpl__fetchAllResponse))
		soap_serialize_bpl__fetchAllResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobpl__fetchAllResponse(struct soap *soap, struct bpl__fetchAllResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobpl__fetchAllResponse);
	if (soap_out_PointerTobpl__fetchAllResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobpl__fetchAllResponse(struct soap *soap, const char *tag, int id, struct bpl__fetchAllResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bpl__fetchAllResponse);
	if (id < 0)
		return soap->error;
	return soap_out_bpl__fetchAllResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bpl__fetchAllResponse ** SOAP_FMAC4 soap_get_PointerTobpl__fetchAllResponse(struct soap *soap, struct bpl__fetchAllResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobpl__fetchAllResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__fetchAllResponse ** SOAP_FMAC4 soap_in_PointerTobpl__fetchAllResponse(struct soap *soap, const char *tag, struct bpl__fetchAllResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bpl__fetchAllResponse **)soap_malloc(soap, sizeof(struct bpl__fetchAllResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bpl__fetchAllResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bpl__fetchAllResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bpl__fetchAllResponse, sizeof(struct bpl__fetchAllResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobpl__fetchByBillingPlanStatusResponse(struct soap *soap, struct bpl__fetchByBillingPlanStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bpl__fetchByBillingPlanStatusResponse))
		soap_serialize_bpl__fetchByBillingPlanStatusResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobpl__fetchByBillingPlanStatusResponse(struct soap *soap, struct bpl__fetchByBillingPlanStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobpl__fetchByBillingPlanStatusResponse);
	if (soap_out_PointerTobpl__fetchByBillingPlanStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobpl__fetchByBillingPlanStatusResponse(struct soap *soap, const char *tag, int id, struct bpl__fetchByBillingPlanStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bpl__fetchByBillingPlanStatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out_bpl__fetchByBillingPlanStatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bpl__fetchByBillingPlanStatusResponse ** SOAP_FMAC4 soap_get_PointerTobpl__fetchByBillingPlanStatusResponse(struct soap *soap, struct bpl__fetchByBillingPlanStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobpl__fetchByBillingPlanStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__fetchByBillingPlanStatusResponse ** SOAP_FMAC4 soap_in_PointerTobpl__fetchByBillingPlanStatusResponse(struct soap *soap, const char *tag, struct bpl__fetchByBillingPlanStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bpl__fetchByBillingPlanStatusResponse **)soap_malloc(soap, sizeof(struct bpl__fetchByBillingPlanStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bpl__fetchByBillingPlanStatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bpl__fetchByBillingPlanStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bpl__fetchByBillingPlanStatusResponse, sizeof(struct bpl__fetchByBillingPlanStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfBillingPlans(struct soap *soap, struct ArrayOfBillingPlans *const*a)
{
	if (*a)
		soap_serialize_ArrayOfBillingPlans(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfBillingPlans(struct soap *soap, struct ArrayOfBillingPlans *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfBillingPlans);
	if (soap_out_PointerToArrayOfBillingPlans(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfBillingPlans(struct soap *soap, const char *tag, int id, struct ArrayOfBillingPlans *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfBillingPlans);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfBillingPlans(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfBillingPlans ** SOAP_FMAC4 soap_get_PointerToArrayOfBillingPlans(struct soap *soap, struct ArrayOfBillingPlans **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfBillingPlans(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfBillingPlans ** SOAP_FMAC4 soap_in_PointerToArrayOfBillingPlans(struct soap *soap, const char *tag, struct ArrayOfBillingPlans **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfBillingPlans **)soap_malloc(soap, sizeof(struct ArrayOfBillingPlans *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfBillingPlans(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfBillingPlans **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfBillingPlans, sizeof(struct ArrayOfBillingPlans), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobpl__fetchByMerchantBillingPlanIdResponse(struct soap *soap, struct bpl__fetchByMerchantBillingPlanIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bpl__fetchByMerchantBillingPlanIdResponse))
		soap_serialize_bpl__fetchByMerchantBillingPlanIdResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobpl__fetchByMerchantBillingPlanIdResponse(struct soap *soap, struct bpl__fetchByMerchantBillingPlanIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobpl__fetchByMerchantBillingPlanIdResponse);
	if (soap_out_PointerTobpl__fetchByMerchantBillingPlanIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobpl__fetchByMerchantBillingPlanIdResponse(struct soap *soap, const char *tag, int id, struct bpl__fetchByMerchantBillingPlanIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bpl__fetchByMerchantBillingPlanIdResponse);
	if (id < 0)
		return soap->error;
	return soap_out_bpl__fetchByMerchantBillingPlanIdResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bpl__fetchByMerchantBillingPlanIdResponse ** SOAP_FMAC4 soap_get_PointerTobpl__fetchByMerchantBillingPlanIdResponse(struct soap *soap, struct bpl__fetchByMerchantBillingPlanIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobpl__fetchByMerchantBillingPlanIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__fetchByMerchantBillingPlanIdResponse ** SOAP_FMAC4 soap_in_PointerTobpl__fetchByMerchantBillingPlanIdResponse(struct soap *soap, const char *tag, struct bpl__fetchByMerchantBillingPlanIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bpl__fetchByMerchantBillingPlanIdResponse **)soap_malloc(soap, sizeof(struct bpl__fetchByMerchantBillingPlanIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bpl__fetchByMerchantBillingPlanIdResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bpl__fetchByMerchantBillingPlanIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bpl__fetchByMerchantBillingPlanIdResponse, sizeof(struct bpl__fetchByMerchantBillingPlanIdResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobpl__fetchByVidResponse(struct soap *soap, struct bpl__fetchByVidResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bpl__fetchByVidResponse))
		soap_serialize_bpl__fetchByVidResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobpl__fetchByVidResponse(struct soap *soap, struct bpl__fetchByVidResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobpl__fetchByVidResponse);
	if (soap_out_PointerTobpl__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobpl__fetchByVidResponse(struct soap *soap, const char *tag, int id, struct bpl__fetchByVidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bpl__fetchByVidResponse);
	if (id < 0)
		return soap->error;
	return soap_out_bpl__fetchByVidResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bpl__fetchByVidResponse ** SOAP_FMAC4 soap_get_PointerTobpl__fetchByVidResponse(struct soap *soap, struct bpl__fetchByVidResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobpl__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__fetchByVidResponse ** SOAP_FMAC4 soap_in_PointerTobpl__fetchByVidResponse(struct soap *soap, const char *tag, struct bpl__fetchByVidResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bpl__fetchByVidResponse **)soap_malloc(soap, sizeof(struct bpl__fetchByVidResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bpl__fetchByVidResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bpl__fetchByVidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bpl__fetchByVidResponse, sizeof(struct bpl__fetchByVidResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobpl__updateResponse(struct soap *soap, struct bpl__updateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bpl__updateResponse))
		soap_serialize_bpl__updateResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobpl__updateResponse(struct soap *soap, struct bpl__updateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobpl__updateResponse);
	if (soap_out_PointerTobpl__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobpl__updateResponse(struct soap *soap, const char *tag, int id, struct bpl__updateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bpl__updateResponse);
	if (id < 0)
		return soap->error;
	return soap_out_bpl__updateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bpl__updateResponse ** SOAP_FMAC4 soap_get_PointerTobpl__updateResponse(struct soap *soap, struct bpl__updateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobpl__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct bpl__updateResponse ** SOAP_FMAC4 soap_in_PointerTobpl__updateResponse(struct soap *soap, const char *tag, struct bpl__updateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bpl__updateResponse **)soap_malloc(soap, sizeof(struct bpl__updateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bpl__updateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bpl__updateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bpl__updateResponse, sizeof(struct bpl__updateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToadd__fetchByVidResponse(struct soap *soap, struct add__fetchByVidResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_add__fetchByVidResponse))
		soap_serialize_add__fetchByVidResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToadd__fetchByVidResponse(struct soap *soap, struct add__fetchByVidResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToadd__fetchByVidResponse);
	if (soap_out_PointerToadd__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToadd__fetchByVidResponse(struct soap *soap, const char *tag, int id, struct add__fetchByVidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_add__fetchByVidResponse);
	if (id < 0)
		return soap->error;
	return soap_out_add__fetchByVidResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct add__fetchByVidResponse ** SOAP_FMAC4 soap_get_PointerToadd__fetchByVidResponse(struct soap *soap, struct add__fetchByVidResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToadd__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct add__fetchByVidResponse ** SOAP_FMAC4 soap_in_PointerToadd__fetchByVidResponse(struct soap *soap, const char *tag, struct add__fetchByVidResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct add__fetchByVidResponse **)soap_malloc(soap, sizeof(struct add__fetchByVidResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_add__fetchByVidResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct add__fetchByVidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_add__fetchByVidResponse, sizeof(struct add__fetchByVidResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToadd__updateResponse(struct soap *soap, struct add__updateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_add__updateResponse))
		soap_serialize_add__updateResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToadd__updateResponse(struct soap *soap, struct add__updateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToadd__updateResponse);
	if (soap_out_PointerToadd__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToadd__updateResponse(struct soap *soap, const char *tag, int id, struct add__updateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_add__updateResponse);
	if (id < 0)
		return soap->error;
	return soap_out_add__updateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct add__updateResponse ** SOAP_FMAC4 soap_get_PointerToadd__updateResponse(struct soap *soap, struct add__updateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToadd__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct add__updateResponse ** SOAP_FMAC4 soap_in_PointerToadd__updateResponse(struct soap *soap, const char *tag, struct add__updateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct add__updateResponse **)soap_malloc(soap, sizeof(struct add__updateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_add__updateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct add__updateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_add__updateResponse, sizeof(struct add__updateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToact__recordResponse(struct soap *soap, struct act__recordResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_act__recordResponse))
		soap_serialize_act__recordResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToact__recordResponse(struct soap *soap, struct act__recordResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToact__recordResponse);
	if (soap_out_PointerToact__recordResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToact__recordResponse(struct soap *soap, const char *tag, int id, struct act__recordResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_act__recordResponse);
	if (id < 0)
		return soap->error;
	return soap_out_act__recordResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct act__recordResponse ** SOAP_FMAC4 soap_get_PointerToact__recordResponse(struct soap *soap, struct act__recordResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToact__recordResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct act__recordResponse ** SOAP_FMAC4 soap_in_PointerToact__recordResponse(struct soap *soap, const char *tag, struct act__recordResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct act__recordResponse **)soap_malloc(soap, sizeof(struct act__recordResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_act__recordResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct act__recordResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_act__recordResponse, sizeof(struct act__recordResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfActivities(struct soap *soap, struct ArrayOfActivities *const*a)
{
	if (*a)
		soap_serialize_ArrayOfActivities(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfActivities(struct soap *soap, struct ArrayOfActivities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfActivities);
	if (soap_out_PointerToArrayOfActivities(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfActivities(struct soap *soap, const char *tag, int id, struct ArrayOfActivities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfActivities);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfActivities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfActivities ** SOAP_FMAC4 soap_get_PointerToArrayOfActivities(struct soap *soap, struct ArrayOfActivities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfActivities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfActivities ** SOAP_FMAC4 soap_in_PointerToArrayOfActivities(struct soap *soap, const char *tag, struct ArrayOfActivities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfActivities **)soap_malloc(soap, sizeof(struct ArrayOfActivities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfActivities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfActivities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfActivities, sizeof(struct ArrayOfActivities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToacc__transferResponse(struct soap *soap, struct acc__transferResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_acc__transferResponse))
		soap_serialize_acc__transferResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToacc__transferResponse(struct soap *soap, struct acc__transferResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToacc__transferResponse);
	if (soap_out_PointerToacc__transferResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToacc__transferResponse(struct soap *soap, const char *tag, int id, struct acc__transferResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_acc__transferResponse);
	if (id < 0)
		return soap->error;
	return soap_out_acc__transferResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct acc__transferResponse ** SOAP_FMAC4 soap_get_PointerToacc__transferResponse(struct soap *soap, struct acc__transferResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToacc__transferResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__transferResponse ** SOAP_FMAC4 soap_in_PointerToacc__transferResponse(struct soap *soap, const char *tag, struct acc__transferResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct acc__transferResponse **)soap_malloc(soap, sizeof(struct acc__transferResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_acc__transferResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct acc__transferResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_acc__transferResponse, sizeof(struct acc__transferResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToacc__decrementTokensResponse(struct soap *soap, struct acc__decrementTokensResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_acc__decrementTokensResponse))
		soap_serialize_acc__decrementTokensResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToacc__decrementTokensResponse(struct soap *soap, struct acc__decrementTokensResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToacc__decrementTokensResponse);
	if (soap_out_PointerToacc__decrementTokensResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToacc__decrementTokensResponse(struct soap *soap, const char *tag, int id, struct acc__decrementTokensResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_acc__decrementTokensResponse);
	if (id < 0)
		return soap->error;
	return soap_out_acc__decrementTokensResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct acc__decrementTokensResponse ** SOAP_FMAC4 soap_get_PointerToacc__decrementTokensResponse(struct soap *soap, struct acc__decrementTokensResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToacc__decrementTokensResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__decrementTokensResponse ** SOAP_FMAC4 soap_in_PointerToacc__decrementTokensResponse(struct soap *soap, const char *tag, struct acc__decrementTokensResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct acc__decrementTokensResponse **)soap_malloc(soap, sizeof(struct acc__decrementTokensResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_acc__decrementTokensResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct acc__decrementTokensResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_acc__decrementTokensResponse, sizeof(struct acc__decrementTokensResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToacc__incrementTokensResponse(struct soap *soap, struct acc__incrementTokensResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_acc__incrementTokensResponse))
		soap_serialize_acc__incrementTokensResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToacc__incrementTokensResponse(struct soap *soap, struct acc__incrementTokensResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToacc__incrementTokensResponse);
	if (soap_out_PointerToacc__incrementTokensResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToacc__incrementTokensResponse(struct soap *soap, const char *tag, int id, struct acc__incrementTokensResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_acc__incrementTokensResponse);
	if (id < 0)
		return soap->error;
	return soap_out_acc__incrementTokensResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct acc__incrementTokensResponse ** SOAP_FMAC4 soap_get_PointerToacc__incrementTokensResponse(struct soap *soap, struct acc__incrementTokensResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToacc__incrementTokensResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__incrementTokensResponse ** SOAP_FMAC4 soap_in_PointerToacc__incrementTokensResponse(struct soap *soap, const char *tag, struct acc__incrementTokensResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct acc__incrementTokensResponse **)soap_malloc(soap, sizeof(struct acc__incrementTokensResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_acc__incrementTokensResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct acc__incrementTokensResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_acc__incrementTokensResponse, sizeof(struct acc__incrementTokensResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToacc__tokenTransactionResponse(struct soap *soap, struct acc__tokenTransactionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_acc__tokenTransactionResponse))
		soap_serialize_acc__tokenTransactionResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToacc__tokenTransactionResponse(struct soap *soap, struct acc__tokenTransactionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToacc__tokenTransactionResponse);
	if (soap_out_PointerToacc__tokenTransactionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToacc__tokenTransactionResponse(struct soap *soap, const char *tag, int id, struct acc__tokenTransactionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_acc__tokenTransactionResponse);
	if (id < 0)
		return soap->error;
	return soap_out_acc__tokenTransactionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct acc__tokenTransactionResponse ** SOAP_FMAC4 soap_get_PointerToacc__tokenTransactionResponse(struct soap *soap, struct acc__tokenTransactionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToacc__tokenTransactionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__tokenTransactionResponse ** SOAP_FMAC4 soap_in_PointerToacc__tokenTransactionResponse(struct soap *soap, const char *tag, struct acc__tokenTransactionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct acc__tokenTransactionResponse **)soap_malloc(soap, sizeof(struct acc__tokenTransactionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_acc__tokenTransactionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct acc__tokenTransactionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_acc__tokenTransactionResponse, sizeof(struct acc__tokenTransactionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfTokenTransactions(struct soap *soap, struct ArrayOfTokenTransactions *const*a)
{
	if (*a)
		soap_serialize_ArrayOfTokenTransactions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfTokenTransactions(struct soap *soap, struct ArrayOfTokenTransactions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfTokenTransactions);
	if (soap_out_PointerToArrayOfTokenTransactions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfTokenTransactions(struct soap *soap, const char *tag, int id, struct ArrayOfTokenTransactions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfTokenTransactions);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfTokenTransactions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfTokenTransactions ** SOAP_FMAC4 soap_get_PointerToArrayOfTokenTransactions(struct soap *soap, struct ArrayOfTokenTransactions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfTokenTransactions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfTokenTransactions ** SOAP_FMAC4 soap_in_PointerToArrayOfTokenTransactions(struct soap *soap, const char *tag, struct ArrayOfTokenTransactions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfTokenTransactions **)soap_malloc(soap, sizeof(struct ArrayOfTokenTransactions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfTokenTransactions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfTokenTransactions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfTokenTransactions, sizeof(struct ArrayOfTokenTransactions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToacc__tokenBalanceResponse(struct soap *soap, struct acc__tokenBalanceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_acc__tokenBalanceResponse))
		soap_serialize_acc__tokenBalanceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToacc__tokenBalanceResponse(struct soap *soap, struct acc__tokenBalanceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToacc__tokenBalanceResponse);
	if (soap_out_PointerToacc__tokenBalanceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToacc__tokenBalanceResponse(struct soap *soap, const char *tag, int id, struct acc__tokenBalanceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_acc__tokenBalanceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_acc__tokenBalanceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct acc__tokenBalanceResponse ** SOAP_FMAC4 soap_get_PointerToacc__tokenBalanceResponse(struct soap *soap, struct acc__tokenBalanceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToacc__tokenBalanceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__tokenBalanceResponse ** SOAP_FMAC4 soap_in_PointerToacc__tokenBalanceResponse(struct soap *soap, const char *tag, struct acc__tokenBalanceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct acc__tokenBalanceResponse **)soap_malloc(soap, sizeof(struct acc__tokenBalanceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_acc__tokenBalanceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct acc__tokenBalanceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_acc__tokenBalanceResponse, sizeof(struct acc__tokenBalanceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfTokens(struct soap *soap, struct ArrayOfTokens *const*a)
{
	if (*a)
		soap_serialize_ArrayOfTokens(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfTokens(struct soap *soap, struct ArrayOfTokens *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfTokens);
	if (soap_out_PointerToArrayOfTokens(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfTokens(struct soap *soap, const char *tag, int id, struct ArrayOfTokens *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfTokens);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfTokens(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfTokens ** SOAP_FMAC4 soap_get_PointerToArrayOfTokens(struct soap *soap, struct ArrayOfTokens **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfTokens(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfTokens ** SOAP_FMAC4 soap_in_PointerToArrayOfTokens(struct soap *soap, const char *tag, struct ArrayOfTokens **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfTokens **)soap_malloc(soap, sizeof(struct ArrayOfTokens *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfTokens(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfTokens **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfTokens, sizeof(struct ArrayOfTokens), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToacc__fetchByPaymentMethodResponse(struct soap *soap, struct acc__fetchByPaymentMethodResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_acc__fetchByPaymentMethodResponse))
		soap_serialize_acc__fetchByPaymentMethodResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToacc__fetchByPaymentMethodResponse(struct soap *soap, struct acc__fetchByPaymentMethodResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToacc__fetchByPaymentMethodResponse);
	if (soap_out_PointerToacc__fetchByPaymentMethodResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToacc__fetchByPaymentMethodResponse(struct soap *soap, const char *tag, int id, struct acc__fetchByPaymentMethodResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_acc__fetchByPaymentMethodResponse);
	if (id < 0)
		return soap->error;
	return soap_out_acc__fetchByPaymentMethodResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct acc__fetchByPaymentMethodResponse ** SOAP_FMAC4 soap_get_PointerToacc__fetchByPaymentMethodResponse(struct soap *soap, struct acc__fetchByPaymentMethodResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToacc__fetchByPaymentMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__fetchByPaymentMethodResponse ** SOAP_FMAC4 soap_in_PointerToacc__fetchByPaymentMethodResponse(struct soap *soap, const char *tag, struct acc__fetchByPaymentMethodResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct acc__fetchByPaymentMethodResponse **)soap_malloc(soap, sizeof(struct acc__fetchByPaymentMethodResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_acc__fetchByPaymentMethodResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct acc__fetchByPaymentMethodResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_acc__fetchByPaymentMethodResponse, sizeof(struct acc__fetchByPaymentMethodResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToacc__fetchByEmailResponse(struct soap *soap, struct acc__fetchByEmailResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_acc__fetchByEmailResponse))
		soap_serialize_acc__fetchByEmailResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToacc__fetchByEmailResponse(struct soap *soap, struct acc__fetchByEmailResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToacc__fetchByEmailResponse);
	if (soap_out_PointerToacc__fetchByEmailResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToacc__fetchByEmailResponse(struct soap *soap, const char *tag, int id, struct acc__fetchByEmailResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_acc__fetchByEmailResponse);
	if (id < 0)
		return soap->error;
	return soap_out_acc__fetchByEmailResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct acc__fetchByEmailResponse ** SOAP_FMAC4 soap_get_PointerToacc__fetchByEmailResponse(struct soap *soap, struct acc__fetchByEmailResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToacc__fetchByEmailResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__fetchByEmailResponse ** SOAP_FMAC4 soap_in_PointerToacc__fetchByEmailResponse(struct soap *soap, const char *tag, struct acc__fetchByEmailResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct acc__fetchByEmailResponse **)soap_malloc(soap, sizeof(struct acc__fetchByEmailResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_acc__fetchByEmailResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct acc__fetchByEmailResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_acc__fetchByEmailResponse, sizeof(struct acc__fetchByEmailResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfAccounts(struct soap *soap, struct ArrayOfAccounts *const*a)
{
	if (*a)
		soap_serialize_ArrayOfAccounts(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfAccounts(struct soap *soap, struct ArrayOfAccounts *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfAccounts);
	if (soap_out_PointerToArrayOfAccounts(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfAccounts(struct soap *soap, const char *tag, int id, struct ArrayOfAccounts *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfAccounts);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfAccounts(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfAccounts ** SOAP_FMAC4 soap_get_PointerToArrayOfAccounts(struct soap *soap, struct ArrayOfAccounts **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfAccounts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfAccounts ** SOAP_FMAC4 soap_in_PointerToArrayOfAccounts(struct soap *soap, const char *tag, struct ArrayOfAccounts **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfAccounts **)soap_malloc(soap, sizeof(struct ArrayOfAccounts *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfAccounts(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfAccounts **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfAccounts, sizeof(struct ArrayOfAccounts), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToacc__fetchByVidResponse(struct soap *soap, struct acc__fetchByVidResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_acc__fetchByVidResponse))
		soap_serialize_acc__fetchByVidResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToacc__fetchByVidResponse(struct soap *soap, struct acc__fetchByVidResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToacc__fetchByVidResponse);
	if (soap_out_PointerToacc__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToacc__fetchByVidResponse(struct soap *soap, const char *tag, int id, struct acc__fetchByVidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_acc__fetchByVidResponse);
	if (id < 0)
		return soap->error;
	return soap_out_acc__fetchByVidResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct acc__fetchByVidResponse ** SOAP_FMAC4 soap_get_PointerToacc__fetchByVidResponse(struct soap *soap, struct acc__fetchByVidResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToacc__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__fetchByVidResponse ** SOAP_FMAC4 soap_in_PointerToacc__fetchByVidResponse(struct soap *soap, const char *tag, struct acc__fetchByVidResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct acc__fetchByVidResponse **)soap_malloc(soap, sizeof(struct acc__fetchByVidResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_acc__fetchByVidResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct acc__fetchByVidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_acc__fetchByVidResponse, sizeof(struct acc__fetchByVidResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToacc__fetchByMerchantAccountIdResponse(struct soap *soap, struct acc__fetchByMerchantAccountIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_acc__fetchByMerchantAccountIdResponse))
		soap_serialize_acc__fetchByMerchantAccountIdResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToacc__fetchByMerchantAccountIdResponse(struct soap *soap, struct acc__fetchByMerchantAccountIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToacc__fetchByMerchantAccountIdResponse);
	if (soap_out_PointerToacc__fetchByMerchantAccountIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToacc__fetchByMerchantAccountIdResponse(struct soap *soap, const char *tag, int id, struct acc__fetchByMerchantAccountIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_acc__fetchByMerchantAccountIdResponse);
	if (id < 0)
		return soap->error;
	return soap_out_acc__fetchByMerchantAccountIdResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct acc__fetchByMerchantAccountIdResponse ** SOAP_FMAC4 soap_get_PointerToacc__fetchByMerchantAccountIdResponse(struct soap *soap, struct acc__fetchByMerchantAccountIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToacc__fetchByMerchantAccountIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__fetchByMerchantAccountIdResponse ** SOAP_FMAC4 soap_in_PointerToacc__fetchByMerchantAccountIdResponse(struct soap *soap, const char *tag, struct acc__fetchByMerchantAccountIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct acc__fetchByMerchantAccountIdResponse **)soap_malloc(soap, sizeof(struct acc__fetchByMerchantAccountIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_acc__fetchByMerchantAccountIdResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct acc__fetchByMerchantAccountIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_acc__fetchByMerchantAccountIdResponse, sizeof(struct acc__fetchByMerchantAccountIdResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToacc__updatePaymentMethodResponse(struct soap *soap, struct acc__updatePaymentMethodResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_acc__updatePaymentMethodResponse))
		soap_serialize_acc__updatePaymentMethodResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToacc__updatePaymentMethodResponse(struct soap *soap, struct acc__updatePaymentMethodResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToacc__updatePaymentMethodResponse);
	if (soap_out_PointerToacc__updatePaymentMethodResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToacc__updatePaymentMethodResponse(struct soap *soap, const char *tag, int id, struct acc__updatePaymentMethodResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_acc__updatePaymentMethodResponse);
	if (id < 0)
		return soap->error;
	return soap_out_acc__updatePaymentMethodResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct acc__updatePaymentMethodResponse ** SOAP_FMAC4 soap_get_PointerToacc__updatePaymentMethodResponse(struct soap *soap, struct acc__updatePaymentMethodResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToacc__updatePaymentMethodResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__updatePaymentMethodResponse ** SOAP_FMAC4 soap_in_PointerToacc__updatePaymentMethodResponse(struct soap *soap, const char *tag, struct acc__updatePaymentMethodResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct acc__updatePaymentMethodResponse **)soap_malloc(soap, sizeof(struct acc__updatePaymentMethodResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_acc__updatePaymentMethodResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct acc__updatePaymentMethodResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_acc__updatePaymentMethodResponse, sizeof(struct acc__updatePaymentMethodResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToacc__stopAutoBillingResponse(struct soap *soap, struct acc__stopAutoBillingResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_acc__stopAutoBillingResponse))
		soap_serialize_acc__stopAutoBillingResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToacc__stopAutoBillingResponse(struct soap *soap, struct acc__stopAutoBillingResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToacc__stopAutoBillingResponse);
	if (soap_out_PointerToacc__stopAutoBillingResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToacc__stopAutoBillingResponse(struct soap *soap, const char *tag, int id, struct acc__stopAutoBillingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_acc__stopAutoBillingResponse);
	if (id < 0)
		return soap->error;
	return soap_out_acc__stopAutoBillingResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct acc__stopAutoBillingResponse ** SOAP_FMAC4 soap_get_PointerToacc__stopAutoBillingResponse(struct soap *soap, struct acc__stopAutoBillingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToacc__stopAutoBillingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__stopAutoBillingResponse ** SOAP_FMAC4 soap_in_PointerToacc__stopAutoBillingResponse(struct soap *soap, const char *tag, struct acc__stopAutoBillingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct acc__stopAutoBillingResponse **)soap_malloc(soap, sizeof(struct acc__stopAutoBillingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_acc__stopAutoBillingResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct acc__stopAutoBillingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_acc__stopAutoBillingResponse, sizeof(struct acc__stopAutoBillingResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToacc__updateResponse(struct soap *soap, struct acc__updateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_acc__updateResponse))
		soap_serialize_acc__updateResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToacc__updateResponse(struct soap *soap, struct acc__updateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToacc__updateResponse);
	if (soap_out_PointerToacc__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToacc__updateResponse(struct soap *soap, const char *tag, int id, struct acc__updateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_acc__updateResponse);
	if (id < 0)
		return soap->error;
	return soap_out_acc__updateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct acc__updateResponse ** SOAP_FMAC4 soap_get_PointerToacc__updateResponse(struct soap *soap, struct acc__updateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToacc__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct acc__updateResponse ** SOAP_FMAC4 soap_in_PointerToacc__updateResponse(struct soap *soap, const char *tag, struct acc__updateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct acc__updateResponse **)soap_malloc(soap, sizeof(struct acc__updateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_acc__updateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct acc__updateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_acc__updateResponse, sizeof(struct acc__updateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToabl__fetchDeltaSinceResponse(struct soap *soap, struct abl__fetchDeltaSinceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_abl__fetchDeltaSinceResponse))
		soap_serialize_abl__fetchDeltaSinceResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToabl__fetchDeltaSinceResponse(struct soap *soap, struct abl__fetchDeltaSinceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToabl__fetchDeltaSinceResponse);
	if (soap_out_PointerToabl__fetchDeltaSinceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToabl__fetchDeltaSinceResponse(struct soap *soap, const char *tag, int id, struct abl__fetchDeltaSinceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_abl__fetchDeltaSinceResponse);
	if (id < 0)
		return soap->error;
	return soap_out_abl__fetchDeltaSinceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct abl__fetchDeltaSinceResponse ** SOAP_FMAC4 soap_get_PointerToabl__fetchDeltaSinceResponse(struct soap *soap, struct abl__fetchDeltaSinceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToabl__fetchDeltaSinceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchDeltaSinceResponse ** SOAP_FMAC4 soap_in_PointerToabl__fetchDeltaSinceResponse(struct soap *soap, const char *tag, struct abl__fetchDeltaSinceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct abl__fetchDeltaSinceResponse **)soap_malloc(soap, sizeof(struct abl__fetchDeltaSinceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_abl__fetchDeltaSinceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct abl__fetchDeltaSinceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_abl__fetchDeltaSinceResponse, sizeof(struct abl__fetchDeltaSinceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToabl__futureRebillsResponse(struct soap *soap, struct abl__futureRebillsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_abl__futureRebillsResponse))
		soap_serialize_abl__futureRebillsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToabl__futureRebillsResponse(struct soap *soap, struct abl__futureRebillsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToabl__futureRebillsResponse);
	if (soap_out_PointerToabl__futureRebillsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToabl__futureRebillsResponse(struct soap *soap, const char *tag, int id, struct abl__futureRebillsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_abl__futureRebillsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_abl__futureRebillsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct abl__futureRebillsResponse ** SOAP_FMAC4 soap_get_PointerToabl__futureRebillsResponse(struct soap *soap, struct abl__futureRebillsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToabl__futureRebillsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__futureRebillsResponse ** SOAP_FMAC4 soap_in_PointerToabl__futureRebillsResponse(struct soap *soap, const char *tag, struct abl__futureRebillsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct abl__futureRebillsResponse **)soap_malloc(soap, sizeof(struct abl__futureRebillsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_abl__futureRebillsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct abl__futureRebillsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_abl__futureRebillsResponse, sizeof(struct abl__futureRebillsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToabl__fetchByAccountResponse(struct soap *soap, struct abl__fetchByAccountResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_abl__fetchByAccountResponse))
		soap_serialize_abl__fetchByAccountResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToabl__fetchByAccountResponse(struct soap *soap, struct abl__fetchByAccountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToabl__fetchByAccountResponse);
	if (soap_out_PointerToabl__fetchByAccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToabl__fetchByAccountResponse(struct soap *soap, const char *tag, int id, struct abl__fetchByAccountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_abl__fetchByAccountResponse);
	if (id < 0)
		return soap->error;
	return soap_out_abl__fetchByAccountResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct abl__fetchByAccountResponse ** SOAP_FMAC4 soap_get_PointerToabl__fetchByAccountResponse(struct soap *soap, struct abl__fetchByAccountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToabl__fetchByAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchByAccountResponse ** SOAP_FMAC4 soap_in_PointerToabl__fetchByAccountResponse(struct soap *soap, const char *tag, struct abl__fetchByAccountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct abl__fetchByAccountResponse **)soap_malloc(soap, sizeof(struct abl__fetchByAccountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_abl__fetchByAccountResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct abl__fetchByAccountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_abl__fetchByAccountResponse, sizeof(struct abl__fetchByAccountResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToabl__fetchByEmailResponse(struct soap *soap, struct abl__fetchByEmailResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_abl__fetchByEmailResponse))
		soap_serialize_abl__fetchByEmailResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToabl__fetchByEmailResponse(struct soap *soap, struct abl__fetchByEmailResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToabl__fetchByEmailResponse);
	if (soap_out_PointerToabl__fetchByEmailResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToabl__fetchByEmailResponse(struct soap *soap, const char *tag, int id, struct abl__fetchByEmailResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_abl__fetchByEmailResponse);
	if (id < 0)
		return soap->error;
	return soap_out_abl__fetchByEmailResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct abl__fetchByEmailResponse ** SOAP_FMAC4 soap_get_PointerToabl__fetchByEmailResponse(struct soap *soap, struct abl__fetchByEmailResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToabl__fetchByEmailResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchByEmailResponse ** SOAP_FMAC4 soap_in_PointerToabl__fetchByEmailResponse(struct soap *soap, const char *tag, struct abl__fetchByEmailResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct abl__fetchByEmailResponse **)soap_malloc(soap, sizeof(struct abl__fetchByEmailResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_abl__fetchByEmailResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct abl__fetchByEmailResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_abl__fetchByEmailResponse, sizeof(struct abl__fetchByEmailResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToabl__fetchByVidResponse(struct soap *soap, struct abl__fetchByVidResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_abl__fetchByVidResponse))
		soap_serialize_abl__fetchByVidResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToabl__fetchByVidResponse(struct soap *soap, struct abl__fetchByVidResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToabl__fetchByVidResponse);
	if (soap_out_PointerToabl__fetchByVidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToabl__fetchByVidResponse(struct soap *soap, const char *tag, int id, struct abl__fetchByVidResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_abl__fetchByVidResponse);
	if (id < 0)
		return soap->error;
	return soap_out_abl__fetchByVidResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct abl__fetchByVidResponse ** SOAP_FMAC4 soap_get_PointerToabl__fetchByVidResponse(struct soap *soap, struct abl__fetchByVidResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToabl__fetchByVidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchByVidResponse ** SOAP_FMAC4 soap_in_PointerToabl__fetchByVidResponse(struct soap *soap, const char *tag, struct abl__fetchByVidResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct abl__fetchByVidResponse **)soap_malloc(soap, sizeof(struct abl__fetchByVidResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_abl__fetchByVidResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct abl__fetchByVidResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_abl__fetchByVidResponse, sizeof(struct abl__fetchByVidResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToabl__fetchByMerchantAutoBillIdResponse(struct soap *soap, struct abl__fetchByMerchantAutoBillIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_abl__fetchByMerchantAutoBillIdResponse))
		soap_serialize_abl__fetchByMerchantAutoBillIdResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToabl__fetchByMerchantAutoBillIdResponse(struct soap *soap, struct abl__fetchByMerchantAutoBillIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToabl__fetchByMerchantAutoBillIdResponse);
	if (soap_out_PointerToabl__fetchByMerchantAutoBillIdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToabl__fetchByMerchantAutoBillIdResponse(struct soap *soap, const char *tag, int id, struct abl__fetchByMerchantAutoBillIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_abl__fetchByMerchantAutoBillIdResponse);
	if (id < 0)
		return soap->error;
	return soap_out_abl__fetchByMerchantAutoBillIdResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct abl__fetchByMerchantAutoBillIdResponse ** SOAP_FMAC4 soap_get_PointerToabl__fetchByMerchantAutoBillIdResponse(struct soap *soap, struct abl__fetchByMerchantAutoBillIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToabl__fetchByMerchantAutoBillIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchByMerchantAutoBillIdResponse ** SOAP_FMAC4 soap_in_PointerToabl__fetchByMerchantAutoBillIdResponse(struct soap *soap, const char *tag, struct abl__fetchByMerchantAutoBillIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct abl__fetchByMerchantAutoBillIdResponse **)soap_malloc(soap, sizeof(struct abl__fetchByMerchantAutoBillIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_abl__fetchByMerchantAutoBillIdResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct abl__fetchByMerchantAutoBillIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_abl__fetchByMerchantAutoBillIdResponse, sizeof(struct abl__fetchByMerchantAutoBillIdResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToabl__fetchByAccountAndProductResponse(struct soap *soap, struct abl__fetchByAccountAndProductResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_abl__fetchByAccountAndProductResponse))
		soap_serialize_abl__fetchByAccountAndProductResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToabl__fetchByAccountAndProductResponse(struct soap *soap, struct abl__fetchByAccountAndProductResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToabl__fetchByAccountAndProductResponse);
	if (soap_out_PointerToabl__fetchByAccountAndProductResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToabl__fetchByAccountAndProductResponse(struct soap *soap, const char *tag, int id, struct abl__fetchByAccountAndProductResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_abl__fetchByAccountAndProductResponse);
	if (id < 0)
		return soap->error;
	return soap_out_abl__fetchByAccountAndProductResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct abl__fetchByAccountAndProductResponse ** SOAP_FMAC4 soap_get_PointerToabl__fetchByAccountAndProductResponse(struct soap *soap, struct abl__fetchByAccountAndProductResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToabl__fetchByAccountAndProductResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__fetchByAccountAndProductResponse ** SOAP_FMAC4 soap_in_PointerToabl__fetchByAccountAndProductResponse(struct soap *soap, const char *tag, struct abl__fetchByAccountAndProductResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct abl__fetchByAccountAndProductResponse **)soap_malloc(soap, sizeof(struct abl__fetchByAccountAndProductResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_abl__fetchByAccountAndProductResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct abl__fetchByAccountAndProductResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_abl__fetchByAccountAndProductResponse, sizeof(struct abl__fetchByAccountAndProductResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfAutoBills(struct soap *soap, struct ArrayOfAutoBills *const*a)
{
	if (*a)
		soap_serialize_ArrayOfAutoBills(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfAutoBills(struct soap *soap, struct ArrayOfAutoBills *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfAutoBills);
	if (soap_out_PointerToArrayOfAutoBills(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfAutoBills(struct soap *soap, const char *tag, int id, struct ArrayOfAutoBills *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfAutoBills);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfAutoBills(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfAutoBills ** SOAP_FMAC4 soap_get_PointerToArrayOfAutoBills(struct soap *soap, struct ArrayOfAutoBills **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfAutoBills(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfAutoBills ** SOAP_FMAC4 soap_in_PointerToArrayOfAutoBills(struct soap *soap, const char *tag, struct ArrayOfAutoBills **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfAutoBills **)soap_malloc(soap, sizeof(struct ArrayOfAutoBills *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfAutoBills(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfAutoBills **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfAutoBills, sizeof(struct ArrayOfAutoBills), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToabl__changeBillingDayOfMonthResponse(struct soap *soap, struct abl__changeBillingDayOfMonthResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_abl__changeBillingDayOfMonthResponse))
		soap_serialize_abl__changeBillingDayOfMonthResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToabl__changeBillingDayOfMonthResponse(struct soap *soap, struct abl__changeBillingDayOfMonthResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToabl__changeBillingDayOfMonthResponse);
	if (soap_out_PointerToabl__changeBillingDayOfMonthResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToabl__changeBillingDayOfMonthResponse(struct soap *soap, const char *tag, int id, struct abl__changeBillingDayOfMonthResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_abl__changeBillingDayOfMonthResponse);
	if (id < 0)
		return soap->error;
	return soap_out_abl__changeBillingDayOfMonthResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct abl__changeBillingDayOfMonthResponse ** SOAP_FMAC4 soap_get_PointerToabl__changeBillingDayOfMonthResponse(struct soap *soap, struct abl__changeBillingDayOfMonthResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToabl__changeBillingDayOfMonthResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__changeBillingDayOfMonthResponse ** SOAP_FMAC4 soap_in_PointerToabl__changeBillingDayOfMonthResponse(struct soap *soap, const char *tag, struct abl__changeBillingDayOfMonthResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct abl__changeBillingDayOfMonthResponse **)soap_malloc(soap, sizeof(struct abl__changeBillingDayOfMonthResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_abl__changeBillingDayOfMonthResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct abl__changeBillingDayOfMonthResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_abl__changeBillingDayOfMonthResponse, sizeof(struct abl__changeBillingDayOfMonthResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToabl__delayBillingByDaysResponse(struct soap *soap, struct abl__delayBillingByDaysResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_abl__delayBillingByDaysResponse))
		soap_serialize_abl__delayBillingByDaysResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToabl__delayBillingByDaysResponse(struct soap *soap, struct abl__delayBillingByDaysResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToabl__delayBillingByDaysResponse);
	if (soap_out_PointerToabl__delayBillingByDaysResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToabl__delayBillingByDaysResponse(struct soap *soap, const char *tag, int id, struct abl__delayBillingByDaysResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_abl__delayBillingByDaysResponse);
	if (id < 0)
		return soap->error;
	return soap_out_abl__delayBillingByDaysResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct abl__delayBillingByDaysResponse ** SOAP_FMAC4 soap_get_PointerToabl__delayBillingByDaysResponse(struct soap *soap, struct abl__delayBillingByDaysResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToabl__delayBillingByDaysResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__delayBillingByDaysResponse ** SOAP_FMAC4 soap_in_PointerToabl__delayBillingByDaysResponse(struct soap *soap, const char *tag, struct abl__delayBillingByDaysResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct abl__delayBillingByDaysResponse **)soap_malloc(soap, sizeof(struct abl__delayBillingByDaysResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_abl__delayBillingByDaysResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct abl__delayBillingByDaysResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_abl__delayBillingByDaysResponse, sizeof(struct abl__delayBillingByDaysResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToabl__delayBillingToDateResponse(struct soap *soap, struct abl__delayBillingToDateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_abl__delayBillingToDateResponse))
		soap_serialize_abl__delayBillingToDateResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToabl__delayBillingToDateResponse(struct soap *soap, struct abl__delayBillingToDateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToabl__delayBillingToDateResponse);
	if (soap_out_PointerToabl__delayBillingToDateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToabl__delayBillingToDateResponse(struct soap *soap, const char *tag, int id, struct abl__delayBillingToDateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_abl__delayBillingToDateResponse);
	if (id < 0)
		return soap->error;
	return soap_out_abl__delayBillingToDateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct abl__delayBillingToDateResponse ** SOAP_FMAC4 soap_get_PointerToabl__delayBillingToDateResponse(struct soap *soap, struct abl__delayBillingToDateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToabl__delayBillingToDateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__delayBillingToDateResponse ** SOAP_FMAC4 soap_in_PointerToabl__delayBillingToDateResponse(struct soap *soap, const char *tag, struct abl__delayBillingToDateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct abl__delayBillingToDateResponse **)soap_malloc(soap, sizeof(struct abl__delayBillingToDateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_abl__delayBillingToDateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct abl__delayBillingToDateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_abl__delayBillingToDateResponse, sizeof(struct abl__delayBillingToDateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToabl__cancelResponse(struct soap *soap, struct abl__cancelResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_abl__cancelResponse))
		soap_serialize_abl__cancelResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToabl__cancelResponse(struct soap *soap, struct abl__cancelResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToabl__cancelResponse);
	if (soap_out_PointerToabl__cancelResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToabl__cancelResponse(struct soap *soap, const char *tag, int id, struct abl__cancelResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_abl__cancelResponse);
	if (id < 0)
		return soap->error;
	return soap_out_abl__cancelResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct abl__cancelResponse ** SOAP_FMAC4 soap_get_PointerToabl__cancelResponse(struct soap *soap, struct abl__cancelResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToabl__cancelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__cancelResponse ** SOAP_FMAC4 soap_in_PointerToabl__cancelResponse(struct soap *soap, const char *tag, struct abl__cancelResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct abl__cancelResponse **)soap_malloc(soap, sizeof(struct abl__cancelResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_abl__cancelResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct abl__cancelResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_abl__cancelResponse, sizeof(struct abl__cancelResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToabl__updateResponse(struct soap *soap, struct abl__updateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_abl__updateResponse))
		soap_serialize_abl__updateResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToabl__updateResponse(struct soap *soap, struct abl__updateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToabl__updateResponse);
	if (soap_out_PointerToabl__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToabl__updateResponse(struct soap *soap, const char *tag, int id, struct abl__updateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_abl__updateResponse);
	if (id < 0)
		return soap->error;
	return soap_out_abl__updateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct abl__updateResponse ** SOAP_FMAC4 soap_get_PointerToabl__updateResponse(struct soap *soap, struct abl__updateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToabl__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct abl__updateResponse ** SOAP_FMAC4 soap_in_PointerToabl__updateResponse(struct soap *soap, const char *tag, struct abl__updateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct abl__updateResponse **)soap_malloc(soap, sizeof(struct abl__updateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_abl__updateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct abl__updateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_abl__updateResponse, sizeof(struct abl__updateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__Authentication(struct soap *soap, struct vin__Authentication *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__Authentication))
		soap_serialize_vin__Authentication(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__Authentication(struct soap *soap, struct vin__Authentication *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__Authentication);
	if (soap_out_PointerTovin__Authentication(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__Authentication(struct soap *soap, const char *tag, int id, struct vin__Authentication *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__Authentication);
	if (id < 0)
		return soap->error;
	return soap_out_vin__Authentication(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Authentication ** SOAP_FMAC4 soap_get_PointerTovin__Authentication(struct soap *soap, struct vin__Authentication **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__Authentication(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Authentication ** SOAP_FMAC4 soap_in_PointerTovin__Authentication(struct soap *soap, const char *tag, struct vin__Authentication **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Authentication **)soap_malloc(soap, sizeof(struct vin__Authentication *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__Authentication(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Authentication **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__Authentication, sizeof(struct vin__Authentication), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__Return(struct soap *soap, struct vin__Return *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__Return))
		soap_serialize_vin__Return(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__Return(struct soap *soap, struct vin__Return *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__Return);
	if (soap_out_PointerTovin__Return(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__Return(struct soap *soap, const char *tag, int id, struct vin__Return *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__Return);
	if (id < 0)
		return soap->error;
	return soap_out_vin__Return(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Return ** SOAP_FMAC4 soap_get_PointerTovin__Return(struct soap *soap, struct vin__Return **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__Return(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Return ** SOAP_FMAC4 soap_in_PointerTovin__Return(struct soap *soap, const char *tag, struct vin__Return **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Return **)soap_malloc(soap, sizeof(struct vin__Return *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__Return(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Return **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__Return, sizeof(struct vin__Return), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__Transaction(struct soap *soap, struct vin__Transaction **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__Transaction))
		soap_serialize_PointerTovin__Transaction(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__Transaction(struct soap *soap, struct vin__Transaction **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__Transaction);
	if (soap_out_PointerToPointerTovin__Transaction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__Transaction(struct soap *soap, const char *tag, int id, struct vin__Transaction **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__Transaction);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__Transaction(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Transaction *** SOAP_FMAC4 soap_get_PointerToPointerTovin__Transaction(struct soap *soap, struct vin__Transaction ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__Transaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Transaction *** SOAP_FMAC4 soap_in_PointerToPointerTovin__Transaction(struct soap *soap, const char *tag, struct vin__Transaction ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Transaction ***)soap_malloc(soap, sizeof(struct vin__Transaction **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__Transaction(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Transaction ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__Transaction, sizeof(struct vin__Transaction *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__TransactionStatus(struct soap *soap, struct vin__TransactionStatus **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__TransactionStatus))
		soap_serialize_PointerTovin__TransactionStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__TransactionStatus(struct soap *soap, struct vin__TransactionStatus **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__TransactionStatus);
	if (soap_out_PointerToPointerTovin__TransactionStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__TransactionStatus(struct soap *soap, const char *tag, int id, struct vin__TransactionStatus **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__TransactionStatus);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__TransactionStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__TransactionStatus *** SOAP_FMAC4 soap_get_PointerToPointerTovin__TransactionStatus(struct soap *soap, struct vin__TransactionStatus ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__TransactionStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TransactionStatus *** SOAP_FMAC4 soap_in_PointerToPointerTovin__TransactionStatus(struct soap *soap, const char *tag, struct vin__TransactionStatus ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__TransactionStatus ***)soap_malloc(soap, sizeof(struct vin__TransactionStatus **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__TransactionStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__TransactionStatus ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__TransactionStatus, sizeof(struct vin__TransactionStatus *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__TransactionStatus(struct soap *soap, struct vin__TransactionStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__TransactionStatus))
		soap_serialize_vin__TransactionStatus(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__TransactionStatus(struct soap *soap, struct vin__TransactionStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__TransactionStatus);
	if (soap_out_PointerTovin__TransactionStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__TransactionStatus(struct soap *soap, const char *tag, int id, struct vin__TransactionStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__TransactionStatus);
	if (id < 0)
		return soap->error;
	return soap_out_vin__TransactionStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__TransactionStatus ** SOAP_FMAC4 soap_get_PointerTovin__TransactionStatus(struct soap *soap, struct vin__TransactionStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__TransactionStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TransactionStatus ** SOAP_FMAC4 soap_in_PointerTovin__TransactionStatus(struct soap *soap, const char *tag, struct vin__TransactionStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__TransactionStatus **)soap_malloc(soap, sizeof(struct vin__TransactionStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__TransactionStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__TransactionStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__TransactionStatus, sizeof(struct vin__TransactionStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__TransactionItem(struct soap *soap, struct vin__TransactionItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__TransactionItem))
		soap_serialize_PointerTovin__TransactionItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__TransactionItem(struct soap *soap, struct vin__TransactionItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__TransactionItem);
	if (soap_out_PointerToPointerTovin__TransactionItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__TransactionItem(struct soap *soap, const char *tag, int id, struct vin__TransactionItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__TransactionItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__TransactionItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__TransactionItem *** SOAP_FMAC4 soap_get_PointerToPointerTovin__TransactionItem(struct soap *soap, struct vin__TransactionItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__TransactionItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TransactionItem *** SOAP_FMAC4 soap_in_PointerToPointerTovin__TransactionItem(struct soap *soap, const char *tag, struct vin__TransactionItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__TransactionItem ***)soap_malloc(soap, sizeof(struct vin__TransactionItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__TransactionItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__TransactionItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__TransactionItem, sizeof(struct vin__TransactionItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__TransactionItem(struct soap *soap, struct vin__TransactionItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__TransactionItem))
		soap_serialize_vin__TransactionItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__TransactionItem(struct soap *soap, struct vin__TransactionItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__TransactionItem);
	if (soap_out_PointerTovin__TransactionItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__TransactionItem(struct soap *soap, const char *tag, int id, struct vin__TransactionItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__TransactionItem);
	if (id < 0)
		return soap->error;
	return soap_out_vin__TransactionItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__TransactionItem ** SOAP_FMAC4 soap_get_PointerTovin__TransactionItem(struct soap *soap, struct vin__TransactionItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__TransactionItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TransactionItem ** SOAP_FMAC4 soap_in_PointerTovin__TransactionItem(struct soap *soap, const char *tag, struct vin__TransactionItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__TransactionItem **)soap_malloc(soap, sizeof(struct vin__TransactionItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__TransactionItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__TransactionItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__TransactionItem, sizeof(struct vin__TransactionItem), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__ScoreCode(struct soap *soap, struct vin__ScoreCode **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__ScoreCode))
		soap_serialize_PointerTovin__ScoreCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__ScoreCode(struct soap *soap, struct vin__ScoreCode **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__ScoreCode);
	if (soap_out_PointerToPointerTovin__ScoreCode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__ScoreCode(struct soap *soap, const char *tag, int id, struct vin__ScoreCode **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__ScoreCode);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__ScoreCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__ScoreCode *** SOAP_FMAC4 soap_get_PointerToPointerTovin__ScoreCode(struct soap *soap, struct vin__ScoreCode ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__ScoreCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ScoreCode *** SOAP_FMAC4 soap_in_PointerToPointerTovin__ScoreCode(struct soap *soap, const char *tag, struct vin__ScoreCode ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__ScoreCode ***)soap_malloc(soap, sizeof(struct vin__ScoreCode **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__ScoreCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__ScoreCode ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__ScoreCode, sizeof(struct vin__ScoreCode *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__ScoreCode(struct soap *soap, struct vin__ScoreCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__ScoreCode))
		soap_serialize_vin__ScoreCode(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__ScoreCode(struct soap *soap, struct vin__ScoreCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__ScoreCode);
	if (soap_out_PointerTovin__ScoreCode(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__ScoreCode(struct soap *soap, const char *tag, int id, struct vin__ScoreCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__ScoreCode);
	if (id < 0)
		return soap->error;
	return soap_out_vin__ScoreCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__ScoreCode ** SOAP_FMAC4 soap_get_PointerTovin__ScoreCode(struct soap *soap, struct vin__ScoreCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__ScoreCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ScoreCode ** SOAP_FMAC4 soap_in_PointerTovin__ScoreCode(struct soap *soap, const char *tag, struct vin__ScoreCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__ScoreCode **)soap_malloc(soap, sizeof(struct vin__ScoreCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__ScoreCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__ScoreCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__ScoreCode, sizeof(struct vin__ScoreCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__CancelResult(struct soap *soap, struct vin__CancelResult **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__CancelResult))
		soap_serialize_PointerTovin__CancelResult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__CancelResult(struct soap *soap, struct vin__CancelResult **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__CancelResult);
	if (soap_out_PointerToPointerTovin__CancelResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__CancelResult(struct soap *soap, const char *tag, int id, struct vin__CancelResult **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__CancelResult);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__CancelResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__CancelResult *** SOAP_FMAC4 soap_get_PointerToPointerTovin__CancelResult(struct soap *soap, struct vin__CancelResult ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__CancelResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__CancelResult *** SOAP_FMAC4 soap_in_PointerToPointerTovin__CancelResult(struct soap *soap, const char *tag, struct vin__CancelResult ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__CancelResult ***)soap_malloc(soap, sizeof(struct vin__CancelResult **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__CancelResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__CancelResult ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__CancelResult, sizeof(struct vin__CancelResult *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__CancelResult(struct soap *soap, struct vin__CancelResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__CancelResult))
		soap_serialize_vin__CancelResult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__CancelResult(struct soap *soap, struct vin__CancelResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__CancelResult);
	if (soap_out_PointerTovin__CancelResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__CancelResult(struct soap *soap, const char *tag, int id, struct vin__CancelResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__CancelResult);
	if (id < 0)
		return soap->error;
	return soap_out_vin__CancelResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__CancelResult ** SOAP_FMAC4 soap_get_PointerTovin__CancelResult(struct soap *soap, struct vin__CancelResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__CancelResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__CancelResult ** SOAP_FMAC4 soap_in_PointerTovin__CancelResult(struct soap *soap, const char *tag, struct vin__CancelResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__CancelResult **)soap_malloc(soap, sizeof(struct vin__CancelResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__CancelResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__CancelResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__CancelResult, sizeof(struct vin__CancelResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__CaptureResult(struct soap *soap, struct vin__CaptureResult **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__CaptureResult))
		soap_serialize_PointerTovin__CaptureResult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__CaptureResult(struct soap *soap, struct vin__CaptureResult **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__CaptureResult);
	if (soap_out_PointerToPointerTovin__CaptureResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__CaptureResult(struct soap *soap, const char *tag, int id, struct vin__CaptureResult **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__CaptureResult);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__CaptureResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__CaptureResult *** SOAP_FMAC4 soap_get_PointerToPointerTovin__CaptureResult(struct soap *soap, struct vin__CaptureResult ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__CaptureResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__CaptureResult *** SOAP_FMAC4 soap_in_PointerToPointerTovin__CaptureResult(struct soap *soap, const char *tag, struct vin__CaptureResult ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__CaptureResult ***)soap_malloc(soap, sizeof(struct vin__CaptureResult **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__CaptureResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__CaptureResult ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__CaptureResult, sizeof(struct vin__CaptureResult *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__CaptureResult(struct soap *soap, struct vin__CaptureResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__CaptureResult))
		soap_serialize_vin__CaptureResult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__CaptureResult(struct soap *soap, struct vin__CaptureResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__CaptureResult);
	if (soap_out_PointerTovin__CaptureResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__CaptureResult(struct soap *soap, const char *tag, int id, struct vin__CaptureResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__CaptureResult);
	if (id < 0)
		return soap->error;
	return soap_out_vin__CaptureResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__CaptureResult ** SOAP_FMAC4 soap_get_PointerTovin__CaptureResult(struct soap *soap, struct vin__CaptureResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__CaptureResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__CaptureResult ** SOAP_FMAC4 soap_in_PointerTovin__CaptureResult(struct soap *soap, const char *tag, struct vin__CaptureResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__CaptureResult **)soap_malloc(soap, sizeof(struct vin__CaptureResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__CaptureResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__CaptureResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__CaptureResult, sizeof(struct vin__CaptureResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__TokenTransaction(struct soap *soap, struct vin__TokenTransaction **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__TokenTransaction))
		soap_serialize_PointerTovin__TokenTransaction(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__TokenTransaction(struct soap *soap, struct vin__TokenTransaction **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__TokenTransaction);
	if (soap_out_PointerToPointerTovin__TokenTransaction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__TokenTransaction(struct soap *soap, const char *tag, int id, struct vin__TokenTransaction **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__TokenTransaction);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__TokenTransaction(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__TokenTransaction *** SOAP_FMAC4 soap_get_PointerToPointerTovin__TokenTransaction(struct soap *soap, struct vin__TokenTransaction ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__TokenTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TokenTransaction *** SOAP_FMAC4 soap_in_PointerToPointerTovin__TokenTransaction(struct soap *soap, const char *tag, struct vin__TokenTransaction ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__TokenTransaction ***)soap_malloc(soap, sizeof(struct vin__TokenTransaction **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__TokenTransaction(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__TokenTransaction ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__TokenTransaction, sizeof(struct vin__TokenTransaction *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__TokenTransaction(struct soap *soap, struct vin__TokenTransaction *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__TokenTransaction))
		soap_serialize_vin__TokenTransaction(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__TokenTransaction(struct soap *soap, struct vin__TokenTransaction *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__TokenTransaction);
	if (soap_out_PointerTovin__TokenTransaction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__TokenTransaction(struct soap *soap, const char *tag, int id, struct vin__TokenTransaction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__TokenTransaction);
	if (id < 0)
		return soap->error;
	return soap_out_vin__TokenTransaction(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__TokenTransaction ** SOAP_FMAC4 soap_get_PointerTovin__TokenTransaction(struct soap *soap, struct vin__TokenTransaction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__TokenTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TokenTransaction ** SOAP_FMAC4 soap_in_PointerTovin__TokenTransaction(struct soap *soap, const char *tag, struct vin__TokenTransaction **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__TokenTransaction **)soap_malloc(soap, sizeof(struct vin__TokenTransaction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__TokenTransaction(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__TokenTransaction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__TokenTransaction, sizeof(struct vin__TokenTransaction), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__TokenAmount(struct soap *soap, struct vin__TokenAmount **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__TokenAmount))
		soap_serialize_PointerTovin__TokenAmount(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__TokenAmount(struct soap *soap, struct vin__TokenAmount **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__TokenAmount);
	if (soap_out_PointerToPointerTovin__TokenAmount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__TokenAmount(struct soap *soap, const char *tag, int id, struct vin__TokenAmount **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__TokenAmount);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__TokenAmount(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__TokenAmount *** SOAP_FMAC4 soap_get_PointerToPointerTovin__TokenAmount(struct soap *soap, struct vin__TokenAmount ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__TokenAmount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TokenAmount *** SOAP_FMAC4 soap_in_PointerToPointerTovin__TokenAmount(struct soap *soap, const char *tag, struct vin__TokenAmount ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__TokenAmount ***)soap_malloc(soap, sizeof(struct vin__TokenAmount **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__TokenAmount(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__TokenAmount ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__TokenAmount, sizeof(struct vin__TokenAmount *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__Token(struct soap *soap, struct vin__Token **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__Token))
		soap_serialize_PointerTovin__Token(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__Token(struct soap *soap, struct vin__Token **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__Token);
	if (soap_out_PointerToPointerTovin__Token(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__Token(struct soap *soap, const char *tag, int id, struct vin__Token **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__Token);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__Token(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Token *** SOAP_FMAC4 soap_get_PointerToPointerTovin__Token(struct soap *soap, struct vin__Token ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__Token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Token *** SOAP_FMAC4 soap_in_PointerToPointerTovin__Token(struct soap *soap, const char *tag, struct vin__Token ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Token ***)soap_malloc(soap, sizeof(struct vin__Token **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__Token(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Token ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__Token, sizeof(struct vin__Token *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__SalesTax(struct soap *soap, struct vin__SalesTax **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__SalesTax))
		soap_serialize_PointerTovin__SalesTax(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__SalesTax(struct soap *soap, struct vin__SalesTax **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__SalesTax);
	if (soap_out_PointerToPointerTovin__SalesTax(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__SalesTax(struct soap *soap, const char *tag, int id, struct vin__SalesTax **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__SalesTax);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__SalesTax(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__SalesTax *** SOAP_FMAC4 soap_get_PointerToPointerTovin__SalesTax(struct soap *soap, struct vin__SalesTax ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__SalesTax(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__SalesTax *** SOAP_FMAC4 soap_in_PointerToPointerTovin__SalesTax(struct soap *soap, const char *tag, struct vin__SalesTax ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__SalesTax ***)soap_malloc(soap, sizeof(struct vin__SalesTax **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__SalesTax(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__SalesTax ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__SalesTax, sizeof(struct vin__SalesTax *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__SalesTax(struct soap *soap, struct vin__SalesTax *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__SalesTax))
		soap_serialize_vin__SalesTax(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__SalesTax(struct soap *soap, struct vin__SalesTax *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__SalesTax);
	if (soap_out_PointerTovin__SalesTax(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__SalesTax(struct soap *soap, const char *tag, int id, struct vin__SalesTax *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__SalesTax);
	if (id < 0)
		return soap->error;
	return soap_out_vin__SalesTax(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__SalesTax ** SOAP_FMAC4 soap_get_PointerTovin__SalesTax(struct soap *soap, struct vin__SalesTax **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__SalesTax(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__SalesTax ** SOAP_FMAC4 soap_in_PointerTovin__SalesTax(struct soap *soap, const char *tag, struct vin__SalesTax **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__SalesTax **)soap_malloc(soap, sizeof(struct vin__SalesTax *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__SalesTax(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__SalesTax **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__SalesTax, sizeof(struct vin__SalesTax), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__TaxExemption(struct soap *soap, struct vin__TaxExemption **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__TaxExemption))
		soap_serialize_PointerTovin__TaxExemption(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__TaxExemption(struct soap *soap, struct vin__TaxExemption **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__TaxExemption);
	if (soap_out_PointerToPointerTovin__TaxExemption(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__TaxExemption(struct soap *soap, const char *tag, int id, struct vin__TaxExemption **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__TaxExemption);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__TaxExemption(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__TaxExemption *** SOAP_FMAC4 soap_get_PointerToPointerTovin__TaxExemption(struct soap *soap, struct vin__TaxExemption ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__TaxExemption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TaxExemption *** SOAP_FMAC4 soap_in_PointerToPointerTovin__TaxExemption(struct soap *soap, const char *tag, struct vin__TaxExemption ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__TaxExemption ***)soap_malloc(soap, sizeof(struct vin__TaxExemption **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__TaxExemption(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__TaxExemption ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__TaxExemption, sizeof(struct vin__TaxExemption *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__TaxExemption(struct soap *soap, struct vin__TaxExemption *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__TaxExemption))
		soap_serialize_vin__TaxExemption(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__TaxExemption(struct soap *soap, struct vin__TaxExemption *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__TaxExemption);
	if (soap_out_PointerTovin__TaxExemption(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__TaxExemption(struct soap *soap, const char *tag, int id, struct vin__TaxExemption *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__TaxExemption);
	if (id < 0)
		return soap->error;
	return soap_out_vin__TaxExemption(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__TaxExemption ** SOAP_FMAC4 soap_get_PointerTovin__TaxExemption(struct soap *soap, struct vin__TaxExemption **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__TaxExemption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TaxExemption ** SOAP_FMAC4 soap_in_PointerTovin__TaxExemption(struct soap *soap, const char *tag, struct vin__TaxExemption **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__TaxExemption **)soap_malloc(soap, sizeof(struct vin__TaxExemption *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__TaxExemption(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__TaxExemption **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__TaxExemption, sizeof(struct vin__TaxExemption), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__Refund(struct soap *soap, struct vin__Refund **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__Refund))
		soap_serialize_PointerTovin__Refund(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__Refund(struct soap *soap, struct vin__Refund **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__Refund);
	if (soap_out_PointerToPointerTovin__Refund(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__Refund(struct soap *soap, const char *tag, int id, struct vin__Refund **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__Refund);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__Refund(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Refund *** SOAP_FMAC4 soap_get_PointerToPointerTovin__Refund(struct soap *soap, struct vin__Refund ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__Refund(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Refund *** SOAP_FMAC4 soap_in_PointerToPointerTovin__Refund(struct soap *soap, const char *tag, struct vin__Refund ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Refund ***)soap_malloc(soap, sizeof(struct vin__Refund **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__Refund(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Refund ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__Refund, sizeof(struct vin__Refund *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__Refund(struct soap *soap, struct vin__Refund *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__Refund))
		soap_serialize_vin__Refund(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__Refund(struct soap *soap, struct vin__Refund *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__Refund);
	if (soap_out_PointerTovin__Refund(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__Refund(struct soap *soap, const char *tag, int id, struct vin__Refund *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__Refund);
	if (id < 0)
		return soap->error;
	return soap_out_vin__Refund(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Refund ** SOAP_FMAC4 soap_get_PointerTovin__Refund(struct soap *soap, struct vin__Refund **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__Refund(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Refund ** SOAP_FMAC4 soap_in_PointerTovin__Refund(struct soap *soap, const char *tag, struct vin__Refund **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Refund **)soap_malloc(soap, sizeof(struct vin__Refund *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__Refund(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Refund **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__Refund, sizeof(struct vin__Refund), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__Product(struct soap *soap, struct vin__Product **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__Product))
		soap_serialize_PointerTovin__Product(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__Product(struct soap *soap, struct vin__Product **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__Product);
	if (soap_out_PointerToPointerTovin__Product(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__Product(struct soap *soap, const char *tag, int id, struct vin__Product **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__Product);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__Product(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Product *** SOAP_FMAC4 soap_get_PointerToPointerTovin__Product(struct soap *soap, struct vin__Product ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__Product(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Product *** SOAP_FMAC4 soap_in_PointerToPointerTovin__Product(struct soap *soap, const char *tag, struct vin__Product ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Product ***)soap_malloc(soap, sizeof(struct vin__Product **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__Product(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Product ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__Product, sizeof(struct vin__Product *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__NameValuePair(struct soap *soap, struct vin__NameValuePair **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__NameValuePair))
		soap_serialize_PointerTovin__NameValuePair(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__NameValuePair(struct soap *soap, struct vin__NameValuePair **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__NameValuePair);
	if (soap_out_PointerToPointerTovin__NameValuePair(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__NameValuePair(struct soap *soap, const char *tag, int id, struct vin__NameValuePair **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__NameValuePair);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__NameValuePair(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__NameValuePair *** SOAP_FMAC4 soap_get_PointerToPointerTovin__NameValuePair(struct soap *soap, struct vin__NameValuePair ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__NameValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__NameValuePair *** SOAP_FMAC4 soap_in_PointerToPointerTovin__NameValuePair(struct soap *soap, const char *tag, struct vin__NameValuePair ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__NameValuePair ***)soap_malloc(soap, sizeof(struct vin__NameValuePair **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__NameValuePair(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__NameValuePair ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__NameValuePair, sizeof(struct vin__NameValuePair *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__NameValuePair(struct soap *soap, struct vin__NameValuePair *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__NameValuePair))
		soap_serialize_vin__NameValuePair(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__NameValuePair(struct soap *soap, struct vin__NameValuePair *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__NameValuePair);
	if (soap_out_PointerTovin__NameValuePair(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__NameValuePair(struct soap *soap, const char *tag, int id, struct vin__NameValuePair *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__NameValuePair);
	if (id < 0)
		return soap->error;
	return soap_out_vin__NameValuePair(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__NameValuePair ** SOAP_FMAC4 soap_get_PointerTovin__NameValuePair(struct soap *soap, struct vin__NameValuePair **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__NameValuePair(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__NameValuePair ** SOAP_FMAC4 soap_in_PointerTovin__NameValuePair(struct soap *soap, const char *tag, struct vin__NameValuePair **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__NameValuePair **)soap_malloc(soap, sizeof(struct vin__NameValuePair *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__NameValuePair(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__NameValuePair **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__NameValuePair, sizeof(struct vin__NameValuePair), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__MerchantEntitlementId(struct soap *soap, struct vin__MerchantEntitlementId **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__MerchantEntitlementId))
		soap_serialize_PointerTovin__MerchantEntitlementId(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__MerchantEntitlementId(struct soap *soap, struct vin__MerchantEntitlementId **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__MerchantEntitlementId);
	if (soap_out_PointerToPointerTovin__MerchantEntitlementId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__MerchantEntitlementId(struct soap *soap, const char *tag, int id, struct vin__MerchantEntitlementId **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__MerchantEntitlementId);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__MerchantEntitlementId(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__MerchantEntitlementId *** SOAP_FMAC4 soap_get_PointerToPointerTovin__MerchantEntitlementId(struct soap *soap, struct vin__MerchantEntitlementId ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__MerchantEntitlementId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__MerchantEntitlementId *** SOAP_FMAC4 soap_in_PointerToPointerTovin__MerchantEntitlementId(struct soap *soap, const char *tag, struct vin__MerchantEntitlementId ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__MerchantEntitlementId ***)soap_malloc(soap, sizeof(struct vin__MerchantEntitlementId **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__MerchantEntitlementId(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__MerchantEntitlementId ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__MerchantEntitlementId, sizeof(struct vin__MerchantEntitlementId *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__MerchantEntitlementId(struct soap *soap, struct vin__MerchantEntitlementId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__MerchantEntitlementId))
		soap_serialize_vin__MerchantEntitlementId(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__MerchantEntitlementId(struct soap *soap, struct vin__MerchantEntitlementId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__MerchantEntitlementId);
	if (soap_out_PointerTovin__MerchantEntitlementId(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__MerchantEntitlementId(struct soap *soap, const char *tag, int id, struct vin__MerchantEntitlementId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__MerchantEntitlementId);
	if (id < 0)
		return soap->error;
	return soap_out_vin__MerchantEntitlementId(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__MerchantEntitlementId ** SOAP_FMAC4 soap_get_PointerTovin__MerchantEntitlementId(struct soap *soap, struct vin__MerchantEntitlementId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__MerchantEntitlementId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__MerchantEntitlementId ** SOAP_FMAC4 soap_in_PointerTovin__MerchantEntitlementId(struct soap *soap, const char *tag, struct vin__MerchantEntitlementId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__MerchantEntitlementId **)soap_malloc(soap, sizeof(struct vin__MerchantEntitlementId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__MerchantEntitlementId(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__MerchantEntitlementId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__MerchantEntitlementId, sizeof(struct vin__MerchantEntitlementId), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__PaymentMethod(struct soap *soap, struct vin__PaymentMethod **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__PaymentMethod))
		soap_serialize_PointerTovin__PaymentMethod(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__PaymentMethod(struct soap *soap, struct vin__PaymentMethod **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__PaymentMethod);
	if (soap_out_PointerToPointerTovin__PaymentMethod(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__PaymentMethod(struct soap *soap, const char *tag, int id, struct vin__PaymentMethod **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__PaymentMethod);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__PaymentMethod(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__PaymentMethod *** SOAP_FMAC4 soap_get_PointerToPointerTovin__PaymentMethod(struct soap *soap, struct vin__PaymentMethod ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__PaymentMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__PaymentMethod *** SOAP_FMAC4 soap_in_PointerToPointerTovin__PaymentMethod(struct soap *soap, const char *tag, struct vin__PaymentMethod ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__PaymentMethod ***)soap_malloc(soap, sizeof(struct vin__PaymentMethod **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__PaymentMethod(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__PaymentMethod ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__PaymentMethod, sizeof(struct vin__PaymentMethod *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__MetricStatistics(struct soap *soap, struct vin__MetricStatistics **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__MetricStatistics))
		soap_serialize_PointerTovin__MetricStatistics(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__MetricStatistics(struct soap *soap, struct vin__MetricStatistics **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__MetricStatistics);
	if (soap_out_PointerToPointerTovin__MetricStatistics(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__MetricStatistics(struct soap *soap, const char *tag, int id, struct vin__MetricStatistics **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__MetricStatistics);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__MetricStatistics(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__MetricStatistics *** SOAP_FMAC4 soap_get_PointerToPointerTovin__MetricStatistics(struct soap *soap, struct vin__MetricStatistics ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__MetricStatistics(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__MetricStatistics *** SOAP_FMAC4 soap_in_PointerToPointerTovin__MetricStatistics(struct soap *soap, const char *tag, struct vin__MetricStatistics ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__MetricStatistics ***)soap_malloc(soap, sizeof(struct vin__MetricStatistics **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__MetricStatistics(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__MetricStatistics ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__MetricStatistics, sizeof(struct vin__MetricStatistics *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__MetricStatistics(struct soap *soap, struct vin__MetricStatistics *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__MetricStatistics))
		soap_serialize_vin__MetricStatistics(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__MetricStatistics(struct soap *soap, struct vin__MetricStatistics *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__MetricStatistics);
	if (soap_out_PointerTovin__MetricStatistics(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__MetricStatistics(struct soap *soap, const char *tag, int id, struct vin__MetricStatistics *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__MetricStatistics);
	if (id < 0)
		return soap->error;
	return soap_out_vin__MetricStatistics(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__MetricStatistics ** SOAP_FMAC4 soap_get_PointerTovin__MetricStatistics(struct soap *soap, struct vin__MetricStatistics **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__MetricStatistics(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__MetricStatistics ** SOAP_FMAC4 soap_in_PointerTovin__MetricStatistics(struct soap *soap, const char *tag, struct vin__MetricStatistics **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__MetricStatistics **)soap_malloc(soap, sizeof(struct vin__MetricStatistics *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__MetricStatistics(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__MetricStatistics **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__MetricStatistics, sizeof(struct vin__MetricStatistics), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__Entitlement(struct soap *soap, struct vin__Entitlement **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__Entitlement))
		soap_serialize_PointerTovin__Entitlement(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__Entitlement(struct soap *soap, struct vin__Entitlement **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__Entitlement);
	if (soap_out_PointerToPointerTovin__Entitlement(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__Entitlement(struct soap *soap, const char *tag, int id, struct vin__Entitlement **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__Entitlement);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__Entitlement(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Entitlement *** SOAP_FMAC4 soap_get_PointerToPointerTovin__Entitlement(struct soap *soap, struct vin__Entitlement ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__Entitlement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Entitlement *** SOAP_FMAC4 soap_in_PointerToPointerTovin__Entitlement(struct soap *soap, const char *tag, struct vin__Entitlement ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Entitlement ***)soap_malloc(soap, sizeof(struct vin__Entitlement **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__Entitlement(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Entitlement ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__Entitlement, sizeof(struct vin__Entitlement *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__Entitlement(struct soap *soap, struct vin__Entitlement *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__Entitlement))
		soap_serialize_vin__Entitlement(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__Entitlement(struct soap *soap, struct vin__Entitlement *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__Entitlement);
	if (soap_out_PointerTovin__Entitlement(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__Entitlement(struct soap *soap, const char *tag, int id, struct vin__Entitlement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__Entitlement);
	if (id < 0)
		return soap->error;
	return soap_out_vin__Entitlement(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Entitlement ** SOAP_FMAC4 soap_get_PointerTovin__Entitlement(struct soap *soap, struct vin__Entitlement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__Entitlement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Entitlement ** SOAP_FMAC4 soap_in_PointerTovin__Entitlement(struct soap *soap, const char *tag, struct vin__Entitlement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Entitlement **)soap_malloc(soap, sizeof(struct vin__Entitlement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__Entitlement(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Entitlement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__Entitlement, sizeof(struct vin__Entitlement), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__EmailTemplate(struct soap *soap, struct vin__EmailTemplate **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__EmailTemplate))
		soap_serialize_PointerTovin__EmailTemplate(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__EmailTemplate(struct soap *soap, struct vin__EmailTemplate **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__EmailTemplate);
	if (soap_out_PointerToPointerTovin__EmailTemplate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__EmailTemplate(struct soap *soap, const char *tag, int id, struct vin__EmailTemplate **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__EmailTemplate);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__EmailTemplate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__EmailTemplate *** SOAP_FMAC4 soap_get_PointerToPointerTovin__EmailTemplate(struct soap *soap, struct vin__EmailTemplate ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__EmailTemplate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__EmailTemplate *** SOAP_FMAC4 soap_in_PointerToPointerTovin__EmailTemplate(struct soap *soap, const char *tag, struct vin__EmailTemplate ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__EmailTemplate ***)soap_malloc(soap, sizeof(struct vin__EmailTemplate **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__EmailTemplate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__EmailTemplate ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__EmailTemplate, sizeof(struct vin__EmailTemplate *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__EmailTemplate(struct soap *soap, struct vin__EmailTemplate *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__EmailTemplate))
		soap_serialize_vin__EmailTemplate(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__EmailTemplate(struct soap *soap, struct vin__EmailTemplate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__EmailTemplate);
	if (soap_out_PointerTovin__EmailTemplate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__EmailTemplate(struct soap *soap, const char *tag, int id, struct vin__EmailTemplate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__EmailTemplate);
	if (id < 0)
		return soap->error;
	return soap_out_vin__EmailTemplate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__EmailTemplate ** SOAP_FMAC4 soap_get_PointerTovin__EmailTemplate(struct soap *soap, struct vin__EmailTemplate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__EmailTemplate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__EmailTemplate ** SOAP_FMAC4 soap_in_PointerTovin__EmailTemplate(struct soap *soap, const char *tag, struct vin__EmailTemplate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__EmailTemplate **)soap_malloc(soap, sizeof(struct vin__EmailTemplate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__EmailTemplate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__EmailTemplate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__EmailTemplate, sizeof(struct vin__EmailTemplate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__Chargeback(struct soap *soap, struct vin__Chargeback **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__Chargeback))
		soap_serialize_PointerTovin__Chargeback(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__Chargeback(struct soap *soap, struct vin__Chargeback **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__Chargeback);
	if (soap_out_PointerToPointerTovin__Chargeback(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__Chargeback(struct soap *soap, const char *tag, int id, struct vin__Chargeback **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__Chargeback);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__Chargeback(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Chargeback *** SOAP_FMAC4 soap_get_PointerToPointerTovin__Chargeback(struct soap *soap, struct vin__Chargeback ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__Chargeback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Chargeback *** SOAP_FMAC4 soap_in_PointerToPointerTovin__Chargeback(struct soap *soap, const char *tag, struct vin__Chargeback ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Chargeback ***)soap_malloc(soap, sizeof(struct vin__Chargeback **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__Chargeback(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Chargeback ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__Chargeback, sizeof(struct vin__Chargeback *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__Chargeback(struct soap *soap, struct vin__Chargeback *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__Chargeback))
		soap_serialize_vin__Chargeback(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__Chargeback(struct soap *soap, struct vin__Chargeback *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__Chargeback);
	if (soap_out_PointerTovin__Chargeback(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__Chargeback(struct soap *soap, const char *tag, int id, struct vin__Chargeback *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__Chargeback);
	if (id < 0)
		return soap->error;
	return soap_out_vin__Chargeback(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Chargeback ** SOAP_FMAC4 soap_get_PointerTovin__Chargeback(struct soap *soap, struct vin__Chargeback **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__Chargeback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Chargeback ** SOAP_FMAC4 soap_in_PointerTovin__Chargeback(struct soap *soap, const char *tag, struct vin__Chargeback **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Chargeback **)soap_malloc(soap, sizeof(struct vin__Chargeback *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__Chargeback(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Chargeback **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__Chargeback, sizeof(struct vin__Chargeback), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__BillingPlan(struct soap *soap, struct vin__BillingPlan **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__BillingPlan))
		soap_serialize_PointerTovin__BillingPlan(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__BillingPlan(struct soap *soap, struct vin__BillingPlan **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__BillingPlan);
	if (soap_out_PointerToPointerTovin__BillingPlan(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__BillingPlan(struct soap *soap, const char *tag, int id, struct vin__BillingPlan **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__BillingPlan);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__BillingPlan(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__BillingPlan *** SOAP_FMAC4 soap_get_PointerToPointerTovin__BillingPlan(struct soap *soap, struct vin__BillingPlan ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__BillingPlan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__BillingPlan *** SOAP_FMAC4 soap_in_PointerToPointerTovin__BillingPlan(struct soap *soap, const char *tag, struct vin__BillingPlan ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__BillingPlan ***)soap_malloc(soap, sizeof(struct vin__BillingPlan **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__BillingPlan(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__BillingPlan ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__BillingPlan, sizeof(struct vin__BillingPlan *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__BillingPlanPeriod(struct soap *soap, struct vin__BillingPlanPeriod **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__BillingPlanPeriod))
		soap_serialize_PointerTovin__BillingPlanPeriod(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__BillingPlanPeriod(struct soap *soap, struct vin__BillingPlanPeriod **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__BillingPlanPeriod);
	if (soap_out_PointerToPointerTovin__BillingPlanPeriod(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__BillingPlanPeriod(struct soap *soap, const char *tag, int id, struct vin__BillingPlanPeriod **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__BillingPlanPeriod);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__BillingPlanPeriod(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__BillingPlanPeriod *** SOAP_FMAC4 soap_get_PointerToPointerTovin__BillingPlanPeriod(struct soap *soap, struct vin__BillingPlanPeriod ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__BillingPlanPeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__BillingPlanPeriod *** SOAP_FMAC4 soap_in_PointerToPointerTovin__BillingPlanPeriod(struct soap *soap, const char *tag, struct vin__BillingPlanPeriod ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__BillingPlanPeriod ***)soap_malloc(soap, sizeof(struct vin__BillingPlanPeriod **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__BillingPlanPeriod(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__BillingPlanPeriod ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__BillingPlanPeriod, sizeof(struct vin__BillingPlanPeriod *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__BillingPlanPeriod(struct soap *soap, struct vin__BillingPlanPeriod *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__BillingPlanPeriod))
		soap_serialize_vin__BillingPlanPeriod(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__BillingPlanPeriod(struct soap *soap, struct vin__BillingPlanPeriod *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__BillingPlanPeriod);
	if (soap_out_PointerTovin__BillingPlanPeriod(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__BillingPlanPeriod(struct soap *soap, const char *tag, int id, struct vin__BillingPlanPeriod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__BillingPlanPeriod);
	if (id < 0)
		return soap->error;
	return soap_out_vin__BillingPlanPeriod(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__BillingPlanPeriod ** SOAP_FMAC4 soap_get_PointerTovin__BillingPlanPeriod(struct soap *soap, struct vin__BillingPlanPeriod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__BillingPlanPeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__BillingPlanPeriod ** SOAP_FMAC4 soap_in_PointerTovin__BillingPlanPeriod(struct soap *soap, const char *tag, struct vin__BillingPlanPeriod **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__BillingPlanPeriod **)soap_malloc(soap, sizeof(struct vin__BillingPlanPeriod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__BillingPlanPeriod(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__BillingPlanPeriod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__BillingPlanPeriod, sizeof(struct vin__BillingPlanPeriod), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__BillingPlanPrice(struct soap *soap, struct vin__BillingPlanPrice **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__BillingPlanPrice))
		soap_serialize_PointerTovin__BillingPlanPrice(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__BillingPlanPrice(struct soap *soap, struct vin__BillingPlanPrice **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__BillingPlanPrice);
	if (soap_out_PointerToPointerTovin__BillingPlanPrice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__BillingPlanPrice(struct soap *soap, const char *tag, int id, struct vin__BillingPlanPrice **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__BillingPlanPrice);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__BillingPlanPrice(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__BillingPlanPrice *** SOAP_FMAC4 soap_get_PointerToPointerTovin__BillingPlanPrice(struct soap *soap, struct vin__BillingPlanPrice ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__BillingPlanPrice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__BillingPlanPrice *** SOAP_FMAC4 soap_in_PointerToPointerTovin__BillingPlanPrice(struct soap *soap, const char *tag, struct vin__BillingPlanPrice ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__BillingPlanPrice ***)soap_malloc(soap, sizeof(struct vin__BillingPlanPrice **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__BillingPlanPrice(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__BillingPlanPrice ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__BillingPlanPrice, sizeof(struct vin__BillingPlanPrice *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__BillingPlanPrice(struct soap *soap, struct vin__BillingPlanPrice *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__BillingPlanPrice))
		soap_serialize_vin__BillingPlanPrice(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__BillingPlanPrice(struct soap *soap, struct vin__BillingPlanPrice *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__BillingPlanPrice);
	if (soap_out_PointerTovin__BillingPlanPrice(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__BillingPlanPrice(struct soap *soap, const char *tag, int id, struct vin__BillingPlanPrice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__BillingPlanPrice);
	if (id < 0)
		return soap->error;
	return soap_out_vin__BillingPlanPrice(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__BillingPlanPrice ** SOAP_FMAC4 soap_get_PointerTovin__BillingPlanPrice(struct soap *soap, struct vin__BillingPlanPrice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__BillingPlanPrice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__BillingPlanPrice ** SOAP_FMAC4 soap_in_PointerTovin__BillingPlanPrice(struct soap *soap, const char *tag, struct vin__BillingPlanPrice **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__BillingPlanPrice **)soap_malloc(soap, sizeof(struct vin__BillingPlanPrice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__BillingPlanPrice(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__BillingPlanPrice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__BillingPlanPrice, sizeof(struct vin__BillingPlanPrice), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__AutoBill(struct soap *soap, struct vin__AutoBill **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__AutoBill))
		soap_serialize_PointerTovin__AutoBill(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__AutoBill(struct soap *soap, struct vin__AutoBill **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__AutoBill);
	if (soap_out_PointerToPointerTovin__AutoBill(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__AutoBill(struct soap *soap, const char *tag, int id, struct vin__AutoBill **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__AutoBill);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__AutoBill(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__AutoBill *** SOAP_FMAC4 soap_get_PointerToPointerTovin__AutoBill(struct soap *soap, struct vin__AutoBill ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__AutoBill(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__AutoBill *** SOAP_FMAC4 soap_in_PointerToPointerTovin__AutoBill(struct soap *soap, const char *tag, struct vin__AutoBill ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__AutoBill ***)soap_malloc(soap, sizeof(struct vin__AutoBill **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__AutoBill(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__AutoBill ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__AutoBill, sizeof(struct vin__AutoBill *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__AutoBill(struct soap *soap, struct vin__AutoBill *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__AutoBill))
		soap_serialize_vin__AutoBill(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__AutoBill(struct soap *soap, struct vin__AutoBill *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__AutoBill);
	if (soap_out_PointerTovin__AutoBill(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__AutoBill(struct soap *soap, const char *tag, int id, struct vin__AutoBill *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__AutoBill);
	if (id < 0)
		return soap->error;
	return soap_out_vin__AutoBill(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__AutoBill ** SOAP_FMAC4 soap_get_PointerTovin__AutoBill(struct soap *soap, struct vin__AutoBill **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__AutoBill(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__AutoBill ** SOAP_FMAC4 soap_in_PointerTovin__AutoBill(struct soap *soap, const char *tag, struct vin__AutoBill **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__AutoBill **)soap_malloc(soap, sizeof(struct vin__AutoBill *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__AutoBill(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__AutoBill **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__AutoBill, sizeof(struct vin__AutoBill), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__Activity(struct soap *soap, struct vin__Activity **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__Activity))
		soap_serialize_PointerTovin__Activity(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__Activity(struct soap *soap, struct vin__Activity **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__Activity);
	if (soap_out_PointerToPointerTovin__Activity(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__Activity(struct soap *soap, const char *tag, int id, struct vin__Activity **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__Activity);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__Activity(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Activity *** SOAP_FMAC4 soap_get_PointerToPointerTovin__Activity(struct soap *soap, struct vin__Activity ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__Activity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Activity *** SOAP_FMAC4 soap_in_PointerToPointerTovin__Activity(struct soap *soap, const char *tag, struct vin__Activity ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Activity ***)soap_malloc(soap, sizeof(struct vin__Activity **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__Activity(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Activity ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__Activity, sizeof(struct vin__Activity *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__Activity(struct soap *soap, struct vin__Activity *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__Activity))
		soap_serialize_vin__Activity(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__Activity(struct soap *soap, struct vin__Activity *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__Activity);
	if (soap_out_PointerTovin__Activity(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__Activity(struct soap *soap, const char *tag, int id, struct vin__Activity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__Activity);
	if (id < 0)
		return soap->error;
	return soap_out_vin__Activity(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Activity ** SOAP_FMAC4 soap_get_PointerTovin__Activity(struct soap *soap, struct vin__Activity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__Activity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Activity ** SOAP_FMAC4 soap_in_PointerTovin__Activity(struct soap *soap, const char *tag, struct vin__Activity **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Activity **)soap_malloc(soap, sizeof(struct vin__Activity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__Activity(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Activity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__Activity, sizeof(struct vin__Activity), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTovin__Account(struct soap *soap, struct vin__Account **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTovin__Account))
		soap_serialize_PointerTovin__Account(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTovin__Account(struct soap *soap, struct vin__Account **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTovin__Account);
	if (soap_out_PointerToPointerTovin__Account(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTovin__Account(struct soap *soap, const char *tag, int id, struct vin__Account **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTovin__Account);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTovin__Account(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Account *** SOAP_FMAC4 soap_get_PointerToPointerTovin__Account(struct soap *soap, struct vin__Account ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTovin__Account(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Account *** SOAP_FMAC4 soap_in_PointerToPointerTovin__Account(struct soap *soap, const char *tag, struct vin__Account ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Account ***)soap_malloc(soap, sizeof(struct vin__Account **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTovin__Account(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Account ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTovin__Account, sizeof(struct vin__Account *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfTransactionItems(struct soap *soap, struct ArrayOfTransactionItems *const*a)
{
	if (*a)
		soap_serialize_ArrayOfTransactionItems(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfTransactionItems(struct soap *soap, struct ArrayOfTransactionItems *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfTransactionItems);
	if (soap_out_PointerToArrayOfTransactionItems(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfTransactionItems(struct soap *soap, const char *tag, int id, struct ArrayOfTransactionItems *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfTransactionItems);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfTransactionItems(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfTransactionItems ** SOAP_FMAC4 soap_get_PointerToArrayOfTransactionItems(struct soap *soap, struct ArrayOfTransactionItems **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfTransactionItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfTransactionItems ** SOAP_FMAC4 soap_in_PointerToArrayOfTransactionItems(struct soap *soap, const char *tag, struct ArrayOfTransactionItems **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfTransactionItems **)soap_malloc(soap, sizeof(struct ArrayOfTransactionItems *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfTransactionItems(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfTransactionItems **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfTransactionItems, sizeof(struct ArrayOfTransactionItems), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfTransactionStatuses(struct soap *soap, struct ArrayOfTransactionStatuses *const*a)
{
	if (*a)
		soap_serialize_ArrayOfTransactionStatuses(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfTransactionStatuses(struct soap *soap, struct ArrayOfTransactionStatuses *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfTransactionStatuses);
	if (soap_out_PointerToArrayOfTransactionStatuses(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfTransactionStatuses(struct soap *soap, const char *tag, int id, struct ArrayOfTransactionStatuses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfTransactionStatuses);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfTransactionStatuses(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfTransactionStatuses ** SOAP_FMAC4 soap_get_PointerToArrayOfTransactionStatuses(struct soap *soap, struct ArrayOfTransactionStatuses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfTransactionStatuses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfTransactionStatuses ** SOAP_FMAC4 soap_in_PointerToArrayOfTransactionStatuses(struct soap *soap, const char *tag, struct ArrayOfTransactionStatuses **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfTransactionStatuses **)soap_malloc(soap, sizeof(struct ArrayOfTransactionStatuses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfTransactionStatuses(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfTransactionStatuses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfTransactionStatuses, sizeof(struct ArrayOfTransactionStatuses), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__AVSMatchType(struct soap *soap, enum vin__AVSMatchType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vin__AVSMatchType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__AVSMatchType(struct soap *soap, enum vin__AVSMatchType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__AVSMatchType);
	if (soap_out_PointerTovin__AVSMatchType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__AVSMatchType(struct soap *soap, const char *tag, int id, enum vin__AVSMatchType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__AVSMatchType);
	if (id < 0)
		return soap->error;
	return soap_out_vin__AVSMatchType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vin__AVSMatchType ** SOAP_FMAC4 soap_get_PointerTovin__AVSMatchType(struct soap *soap, enum vin__AVSMatchType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__AVSMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum vin__AVSMatchType ** SOAP_FMAC4 soap_in_PointerTovin__AVSMatchType(struct soap *soap, const char *tag, enum vin__AVSMatchType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum vin__AVSMatchType **)soap_malloc(soap, sizeof(enum vin__AVSMatchType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__AVSMatchType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum vin__AVSMatchType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__AVSMatchType, sizeof(enum vin__AVSMatchType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__TransactionStatusDirectDebit(struct soap *soap, struct vin__TransactionStatusDirectDebit *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__TransactionStatusDirectDebit))
		soap_serialize_vin__TransactionStatusDirectDebit(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__TransactionStatusDirectDebit(struct soap *soap, struct vin__TransactionStatusDirectDebit *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__TransactionStatusDirectDebit);
	if (soap_out_PointerTovin__TransactionStatusDirectDebit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__TransactionStatusDirectDebit(struct soap *soap, const char *tag, int id, struct vin__TransactionStatusDirectDebit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__TransactionStatusDirectDebit);
	if (id < 0)
		return soap->error;
	return soap_out_vin__TransactionStatusDirectDebit(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__TransactionStatusDirectDebit ** SOAP_FMAC4 soap_get_PointerTovin__TransactionStatusDirectDebit(struct soap *soap, struct vin__TransactionStatusDirectDebit **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__TransactionStatusDirectDebit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TransactionStatusDirectDebit ** SOAP_FMAC4 soap_in_PointerTovin__TransactionStatusDirectDebit(struct soap *soap, const char *tag, struct vin__TransactionStatusDirectDebit **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__TransactionStatusDirectDebit **)soap_malloc(soap, sizeof(struct vin__TransactionStatusDirectDebit *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__TransactionStatusDirectDebit(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__TransactionStatusDirectDebit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__TransactionStatusDirectDebit, sizeof(struct vin__TransactionStatusDirectDebit), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__TransactionStatusPayPal(struct soap *soap, struct vin__TransactionStatusPayPal *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__TransactionStatusPayPal))
		soap_serialize_vin__TransactionStatusPayPal(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__TransactionStatusPayPal(struct soap *soap, struct vin__TransactionStatusPayPal *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__TransactionStatusPayPal);
	if (soap_out_PointerTovin__TransactionStatusPayPal(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__TransactionStatusPayPal(struct soap *soap, const char *tag, int id, struct vin__TransactionStatusPayPal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__TransactionStatusPayPal);
	if (id < 0)
		return soap->error;
	return soap_out_vin__TransactionStatusPayPal(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__TransactionStatusPayPal ** SOAP_FMAC4 soap_get_PointerTovin__TransactionStatusPayPal(struct soap *soap, struct vin__TransactionStatusPayPal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__TransactionStatusPayPal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TransactionStatusPayPal ** SOAP_FMAC4 soap_in_PointerTovin__TransactionStatusPayPal(struct soap *soap, const char *tag, struct vin__TransactionStatusPayPal **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__TransactionStatusPayPal **)soap_malloc(soap, sizeof(struct vin__TransactionStatusPayPal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__TransactionStatusPayPal(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__TransactionStatusPayPal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__TransactionStatusPayPal, sizeof(struct vin__TransactionStatusPayPal), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__TransactionStatusBoleto(struct soap *soap, struct vin__TransactionStatusBoleto *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__TransactionStatusBoleto))
		soap_serialize_vin__TransactionStatusBoleto(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__TransactionStatusBoleto(struct soap *soap, struct vin__TransactionStatusBoleto *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__TransactionStatusBoleto);
	if (soap_out_PointerTovin__TransactionStatusBoleto(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__TransactionStatusBoleto(struct soap *soap, const char *tag, int id, struct vin__TransactionStatusBoleto *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__TransactionStatusBoleto);
	if (id < 0)
		return soap->error;
	return soap_out_vin__TransactionStatusBoleto(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__TransactionStatusBoleto ** SOAP_FMAC4 soap_get_PointerTovin__TransactionStatusBoleto(struct soap *soap, struct vin__TransactionStatusBoleto **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__TransactionStatusBoleto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TransactionStatusBoleto ** SOAP_FMAC4 soap_in_PointerTovin__TransactionStatusBoleto(struct soap *soap, const char *tag, struct vin__TransactionStatusBoleto **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__TransactionStatusBoleto **)soap_malloc(soap, sizeof(struct vin__TransactionStatusBoleto *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__TransactionStatusBoleto(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__TransactionStatusBoleto **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__TransactionStatusBoleto, sizeof(struct vin__TransactionStatusBoleto), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__TransactionStatusECP(struct soap *soap, struct vin__TransactionStatusECP *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__TransactionStatusECP))
		soap_serialize_vin__TransactionStatusECP(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__TransactionStatusECP(struct soap *soap, struct vin__TransactionStatusECP *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__TransactionStatusECP);
	if (soap_out_PointerTovin__TransactionStatusECP(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__TransactionStatusECP(struct soap *soap, const char *tag, int id, struct vin__TransactionStatusECP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__TransactionStatusECP);
	if (id < 0)
		return soap->error;
	return soap_out_vin__TransactionStatusECP(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__TransactionStatusECP ** SOAP_FMAC4 soap_get_PointerTovin__TransactionStatusECP(struct soap *soap, struct vin__TransactionStatusECP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__TransactionStatusECP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TransactionStatusECP ** SOAP_FMAC4 soap_in_PointerTovin__TransactionStatusECP(struct soap *soap, const char *tag, struct vin__TransactionStatusECP **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__TransactionStatusECP **)soap_malloc(soap, sizeof(struct vin__TransactionStatusECP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__TransactionStatusECP(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__TransactionStatusECP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__TransactionStatusECP, sizeof(struct vin__TransactionStatusECP), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__TransactionStatusCreditCard(struct soap *soap, struct vin__TransactionStatusCreditCard *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__TransactionStatusCreditCard))
		soap_serialize_vin__TransactionStatusCreditCard(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__TransactionStatusCreditCard(struct soap *soap, struct vin__TransactionStatusCreditCard *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__TransactionStatusCreditCard);
	if (soap_out_PointerTovin__TransactionStatusCreditCard(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__TransactionStatusCreditCard(struct soap *soap, const char *tag, int id, struct vin__TransactionStatusCreditCard *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__TransactionStatusCreditCard);
	if (id < 0)
		return soap->error;
	return soap_out_vin__TransactionStatusCreditCard(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__TransactionStatusCreditCard ** SOAP_FMAC4 soap_get_PointerTovin__TransactionStatusCreditCard(struct soap *soap, struct vin__TransactionStatusCreditCard **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__TransactionStatusCreditCard(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TransactionStatusCreditCard ** SOAP_FMAC4 soap_in_PointerTovin__TransactionStatusCreditCard(struct soap *soap, const char *tag, struct vin__TransactionStatusCreditCard **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__TransactionStatusCreditCard **)soap_malloc(soap, sizeof(struct vin__TransactionStatusCreditCard *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__TransactionStatusCreditCard(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__TransactionStatusCreditCard **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__TransactionStatusCreditCard, sizeof(struct vin__TransactionStatusCreditCard), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__TaxRegion(struct soap *soap, enum vin__TaxRegion *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vin__TaxRegion);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__TaxRegion(struct soap *soap, enum vin__TaxRegion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__TaxRegion);
	if (soap_out_PointerTovin__TaxRegion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__TaxRegion(struct soap *soap, const char *tag, int id, enum vin__TaxRegion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__TaxRegion);
	if (id < 0)
		return soap->error;
	return soap_out_vin__TaxRegion(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vin__TaxRegion ** SOAP_FMAC4 soap_get_PointerTovin__TaxRegion(struct soap *soap, enum vin__TaxRegion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__TaxRegion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum vin__TaxRegion ** SOAP_FMAC4 soap_in_PointerTovin__TaxRegion(struct soap *soap, const char *tag, enum vin__TaxRegion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum vin__TaxRegion **)soap_malloc(soap, sizeof(enum vin__TaxRegion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__TaxRegion(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum vin__TaxRegion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__TaxRegion, sizeof(enum vin__TaxRegion), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__RefundTokenAction(struct soap *soap, enum vin__RefundTokenAction *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vin__RefundTokenAction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__RefundTokenAction(struct soap *soap, enum vin__RefundTokenAction *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__RefundTokenAction);
	if (soap_out_PointerTovin__RefundTokenAction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__RefundTokenAction(struct soap *soap, const char *tag, int id, enum vin__RefundTokenAction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__RefundTokenAction);
	if (id < 0)
		return soap->error;
	return soap_out_vin__RefundTokenAction(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vin__RefundTokenAction ** SOAP_FMAC4 soap_get_PointerTovin__RefundTokenAction(struct soap *soap, enum vin__RefundTokenAction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__RefundTokenAction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum vin__RefundTokenAction ** SOAP_FMAC4 soap_in_PointerTovin__RefundTokenAction(struct soap *soap, const char *tag, enum vin__RefundTokenAction **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum vin__RefundTokenAction **)soap_malloc(soap, sizeof(enum vin__RefundTokenAction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__RefundTokenAction(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum vin__RefundTokenAction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__RefundTokenAction, sizeof(enum vin__RefundTokenAction), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__TaxClassification(struct soap *soap, enum vin__TaxClassification *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vin__TaxClassification);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__TaxClassification(struct soap *soap, enum vin__TaxClassification *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__TaxClassification);
	if (soap_out_PointerTovin__TaxClassification(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__TaxClassification(struct soap *soap, const char *tag, int id, enum vin__TaxClassification *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__TaxClassification);
	if (id < 0)
		return soap->error;
	return soap_out_vin__TaxClassification(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vin__TaxClassification ** SOAP_FMAC4 soap_get_PointerTovin__TaxClassification(struct soap *soap, enum vin__TaxClassification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__TaxClassification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum vin__TaxClassification ** SOAP_FMAC4 soap_in_PointerTovin__TaxClassification(struct soap *soap, const char *tag, enum vin__TaxClassification **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum vin__TaxClassification **)soap_malloc(soap, sizeof(enum vin__TaxClassification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__TaxClassification(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum vin__TaxClassification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__TaxClassification, sizeof(enum vin__TaxClassification), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__ProductStatus(struct soap *soap, enum vin__ProductStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vin__ProductStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__ProductStatus(struct soap *soap, enum vin__ProductStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__ProductStatus);
	if (soap_out_PointerTovin__ProductStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__ProductStatus(struct soap *soap, const char *tag, int id, enum vin__ProductStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__ProductStatus);
	if (id < 0)
		return soap->error;
	return soap_out_vin__ProductStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vin__ProductStatus ** SOAP_FMAC4 soap_get_PointerTovin__ProductStatus(struct soap *soap, enum vin__ProductStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__ProductStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum vin__ProductStatus ** SOAP_FMAC4 soap_in_PointerTovin__ProductStatus(struct soap *soap, const char *tag, enum vin__ProductStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum vin__ProductStatus **)soap_malloc(soap, sizeof(enum vin__ProductStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__ProductStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum vin__ProductStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__ProductStatus, sizeof(enum vin__ProductStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__Token(struct soap *soap, struct vin__Token *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__Token))
		soap_serialize_vin__Token(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__Token(struct soap *soap, struct vin__Token *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__Token);
	if (soap_out_PointerTovin__Token(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__Token(struct soap *soap, const char *tag, int id, struct vin__Token *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__Token);
	if (id < 0)
		return soap->error;
	return soap_out_vin__Token(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Token ** SOAP_FMAC4 soap_get_PointerTovin__Token(struct soap *soap, struct vin__Token **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__Token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Token ** SOAP_FMAC4 soap_in_PointerTovin__Token(struct soap *soap, const char *tag, struct vin__Token **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Token **)soap_malloc(soap, sizeof(struct vin__Token *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__Token(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Token **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__Token, sizeof(struct vin__Token), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__Boleto(struct soap *soap, struct vin__Boleto *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__Boleto))
		soap_serialize_vin__Boleto(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__Boleto(struct soap *soap, struct vin__Boleto *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__Boleto);
	if (soap_out_PointerTovin__Boleto(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__Boleto(struct soap *soap, const char *tag, int id, struct vin__Boleto *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__Boleto);
	if (id < 0)
		return soap->error;
	return soap_out_vin__Boleto(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Boleto ** SOAP_FMAC4 soap_get_PointerTovin__Boleto(struct soap *soap, struct vin__Boleto **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__Boleto(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Boleto ** SOAP_FMAC4 soap_in_PointerTovin__Boleto(struct soap *soap, const char *tag, struct vin__Boleto **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Boleto **)soap_malloc(soap, sizeof(struct vin__Boleto *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__Boleto(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Boleto **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__Boleto, sizeof(struct vin__Boleto), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__PayPal(struct soap *soap, struct vin__PayPal *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__PayPal))
		soap_serialize_vin__PayPal(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__PayPal(struct soap *soap, struct vin__PayPal *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__PayPal);
	if (soap_out_PointerTovin__PayPal(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__PayPal(struct soap *soap, const char *tag, int id, struct vin__PayPal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__PayPal);
	if (id < 0)
		return soap->error;
	return soap_out_vin__PayPal(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__PayPal ** SOAP_FMAC4 soap_get_PointerTovin__PayPal(struct soap *soap, struct vin__PayPal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__PayPal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__PayPal ** SOAP_FMAC4 soap_in_PointerTovin__PayPal(struct soap *soap, const char *tag, struct vin__PayPal **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__PayPal **)soap_malloc(soap, sizeof(struct vin__PayPal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__PayPal(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__PayPal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__PayPal, sizeof(struct vin__PayPal), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__DirectDebit(struct soap *soap, struct vin__DirectDebit *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__DirectDebit))
		soap_serialize_vin__DirectDebit(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__DirectDebit(struct soap *soap, struct vin__DirectDebit *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__DirectDebit);
	if (soap_out_PointerTovin__DirectDebit(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__DirectDebit(struct soap *soap, const char *tag, int id, struct vin__DirectDebit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__DirectDebit);
	if (id < 0)
		return soap->error;
	return soap_out_vin__DirectDebit(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__DirectDebit ** SOAP_FMAC4 soap_get_PointerTovin__DirectDebit(struct soap *soap, struct vin__DirectDebit **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__DirectDebit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__DirectDebit ** SOAP_FMAC4 soap_in_PointerTovin__DirectDebit(struct soap *soap, const char *tag, struct vin__DirectDebit **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__DirectDebit **)soap_malloc(soap, sizeof(struct vin__DirectDebit *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__DirectDebit(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__DirectDebit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__DirectDebit, sizeof(struct vin__DirectDebit), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__ECP(struct soap *soap, struct vin__ECP *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__ECP))
		soap_serialize_vin__ECP(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__ECP(struct soap *soap, struct vin__ECP *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__ECP);
	if (soap_out_PointerTovin__ECP(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__ECP(struct soap *soap, const char *tag, int id, struct vin__ECP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__ECP);
	if (id < 0)
		return soap->error;
	return soap_out_vin__ECP(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__ECP ** SOAP_FMAC4 soap_get_PointerTovin__ECP(struct soap *soap, struct vin__ECP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__ECP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ECP ** SOAP_FMAC4 soap_in_PointerTovin__ECP(struct soap *soap, const char *tag, struct vin__ECP **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__ECP **)soap_malloc(soap, sizeof(struct vin__ECP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__ECP(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__ECP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__ECP, sizeof(struct vin__ECP), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__CreditCard(struct soap *soap, struct vin__CreditCard *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__CreditCard))
		soap_serialize_vin__CreditCard(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__CreditCard(struct soap *soap, struct vin__CreditCard *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__CreditCard);
	if (soap_out_PointerTovin__CreditCard(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__CreditCard(struct soap *soap, const char *tag, int id, struct vin__CreditCard *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__CreditCard);
	if (id < 0)
		return soap->error;
	return soap_out_vin__CreditCard(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__CreditCard ** SOAP_FMAC4 soap_get_PointerTovin__CreditCard(struct soap *soap, struct vin__CreditCard **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__CreditCard(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__CreditCard ** SOAP_FMAC4 soap_in_PointerTovin__CreditCard(struct soap *soap, const char *tag, struct vin__CreditCard **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__CreditCard **)soap_malloc(soap, sizeof(struct vin__CreditCard *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__CreditCard(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__CreditCard **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__CreditCard, sizeof(struct vin__CreditCard), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__PaymentMethodType(struct soap *soap, enum vin__PaymentMethodType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vin__PaymentMethodType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__PaymentMethodType(struct soap *soap, enum vin__PaymentMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__PaymentMethodType);
	if (soap_out_PointerTovin__PaymentMethodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__PaymentMethodType(struct soap *soap, const char *tag, int id, enum vin__PaymentMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__PaymentMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_vin__PaymentMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vin__PaymentMethodType ** SOAP_FMAC4 soap_get_PointerTovin__PaymentMethodType(struct soap *soap, enum vin__PaymentMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__PaymentMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum vin__PaymentMethodType ** SOAP_FMAC4 soap_in_PointerTovin__PaymentMethodType(struct soap *soap, const char *tag, enum vin__PaymentMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum vin__PaymentMethodType **)soap_malloc(soap, sizeof(enum vin__PaymentMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__PaymentMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum vin__PaymentMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__PaymentMethodType, sizeof(enum vin__PaymentMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__ECPTransactionType(struct soap *soap, enum vin__ECPTransactionType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vin__ECPTransactionType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__ECPTransactionType(struct soap *soap, enum vin__ECPTransactionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__ECPTransactionType);
	if (soap_out_PointerTovin__ECPTransactionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__ECPTransactionType(struct soap *soap, const char *tag, int id, enum vin__ECPTransactionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__ECPTransactionType);
	if (id < 0)
		return soap->error;
	return soap_out_vin__ECPTransactionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vin__ECPTransactionType ** SOAP_FMAC4 soap_get_PointerTovin__ECPTransactionType(struct soap *soap, enum vin__ECPTransactionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__ECPTransactionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum vin__ECPTransactionType ** SOAP_FMAC4 soap_in_PointerTovin__ECPTransactionType(struct soap *soap, const char *tag, enum vin__ECPTransactionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum vin__ECPTransactionType **)soap_malloc(soap, sizeof(enum vin__ECPTransactionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__ECPTransactionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum vin__ECPTransactionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__ECPTransactionType, sizeof(enum vin__ECPTransactionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__AccountType(struct soap *soap, enum vin__AccountType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vin__AccountType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__AccountType(struct soap *soap, enum vin__AccountType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__AccountType);
	if (soap_out_PointerTovin__AccountType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__AccountType(struct soap *soap, const char *tag, int id, enum vin__AccountType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__AccountType);
	if (id < 0)
		return soap->error;
	return soap_out_vin__AccountType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vin__AccountType ** SOAP_FMAC4 soap_get_PointerTovin__AccountType(struct soap *soap, enum vin__AccountType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__AccountType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum vin__AccountType ** SOAP_FMAC4 soap_in_PointerTovin__AccountType(struct soap *soap, const char *tag, enum vin__AccountType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum vin__AccountType **)soap_malloc(soap, sizeof(enum vin__AccountType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__AccountType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum vin__AccountType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__AccountType, sizeof(enum vin__AccountType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__HashType(struct soap *soap, enum vin__HashType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vin__HashType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__HashType(struct soap *soap, enum vin__HashType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__HashType);
	if (soap_out_PointerTovin__HashType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__HashType(struct soap *soap, const char *tag, int id, enum vin__HashType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__HashType);
	if (id < 0)
		return soap->error;
	return soap_out_vin__HashType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vin__HashType ** SOAP_FMAC4 soap_get_PointerTovin__HashType(struct soap *soap, enum vin__HashType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__HashType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum vin__HashType ** SOAP_FMAC4 soap_in_PointerTovin__HashType(struct soap *soap, const char *tag, enum vin__HashType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum vin__HashType **)soap_malloc(soap, sizeof(enum vin__HashType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__HashType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum vin__HashType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__HashType, sizeof(enum vin__HashType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__EmailTemplateType(struct soap *soap, enum vin__EmailTemplateType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vin__EmailTemplateType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__EmailTemplateType(struct soap *soap, enum vin__EmailTemplateType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__EmailTemplateType);
	if (soap_out_PointerTovin__EmailTemplateType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__EmailTemplateType(struct soap *soap, const char *tag, int id, enum vin__EmailTemplateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__EmailTemplateType);
	if (id < 0)
		return soap->error;
	return soap_out_vin__EmailTemplateType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vin__EmailTemplateType ** SOAP_FMAC4 soap_get_PointerTovin__EmailTemplateType(struct soap *soap, enum vin__EmailTemplateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__EmailTemplateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum vin__EmailTemplateType ** SOAP_FMAC4 soap_in_PointerTovin__EmailTemplateType(struct soap *soap, const char *tag, enum vin__EmailTemplateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum vin__EmailTemplateType **)soap_malloc(soap, sizeof(enum vin__EmailTemplateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__EmailTemplateType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum vin__EmailTemplateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__EmailTemplateType, sizeof(enum vin__EmailTemplateType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__Transaction(struct soap *soap, struct vin__Transaction *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__Transaction))
		soap_serialize_vin__Transaction(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__Transaction(struct soap *soap, struct vin__Transaction *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__Transaction);
	if (soap_out_PointerTovin__Transaction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__Transaction(struct soap *soap, const char *tag, int id, struct vin__Transaction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__Transaction);
	if (id < 0)
		return soap->error;
	return soap_out_vin__Transaction(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Transaction ** SOAP_FMAC4 soap_get_PointerTovin__Transaction(struct soap *soap, struct vin__Transaction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__Transaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Transaction ** SOAP_FMAC4 soap_in_PointerTovin__Transaction(struct soap *soap, const char *tag, struct vin__Transaction **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Transaction **)soap_malloc(soap, sizeof(struct vin__Transaction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__Transaction(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Transaction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__Transaction, sizeof(struct vin__Transaction), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfMerchantEntitlementIds(struct soap *soap, struct ArrayOfMerchantEntitlementIds *const*a)
{
	if (*a)
		soap_serialize_ArrayOfMerchantEntitlementIds(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfMerchantEntitlementIds(struct soap *soap, struct ArrayOfMerchantEntitlementIds *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfMerchantEntitlementIds);
	if (soap_out_PointerToArrayOfMerchantEntitlementIds(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfMerchantEntitlementIds(struct soap *soap, const char *tag, int id, struct ArrayOfMerchantEntitlementIds *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfMerchantEntitlementIds);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfMerchantEntitlementIds(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfMerchantEntitlementIds ** SOAP_FMAC4 soap_get_PointerToArrayOfMerchantEntitlementIds(struct soap *soap, struct ArrayOfMerchantEntitlementIds **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfMerchantEntitlementIds(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfMerchantEntitlementIds ** SOAP_FMAC4 soap_in_PointerToArrayOfMerchantEntitlementIds(struct soap *soap, const char *tag, struct ArrayOfMerchantEntitlementIds **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfMerchantEntitlementIds **)soap_malloc(soap, sizeof(struct ArrayOfMerchantEntitlementIds *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfMerchantEntitlementIds(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfMerchantEntitlementIds **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfMerchantEntitlementIds, sizeof(struct ArrayOfMerchantEntitlementIds), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfBillingPlanPeriods(struct soap *soap, struct ArrayOfBillingPlanPeriods *const*a)
{
	if (*a)
		soap_serialize_ArrayOfBillingPlanPeriods(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfBillingPlanPeriods(struct soap *soap, struct ArrayOfBillingPlanPeriods *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfBillingPlanPeriods);
	if (soap_out_PointerToArrayOfBillingPlanPeriods(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfBillingPlanPeriods(struct soap *soap, const char *tag, int id, struct ArrayOfBillingPlanPeriods *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfBillingPlanPeriods);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfBillingPlanPeriods(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfBillingPlanPeriods ** SOAP_FMAC4 soap_get_PointerToArrayOfBillingPlanPeriods(struct soap *soap, struct ArrayOfBillingPlanPeriods **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfBillingPlanPeriods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfBillingPlanPeriods ** SOAP_FMAC4 soap_in_PointerToArrayOfBillingPlanPeriods(struct soap *soap, const char *tag, struct ArrayOfBillingPlanPeriods **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfBillingPlanPeriods **)soap_malloc(soap, sizeof(struct ArrayOfBillingPlanPeriods *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfBillingPlanPeriods(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfBillingPlanPeriods **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfBillingPlanPeriods, sizeof(struct ArrayOfBillingPlanPeriods), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__BillingPlanStatus(struct soap *soap, enum vin__BillingPlanStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vin__BillingPlanStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__BillingPlanStatus(struct soap *soap, enum vin__BillingPlanStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__BillingPlanStatus);
	if (soap_out_PointerTovin__BillingPlanStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__BillingPlanStatus(struct soap *soap, const char *tag, int id, enum vin__BillingPlanStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__BillingPlanStatus);
	if (id < 0)
		return soap->error;
	return soap_out_vin__BillingPlanStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vin__BillingPlanStatus ** SOAP_FMAC4 soap_get_PointerTovin__BillingPlanStatus(struct soap *soap, enum vin__BillingPlanStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__BillingPlanStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum vin__BillingPlanStatus ** SOAP_FMAC4 soap_in_PointerTovin__BillingPlanStatus(struct soap *soap, const char *tag, enum vin__BillingPlanStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum vin__BillingPlanStatus **)soap_malloc(soap, sizeof(enum vin__BillingPlanStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__BillingPlanStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum vin__BillingPlanStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__BillingPlanStatus, sizeof(enum vin__BillingPlanStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfBillingPlanPrices(struct soap *soap, struct ArrayOfBillingPlanPrices *const*a)
{
	if (*a)
		soap_serialize_ArrayOfBillingPlanPrices(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfBillingPlanPrices(struct soap *soap, struct ArrayOfBillingPlanPrices *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfBillingPlanPrices);
	if (soap_out_PointerToArrayOfBillingPlanPrices(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfBillingPlanPrices(struct soap *soap, const char *tag, int id, struct ArrayOfBillingPlanPrices *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfBillingPlanPrices);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfBillingPlanPrices(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfBillingPlanPrices ** SOAP_FMAC4 soap_get_PointerToArrayOfBillingPlanPrices(struct soap *soap, struct ArrayOfBillingPlanPrices **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfBillingPlanPrices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfBillingPlanPrices ** SOAP_FMAC4 soap_in_PointerToArrayOfBillingPlanPrices(struct soap *soap, const char *tag, struct ArrayOfBillingPlanPrices **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfBillingPlanPrices **)soap_malloc(soap, sizeof(struct ArrayOfBillingPlanPrices *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfBillingPlanPrices(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfBillingPlanPrices **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfBillingPlanPrices, sizeof(struct ArrayOfBillingPlanPrices), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__BillingPeriodType(struct soap *soap, enum vin__BillingPeriodType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vin__BillingPeriodType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__BillingPeriodType(struct soap *soap, enum vin__BillingPeriodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__BillingPeriodType);
	if (soap_out_PointerTovin__BillingPeriodType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__BillingPeriodType(struct soap *soap, const char *tag, int id, enum vin__BillingPeriodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__BillingPeriodType);
	if (id < 0)
		return soap->error;
	return soap_out_vin__BillingPeriodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vin__BillingPeriodType ** SOAP_FMAC4 soap_get_PointerTovin__BillingPeriodType(struct soap *soap, enum vin__BillingPeriodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__BillingPeriodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum vin__BillingPeriodType ** SOAP_FMAC4 soap_in_PointerTovin__BillingPeriodType(struct soap *soap, const char *tag, enum vin__BillingPeriodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum vin__BillingPeriodType **)soap_malloc(soap, sizeof(enum vin__BillingPeriodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__BillingPeriodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum vin__BillingPeriodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__BillingPeriodType, sizeof(enum vin__BillingPeriodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__TokenAmount(struct soap *soap, struct vin__TokenAmount *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__TokenAmount))
		soap_serialize_vin__TokenAmount(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__TokenAmount(struct soap *soap, struct vin__TokenAmount *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__TokenAmount);
	if (soap_out_PointerTovin__TokenAmount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__TokenAmount(struct soap *soap, const char *tag, int id, struct vin__TokenAmount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__TokenAmount);
	if (id < 0)
		return soap->error;
	return soap_out_vin__TokenAmount(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__TokenAmount ** SOAP_FMAC4 soap_get_PointerTovin__TokenAmount(struct soap *soap, struct vin__TokenAmount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__TokenAmount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__TokenAmount ** SOAP_FMAC4 soap_in_PointerTovin__TokenAmount(struct soap *soap, const char *tag, struct vin__TokenAmount **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__TokenAmount **)soap_malloc(soap, sizeof(struct vin__TokenAmount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__TokenAmount(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__TokenAmount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__TokenAmount, sizeof(struct vin__TokenAmount), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfTransactions(struct soap *soap, struct ArrayOfTransactions *const*a)
{
	if (*a)
		soap_serialize_ArrayOfTransactions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfTransactions(struct soap *soap, struct ArrayOfTransactions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfTransactions);
	if (soap_out_PointerToArrayOfTransactions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfTransactions(struct soap *soap, const char *tag, int id, struct ArrayOfTransactions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfTransactions);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfTransactions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfTransactions ** SOAP_FMAC4 soap_get_PointerToArrayOfTransactions(struct soap *soap, struct ArrayOfTransactions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfTransactions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfTransactions ** SOAP_FMAC4 soap_in_PointerToArrayOfTransactions(struct soap *soap, const char *tag, struct ArrayOfTransactions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfTransactions **)soap_malloc(soap, sizeof(struct ArrayOfTransactions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfTransactions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfTransactions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfTransactions, sizeof(struct ArrayOfTransactions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__AutoBillStatus(struct soap *soap, enum vin__AutoBillStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vin__AutoBillStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__AutoBillStatus(struct soap *soap, enum vin__AutoBillStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__AutoBillStatus);
	if (soap_out_PointerTovin__AutoBillStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__AutoBillStatus(struct soap *soap, const char *tag, int id, enum vin__AutoBillStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__AutoBillStatus);
	if (id < 0)
		return soap->error;
	return soap_out_vin__AutoBillStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vin__AutoBillStatus ** SOAP_FMAC4 soap_get_PointerTovin__AutoBillStatus(struct soap *soap, enum vin__AutoBillStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__AutoBillStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum vin__AutoBillStatus ** SOAP_FMAC4 soap_in_PointerTovin__AutoBillStatus(struct soap *soap, const char *tag, enum vin__AutoBillStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum vin__AutoBillStatus **)soap_malloc(soap, sizeof(enum vin__AutoBillStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__AutoBillStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum vin__AutoBillStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__AutoBillStatus, sizeof(enum vin__AutoBillStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__PaymentMethod(struct soap *soap, struct vin__PaymentMethod *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__PaymentMethod))
		soap_serialize_vin__PaymentMethod(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__PaymentMethod(struct soap *soap, struct vin__PaymentMethod *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__PaymentMethod);
	if (soap_out_PointerTovin__PaymentMethod(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__PaymentMethod(struct soap *soap, const char *tag, int id, struct vin__PaymentMethod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__PaymentMethod);
	if (id < 0)
		return soap->error;
	return soap_out_vin__PaymentMethod(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__PaymentMethod ** SOAP_FMAC4 soap_get_PointerTovin__PaymentMethod(struct soap *soap, struct vin__PaymentMethod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__PaymentMethod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__PaymentMethod ** SOAP_FMAC4 soap_in_PointerTovin__PaymentMethod(struct soap *soap, const char *tag, struct vin__PaymentMethod **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__PaymentMethod **)soap_malloc(soap, sizeof(struct vin__PaymentMethod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__PaymentMethod(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__PaymentMethod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__PaymentMethod, sizeof(struct vin__PaymentMethod), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__BillingPlan(struct soap *soap, struct vin__BillingPlan *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__BillingPlan))
		soap_serialize_vin__BillingPlan(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__BillingPlan(struct soap *soap, struct vin__BillingPlan *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__BillingPlan);
	if (soap_out_PointerTovin__BillingPlan(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__BillingPlan(struct soap *soap, const char *tag, int id, struct vin__BillingPlan *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__BillingPlan);
	if (id < 0)
		return soap->error;
	return soap_out_vin__BillingPlan(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__BillingPlan ** SOAP_FMAC4 soap_get_PointerTovin__BillingPlan(struct soap *soap, struct vin__BillingPlan **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__BillingPlan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__BillingPlan ** SOAP_FMAC4 soap_in_PointerTovin__BillingPlan(struct soap *soap, const char *tag, struct vin__BillingPlan **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__BillingPlan **)soap_malloc(soap, sizeof(struct vin__BillingPlan *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__BillingPlan(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__BillingPlan **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__BillingPlan, sizeof(struct vin__BillingPlan), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__Product(struct soap *soap, struct vin__Product *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__Product))
		soap_serialize_vin__Product(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__Product(struct soap *soap, struct vin__Product *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__Product);
	if (soap_out_PointerTovin__Product(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__Product(struct soap *soap, const char *tag, int id, struct vin__Product *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__Product);
	if (id < 0)
		return soap->error;
	return soap_out_vin__Product(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Product ** SOAP_FMAC4 soap_get_PointerTovin__Product(struct soap *soap, struct vin__Product **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__Product(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Product ** SOAP_FMAC4 soap_in_PointerTovin__Product(struct soap *soap, const char *tag, struct vin__Product **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Product **)soap_malloc(soap, sizeof(struct vin__Product *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__Product(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Product **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__Product, sizeof(struct vin__Product), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__ActivityTypeArg(struct soap *soap, struct vin__ActivityTypeArg *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__ActivityTypeArg))
		soap_serialize_vin__ActivityTypeArg(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__ActivityTypeArg(struct soap *soap, struct vin__ActivityTypeArg *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__ActivityTypeArg);
	if (soap_out_PointerTovin__ActivityTypeArg(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__ActivityTypeArg(struct soap *soap, const char *tag, int id, struct vin__ActivityTypeArg *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__ActivityTypeArg);
	if (id < 0)
		return soap->error;
	return soap_out_vin__ActivityTypeArg(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__ActivityTypeArg ** SOAP_FMAC4 soap_get_PointerTovin__ActivityTypeArg(struct soap *soap, struct vin__ActivityTypeArg **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__ActivityTypeArg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityTypeArg ** SOAP_FMAC4 soap_in_PointerTovin__ActivityTypeArg(struct soap *soap, const char *tag, struct vin__ActivityTypeArg **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__ActivityTypeArg **)soap_malloc(soap, sizeof(struct vin__ActivityTypeArg *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__ActivityTypeArg(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityTypeArg **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__ActivityTypeArg, sizeof(struct vin__ActivityTypeArg), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__Account(struct soap *soap, struct vin__Account *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__Account))
		soap_serialize_vin__Account(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__Account(struct soap *soap, struct vin__Account *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__Account);
	if (soap_out_PointerTovin__Account(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__Account(struct soap *soap, const char *tag, int id, struct vin__Account *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__Account);
	if (id < 0)
		return soap->error;
	return soap_out_vin__Account(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Account ** SOAP_FMAC4 soap_get_PointerTovin__Account(struct soap *soap, struct vin__Account **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__Account(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Account ** SOAP_FMAC4 soap_in_PointerTovin__Account(struct soap *soap, const char *tag, struct vin__Account **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Account **)soap_malloc(soap, sizeof(struct vin__Account *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__Account(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Account **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__Account, sizeof(struct vin__Account), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__ActivityNote(struct soap *soap, struct vin__ActivityNote *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__ActivityNote))
		soap_serialize_vin__ActivityNote(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__ActivityNote(struct soap *soap, struct vin__ActivityNote *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__ActivityNote);
	if (soap_out_PointerTovin__ActivityNote(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__ActivityNote(struct soap *soap, const char *tag, int id, struct vin__ActivityNote *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__ActivityNote);
	if (id < 0)
		return soap->error;
	return soap_out_vin__ActivityNote(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__ActivityNote ** SOAP_FMAC4 soap_get_PointerTovin__ActivityNote(struct soap *soap, struct vin__ActivityNote **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__ActivityNote(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityNote ** SOAP_FMAC4 soap_in_PointerTovin__ActivityNote(struct soap *soap, const char *tag, struct vin__ActivityNote **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__ActivityNote **)soap_malloc(soap, sizeof(struct vin__ActivityNote *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__ActivityNote(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityNote **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__ActivityNote, sizeof(struct vin__ActivityNote), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__ActivityCancellation(struct soap *soap, struct vin__ActivityCancellation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__ActivityCancellation))
		soap_serialize_vin__ActivityCancellation(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__ActivityCancellation(struct soap *soap, struct vin__ActivityCancellation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__ActivityCancellation);
	if (soap_out_PointerTovin__ActivityCancellation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__ActivityCancellation(struct soap *soap, const char *tag, int id, struct vin__ActivityCancellation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__ActivityCancellation);
	if (id < 0)
		return soap->error;
	return soap_out_vin__ActivityCancellation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__ActivityCancellation ** SOAP_FMAC4 soap_get_PointerTovin__ActivityCancellation(struct soap *soap, struct vin__ActivityCancellation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__ActivityCancellation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityCancellation ** SOAP_FMAC4 soap_in_PointerTovin__ActivityCancellation(struct soap *soap, const char *tag, struct vin__ActivityCancellation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__ActivityCancellation **)soap_malloc(soap, sizeof(struct vin__ActivityCancellation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__ActivityCancellation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityCancellation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__ActivityCancellation, sizeof(struct vin__ActivityCancellation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__ActivityNamedValue(struct soap *soap, struct vin__ActivityNamedValue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__ActivityNamedValue))
		soap_serialize_vin__ActivityNamedValue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__ActivityNamedValue(struct soap *soap, struct vin__ActivityNamedValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__ActivityNamedValue);
	if (soap_out_PointerTovin__ActivityNamedValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__ActivityNamedValue(struct soap *soap, const char *tag, int id, struct vin__ActivityNamedValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__ActivityNamedValue);
	if (id < 0)
		return soap->error;
	return soap_out_vin__ActivityNamedValue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__ActivityNamedValue ** SOAP_FMAC4 soap_get_PointerTovin__ActivityNamedValue(struct soap *soap, struct vin__ActivityNamedValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__ActivityNamedValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityNamedValue ** SOAP_FMAC4 soap_in_PointerTovin__ActivityNamedValue(struct soap *soap, const char *tag, struct vin__ActivityNamedValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__ActivityNamedValue **)soap_malloc(soap, sizeof(struct vin__ActivityNamedValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__ActivityNamedValue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityNamedValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__ActivityNamedValue, sizeof(struct vin__ActivityNamedValue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__ActivityUsage(struct soap *soap, struct vin__ActivityUsage *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__ActivityUsage))
		soap_serialize_vin__ActivityUsage(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__ActivityUsage(struct soap *soap, struct vin__ActivityUsage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__ActivityUsage);
	if (soap_out_PointerTovin__ActivityUsage(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__ActivityUsage(struct soap *soap, const char *tag, int id, struct vin__ActivityUsage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__ActivityUsage);
	if (id < 0)
		return soap->error;
	return soap_out_vin__ActivityUsage(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__ActivityUsage ** SOAP_FMAC4 soap_get_PointerTovin__ActivityUsage(struct soap *soap, struct vin__ActivityUsage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__ActivityUsage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityUsage ** SOAP_FMAC4 soap_in_PointerTovin__ActivityUsage(struct soap *soap, const char *tag, struct vin__ActivityUsage **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__ActivityUsage **)soap_malloc(soap, sizeof(struct vin__ActivityUsage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__ActivityUsage(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityUsage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__ActivityUsage, sizeof(struct vin__ActivityUsage), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__ActivityFulfillment(struct soap *soap, struct vin__ActivityFulfillment *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__ActivityFulfillment))
		soap_serialize_vin__ActivityFulfillment(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__ActivityFulfillment(struct soap *soap, struct vin__ActivityFulfillment *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__ActivityFulfillment);
	if (soap_out_PointerTovin__ActivityFulfillment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__ActivityFulfillment(struct soap *soap, const char *tag, int id, struct vin__ActivityFulfillment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__ActivityFulfillment);
	if (id < 0)
		return soap->error;
	return soap_out_vin__ActivityFulfillment(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__ActivityFulfillment ** SOAP_FMAC4 soap_get_PointerTovin__ActivityFulfillment(struct soap *soap, struct vin__ActivityFulfillment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__ActivityFulfillment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityFulfillment ** SOAP_FMAC4 soap_in_PointerTovin__ActivityFulfillment(struct soap *soap, const char *tag, struct vin__ActivityFulfillment **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__ActivityFulfillment **)soap_malloc(soap, sizeof(struct vin__ActivityFulfillment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__ActivityFulfillment(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityFulfillment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__ActivityFulfillment, sizeof(struct vin__ActivityFulfillment), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__ActivityEmailContact(struct soap *soap, struct vin__ActivityEmailContact *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__ActivityEmailContact))
		soap_serialize_vin__ActivityEmailContact(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__ActivityEmailContact(struct soap *soap, struct vin__ActivityEmailContact *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__ActivityEmailContact);
	if (soap_out_PointerTovin__ActivityEmailContact(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__ActivityEmailContact(struct soap *soap, const char *tag, int id, struct vin__ActivityEmailContact *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__ActivityEmailContact);
	if (id < 0)
		return soap->error;
	return soap_out_vin__ActivityEmailContact(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__ActivityEmailContact ** SOAP_FMAC4 soap_get_PointerTovin__ActivityEmailContact(struct soap *soap, struct vin__ActivityEmailContact **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__ActivityEmailContact(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityEmailContact ** SOAP_FMAC4 soap_in_PointerTovin__ActivityEmailContact(struct soap *soap, const char *tag, struct vin__ActivityEmailContact **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__ActivityEmailContact **)soap_malloc(soap, sizeof(struct vin__ActivityEmailContact *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__ActivityEmailContact(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityEmailContact **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__ActivityEmailContact, sizeof(struct vin__ActivityEmailContact), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__ActivityPhoneContact(struct soap *soap, struct vin__ActivityPhoneContact *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__ActivityPhoneContact))
		soap_serialize_vin__ActivityPhoneContact(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__ActivityPhoneContact(struct soap *soap, struct vin__ActivityPhoneContact *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__ActivityPhoneContact);
	if (soap_out_PointerTovin__ActivityPhoneContact(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__ActivityPhoneContact(struct soap *soap, const char *tag, int id, struct vin__ActivityPhoneContact *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__ActivityPhoneContact);
	if (id < 0)
		return soap->error;
	return soap_out_vin__ActivityPhoneContact(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__ActivityPhoneContact ** SOAP_FMAC4 soap_get_PointerTovin__ActivityPhoneContact(struct soap *soap, struct vin__ActivityPhoneContact **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__ActivityPhoneContact(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityPhoneContact ** SOAP_FMAC4 soap_in_PointerTovin__ActivityPhoneContact(struct soap *soap, const char *tag, struct vin__ActivityPhoneContact **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__ActivityPhoneContact **)soap_malloc(soap, sizeof(struct vin__ActivityPhoneContact *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__ActivityPhoneContact(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityPhoneContact **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__ActivityPhoneContact, sizeof(struct vin__ActivityPhoneContact), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__ActivityURIView(struct soap *soap, struct vin__ActivityURIView *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__ActivityURIView))
		soap_serialize_vin__ActivityURIView(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__ActivityURIView(struct soap *soap, struct vin__ActivityURIView *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__ActivityURIView);
	if (soap_out_PointerTovin__ActivityURIView(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__ActivityURIView(struct soap *soap, const char *tag, int id, struct vin__ActivityURIView *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__ActivityURIView);
	if (id < 0)
		return soap->error;
	return soap_out_vin__ActivityURIView(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__ActivityURIView ** SOAP_FMAC4 soap_get_PointerTovin__ActivityURIView(struct soap *soap, struct vin__ActivityURIView **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__ActivityURIView(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityURIView ** SOAP_FMAC4 soap_in_PointerTovin__ActivityURIView(struct soap *soap, const char *tag, struct vin__ActivityURIView **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__ActivityURIView **)soap_malloc(soap, sizeof(struct vin__ActivityURIView *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__ActivityURIView(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityURIView **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__ActivityURIView, sizeof(struct vin__ActivityURIView), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__ActivityLogout(struct soap *soap, struct vin__ActivityLogout *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__ActivityLogout))
		soap_serialize_vin__ActivityLogout(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__ActivityLogout(struct soap *soap, struct vin__ActivityLogout *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__ActivityLogout);
	if (soap_out_PointerTovin__ActivityLogout(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__ActivityLogout(struct soap *soap, const char *tag, int id, struct vin__ActivityLogout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__ActivityLogout);
	if (id < 0)
		return soap->error;
	return soap_out_vin__ActivityLogout(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__ActivityLogout ** SOAP_FMAC4 soap_get_PointerTovin__ActivityLogout(struct soap *soap, struct vin__ActivityLogout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__ActivityLogout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityLogout ** SOAP_FMAC4 soap_in_PointerTovin__ActivityLogout(struct soap *soap, const char *tag, struct vin__ActivityLogout **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__ActivityLogout **)soap_malloc(soap, sizeof(struct vin__ActivityLogout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__ActivityLogout(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityLogout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__ActivityLogout, sizeof(struct vin__ActivityLogout), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__ActivityLogin(struct soap *soap, struct vin__ActivityLogin *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__ActivityLogin))
		soap_serialize_vin__ActivityLogin(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__ActivityLogin(struct soap *soap, struct vin__ActivityLogin *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__ActivityLogin);
	if (soap_out_PointerTovin__ActivityLogin(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__ActivityLogin(struct soap *soap, const char *tag, int id, struct vin__ActivityLogin *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__ActivityLogin);
	if (id < 0)
		return soap->error;
	return soap_out_vin__ActivityLogin(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__ActivityLogin ** SOAP_FMAC4 soap_get_PointerTovin__ActivityLogin(struct soap *soap, struct vin__ActivityLogin **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__ActivityLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__ActivityLogin ** SOAP_FMAC4 soap_in_PointerTovin__ActivityLogin(struct soap *soap, const char *tag, struct vin__ActivityLogin **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__ActivityLogin **)soap_malloc(soap, sizeof(struct vin__ActivityLogin *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__ActivityLogin(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__ActivityLogin **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__ActivityLogin, sizeof(struct vin__ActivityLogin), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfTokenAmounts(struct soap *soap, struct ArrayOfTokenAmounts *const*a)
{
	if (*a)
		soap_serialize_ArrayOfTokenAmounts(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfTokenAmounts(struct soap *soap, struct ArrayOfTokenAmounts *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfTokenAmounts);
	if (soap_out_PointerToArrayOfTokenAmounts(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfTokenAmounts(struct soap *soap, const char *tag, int id, struct ArrayOfTokenAmounts *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfTokenAmounts);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfTokenAmounts(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfTokenAmounts ** SOAP_FMAC4 soap_get_PointerToArrayOfTokenAmounts(struct soap *soap, struct ArrayOfTokenAmounts **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfTokenAmounts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfTokenAmounts ** SOAP_FMAC4 soap_in_PointerToArrayOfTokenAmounts(struct soap *soap, const char *tag, struct ArrayOfTokenAmounts **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfTokenAmounts **)soap_malloc(soap, sizeof(struct ArrayOfTokenAmounts *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfTokenAmounts(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfTokenAmounts **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfTokenAmounts, sizeof(struct ArrayOfTokenAmounts), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfTaxExemptions(struct soap *soap, struct ArrayOfTaxExemptions *const*a)
{
	if (*a)
		soap_serialize_ArrayOfTaxExemptions(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfTaxExemptions(struct soap *soap, struct ArrayOfTaxExemptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfTaxExemptions);
	if (soap_out_PointerToArrayOfTaxExemptions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfTaxExemptions(struct soap *soap, const char *tag, int id, struct ArrayOfTaxExemptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfTaxExemptions);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfTaxExemptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfTaxExemptions ** SOAP_FMAC4 soap_get_PointerToArrayOfTaxExemptions(struct soap *soap, struct ArrayOfTaxExemptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfTaxExemptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfTaxExemptions ** SOAP_FMAC4 soap_in_PointerToArrayOfTaxExemptions(struct soap *soap, const char *tag, struct ArrayOfTaxExemptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfTaxExemptions **)soap_malloc(soap, sizeof(struct ArrayOfTaxExemptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfTaxExemptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfTaxExemptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfTaxExemptions, sizeof(struct ArrayOfTaxExemptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfNameValuePairs(struct soap *soap, struct ArrayOfNameValuePairs *const*a)
{
	if (*a)
		soap_serialize_ArrayOfNameValuePairs(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfNameValuePairs(struct soap *soap, struct ArrayOfNameValuePairs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfNameValuePairs);
	if (soap_out_PointerToArrayOfNameValuePairs(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfNameValuePairs(struct soap *soap, const char *tag, int id, struct ArrayOfNameValuePairs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfNameValuePairs);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfNameValuePairs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfNameValuePairs ** SOAP_FMAC4 soap_get_PointerToArrayOfNameValuePairs(struct soap *soap, struct ArrayOfNameValuePairs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfNameValuePairs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfNameValuePairs ** SOAP_FMAC4 soap_in_PointerToArrayOfNameValuePairs(struct soap *soap, const char *tag, struct ArrayOfNameValuePairs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfNameValuePairs **)soap_malloc(soap, sizeof(struct ArrayOfNameValuePairs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfNameValuePairs(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfNameValuePairs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfNameValuePairs, sizeof(struct ArrayOfNameValuePairs), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfPaymentMethods(struct soap *soap, struct ArrayOfPaymentMethods *const*a)
{
	if (*a)
		soap_serialize_ArrayOfPaymentMethods(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfPaymentMethods(struct soap *soap, struct ArrayOfPaymentMethods *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfPaymentMethods);
	if (soap_out_PointerToArrayOfPaymentMethods(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfPaymentMethods(struct soap *soap, const char *tag, int id, struct ArrayOfPaymentMethods *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfPaymentMethods);
	if (id < 0)
		return soap->error;
	return soap_out_ArrayOfPaymentMethods(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ArrayOfPaymentMethods ** SOAP_FMAC4 soap_get_PointerToArrayOfPaymentMethods(struct soap *soap, struct ArrayOfPaymentMethods **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfPaymentMethods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ArrayOfPaymentMethods ** SOAP_FMAC4 soap_in_PointerToArrayOfPaymentMethods(struct soap *soap, const char *tag, struct ArrayOfPaymentMethods **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ArrayOfPaymentMethods **)soap_malloc(soap, sizeof(struct ArrayOfPaymentMethods *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ArrayOfPaymentMethods(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ArrayOfPaymentMethods **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfPaymentMethods, sizeof(struct ArrayOfPaymentMethods), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__Address(struct soap *soap, struct vin__Address *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_vin__Address))
		soap_serialize_vin__Address(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__Address(struct soap *soap, struct vin__Address *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__Address);
	if (soap_out_PointerTovin__Address(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__Address(struct soap *soap, const char *tag, int id, struct vin__Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__Address);
	if (id < 0)
		return soap->error;
	return soap_out_vin__Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct vin__Address ** SOAP_FMAC4 soap_get_PointerTovin__Address(struct soap *soap, struct vin__Address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct vin__Address ** SOAP_FMAC4 soap_in_PointerTovin__Address(struct soap *soap, const char *tag, struct vin__Address **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct vin__Address **)soap_malloc(soap, sizeof(struct vin__Address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct vin__Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__Address, sizeof(struct vin__Address), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__boolean);
	if (soap_out_PointerToxsd__boolean(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTovin__EmailPreference(struct soap *soap, enum vin__EmailPreference *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_vin__EmailPreference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTovin__EmailPreference(struct soap *soap, enum vin__EmailPreference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTovin__EmailPreference);
	if (soap_out_PointerTovin__EmailPreference(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTovin__EmailPreference(struct soap *soap, const char *tag, int id, enum vin__EmailPreference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_vin__EmailPreference);
	if (id < 0)
		return soap->error;
	return soap_out_vin__EmailPreference(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum vin__EmailPreference ** SOAP_FMAC4 soap_get_PointerTovin__EmailPreference(struct soap *soap, enum vin__EmailPreference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTovin__EmailPreference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum vin__EmailPreference ** SOAP_FMAC4 soap_in_PointerTovin__EmailPreference(struct soap *soap, const char *tag, enum vin__EmailPreference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum vin__EmailPreference **)soap_malloc(soap, sizeof(enum vin__EmailPreference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_vin__EmailPreference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum vin__EmailPreference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_vin__EmailPreference, sizeof(enum vin__EmailPreference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__decimal(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__decimal);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__decimal, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__date(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__date(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__date);
	if (soap_out_xsd__date(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__date);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__date(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__date, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__anyURI(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

#ifdef __cplusplus
}
#endif

/* End of VindiciaStructsC.c */
