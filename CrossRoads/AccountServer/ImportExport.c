#include "ImportExport.h"
#include "ImportExport_c_ast.h"
#include "timing.h"
#include "EString.h"
#include "file.h"
#include "utilitiesLib.h"
#include "crypt.h"
#include "StringUtil.h"

#define CHECKSUM_SALT "pleasedontmessupimports"

/************************************************************************/
/* Types                                                                */
/************************************************************************/

AUTO_STRUCT;
typedef struct ExportData
{
	STRING_EARRAY eaEntries; AST(ESTRING)
} ExportData;

AUTO_STRUCT;
typedef struct Export
{
	char *pAuthor;
	U32 uTimeCreatedSS2000; AST(NAME(Time))
	char *pChecksum;
	bool bProduction;
	char *pVersion;
	char *pInstance;
	char *pHost;
	int iFormatVersion;
	char *pDescription;
	ExportData data;
} Export;


/************************************************************************/
/* Private functions                                                    */
/************************************************************************/

// Returns a regular string
SA_RET_OP_VALID static char * CalculateExportChecksum(SA_PARAM_NN_VALID Export *pExport)
{
	char *pData = NULL;
	static char md5[33];

	if (!verify(pExport)) return NULL;

	PERFINFO_AUTO_START_FUNC();

	EARRAY_CONST_FOREACH_BEGIN(pExport->data.eaEntries, iCurEntry, iNumEntries);
	{
		estrConcatf(&pData, "%s", pExport->data.eaEntries[iCurEntry]);
	}
	EARRAY_FOREACH_END;

	estrConcatf(&pData, "%s%s%u%u%s%s%i%s",
		pExport->pAuthor, pExport->pVersion, pExport->uTimeCreatedSS2000, pExport->bProduction, pExport->pHost, pExport->pInstance, pExport->iFormatVersion, pExport->pDescription);

	estrConcatf(&pData, "%s", CHECKSUM_SALT);

	cryptMD5Hex(pData, estrLength(&pData), SAFESTR(md5));

	estrDestroy(&pData);

	PERFINFO_AUTO_STOP_FUNC();

	return md5;
}


/************************************************************************/
/* Public functions                                                     */
/************************************************************************/

SA_RET_OP_VALID Export * CreateExport(void)
{
	return StructCreate(parse_Export);
}

void DestroyExport(Export **pExport)
{
	if (verify(pExport))
	{
		StructDestroy(parse_Export, *pExport);
		*pExport = NULL;
	}
}

// Returns an estring the caller must destroy
SA_RET_OP_STR char * SerializeExport(SA_PARAM_NN_VALID Export *pExport,
									SA_PARAM_OP_STR const char *pAuthor,
									SA_PARAM_OP_STR const char *pDescription,
									int iFormatVersion)
{
	char *pSerialized = NULL;

	if (!verify(pExport)) return NULL;

	PERFINFO_AUTO_START_FUNC();

	if (pExport->pChecksum)
	{
		free(pExport->pChecksum);
	}

	if (pExport->pAuthor)
	{
		free(pExport->pAuthor);
	}

	if (pExport->pVersion)
	{
		free(pExport->pVersion);
	}

	if (pExport->pInstance)
	{
		free(pExport->pInstance);
	}

	if (pExport->pHost)
	{
		free(pExport->pHost);
	}

	if (pExport->pDescription)
	{
		free(pExport->pDescription);
	}

	pExport->pAuthor = strdup(pAuthor);
	pExport->uTimeCreatedSS2000 = timeSecondsSince2000();
	pExport->bProduction = isProductionMode();
	pExport->pVersion = strdup(GetUsefulVersionString());
	pExport->pInstance = strdup(GetShardNameFromShardInfoString());
	pExport->pHost = strdup(getHostName());
	pExport->iFormatVersion = iFormatVersion;
	pExport->pDescription = strdup(pDescription);

	pExport->pChecksum = strdup(CalculateExportChecksum(pExport));

	estrConcatf(&pSerialized, "# This file was generated by the Account Server on %s.\r\n", timeGetLocalDateStringFromSecondsSince2000(pExport->uTimeCreatedSS2000));
	estrConcatf(&pSerialized, "# Changing anything in this file will prevent it from being imported.\r\n");
	ParserWriteText(&pSerialized, parse_Export, pExport, 0, 0, 0);

	PERFINFO_AUTO_STOP_FUNC();

	return pSerialized;
}

SA_RET_OP_VALID Export * UnserializeExport(SA_PARAM_NN_STR const char *pString,
										int iFormatVersion)
{
	Export *pExport = NULL;

	if (!verify(pString)) return NULL;

	PERFINFO_AUTO_START_FUNC();

	pExport = StructCreate(parse_Export);

	if (!pExport)
	{
		goto error;
	}

	ParserReadText(pString, parse_Export, pExport, 0);

	// The author field must not be NULL for the checksum to work
	if (!pExport->pAuthor)
	{
		pExport->pAuthor = calloc(1, 1);
	}

	if (stricmp_safe(pExport->pChecksum, CalculateExportChecksum(pExport)))
	{
		goto error;
	}

	if (pExport->iFormatVersion != iFormatVersion)
	{
		goto error;
	}

	PERFINFO_AUTO_STOP_FUNC();

	return pExport;

error:

	if (pExport)
	{
		DestroyExport(&pExport);
	}

	PERFINFO_AUTO_STOP_FUNC();

	return NULL;
}

void AddExportEntry(SA_PARAM_NN_VALID Export *pExport,
					SA_PARAM_NN_VALID ParseTable *tpi,
					SA_PARAM_NN_VALID const void *pStruct)
{
	char *pData = NULL;

	if (!verify(pExport)) return;
	if (!verify(tpi)) return;
	if (!verify(pStruct)) return;

	PERFINFO_AUTO_START_FUNC();

	ParserWriteText(&pData, tpi, (void*)pStruct, 0, 0, 0);
	eaPush(&pExport->data.eaEntries, pData);

	PERFINFO_AUTO_STOP_FUNC();
}

int GetNumExportEntries(SA_PARAM_NN_VALID Export *pExport)
{
	if (!verify(pExport)) return 0;

	return eaSize(&pExport->data.eaEntries);
}

SA_RET_NN_VALID void * GetExportEntry(SA_PARAM_NN_VALID Export *pExport,
								  SA_PARAM_NN_VALID ParseTable *tpi,
								  int iIndex)
{
	void *pStruct = NULL;

	if (!verify(pExport)) return NULL;
	if (!verify(tpi)) return NULL;
	if (!verify(iIndex >= 0 && iIndex < GetNumExportEntries(pExport))) return NULL;

	PERFINFO_AUTO_START_FUNC();

	pStruct = StructCreateVoid(tpi);

	if (devassert(pStruct))
	{
		ParserReadText(pExport->data.eaEntries[iIndex], tpi, pStruct, 0);
	}

	PERFINFO_AUTO_STOP_FUNC();

	return pStruct;
}

#include "ImportExport_c_ast.c"