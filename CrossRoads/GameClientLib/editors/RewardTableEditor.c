//
// RewardTableEditor.c
//

#ifndef NO_EDITORS

#include "ItemCommon.h"
#include "itemCommon_h_ast.h"
#include "ItemEnums.h"
#include "itemEnums_h_ast.h"
#include "estring.h"
#include "MultiEditTable.h"
#include "MultiEditWindow.h"
#include "CostumeCommon.h"
#include "ResourceSearch.h"
#include "rewardCommon.h"
#include "RewardTableEditor.h"
#include "StringCache.h"
#include "GameBranch.h"
#include "GamePermissionsCommon.h"
#include "qsortG.h"
#include "Alerts.h"
#include "ActivityCommon.h"

#include "AutoGen/rewardCommon_h_ast.h"



#define RTE_GROUP_MAIN				"Main"
#define RTE_GROUP_OPTIONS			"Options"
#define RTE_GROUP_COSTUME			"Options"
#define RTE_SUBGROUP_REWARDS        "Rewards"

static int s_RewardTabID;

// This magic line is required if you run in Full Debug to avoid assert
AUTO_RUN_ANON(memBudgetAddMapping(__FILE__, BUDGET_Editors););


//-----------------------------------------------------------------------------------
// Global Data
//-----------------------------------------------------------------------------------

static MEWindow *rteWindow = NULL;

extern ExprContext *g_pRewardNonPlayerContext;
extern ExprContext *g_pRewardPlayerContext;
extern ActivityDefs g_ActivityDefs;

//-----------------------------------------------------------------------------------
// Message Fixup
//-----------------------------------------------------------------------------------

static void rte_FixMessages(RewardTable* pTable)
{
	int i;
	char* estrTmp = NULL;

	estrStackCreate(&estrTmp);

	for (i = eaSize(&pTable->ppRewardEntry)-1; i >= 0; i--)
	{
		RewardEntry* pEntry = pTable->ppRewardEntry[i];

		// Fixup broadcast chat message
		if(!pEntry->msgBroadcastChatMessage.pEditorCopy)
		{
			pEntry->msgBroadcastChatMessage.pEditorCopy = StructCreate(parse_Message);
		}

		estrPrintf(&estrTmp, "RewardTableEntry.%s.%d.BroadcastChatMessage", pTable->pchName, i);
		if(!pEntry->msgBroadcastChatMessage.pEditorCopy->pcMessageKey ||
			(stricmp(estrTmp, pEntry->msgBroadcastChatMessage.pEditorCopy->pcMessageKey) != 0)) {
				pEntry->msgBroadcastChatMessage.pEditorCopy->pcMessageKey = allocAddString(estrTmp);
		}

		estrPrintf(&estrTmp, "Broadcast message for a RewardTableEntry");
		if(!pEntry->msgBroadcastChatMessage.pEditorCopy->pcDescription ||
			(stricmp(estrTmp, pEntry->msgBroadcastChatMessage.pEditorCopy->pcDescription) != 0)) {
				pEntry->msgBroadcastChatMessage.pEditorCopy->pcDescription = StructAllocString(estrTmp);
		}

		estrPrintf(&estrTmp, "RewardTable");
		if(!pEntry->msgBroadcastChatMessage.pEditorCopy->pcScope ||
			(stricmp(estrTmp, pEntry->msgBroadcastChatMessage.pEditorCopy->pcScope) != 0)) {
				pEntry->msgBroadcastChatMessage.pEditorCopy->pcScope = allocAddString(estrTmp);
		}
	}
	estrDestroy(&estrTmp);
}


//---------------------------------------------------------------------------------------------------
// Callbacks
//---------------------------------------------------------------------------------------------------

static int rte_compareStrings(const char** left, const char** right)
{
	return stricmp(*left,*right);
}


static void *rte_createRewardEntry(METable *pTable, RewardTable *pRewardTable, RewardEntry *pRewardEntryToClone, RewardEntry *pBeforeRewardEntry, RewardEntry *pAfterRewardEntry)
{
	RewardEntry *pNewRewardEntry = NULL;

	// Allocate the object
	if (pRewardEntryToClone) {
		pNewRewardEntry = (RewardEntry*)StructClone(parse_RewardEntry, pRewardEntryToClone);
	} 
	else 
	{
		pNewRewardEntry = (RewardEntry*)StructCreate(parse_RewardEntry);

		if (pNewRewardEntry)
		{
			pNewRewardEntry->ChoiceType = kRewardChoiceType_Choice;
			pNewRewardEntry->Type = kRewardType_Item;
		}
	}

	if (!pNewRewardEntry) {
		return NULL;
	}

	return pNewRewardEntry;
}



static int rte_validateCallback(METable *pTable, RewardTable *pRewardTable, void *pUserData)
{
	char buf[1024];
	int retcode = 1;


	if(strStartsWith(pRewardTable->pchScope,"Itemgen"))
	{
		sprintf(buf, "The reward table '%s' is either a table that was generated by the Item Gen system, or is tring to be saved into the Item Gen directory. This is not allowed!", pRewardTable->pchName);
		ui_DialogPopup("Saving a file in the Itemgen Scope",buf);
		return 0;
	}

	if (pRewardTable->pchName[0] == '_') 
	{
		sprintf(buf, "The reward table '%s' cannot have a name starting with an underscore.", pRewardTable->pchName);
		ui_DialogPopup("Validation Error", buf);
		retcode = 0;
	}

	if (!rewardTable_Validate(pRewardTable)) 
	{
		retcode = 0;
	}

	return retcode;
}

static void rte_postOpenCallback(METable *pTable, RewardTable *pRewardTable, RewardTable *pOrigRewardTable)
{
	rte_FixMessages(pRewardTable);
	if (pOrigRewardTable) {
		rte_FixMessages(pOrigRewardTable);
	}
}

static void rte_preSaveCallback(METable *pTable, RewardTable *pRewardTable)
{
	//default any N/A fields so that they don't show up in the output file
	{
		int NumRewardEntries = eaSize(&pRewardTable->ppRewardEntry);
		int ii;

		for(ii=0; ii<NumRewardEntries; ii++)
		{
			RewardEntry* pRewardEntry = (RewardEntry*)pRewardTable->ppRewardEntry[ii];

			switch(pRewardEntry->ChoiceType)
			{
			case kRewardChoiceType_Choice:
			case kRewardChoiceType_ChoiceVariableCount:
				//pRewardEntry->Type = 0;
				//REMOVE_HANDLE(pRewardEntry->hItemDef)
				pRewardEntry->MinLevel = 0;
				pRewardEntry->MaxLevel = 0;
				//REMOVE_HANDLE(pRewardEntry->hRewardTable)
				//REMOVE_HANDLE(pRewardEntry->hItemPowerDef)
				//REMOVE_HANDLE(pRewardEntry->hCostumeDef)

				switch (pRewardEntry->Type)
				{
				case kRewardType_ItemWithGems:
					REMOVE_HANDLE(pRewardEntry->hItemPowerDef);
					REMOVE_HANDLE(pRewardEntry->hCostumeDef);
					pRewardEntry->Count = 1;
					break;

				case kRewardType_Item:
					//REMOVE_HANDLE(pRewardEntry->hItemDef)
					REMOVE_HANDLE(pRewardEntry->hRewardTable);
					REMOVE_HANDLE(pRewardEntry->hItemPowerDef);
					REMOVE_HANDLE(pRewardEntry->hCostumeDef);
					break;

				case kRewardType_AlgoItem:
				case kRewardType_AlgoItemForce:
					REMOVE_HANDLE(pRewardEntry->hItemDef);
					REMOVE_HANDLE(pRewardEntry->hRewardTable);
					REMOVE_HANDLE(pRewardEntry->hItemPowerDef);
					REMOVE_HANDLE(pRewardEntry->hCostumeDef);
					break;

				case kRewardType_RewardTable:
					REMOVE_HANDLE(pRewardEntry->hItemDef);
					//REMOVE_HANDLE(pRewardEntry->hRewardTable)
					REMOVE_HANDLE(pRewardEntry->hItemPowerDef);
					REMOVE_HANDLE(pRewardEntry->hCostumeDef);
					break;

				default:
					break;
				}
				break;

			case kRewardChoiceType_Include:
				pRewardEntry->Type = 0;
				REMOVE_HANDLE(pRewardEntry->hItemDef);
				pRewardEntry->MinLevel = 0;
				pRewardEntry->MaxLevel = 0;
				//REMOVE_HANDLE(pRewardEntry->hRewardTable)
				REMOVE_HANDLE(pRewardEntry->hItemPowerDef);
				REMOVE_HANDLE(pRewardEntry->hCostumeDef);
				break;

			case kRewardChoiceType_LevelRange:
			case kRewardChoiceType_SkillRange:
			case kRewardChoiceType_EPRange:
			case kRewardChoiceType_TimeRange:
				pRewardEntry->Type = 0;
				REMOVE_HANDLE(pRewardEntry->hItemDef);
				//pRewardEntry->MinLevel = 0;
				//pRewardEntry->MaxLevel = 0;
				//REMOVE_HANDLE(pRewardEntry->hRewardTable)
				REMOVE_HANDLE(pRewardEntry->hItemPowerDef);
				REMOVE_HANDLE(pRewardEntry->hCostumeDef);
				break;

			case kRewardChoiceType_Empty:
				pRewardEntry->Type = 0;
				REMOVE_HANDLE(pRewardEntry->hItemDef);
				pRewardEntry->MinLevel = 0;
				pRewardEntry->MaxLevel = 0;
				REMOVE_HANDLE(pRewardEntry->hRewardTable);
				REMOVE_HANDLE(pRewardEntry->hItemPowerDef);
				REMOVE_HANDLE(pRewardEntry->hCostumeDef);
				break;

			case kRewardChoiceType_AlgoBase:
				pRewardEntry->Type = 0;
				//REMOVE_HANDLE(pRewardEntry->hItemDef);
				pRewardEntry->MinLevel = 0;
				pRewardEntry->MaxLevel = 0;
				REMOVE_HANDLE(pRewardEntry->hRewardTable);
				REMOVE_HANDLE(pRewardEntry->hItemPowerDef);
				REMOVE_HANDLE(pRewardEntry->hCostumeDef);
				break;

			case kRewardChoiceType_AlgoChar:
				pRewardEntry->Type = 0;
				REMOVE_HANDLE(pRewardEntry->hItemDef);
				pRewardEntry->MinLevel = 0;
				pRewardEntry->MaxLevel = 0;
				REMOVE_HANDLE(pRewardEntry->hRewardTable);
				//REMOVE_HANDLE(pRewardEntry->hItemPowerDef);
				REMOVE_HANDLE(pRewardEntry->hCostumeDef);
				break;

			case kRewardChoiceType_AlgoCost:
				pRewardEntry->Type = 0;
				REMOVE_HANDLE(pRewardEntry->hItemDef);
				pRewardEntry->MinLevel = 0;
				pRewardEntry->MaxLevel = 0;
				REMOVE_HANDLE(pRewardEntry->hRewardTable);
				REMOVE_HANDLE(pRewardEntry->hItemPowerDef);
				//REMOVE_HANDLE(pRewardEntry->hCostumeDef);
				break;

			default:
				break;
			}

			if (!rewardEntry_UsesCountExpression(pRewardEntry) && pRewardEntry->pCountExpr)
			{
				exprDestroy(pRewardEntry->pCountExpr);
				pRewardEntry->pCountExpr = NULL;
			}

		}
	}
}



static void *rte_createObject(METable *pTable, RewardTable *pObjectToClone, char *pcNewName, const char *pchScope, bool bCloneKeepsKeys)
{
	RewardTable *pNewTable = NULL;
	char buf[128];
	const char *pcBaseName;
	char *pchPath = NULL;
	
	// Create the object
	if (pObjectToClone) {
		pNewTable = StructClone(parse_RewardTable, pObjectToClone);
		pcBaseName = pObjectToClone->pchName;
	} else {
		pNewTable = StructCreate(parse_RewardTable);

		pcBaseName = "_New_Table";
	}
	// Use provided name if available
	if (pcNewName) {
		pcBaseName = pcNewName;
	}

	assertmsg(pNewTable, "Failed to create reward table");

	// Assign a new name
	if (!pcNewName) {
		pNewTable->pchName = (char*)METableMakeNewNameShared(pTable, pcBaseName, true);
	} else {
		pNewTable->pchName = (char*)allocAddString(pcNewName);
	}

	// Assign a scope
	pNewTable->pchScope = (char*)allocAddString(pchScope);

	GameBranch_GetDirectory(&pchPath, REWARDS_BASE_DIR);

	// Assign a file
	if (pchScope && pchScope[0])
		sprintf(buf,"%s/%s/%s.%s", pchPath, pchScope, pNewTable->pchName, REWARDS_EXTENSION);
	else
		sprintf(buf,"%s/%s.%s", pchPath, pNewTable->pchName, REWARDS_EXTENSION);

	pNewTable->pchFileName = (char*)allocAddString(buf);

	estrDestroy(&pchPath);

	return pNewTable;
}


static void *rte_tableCreateCallback(METable *pTable, RewardTable *pObjectToClone, bool bCloneKeepsKeys)
{
	return rte_createObject(pTable, pObjectToClone, NULL, pObjectToClone ? pObjectToClone->pchScope : "", bCloneKeepsKeys);
}


static void *rte_windowCreateCallback(MEWindow *pWindow, RewardTable *pObjectToClone)
{
	return rte_createObject(pWindow->pTable, pObjectToClone, NULL,  pObjectToClone ? pObjectToClone->pchScope : "", false);
}


static void rte_ChoiceTypeChangeCallback(METable *pTable, RewardTable *pRewardTable, RewardEntry *pRewardEntry, void *pUserData, bool bInitNotify)
{
	// show/hide appropriate columns,etc

	//start w/ everything NA
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Reward Type", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Numeric Flags", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Weight", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Item", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Min Level", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Max Level", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Reward Table", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Value", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Scale", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Count", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Count Expression", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Characteristic", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Costume", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Quality", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Required Expression", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Character-based Include Prefix", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Character-based Include Type", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Base Items Only", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Scale Numeric", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Numeric Op", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Numeric Gated Type", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Gated Percent", 1);
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Gated Max Percent", 1);

	//activities are valid for everything except range tables
	METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Required Activity", 0);


	switch(pRewardEntry->ChoiceType)
	{

	case kRewardChoiceType_Expression:
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Required Expression", 0);
	case kRewardChoiceType_Choice:
	case kRewardChoiceType_ChoiceVariableCount:
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Reward Type", 0);

		if (pRewardTable->Algorithm == kRewardAlgorithm_Weighted)
			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Weight", 0);

		switch (pRewardEntry->Type)
		{
		case kRewardType_ItemWithGems:
			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Item", 0);
			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Reward Table", 0);
			break;
		case kRewardType_ItemDifficultyScaled:
		case kRewardType_Item:
			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Item", 0);
			if (pRewardEntry->ChoiceType == kRewardChoiceType_ChoiceVariableCount)
			{
				METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Count Expression", 0);
			}
			else
			{
				METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Count", 0);
			}
			break;

		case kRewardType_AlgoItem:
			break;

		case kRewardType_AlgoItemForceDifficultyScaled:
		case kRewardType_AlgoItemForce:
			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Quality", 0);
			break;

		case kRewardType_RewardTable:
			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Reward Table", 0);
			if (pRewardEntry->ChoiceType == kRewardChoiceType_ChoiceVariableCount)
			{
				METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Count Expression", 0);
			}
			else
			{
				METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Count", 0);
			}
			break;

		case kRewardType_Numeric:
			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Item", 0);
			if (pRewardEntry->ChoiceType == kRewardChoiceType_ChoiceVariableCount)
			{
				METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Count Expression", 0);
			}
			else
			{
				METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Value", 0);
			}
			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Scale Numeric", 0);
			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Numeric Op", 0);
            METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Numeric Flags", 0);

			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Numeric Gated Type", 0);
			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Gated Percent", 0);
			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Gated Max Percent", 0);

			break;

		case kRewardType_AlgoNumeric:
		case kRewardType_AlgoNumericNoScale:
			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Item", 0);
			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Numeric Flags", 0);
			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Numeric Op", 0);
			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Scale", 0);

			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Numeric Gated Type", 0);
			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Gated Percent", 0);
			METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Gated Max Percent", 0);

			break;
		default:
			break;

		}
		break;

	case kRewardChoiceType_ExpressionInclude:
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Required Expression", 0);
	case kRewardChoiceType_Include:
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Reward Table", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Base Items Only", 0);
		break;

	case kRewardChoiceType_CharacterBasedInclude:
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Character-based Include Prefix", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Character-based Include Type", 0);
		break;

	case kRewardChoiceType_LevelRange:
	case kRewardChoiceType_SkillRange:
	case kRewardChoiceType_EPRange:
	case kRewardChoiceType_TimeRange:
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Required Activity", 1);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Min Level", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Max Level", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Reward Table", 0);
		break;

	case kRewardChoiceType_Empty:
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Weight", 0);
		break;

	case kRewardChoiceType_AlgoBase:
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Weight", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Item", 0);
		break;

	case kRewardChoiceType_AlgoChar:
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Weight", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Characteristic", 0);
		break;

	case kRewardChoiceType_AlgoCost:
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Weight", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Costume", 0);
		break;

		//"Disabled" shows all fields so designers know what it is that they disabled.
	case kRewardChoiceType_Disabled:
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Weight", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Reward Type", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Costume", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Characteristic", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Item", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Required Activity", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Min Level", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Max Level", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Reward Table", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Character-based Include Prefix", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Character-based Include Type", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Reward Table", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Base Items Only", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Required Expression", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Numeric Flags", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Scale Numeric", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Numeric Op", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Numeric Gated Type", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Gated Percent", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Gated Max Percent", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Count Expression", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Count", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Quality", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Value", 0);
		METableSetSubFieldNotApplicable(pTable, pRewardTable, s_RewardTabID, pRewardEntry, "Scale", 0);
		break;
		
	default:
		break;
	}
}

static void rte_PickupTypeChangeCallback(METable *pTable, RewardTable *pRewardTable, void *pUserData, bool bInitNotify)
{
	METableSetFieldNotApplicable(pTable, pRewardTable, "OwnerType", 1);
	METableSetFieldNotApplicable(pTable, pRewardTable, "LaunchType", 1);
	METableSetFieldNotApplicable(pTable, pRewardTable, "LifeTime", 1);
	METableSetFieldNotApplicable(pTable, pRewardTable, "NotYoursCostume", 1);
	METableSetFieldNotApplicable(pTable, pRewardTable, "YoursCostume", 1);
	METableSetFieldNotApplicable(pTable, pRewardTable, "NumPicks", 1);

	switch (pRewardTable->PickupType)
	{
	default:
	case kRewardPickupType_None:
		break;

	case kRewardPickupType_Direct:
		break;

	case kRewardPickupType_Choose:
		METableSetFieldNotApplicable(pTable, pRewardTable, "NumPicks", 0);
		break;

	case kRewardPickupType_Interact:
	case kRewardPickupType_Rollover:
		METableSetFieldNotApplicable(pTable, pRewardTable, "OwnerType", 0);
		METableSetFieldNotApplicable(pTable, pRewardTable, "LaunchType", 0);
		METableSetFieldNotApplicable(pTable, pRewardTable, "LifeTime", 0);
		METableSetFieldNotApplicable(pTable, pRewardTable, "NotYoursCostume", 0);
		METableSetFieldNotApplicable(pTable, pRewardTable, "YoursCostume", 0);
		break;

	case kRewardPickupType_Clickable:
		METableSetFieldNotApplicable(pTable, pRewardTable, "OwnerType", 0);
		break;
	case kRewardPickupType_FromOrigin:
		METableSetFieldNotApplicable(pTable, pRewardTable, "OwnerType", 0);
		METableSetFieldNotApplicable(pTable, pRewardTable, "LaunchType", 0);
		break;
	}
}


static void rte_AlgorithmChangeCallback(METable *pTable, RewardTable *pRewardTable, void *pUserData, bool bInitNotify)
{
	int NumRewardEntries = eaSize(&pRewardTable->ppRewardEntry);
	int ii;

	if (pRewardTable->Algorithm == kRewardAlgorithm_Weighted)
		METableSetFieldNotApplicable(pTable, pRewardTable, "NumChoices", 0);
	else
		METableSetFieldNotApplicable(pTable, pRewardTable, "NumChoices", 1);

	// kRewardAlgorithm_Gated data
	if (pRewardTable->Algorithm == kRewardAlgorithm_Gated)
		METableSetFieldNotApplicable(pTable, pRewardTable, "Reward Gate Type", 0);
	else
		METableSetFieldNotApplicable(pTable, pRewardTable, "Reward Gate Type", 1);

	//update all reward entries
	for(ii=0; ii<NumRewardEntries; ii++)
	{
		RewardEntry *pRewardEntry = (RewardEntry*)pRewardTable->ppRewardEntry[ii];

		if (pRewardEntry)
			rte_ChoiceTypeChangeCallback(pTable, pRewardTable, pRewardEntry, pUserData, bInitNotify);
	}
}


static void rte_dictChangeCallback(enumResourceEventType eType, const char *pDictName, ConstReferenceData pRefData, Referent pReferent, METable *pTable)
{
	METableDictChanged(pTable, eType, pReferent, pRefData);
}

static void rte_CreateMissingCharBasedIncludes(METable *pTable, RewardTable *pRewardTable, void *pUnused)
{
	int i, j;
	bool bFound = false;
	for (i = 0; i < eaSize(&pRewardTable->ppRewardEntry); i++)
	{
		if (pRewardTable->ppRewardEntry[i]->ChoiceType == kRewardChoiceType_CharacterBasedInclude && pRewardTable->ppRewardEntry[i]->pchCharacterBasedIncludePrefix && pRewardTable->ppRewardEntry[i]->pchCharacterBasedIncludePrefix[0] && pRewardTable->ppRewardEntry[i]->eCharacterBasedIncludeType > 0)
		{
			char** eaTableNames = NULL;
			rewardTableEditor_InitData data;
			char* estrScope = NULL;

			bFound = true;
			rewardentry_GetAllPossibleCharBasedTableNames(pRewardTable->ppRewardEntry[i], &eaTableNames);

			estrStackCreate(&estrScope);
			if (pRewardTable->pchScope && pRewardTable->pchScope[0])
				estrPrintf(&estrScope, "%s/Char-based Tables/%s", pRewardTable->pchScope, pRewardTable->ppRewardEntry[i]->pchCharacterBasedIncludePrefix);
			else
				estrPrintf(&estrScope, "Char-based Tables/%s", pRewardTable->ppRewardEntry[i]->pchCharacterBasedIncludePrefix);
			data.scope = estrScope;

			for (j = 0; j < eaSize(&eaTableNames); j++)
			{
				data.TableName = eaTableNames[j];
				rewardTableEditor_createRewardTable(&data);
			}
			estrDestroy(&estrScope);
			eaDestroyEx(&eaTableNames, NULL);
		}
	
	}
	if (!bFound)
		Alertf("This reward table contains no Character-based include entries, so this won't do anything for you.");
}

static void rte_initCallbacks(MEWindow *pWindow, METable *pTable)
{
	// General Window callbacks
	MEWindowSetCreateCallback(pWindow, rte_windowCreateCallback);

	// General table callbacks
	METableSetValidateCallback(pTable, rte_validateCallback, pTable);
	METableSetPostOpenCallback(pTable, rte_postOpenCallback);
	METableSetPreSaveCallback(pTable, rte_preSaveCallback);
	METableSetCreateCallback(pTable, rte_tableCreateCallback);

	// Column change callbacks
	METableSetColumnChangeCallback(pTable, "Algorithm", rte_AlgorithmChangeCallback, NULL);
	METableSetColumnChangeCallback(pTable, "PickupType", rte_PickupTypeChangeCallback, NULL);
	METableSetSubColumnChangeCallback(pTable, s_RewardTabID, "Choice Type", rte_ChoiceTypeChangeCallback, NULL);
	METableSetSubColumnChangeCallback(pTable, s_RewardTabID, "Reward Type", rte_ChoiceTypeChangeCallback, NULL);
	METableSetSubColumnChangeCallback(pTable, s_RewardTabID, "Numeric Flags",rte_ChoiceTypeChangeCallback, NULL);

	// We need this registered here instead of by METable because the dictionary will 
	// only allow each callback function to be registered once and there may be multiple
	// METable instances.  Our local callback just passes through to the METable.
	resDictRegisterEventCallback(g_hRewardTableDict, rte_dictChangeCallback, pTable);
	METableAddCustomAction(pWindow->pTable, "Open All Char-based Result Tables", rte_CreateMissingCharBasedIncludes, NULL);
}


//---------------------------------------------------------------------------------------------------
// UI Init
//---------------------------------------------------------------------------------------------------

static void rte_initRewardTableColumns(METable *pTable)
{
	char *pcPath = NULL;
	GameBranch_GetDirectory(&pcPath, REWARDS_BASE_DIR);
	METableAddSimpleColumn(pTable,   "Name",          "name",      150, NULL, kMEFieldType_TextEntry);

	// Lock in name column
	METableSetNumLockedColumns(pTable, 2);

	METableAddScopeColumn(pTable,    "Scope",         "Scope",     160, RTE_GROUP_MAIN, kMEFieldType_TextEntry); // Not validated on purpose
	METableAddFileNameColumn(pTable, "File Name",     "fileName",  240, RTE_GROUP_MAIN, NULL, pcPath, pcPath, ".rewards", UIBrowseNewOrExisting);
	METableAddSimpleColumn(pTable,   "Notes",         "notes",     240, RTE_GROUP_MAIN, kMEFieldType_MultiText );

	METableAddEnumColumn(pTable,     "Algorithm",     "Algorithm",        64, RTE_GROUP_OPTIONS, kMEFieldType_Combo, RewardAlgorithmEnum);
	METableAddSimpleColumn(pTable,   "NumChoices",    "NumChoices",      64, RTE_GROUP_OPTIONS, kMEFieldType_TextEntry );
	METableAddEnumColumn(pTable,     "Flags",         "flags",           120, RTE_GROUP_OPTIONS, kMEFieldType_FlagCombo, RewardFlagEnum);
	METableAddSimpleColumn(pTable,  "Show Reward Pack UI", "ShowRewardPackUI",			  100, RTE_GROUP_OPTIONS, kMEFieldType_BooleanCombo);
	METableAddEnumColumn(pTable,     "RewardPack Overall Quality",     "RewardPackOverallQuality",        120, RTE_GROUP_OPTIONS, kMEFieldType_Combo, ItemQualityEnum);

	METableAddEnumColumn(pTable,     "KillerType",    "KillerType",      64, RTE_GROUP_OPTIONS, kMEFieldType_Combo, RewardKillerTypeEnum);
	METableAddEnumColumn(pTable,     "ExecuteType",   "ExecuteType",     64, RTE_GROUP_OPTIONS, kMEFieldType_Combo, RewardExecuteTypeEnum);
	METableAddEnumColumn(pTable,     "PickupType",    "PickupType",      64, RTE_GROUP_OPTIONS, kMEFieldType_Combo, RewardPickupTypeEnum);
	METableAddEnumColumn(pTable,     "OwnerType",     "OwnerType",       64, RTE_GROUP_OPTIONS, kMEFieldType_Combo, RewardOwnerTypeEnum);
	METableAddEnumColumn(pTable,     "LaunchType",    "LaunchType",      64, RTE_GROUP_OPTIONS, kMEFieldType_Combo, RewardLaunchTypeEnum);
 
	METableAddSimpleColumn(pTable,   "NumPicks",      "NumPicks",        64, RTE_GROUP_OPTIONS, kMEFieldType_TextEntry );
	METableAddSimpleColumn(pTable,   "LifeTime",      "LingerTime",      64, RTE_GROUP_OPTIONS, kMEFieldType_TextEntry );

	METableAddGlobalDictColumn(pTable,   "NotYoursCostume", "NotYoursCostume", 180, RTE_GROUP_COSTUME, kMEFieldType_ValidatedTextEntry, "PlayerCostume", "resourceName");
	METableAddGlobalDictColumn(pTable,   "YoursCostume",    "YoursCostume",    180, RTE_GROUP_COSTUME, kMEFieldType_ValidatedTextEntry, "PlayerCostume", "resourceName");

	METableAddSimpleColumn(pTable,   "Difficulty Scaling",  "RewardDiffPowerScale",		100, RTE_GROUP_OPTIONS, kMEFieldType_TextEntry );
	METableAddEnumColumn(pTable,	 "Reward Tags",			"RewardTags",				120, RTE_GROUP_OPTIONS, kMEFieldType_FlagCombo, RewardTagsEnum);

	METableAddEnumColumn(pTable,     "Reward Gate Type",     "RewardGatedType",        150, RTE_GROUP_OPTIONS, kMEFieldType_Combo, RewardGatedTypeEnum);

	estrDestroy(&pcPath);
}

static char** rte_GetGamePermissionTokens(METable *pTable, void *pUnused)
{
	char** eaResult = NULL;
	int i, iSize = eaSize(&g_GamePermissions.eaPermissions);
	for (i = 0; i < iSize; i++)
	{
		gamePermission_GetTokenKeys(g_GamePermissions.eaPermissions[i], &eaResult);
	}
	for (i = eaSize(&eaResult)-1; i >= 0; i--)
	{
		eaResult[i] = strdup(eaResult[i]);
	}
	eaQSort(eaResult, strCmp);
	return eaResult;
}

static char** rte_GetActivityNames(METable *pTable, void *pUnused)
{
	char** eaResult = NULL;
	int i, iSize = eaSize(&g_ActivityDefs.ppDefs);
	for (i = 0; i < iSize; i++)
	{
		eaPush(&eaResult, strdup(g_ActivityDefs.ppDefs[i]->pchActivityName));
	}
	eaQSort(eaResult, strCmp);
	return eaResult;
}

static void rte_initRewardColumns(METable *pTable)
{
	// Create the subtable and get the ID
	s_RewardTabID = METableCreateSubTable(pTable, "RewardEntry", "RewardEntry", parse_RewardEntry, NULL,
										NULL, NULL, rte_createRewardEntry);

	METableAddEnumSubColumn(pTable, s_RewardTabID,		 "Choice Type",   "ChoiceType",   100, RTE_SUBGROUP_REWARDS, kMEFieldType_Combo, RewardChoiceTypeEnum);
	METableAddEnumSubColumn(pTable, s_RewardTabID,		 "Reward Type",   "Type",         120, RTE_SUBGROUP_REWARDS, kMEFieldType_Combo, RewardTypeEnum);
	METableAddEnumSubColumn(pTable, s_RewardTabID,		 "Character-based Include Type",   "CharacterBasedIncludeType",   100, RTE_SUBGROUP_REWARDS, kMEFieldType_Combo, CharacterBasedIncludeTypeEnum);
	METableAddSimpleSubColumn(pTable, s_RewardTabID,	 "Character-based Include Prefix",        "CharacterBasedIncludePrefix",        180, RTE_SUBGROUP_REWARDS, kMEFieldType_TextEntry );
	METableAddEnumSubColumn(pTable, s_RewardTabID,		 "Numeric Op", "numeric_op",         100, RTE_SUBGROUP_REWARDS, kMEFieldType_Combo, NumericOpEnum);
	METableAddSimpleSubColumn(pTable, s_RewardTabID,	 "Weight",        "Weight",        64, RTE_SUBGROUP_REWARDS, kMEFieldType_TextEntry );
	METableAddSimpleSubColumn(pTable, s_RewardTabID,	 "Count",         "Count",         64, RTE_SUBGROUP_REWARDS, kMEFieldType_TextEntry );
	METableAddExprSubColumn(pTable, s_RewardTabID, "Count Expression", "CountExpression", 180, RTE_GROUP_OPTIONS, g_pRewardNonPlayerContext);
	METableAddGlobalDictSubColumn(pTable, s_RewardTabID, "Item",		  "ItemDef",      180, RTE_SUBGROUP_REWARDS, kMEFieldType_ValidatedTextEntry, "ItemDef", "resourceName");
	METableAddSimpleSubColumn(pTable, s_RewardTabID,	 "Min Level",     "MinLevel",      64, RTE_SUBGROUP_REWARDS, kMEFieldType_TextEntry);
	METableAddSimpleSubColumn(pTable, s_RewardTabID,	 "Max Level",     "MaxLevel",      64, RTE_SUBGROUP_REWARDS, kMEFieldType_TextEntry);
	METableAddGlobalDictSubColumn(pTable, s_RewardTabID, "Reward Table",  "RewardTable",  180, RTE_SUBGROUP_REWARDS, kMEFieldType_ValidatedTextEntry, "RewardTable", "resourceName");
	METableAddGlobalDictSubColumn(pTable, s_RewardTabID, "Reward Val Table Override", "RewardValTableOverride", 180, RTE_SUBGROUP_REWARDS, kMEFieldType_ValidatedTextEntry, "RewardValTable", "resourceName");
	METableAddSimpleSubColumn(pTable, s_RewardTabID,  "Scale Numeric", "ScaleNumeric",	128, RTE_SUBGROUP_REWARDS, kMEFieldType_BooleanCombo);
	METableAddSimpleSubColumn(pTable, s_RewardTabID,  "Hide In UI", "HideInUI",			  128, RTE_SUBGROUP_REWARDS, kMEFieldType_BooleanCombo);
	METableAddSimpleSubColumn(pTable, s_RewardTabID,	 "Value",         "Value",         64, RTE_SUBGROUP_REWARDS, kMEFieldType_TextEntry );
	METableAddSimpleSubColumn(pTable, s_RewardTabID,	 "Scale",         "Scale",         64, RTE_SUBGROUP_REWARDS, kMEFieldType_TextEntry );
	METableAddEnumSubColumn(pTable, s_RewardTabID,	     "Quality",  "Quality",            64, RTE_SUBGROUP_REWARDS, kMEFieldType_Combo, ItemQualityEnum);
	METableAddGlobalDictSubColumn(pTable, s_RewardTabID, "Characteristic","ItemPowerDef", 180, RTE_SUBGROUP_REWARDS, kMEFieldType_ValidatedTextEntry, "ItemPowerDef", "resourceName");
	METableAddGlobalDictSubColumn(pTable, s_RewardTabID, "Costume",       "CostumeDef",   180, RTE_SUBGROUP_REWARDS, kMEFieldType_ValidatedTextEntry, "PlayerCostume", "resourceName");
	METableAddExprSubColumn(pTable, s_RewardTabID, "Required Expression", "RequiresExpression", 180, RTE_GROUP_OPTIONS, g_pRewardPlayerContext);
	METableAddSubColumn(pTable, s_RewardTabID, "Req. Game Permission Tokens", "RequiredGamePermissionToken", NULL, 180, RTE_GROUP_OPTIONS, kMEFieldType_ValidatedTextEntry, NULL, NULL, NULL, NULL, NULL, NULL, rte_GetGamePermissionTokens);
	METableAddSimpleSubColumn(pTable, s_RewardTabID,	 "Difficulty Scaling",     "RewardDiffPowerScaleMult",      120, RTE_SUBGROUP_REWARDS, kMEFieldType_TextEntry);
	METableAddSubColumn(pTable, s_RewardTabID, "Required Activity",       "ActivityName",  NULL, 180, RTE_SUBGROUP_REWARDS, kMEFieldType_ValidatedTextEntry, NULL, NULL, NULL, NULL, NULL, NULL, rte_GetActivityNames);
	METableAddSimpleSubColumn(pTable, s_RewardTabID, "Required Shard Variable", "ShardVariable", 180, RTE_SUBGROUP_REWARDS, kMEFieldType_TextEntry);

	METableAddSimpleSubColumn(pTable, s_RewardTabID, "Broadcast Chat Message", ".BroadcastChatMessage.EditorCopy", 180, RTE_SUBGROUP_REWARDS, kMEFieldType_Message);

	METableAddEnumSubColumn(pTable, s_RewardTabID,		 "Numeric Gated Type",   "GatedForNumeric",					150, RTE_SUBGROUP_REWARDS, kMEFieldType_Combo, RewardGatedTypeEnum);
	METableAddSimpleSubColumn(pTable, s_RewardTabID,	 "Gated Percent",        "GatedPercentChange",				120, RTE_SUBGROUP_REWARDS, kMEFieldType_TextEntry );
	METableAddSimpleSubColumn(pTable, s_RewardTabID,	 "Gated Max Percent",    "MaxGatedPercentChange",			120, RTE_SUBGROUP_REWARDS, kMEFieldType_TextEntry );

}


static void rte_init(MultiEditEMDoc *pEditorDoc)
{
	if (!rteWindow) {
		// Create the editor window
		rteWindow = MEWindowCreate("Reward Table Editor", "Reward Table", "Reward Tables", SEARCH_TYPE_REWARD_TABLE, g_hRewardTableDict, parse_RewardTable, "name", "filename", "scope", pEditorDoc);

		// Add reward table specific columns
		rte_initRewardTableColumns(rteWindow->pTable);

		// Add reward specific sub-columns
		rte_initRewardColumns(rteWindow->pTable);
		METableFinishColumns(rteWindow->pTable);

		// Init the menus after adding all the columns
		MEWindowInitTableMenus(rteWindow);

		// Set the callbacks
		rte_initCallbacks(rteWindow, rteWindow->pTable);
	}

	// Show the window
	ui_WindowPresent(rteWindow->pUIWindow);
}


//---------------------------------------------------------------------------------------------------
// Public Interface
//---------------------------------------------------------------------------------------------------

MEWindow *rewardTableEditor_init(MultiEditEMDoc *pEditorDoc) 
{
	rte_init(pEditorDoc);

	return rteWindow;
}


void rewardTableEditor_createRewardTable(rewardTableEditor_InitData *pInitData)
{
	char *TableName = pInitData ? pInitData->TableName : NULL;
	char *Scope = pInitData ? pInitData->scope : NULL;

	if (resGetInfo("RewardTable", TableName)) {
		// It already exists so open it if not already open
		if (!METableIsObjectOpen(rteWindow->pTable, TableName)) {
			MEWindowOpenObject(rteWindow, TableName);
		}
	} else {
		// Create a new object since it is not in the dictionary
		// Add the object as a new object with no old
		void *pObject = rte_createObject(rteWindow->pTable, NULL, TableName, Scope, false);
		METableAddRowByObject(rteWindow->pTable, pObject, 1, 1);
	}
}

#endif